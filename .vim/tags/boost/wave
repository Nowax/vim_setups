!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AQ_EMPTY	wave/cpplexer/re2clex/aq.hpp	46;"	d
AQ_FULL	wave/cpplexer/re2clex/aq.hpp	47;"	d
AQ_HPP_A21D9145_B643_44C0_81E7_DB346DD67EE1_INCLUDED	wave/cpplexer/re2clex/aq.hpp	13;"	d
Alloc	wave/util/flex_string.hpp	/^    void* Alloc(size_type sz, const void* p = 0)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:private	signature:(size_type sz, const void* p = 0)
AllocatorStringStorage	wave/util/flex_string.hpp	/^    AllocatorStringStorage() $/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:()
AllocatorStringStorage	wave/util/flex_string.hpp	/^    AllocatorStringStorage(const A& a) : A(a)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(const A& a)
AllocatorStringStorage	wave/util/flex_string.hpp	/^    AllocatorStringStorage(const AllocatorStringStorage& rhs) $/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(const AllocatorStringStorage& rhs)
AllocatorStringStorage	wave/util/flex_string.hpp	/^    AllocatorStringStorage(const AllocatorStringStorage& s, $/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(const AllocatorStringStorage& s, flex_string_details::Shallow)
AllocatorStringStorage	wave/util/flex_string.hpp	/^    AllocatorStringStorage(const E* s, size_type len, const A& a)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(const E* s, size_type len, const A& a)
AllocatorStringStorage	wave/util/flex_string.hpp	/^    AllocatorStringStorage(size_type len, E c, const A& a)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(size_type len, E c, const A& a)
AllocatorStringStorage	wave/util/flex_string.hpp	/^class AllocatorStringStorage : public A$/;"	c	namespace:boost::wave::util	inherits:A
AltExtTokenType	wave/token_ids.hpp	/^    AltExtTokenType             = 0x00500000,   \/\/ and, bit_and etc.$/;"	e	enum:boost::wave::token_category
AltTokenType	wave/token_ids.hpp	/^    AltTokenType                = 0x00100000,$/;"	e	enum:boost::wave::token_category
BASEID_FROM_TOKEN	wave/token_ids.hpp	326;"	d
BASEID_FROM_TOKEN	wave/token_ids.hpp	327;"	d
BASEID_FROM_TOKEN	wave/token_ids.hpp	42;"	d
BASE_TOKEN	wave/token_ids.hpp	331;"	d
BOOST_CLASS_REQUIRE	wave/cpp_context.hpp	/^    BOOST_CLASS_REQUIRE(IteratorT, boost, ForwardIteratorConcept);$/;"	p	class:boost::wave::context	access:public	signature:(IteratorT, boost, ForwardIteratorConcept)
BOOST_DYN_LINK	wave/wave_config.hpp	461;"	d
BOOST_LIB_NAME	wave/wave_config.hpp	457;"	d
BOOST_NO_MT	wave/wave_config.hpp	193;"	d
BOOST_SPIRIT_DEBUG_FLAGS_CHLIT_GRAMMAR	wave/wave_config.hpp	259;"	d
BOOST_SPIRIT_DEBUG_FLAGS_CPP	wave/wave_config.hpp	264;"	d
BOOST_SPIRIT_DEBUG_FLAGS_CPP_EXPR_GRAMMAR	wave/wave_config.hpp	257;"	d
BOOST_SPIRIT_DEBUG_FLAGS_CPP_GRAMMAR	wave/wave_config.hpp	255;"	d
BOOST_SPIRIT_DEBUG_FLAGS_DEFINED_GRAMMAR	wave/wave_config.hpp	260;"	d
BOOST_SPIRIT_DEBUG_FLAGS_INTLIT_GRAMMAR	wave/wave_config.hpp	258;"	d
BOOST_SPIRIT_DEBUG_FLAGS_PREDEF_MACROS_GRAMMAR	wave/wave_config.hpp	261;"	d
BOOST_SPIRIT_DEBUG_FLAGS_TIME_CONVERSION	wave/wave_config.hpp	256;"	d
BOOST_SPIRIT_PATTERN_PARSER_HPP	wave/util/pattern_parser.hpp	14;"	d
BOOST_SPIRIT_THREADSAFE	wave/wave_config.hpp	189;"	d
BOOST_STATIC_CONSTANT	wave/cpp_context.hpp	/^    BOOST_STATIC_CONSTANT($/;"	p	struct:boost::serialization::tracking_level	access:public	signature:( int, value = tracking_level::type::value )
BOOST_STATIC_CONSTANT	wave/cpp_context.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, value = version::type::value);$/;"	p	struct:boost::serialization::version	access:public	signature:(unsigned int, value = version::type::value)
BOOST_STATIC_CONSTANT	wave/cpp_context.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, version = 0x10);$/;"	p	class:boost::wave::context	access:public	signature:(unsigned int, version = 0x10)
BOOST_STATIC_CONSTANT	wave/cpp_context.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, version_mask = 0x0f);$/;"	p	class:boost::wave::context	access:public	signature:(unsigned int, version_mask = 0x0f)
BOOST_STATIC_CONSTANT	wave/util/cpp_include_paths.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, version = 0x10);$/;"	p	class:boost::wave::util::include_paths	access:public	signature:(unsigned int, version = 0x10)
BOOST_STATIC_CONSTANT	wave/util/cpp_include_paths.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, version_mask = 0x0f);$/;"	p	class:boost::wave::util::include_paths	access:public	signature:(unsigned int, version_mask = 0x0f)
BOOST_STATIC_CONSTANT	wave/util/cpp_include_paths.hpp	/^    BOOST_STATIC_CONSTANT(unsigned, from_offset = offsetof(value_type, first));$/;"	p	struct:boost::wave::util::bidirectional_map	access:public	signature:(unsigned, from_offset = offsetof(value_type, first))
BOOST_STATIC_CONSTANT	wave/util/cpp_include_paths.hpp	/^    BOOST_STATIC_CONSTANT(unsigned, to_offset   = offsetof(value_type, second));$/;"	p	struct:boost::wave::util::bidirectional_map	access:public	signature:(unsigned, to_offset = offsetof(value_type, second))
BOOST_STATIC_CONSTANT	wave/util/cpp_macromap.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, value = version::type::value);$/;"	p	struct:boost::serialization::version	access:public	signature:(unsigned int, value = version::type::value)
BOOST_STATIC_CONSTANT	wave/util/cpp_macromap.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, version = 0x10);$/;"	p	class:boost::wave::util::macromap	access:public	signature:(unsigned int, version = 0x10)
BOOST_STATIC_CONSTANT	wave/util/cpp_macromap.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, version_mask = 0x0f);$/;"	p	class:boost::wave::util::macromap	access:public	signature:(unsigned int, version_mask = 0x0f)
BOOST_STATIC_CONSTANT	wave/util/flex_string.hpp	/^    BOOST_STATIC_CONSTANT($/;"	p	struct:boost::serialization::implementation_level	access:public	signature:( int, value = implementation_level::type::value )
BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(and, &&);$/;"	p	namespace:boost::wave::grammars::impl	signature:(and, &&)
BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(bitand, &);$/;"	p	namespace:boost::wave::grammars::impl	signature:(bitand, &)
BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(bitor, |);$/;"	p	namespace:boost::wave::grammars::impl	signature:(bitor, |)
BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(bitxor, ^);$/;"	p	namespace:boost::wave::grammars::impl	signature:(bitxor, ^)
BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(eq, ==);$/;"	p	namespace:boost::wave::grammars::impl	signature:(eq, ==)
BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(greateq, >=);$/;"	p	namespace:boost::wave::grammars::impl	signature:(greateq, >=)
BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(greater, >);$/;"	p	namespace:boost::wave::grammars::impl	signature:(greater, >)
BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(less, <);$/;"	p	namespace:boost::wave::grammars::impl	signature:(less, <)
BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(lesseq, <=);$/;"	p	namespace:boost::wave::grammars::impl	signature:(lesseq, <=)
BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(ne, !=);$/;"	p	namespace:boost::wave::grammars::impl	signature:(ne, !=)
BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(or, ||);$/;"	p	namespace:boost::wave::grammars::impl	signature:(or, ||)
BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	222;"	d
BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	255;"	d
BOOST_WAVE_BUILD_DLL	wave/wave_config.hpp	439;"	d
BOOST_WAVE_CHLITGRAMMAR_GEN_INLINE	wave/grammars/cpp_chlit_grammar.hpp	296;"	d
BOOST_WAVE_CHLITGRAMMAR_GEN_INLINE	wave/grammars/cpp_chlit_grammar.hpp	298;"	d
BOOST_WAVE_CHLITGRAMMAR_GEN_INLINE	wave/grammars/cpp_chlit_grammar.hpp	342;"	d
BOOST_WAVE_CONFIG	wave/wave_config_constant.hpp	61;"	d
BOOST_WAVE_CONFIG_CONSTANT_HPP	wave/wave_config_constant.hpp	13;"	d
BOOST_WAVE_CPP_THROW_HPP_INCLUDED	wave/cpp_throw.hpp	12;"	d
BOOST_WAVE_CPP_VALUE_ERROR_INCLUDED	wave/grammars/cpp_value_error.hpp	12;"	d
BOOST_WAVE_DECL	wave/wave_config.hpp	438;"	d
BOOST_WAVE_DECL	wave/wave_config.hpp	447;"	d
BOOST_WAVE_DEFINED_GRAMMAR_GEN_INLINE	wave/grammars/cpp_defined_grammar.hpp	127;"	d
BOOST_WAVE_DEFINED_GRAMMAR_GEN_INLINE	wave/grammars/cpp_defined_grammar.hpp	129;"	d
BOOST_WAVE_DEFINED_GRAMMAR_GEN_INLINE	wave/grammars/cpp_defined_grammar.hpp	173;"	d
BOOST_WAVE_DUMP_CONDITIONAL_EXPRESSIONS	wave/wave_config.hpp	293;"	d
BOOST_WAVE_DUMP_CONDITIONAL_EXPRESSIONS_OUT	wave/wave_config.hpp	297;"	d
BOOST_WAVE_DUMP_PARSE_TREE	wave/wave_config.hpp	277;"	d
BOOST_WAVE_DUMP_PARSE_TREE_OUT	wave/wave_config.hpp	280;"	d
BOOST_WAVE_ELIF_ID	wave/grammars/cpp_grammar_gen.hpp	54;"	d
BOOST_WAVE_ELSE_ID	wave/grammars/cpp_grammar_gen.hpp	55;"	d
BOOST_WAVE_EMIT_PRAGMA_DIRECTIVES	wave/wave_config.hpp	132;"	d
BOOST_WAVE_ENABLE_COMMANDLINE_MACROS	wave/wave_config.hpp	153;"	d
BOOST_WAVE_ENABLE_OPTION	wave/language_support.hpp	168;"	d
BOOST_WAVE_ENABLE_OPTION	wave/language_support.hpp	204;"	d
BOOST_WAVE_ENDIF_ID	wave/grammars/cpp_grammar_gen.hpp	56;"	d
BOOST_WAVE_ENDREGION_ID	wave/grammars/cpp_grammar_gen.hpp	65;"	d
BOOST_WAVE_EOF_PREFIX	wave/cpplexer/cpp_lex_iterator.hpp	241;"	d
BOOST_WAVE_EOF_PREFIX	wave/cpplexer/cpp_lex_iterator.hpp	38;"	d
BOOST_WAVE_ERROR_ID	wave/grammars/cpp_grammar_gen.hpp	58;"	d
BOOST_WAVE_EXPRGRAMMAR_GEN_INLINE	wave/grammars/cpp_expression_grammar.hpp	750;"	d
BOOST_WAVE_EXPRGRAMMAR_GEN_INLINE	wave/grammars/cpp_expression_grammar.hpp	752;"	d
BOOST_WAVE_EXPRGRAMMAR_GEN_INLINE	wave/grammars/cpp_expression_grammar.hpp	858;"	d
BOOST_WAVE_FILESYSTEM_COMPATIBILITY_MAR_09_2009_0142PM	wave/util/filesystem_compatibility.hpp	12;"	d
BOOST_WAVE_FLEX_STRING_SERIALIZATION_HACK	wave/util/flex_string.hpp	98;"	d
BOOST_WAVE_GRAMMAR_GEN_INLINE	wave/grammars/cpp_grammar.hpp	719;"	d
BOOST_WAVE_GRAMMAR_GEN_INLINE	wave/grammars/cpp_grammar.hpp	721;"	d
BOOST_WAVE_GRAMMAR_GEN_INLINE	wave/grammars/cpp_grammar.hpp	753;"	d
BOOST_WAVE_IFDEF_ID	wave/grammars/cpp_grammar_gen.hpp	51;"	d
BOOST_WAVE_IFNDEF_ID	wave/grammars/cpp_grammar_gen.hpp	52;"	d
BOOST_WAVE_IF_ID	wave/grammars/cpp_grammar_gen.hpp	53;"	d
BOOST_WAVE_ILLFORMED_ID	wave/grammars/cpp_grammar_gen.hpp	61;"	d
BOOST_WAVE_INCLUDE_FILE_ID	wave/grammars/cpp_grammar_gen.hpp	44;"	d
BOOST_WAVE_INTLITGRAMMAR_GEN_INLINE	wave/grammars/cpp_intlit_grammar.hpp	150;"	d
BOOST_WAVE_INTLITGRAMMAR_GEN_INLINE	wave/grammars/cpp_intlit_grammar.hpp	152;"	d
BOOST_WAVE_INTLITGRAMMAR_GEN_INLINE	wave/grammars/cpp_intlit_grammar.hpp	176;"	d
BOOST_WAVE_LEXER_THROW	wave/cpplexer/cpplexer_exceptions.hpp	33;"	d
BOOST_WAVE_LEXER_THROW	wave/cpplexer/cpplexer_exceptions.hpp	48;"	d
BOOST_WAVE_LEXER_THROW_VAR	wave/cpplexer/cpplexer_exceptions.hpp	66;"	d
BOOST_WAVE_LEXER_THROW_VAR	wave/cpplexer/cpplexer_exceptions.hpp	82;"	d
BOOST_WAVE_LEX_INTERFACE_GENERATOR_HPP_INCLUDED	wave/cpplexer/cpp_lex_interface_generator.hpp	14;"	d
BOOST_WAVE_LINE_ID	wave/grammars/cpp_grammar_gen.hpp	57;"	d
BOOST_WAVE_MACROINCLUDE_FILE_ID	wave/grammars/cpp_grammar_gen.hpp	46;"	d
BOOST_WAVE_MACRO_DEFINITION_ID	wave/grammars/cpp_grammar_gen.hpp	49;"	d
BOOST_WAVE_MACRO_DEFINITION_ID	wave/grammars/cpp_predef_macros_gen.hpp	41;"	d
BOOST_WAVE_MACRO_PARAMETERS_ID	wave/grammars/cpp_grammar_gen.hpp	48;"	d
BOOST_WAVE_MACRO_PARAMETERS_ID	wave/grammars/cpp_predef_macros_gen.hpp	40;"	d
BOOST_WAVE_MAX_INCLUDE_LEVEL_DEPTH	wave/wave_config.hpp	30;"	d
BOOST_WAVE_NEED_OPTION	wave/language_support.hpp	161;"	d
BOOST_WAVE_NEED_OPTION	wave/language_support.hpp	203;"	d
BOOST_WAVE_NEW_LEXER_DECL	wave/cpplexer/cpp_lex_interface_generator.hpp	39;"	d
BOOST_WAVE_NEW_LEXER_DECL	wave/cpplexer/cpp_lex_interface_generator.hpp	64;"	d
BOOST_WAVE_OPTION	wave/language_support.hpp	178;"	d
BOOST_WAVE_OPTION	wave/language_support.hpp	205;"	d
BOOST_WAVE_PLAIN_DEFINE_ID	wave/grammars/cpp_grammar_gen.hpp	47;"	d
BOOST_WAVE_PLAIN_DEFINE_ID	wave/grammars/cpp_predef_macros_gen.hpp	39;"	d
BOOST_WAVE_PPQUALIFIEDNAME_ID	wave/grammars/cpp_grammar_gen.hpp	63;"	d
BOOST_WAVE_PPSPACE_ID	wave/grammars/cpp_grammar_gen.hpp	62;"	d
BOOST_WAVE_PP_STATEMENT_ID	wave/grammars/cpp_grammar_gen.hpp	43;"	d
BOOST_WAVE_PRAGMA_ID	wave/grammars/cpp_grammar_gen.hpp	60;"	d
BOOST_WAVE_PRAGMA_KEYWORD	wave/wave_config.hpp	169;"	d
BOOST_WAVE_PREDEF_MACROS_GRAMMAR_GEN_INLINE	wave/grammars/cpp_predef_macros_grammar.hpp	151;"	d
BOOST_WAVE_PREDEF_MACROS_GRAMMAR_GEN_INLINE	wave/grammars/cpp_predef_macros_grammar.hpp	153;"	d
BOOST_WAVE_PREDEF_MACROS_GRAMMAR_GEN_INLINE	wave/grammars/cpp_predef_macros_grammar.hpp	166;"	d
BOOST_WAVE_PREPROCESS_ERROR_MESSAGE_BODY	wave/wave_config.hpp	121;"	d
BOOST_WAVE_PREPROCESS_PRAGMA_BODY	wave/wave_config.hpp	143;"	d
BOOST_WAVE_PREPROCESS_PRAGMA_BODY_CONFIG	wave/wave_config_constant.hpp	41;"	d
BOOST_WAVE_PREPROCESS_PRAGMA_BODY_CONFIG	wave/wave_config_constant.hpp	43;"	d
BOOST_WAVE_RE2C_NEW_LEXER_INLINE	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	384;"	d
BOOST_WAVE_RE2C_NEW_LEXER_INLINE	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	417;"	d
BOOST_WAVE_REGION_ID	wave/grammars/cpp_grammar_gen.hpp	64;"	d
BOOST_WAVE_SEPARATE_GRAMMAR_INSTANTIATION	wave/wave_config.hpp	327;"	d
BOOST_WAVE_SEPARATE_LEXER_INSTANTIATION	wave/wave_config.hpp	312;"	d
BOOST_WAVE_SERIALIZATION	wave/wave_config.hpp	355;"	d
BOOST_WAVE_STRINGTYPE	wave/wave_config.hpp	210;"	d
BOOST_WAVE_STRINGTYPE	wave/wave_config.hpp	219;"	d
BOOST_WAVE_STRINGTYPE_USE_STDSTRING	wave/wave_config.hpp	213;"	d
BOOST_WAVE_SUPPORT_CPP0X	wave/wave_config.hpp	92;"	d
BOOST_WAVE_SUPPORT_IMPORT_KEYWORD	wave/wave_config.hpp	365;"	d
BOOST_WAVE_SUPPORT_IMPORT_KEYWORD_CONFIG	wave/wave_config_constant.hpp	55;"	d
BOOST_WAVE_SUPPORT_IMPORT_KEYWORD_CONFIG	wave/wave_config_constant.hpp	57;"	d
BOOST_WAVE_SUPPORT_INCLUDE_NEXT	wave/wave_config.hpp	82;"	d
BOOST_WAVE_SUPPORT_LONGLONG_INTEGER_LITERALS	wave/wave_config.hpp	390;"	d
BOOST_WAVE_SUPPORT_MS_EXTENSIONS	wave/wave_config.hpp	107;"	d
BOOST_WAVE_SUPPORT_MS_EXTENSIONS	wave/wave_config.hpp	109;"	d
BOOST_WAVE_SUPPORT_MS_EXTENSIONS_CONFIG	wave/wave_config_constant.hpp	34;"	d
BOOST_WAVE_SUPPORT_MS_EXTENSIONS_CONFIG	wave/wave_config_constant.hpp	36;"	d
BOOST_WAVE_SUPPORT_PRAGMA_MESSAGE	wave/wave_config.hpp	71;"	d
BOOST_WAVE_SUPPORT_PRAGMA_ONCE	wave/wave_config.hpp	61;"	d
BOOST_WAVE_SUPPORT_PRAGMA_ONCE_CONFIG	wave/wave_config_constant.hpp	27;"	d
BOOST_WAVE_SUPPORT_PRAGMA_ONCE_CONFIG	wave/wave_config_constant.hpp	29;"	d
BOOST_WAVE_SUPPORT_THREADING	wave/wave_config.hpp	182;"	d
BOOST_WAVE_SUPPORT_THREADING	wave/wave_config.hpp	184;"	d
BOOST_WAVE_SUPPORT_VARIADICS_PLACEMARKERS	wave/wave_config.hpp	40;"	d
BOOST_WAVE_SUPPORT_VARIADICS_PLACEMARKERS	wave/wave_config.hpp	93;"	d
BOOST_WAVE_SUPPORT_VARIADICS_PLACEMARKERS	wave/wave_config.hpp	94;"	d
BOOST_WAVE_SUPPORT_VARIADICS_PLACEMARKERS_CONFIG	wave/wave_config_constant.hpp	20;"	d
BOOST_WAVE_SUPPORT_VARIADICS_PLACEMARKERS_CONFIG	wave/wave_config_constant.hpp	22;"	d
BOOST_WAVE_SUPPORT_WARNING_DIRECTIVE	wave/wave_config.hpp	51;"	d
BOOST_WAVE_SYSINCLUDE_FILE_ID	wave/grammars/cpp_grammar_gen.hpp	45;"	d
BOOST_WAVE_TEST_CONFIGURATION	wave/wave_config_constant.hpp	83;"	d
BOOST_WAVE_THROW	wave/cpp_throw.hpp	155;"	d
BOOST_WAVE_THROW_CTX	wave/cpp_throw.hpp	159;"	d
BOOST_WAVE_THROW_NAME_CTX	wave/cpp_throw.hpp	167;"	d
BOOST_WAVE_THROW_VAR_CTX	wave/cpp_throw.hpp	175;"	d
BOOST_WAVE_TOKEN_IDS_DEFINED	wave/token_ids.hpp	28;"	d
BOOST_WAVE_UNARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_UNARYOP(neg, !);$/;"	p	namespace:boost::wave::grammars::impl	signature:(neg, !)
BOOST_WAVE_UNARYOP	wave/grammars/cpp_expression_grammar.hpp	258;"	d
BOOST_WAVE_UNARYOP	wave/grammars/cpp_expression_grammar.hpp	279;"	d
BOOST_WAVE_UNDEFINE_ID	wave/grammars/cpp_grammar_gen.hpp	50;"	d
BOOST_WAVE_USE_DEPRECIATED_PREPROCESSING_HOOKS	wave/wave_config.hpp	485;"	d
BOOST_WAVE_USE_STRICT_LEXER	wave/wave_config.hpp	340;"	d
BOOST_WAVE_USE_STRICT_LEXER_CONFIG	wave/wave_config_constant.hpp	48;"	d
BOOST_WAVE_USE_STRICT_LEXER_CONFIG	wave/wave_config_constant.hpp	50;"	d
BOOST_WAVE_VERSION	wave/wave_version.hpp	19;"	d
BOOST_WAVE_VERSION_MAJOR	wave/wave_version.hpp	22;"	d
BOOST_WAVE_VERSION_MINOR	wave/wave_version.hpp	23;"	d
BOOST_WAVE_VERSION_SUBMINOR	wave/wave_version.hpp	24;"	d
BOOST_WAVE_WARNING_ID	wave/grammars/cpp_grammar_gen.hpp	59;"	d
BOOST_WAVE_WCHAR_T_AUTOSELECT	wave/wave_config.hpp	413;"	d
BOOST_WAVE_WCHAR_T_FORCE_SIGNED	wave/wave_config.hpp	414;"	d
BOOST_WAVE_WCHAR_T_FORCE_UNSIGNED	wave/wave_config.hpp	415;"	d
BOOST_WAVE_WCHAR_T_SIGNEDNESS	wave/wave_config.hpp	418;"	d
BoolLiteralTokenType	wave/token_ids.hpp	/^    BoolLiteralTokenType        = 0x45080000,$/;"	e	enum:boost::wave::token_category
CATEGORY_FROM_TOKEN	wave/token_ids.hpp	334;"	d
CONVERT_TRIGRAPHS_HK050403_INCLUDED	wave/cpplexer/convert_trigraphs.hpp	13;"	d
CPPLEXER_EXCEPTIONS_HPP_1A09DE1A_6D1F_4091_AF7F_5F13AB0D31AB_INCLUDED	wave/cpplexer/cpplexer_exceptions.hpp	12;"	d
CPP_CHLIT_GRAMMAR_HPP_9527D349_6592_449A_A409_42A001E6C64C_INCLUDED	wave/grammars/cpp_chlit_grammar.hpp	12;"	d
CPP_CONTEXT_HPP_907485E2_6649_4A87_911B_7F7225F3E5B8_INCLUDED	wave/cpp_context.hpp	13;"	d
CPP_DEFINED_GRAMMAR_GEN_HPP_825BE9F5_98A3_400D_A97C_AD76B3B08632_INCLUDED	wave/grammars/cpp_defined_grammar_gen.hpp	12;"	d
CPP_DEFINED_GRAMMAR_HPP_F48287B2_DC67_40A8_B4A1_800EFBD67869_INCLUDED	wave/grammars/cpp_defined_grammar.hpp	12;"	d
CPP_EXCEPTIONS_HPP_5190E447_A781_4521_A275_5134FF9917D7_INCLUDED	wave/cpp_exceptions.hpp	12;"	d
CPP_EXPRESSION_GRAMMAR_GEN_HPP_42399258_6CDC_4101_863D_5C7D95B5A6CA_INCLUDED	wave/grammars/cpp_expression_grammar_gen.hpp	12;"	d
CPP_EXPRESSION_GRAMMAR_HPP_099CD1A4_A6C0_44BE_8F24_0B00F5BE5674_INCLUDED	wave/grammars/cpp_expression_grammar.hpp	12;"	d
CPP_EXPRESSION_VALUE_HPP_452FE66D_8754_4107_AF1E_E42255A0C18A_INCLUDED	wave/grammars/cpp_expression_value.hpp	12;"	d
CPP_GRAMMAR_GEN_HPP_80CB8A59_5411_4E45_B406_62531A12FB99_INCLUDED	wave/grammars/cpp_grammar_gen.hpp	12;"	d
CPP_GRAMMAR_HPP_FEAEBC2E_2734_428B_A7CA_85E5A415E23E_INCLUDED	wave/grammars/cpp_grammar.hpp	12;"	d
CPP_IFBLOCK_HPP_D4676B36_00C5_41F4_BC9F_9CBBAE3B8006_INCLUDED	wave/util/cpp_ifblock.hpp	12;"	d
CPP_INCLUDE_PATHS_HPP_AF620DA4_B3D2_4221_AD91_8A1ABFFB6944_INCLUDED	wave/util/cpp_include_paths.hpp	12;"	d
CPP_INTLIT_GRAMMAR_HPP_2E1E70B1_F15C_4132_8554_10A231B0D91C_INCLUDED	wave/grammars/cpp_intlit_grammar.hpp	12;"	d
CPP_ITERATION_CONTEXT_HPP_00312288_9DDB_4668_AFE5_25D3994FD095_INCLUDED	wave/cpp_iteration_context.hpp	13;"	d
CPP_ITERATOR_HPP_175CA88F_7273_43FA_9039_BCF7459E1F29_INCLUDED	wave/util/cpp_iterator.hpp	14;"	d
CPP_LEX_INTERFACE_HPP_E83F52A4_90AC_4FBE_A9A7_B65F7F94C497_INCLUDED	wave/cpplexer/cpp_lex_interface.hpp	14;"	d
CPP_LEX_ITERATOR_HPP_AF0C37E3_CBD8_4F33_A225_51CF576FA61F_INCLUDED	wave/cpplexer/cpp_lex_iterator.hpp	14;"	d
CPP_LITERAL_GRAMMAR_GEN_HPP_67794A6C_468A_4AAB_A757_DEDDB182F5A0_INCLUDED	wave/grammars/cpp_literal_grammar_gen.hpp	12;"	d
CPP_MACROMAP_HPP_CB8F51B0_A3F0_411C_AEF4_6FF631B8B414_INCLUDED	wave/util/cpp_macromap.hpp	14;"	d
CPP_MACROMAP_PREDEF_HPP_HK041119	wave/util/cpp_macromap_predef.hpp	14;"	d
CPP_MACROMAP_UTIL_HPP_HK041119	wave/util/cpp_macromap_utils.hpp	14;"	d
CPP_PREDEF_MACROS_GEN_HPP_CADB6D2C_76A4_4988_83E1_EFFC6902B9A2_INCLUDED	wave/grammars/cpp_predef_macros_gen.hpp	12;"	d
CPP_PREDEF_MACROS_GRAMMAR_HPP_53858C9A_C202_4D60_AD92_DC9CAE4DBB43_INCLUDED	wave/grammars/cpp_predef_macros_grammar.hpp	12;"	d
CPP_RE2C_LEXER_HPP_B81A2629_D5B1_4944_A97D_60254182B9A8_INCLUDED	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	14;"	d
CPP_RE_HPP_B76C4F5E_63E9_4B8A_9975_EC32FA6BF027_INCLUDED	wave/cpplexer/re2clex/cpp_re.hpp	14;"	d
CPP_TOKEN_HPP_53A13BD2_FBAA_444B_9B8B_FCB225C2BBA8_INCLUDED	wave/cpplexer/cpp_lex_token.hpp	14;"	d
CharacterLiteralTokenType	wave/token_ids.hpp	/^    CharacterLiteralTokenType   = 0x44080000,$/;"	e	enum:boost::wave::token_category
CowString	wave/util/flex_string.hpp	/^    CowString(const CowString& s)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(const CowString& s)
CowString	wave/util/flex_string.hpp	/^    CowString(const E* s, size_type len, const allocator_type& a)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(const E* s, size_type len, const allocator_type& a)
CowString	wave/util/flex_string.hpp	/^    CowString(const allocator_type& a)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(const allocator_type& a)
CowString	wave/util/flex_string.hpp	/^    CowString(size_type len, E c, const allocator_type& a)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(size_type len, E c, const allocator_type& a)
CowString	wave/util/flex_string.hpp	/^class CowString$/;"	c	namespace:boost::wave::util
DEFAULT_PREPROCESSING_HOOKS_HPP_INCLUDED	wave/preprocessing_hooks.hpp	12;"	d
DETECT_INCLUDE_GUARDS_HK060304_INCLUDED	wave/cpplexer/detect_include_guards.hpp	30;"	d
Data	wave/util/flex_string.hpp	/^        Data() : pEnd_(buffer_), pEndOfMem_(buffer_) { buffer_[0] = E(0); }$/;"	f	struct:boost::wave::util::SimpleStringStorage::Data	access:public	signature:()
Data	wave/util/flex_string.hpp	/^    Storage& Data() const$/;"	f	class:boost::wave::util::CowString	access:private	signature:() const
Data	wave/util/flex_string.hpp	/^    struct Data$/;"	s	class:boost::wave::util::SimpleStringStorage	access:public
Data	wave/util/flex_string.hpp	/^    typedef typename SimpleStringStorage<E, A>::Data Data;$/;"	t	class:boost::wave::util::AllocatorStringStorage	access:private
Data	wave/util/functor_input.hpp	/^            Data(FunctorT const &ftor_) $/;"	f	struct:boost::wave::util::functor_input::inner::Data	access:public	signature:(FunctorT const &ftor_)
Data	wave/util/functor_input.hpp	/^        struct Data {$/;"	s	class:boost::wave::util::functor_input::inner	access:private
DereferenceValidIterator	wave/util/flex_string.hpp	/^    DereferenceValidIterator(Iterator it) const$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(Iterator it) const
DereferenceValidIterator	wave/util/flex_string.hpp	/^    DereferenceValidIterator(std::reverse_iterator<Iterator> it) const$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(std::reverse_iterator<Iterator> it) const
E	wave/util/flex_string.hpp	/^    typedef typename Storage::value_type E;$/;"	t	class:boost::wave::util::CowString	access:private
EOFTokenType	wave/token_ids.hpp	/^    EOFTokenType                = 0xC0000000,$/;"	e	enum:boost::wave::token_category
EOLTokenType	wave/token_ids.hpp	/^    EOLTokenType                = 0xB0000000,$/;"	e	enum:boost::wave::token_category
EXTCATEGORY_FROM_TOKEN	wave/token_ids.hpp	335;"	d
Enforce	wave/util/flex_string.hpp	/^    static void Enforce(bool condition, Exception*, const char* msg)$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(bool condition, Exception*, const char* msg)
ExtParameterTokenType	wave/token_ids.hpp	/^    ExtParameterTokenType       = 0x11180000,$/;"	e	enum:boost::wave::token_category
ExtTokenOnlyMask	wave/token_ids.hpp	/^    ExtTokenOnlyMask            = 0x00F00000,$/;"	e	enum:boost::wave::token_category
ExtTokenTypeMask	wave/token_ids.hpp	/^    ExtTokenTypeMask            = 0xFFF00000,$/;"	e	enum:boost::wave::token_category
FILE_POSITION_H_52BDEDF7_DAD3_4F24_802F_E66BB8098F68_INCLUDED	wave/util/file_position.hpp	14;"	d
FLEX_STRING_INC_	wave/util/flex_string.hpp	39;"	d
FUNCTOR_INPUT_HPP_ED3A4C21_8F8A_453F_B438_08214FAC106A_INCLUDED	wave/util/functor_input.hpp	12;"	d
FloatingLiteralTokenType	wave/token_ids.hpp	/^    FloatingLiteralTokenType    = 0x42080000,$/;"	e	enum:boost::wave::token_category
Free	wave/util/flex_string.hpp	/^    void Free(void* p, size_type sz)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:private	signature:(void* p, size_type sz)
GetRefs	wave/util/flex_string.hpp	/^    RefCountType GetRefs() const$/;"	f	class:boost::wave::util::CowString	access:private	signature:() const
GetStorage	wave/util/flex_string.hpp	/^    Storage& GetStorage()$/;"	f	class:boost::wave::util::SmallStringOpt	access:private	signature:()
GetStorage	wave/util/flex_string.hpp	/^    const Storage& GetStorage() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:private	signature:() const
ID_FROM_TOKEN	wave/token_ids.hpp	320;"	d
ID_FROM_TOKEN	wave/token_ids.hpp	321;"	d
ID_FROM_TOKEN	wave/token_ids.hpp	41;"	d
INSERT_WHITESPACE_DETECTION_HPP_765EF77B_0513_4967_BDD6_6A38148C4C96_INCLUDED	wave/util/insert_whitespace_detection.hpp	13;"	d
INTERPRET_PRAGMA_HPP_B1F2315E_C5CE_4ED1_A343_0EF548B7942A_INCLUDED	wave/util/interpret_pragma.hpp	12;"	d
IS_CATEGORY	wave/token_ids.hpp	336;"	d
IS_EXTCATEGORY	wave/token_ids.hpp	339;"	d
ITERATION_CONTEXT_HPP_9556CD16_F11E_4ADC_AC8B_FB9A174BE664_INCLUDED	wave/util/iteration_context.hpp	12;"	d
IdentifierTokenType	wave/token_ids.hpp	/^    IdentifierTokenType         = 0x10080000,$/;"	e	enum:boost::wave::token_category
Init	wave/util/flex_string.hpp	/^    void Init(size_type size, size_type cap)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:private	signature:(size_type size, size_type cap)
Init	wave/util/flex_string.hpp	/^    void Init(size_type size, size_type capacity)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:private	signature:(size_type size, size_type capacity)
InsertImpl	wave/util/flex_string.hpp	/^    void InsertImpl(iterator i,$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator i, FwdIterator s1, FwdIterator s2, std::forward_iterator_tag)
InsertImpl	wave/util/flex_string.hpp	/^    void InsertImpl(iterator insertPosition,$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator insertPosition, InputIterator inputBegin, InputIterator inputEnd, std::input_iterator_tag)
InsertImplDiscr	wave/util/flex_string.hpp	/^    flex_string& InsertImplDiscr(iterator i,$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator i, InputIterator b, InputIterator e, Selector<0>)
InsertImplDiscr	wave/util/flex_string.hpp	/^    flex_string& InsertImplDiscr(iterator p, $/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator p, size_type n, value_type c, Selector<1>)
IntegerLiteralTokenType	wave/token_ids.hpp	/^    IntegerLiteralTokenType     = 0x41080000,$/;"	e	enum:boost::wave::token_category
InternalTokenType	wave/token_ids.hpp	/^    InternalTokenType           = 0xE0080000,$/;"	e	enum:boost::wave::token_category
Invariant	wave/util/flex_string.hpp	/^        Invariant(const flex_string& s) : s_(s)$/;"	f	struct:boost::wave::util::flex_string::Invariant	access:public	signature:(const flex_string& s)
Invariant	wave/util/flex_string.hpp	/^    struct Invariant$/;"	s	class:boost::wave::util::flex_string	access:private
IsAliasedRange	wave/util/flex_string.hpp	/^    bool IsAliasedRange(Iterator beginIterator, Iterator endIterator)$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(Iterator beginIterator, Iterator endIterator)
KeywordTokenType	wave/token_ids.hpp	/^    KeywordTokenType            = 0x20080000,$/;"	e	enum:boost::wave::token_category
LANGUAGE_SUPPORT_HPP_93EDD057_2DEF_44BC_BC9F_FDABB9F51AFA_INCLUDED	wave/language_support.hpp	12;"	d
LiteralTokenType	wave/token_ids.hpp	/^    LiteralTokenType            = 0x40080000,$/;"	e	enum:boost::wave::token_category
MACRO_DEFINITION_HPP_D68A639E_2DA5_4E9C_8ACD_CFE6B903831E_INCLUDED	wave/util/macro_definition.hpp	12;"	d
MACRO_HELPERS_HPP_931BBC99_EBFA_4692_8FBE_B555998C2C39_INCLUDED	wave/util/macro_helpers.hpp	12;"	d
MainTokenMask	wave/token_ids.hpp	/^    MainTokenMask               = 0xFF0FFFFF    \/\/ TokenTypeMask|TokenValueMask$/;"	e	enum:boost::wave::token_category
MakeUnique	wave/util/flex_string.hpp	/^    void MakeUnique() const$/;"	f	class:boost::wave::util::CowString	access:private	signature:() const
Min	wave/util/flex_string.hpp	/^    static size_type Min(size_type lhs, size_type rhs)$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(size_type lhs, size_type rhs)
OperatorTokenType	wave/token_ids.hpp	/^    OperatorTokenType           = 0x30080000,$/;"	e	enum:boost::wave::token_category
PHOENIX_LIMIT	wave/wave_config.hpp	424;"	d
PHOENIX_THREADSAFE	wave/wave_config.hpp	190;"	d
PPConditionalTokenType	wave/token_ids.hpp	/^    PPConditionalTokenType      = 0x50880000,$/;"	e	enum:boost::wave::token_category
PPTokenFlag	wave/token_ids.hpp	/^    PPTokenFlag                 = 0x00080000,   \/\/ these are 'real' pp-tokens$/;"	e	enum:boost::wave::token_category
PPTokenType	wave/token_ids.hpp	/^    PPTokenType                 = 0x50080000,$/;"	e	enum:boost::wave::token_category
ParameterTokenType	wave/token_ids.hpp	/^    ParameterTokenType          = 0x11080000,$/;"	e	enum:boost::wave::token_category
Procust	wave/util/flex_string.hpp	/^    static void Procust(size_type& n, size_type nmax)$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(size_type& n, size_type nmax)
Realloc	wave/util/flex_string.hpp	/^    void* Realloc(void* p, size_type oldSz, size_type newSz)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:private	signature:(void* p, size_type oldSz, size_type newSz)
Reallocate	wave/util/flex_string.hpp	/^typename Allocator::pointer Reallocate($/;"	f	namespace:boost::wave::util	signature:( Allocator& alloc, typename Allocator::pointer p, typename Allocator::size_type oldObjCount, typename Allocator::size_type newObjCount, mallocator<void>*)
Reallocate	wave/util/flex_string.hpp	/^typename Allocator::pointer Reallocate($/;"	f	namespace:boost::wave::util	signature:( Allocator& alloc, typename Allocator::pointer p, typename Allocator::size_type oldObjCount, typename Allocator::size_type newObjCount, void*)
RefCountType	wave/util/flex_string.hpp	/^    typedef typename flex_string_details::get_unsigned<E>::result RefCountType;$/;"	t	class:boost::wave::util::CowString	access:private
Refs	wave/util/flex_string.hpp	/^    RefCountType& Refs()$/;"	f	class:boost::wave::util::CowString	access:private	signature:()
ReplaceImpl	wave/util/flex_string.hpp	/^    void ReplaceImpl(iterator i1, iterator i2,$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator i1, iterator i2, FwdIterator s1, FwdIterator s2, std::forward_iterator_tag)
ReplaceImpl	wave/util/flex_string.hpp	/^    void ReplaceImpl(iterator i1, iterator i2,$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator i1, iterator i2, InputIterator b, InputIterator e, std::input_iterator_tag)
ReplaceImplDiscr	wave/util/flex_string.hpp	/^    flex_string& ReplaceImplDiscr(iterator i1, iterator i2, $/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator i1, iterator i2, const value_type* s, size_type n, Selector<2>)
ReplaceImplDiscr	wave/util/flex_string.hpp	/^    flex_string& ReplaceImplDiscr(iterator i1, iterator i2,$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator i1, iterator i2, InputIterator b, InputIterator e, Selector<0>)
ReplaceImplDiscr	wave/util/flex_string.hpp	/^    flex_string& ReplaceImplDiscr(iterator i1, iterator i2,$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator i1, iterator i2, size_type n2, value_type c, Selector<1>)
ReportErrorProc	wave/cpplexer/re2clex/scanner.hpp	/^typedef int (* ReportErrorProc)(struct Scanner const *, int errorcode,$/;"	t	namespace:boost::wave::cpplexer::re2clex
SCANNER_HPP_F4FB01EB_E75C_4537_A146_D34B9895EF37_INCLUDED	wave/cpplexer/re2clex/scanner.hpp	13;"	d
SYMBOL_TABLE_HPP_32B0F7C6_3DD6_4113_95A5_E16516C6F45A_INCLUDED	wave/util/symbol_table.hpp	12;"	d
Sane	wave/util/flex_string.hpp	/^    bool Sane() const$/;"	f	class:boost::wave::util::flex_string	access:private	signature:() const
Scanner	wave/cpplexer/re2clex/scanner.hpp	/^typedef struct Scanner {$/;"	s	namespace:boost::wave::cpplexer::re2clex
Scanner	wave/cpplexer/re2clex/scanner.hpp	/^} Scanner;$/;"	t	namespace:boost::wave::cpplexer::re2clex	typeref:struct:boost::wave::cpplexer::re2clex::Scanner
Selector	wave/util/flex_string.hpp	/^    template <int i> class Selector {};$/;"	c	class:boost::wave::util::flex_string	access:private
Shallow	wave/util/flex_string.hpp	/^    enum Shallow {};$/;"	g	namespace:boost::wave::util::flex_string_details
SimpleStringStorage	wave/util/flex_string.hpp	/^    SimpleStringStorage()$/;"	f	class:boost::wave::util::SimpleStringStorage	access:private	signature:()
SimpleStringStorage	wave/util/flex_string.hpp	/^    SimpleStringStorage(const A&)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(const A&)
SimpleStringStorage	wave/util/flex_string.hpp	/^    SimpleStringStorage(const E* s, size_type len, const A&)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(const E* s, size_type len, const A&)
SimpleStringStorage	wave/util/flex_string.hpp	/^    SimpleStringStorage(const SimpleStringStorage& rhs) $/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(const SimpleStringStorage& rhs)
SimpleStringStorage	wave/util/flex_string.hpp	/^    SimpleStringStorage(const SimpleStringStorage& s, $/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(const SimpleStringStorage& s, flex_string_details::Shallow)
SimpleStringStorage	wave/util/flex_string.hpp	/^    SimpleStringStorage(size_type len, E c, const A&)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(size_type len, E c, const A&)
SimpleStringStorage	wave/util/flex_string.hpp	/^class SimpleStringStorage$/;"	c	namespace:boost::wave::util
Small	wave/util/flex_string.hpp	/^    bool Small() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:private	signature:() const
SmallStringOpt	wave/util/flex_string.hpp	/^    SmallStringOpt(const allocator_type&)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(const allocator_type&)
SmallStringOpt	wave/util/flex_string.hpp	/^    SmallStringOpt(const value_type* s, size_type len, const allocator_type& a)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(const value_type* s, size_type len, const allocator_type& a)
SmallStringOpt	wave/util/flex_string.hpp	/^    SmallStringOpt(size_type len, value_type c, const allocator_type& a)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(size_type len, value_type c, const allocator_type& a)
SmallStringOpt	wave/util/flex_string.hpp	/^  SmallStringOpt(const SmallStringOpt& s)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(const SmallStringOpt& s)
SmallStringOpt	wave/util/flex_string.hpp	/^class SmallStringOpt$/;"	c	namespace:boost::wave::util
StringLiteralTokenType	wave/token_ids.hpp	/^    StringLiteralTokenType      = 0x43080000,$/;"	e	enum:boost::wave::token_category
TIME_CONVERSION_HELPER_HPP_DA97E389_1797_43BA_82AE_B071064B3EF4_INCLUDED	wave/util/time_conversion_helper.hpp	12;"	d
TOKEN_CACHE_HPP_4D2320B7_1D56_4113_A114_397E70FA438C_INCLUDED	wave/cpplexer/token_cache.hpp	12;"	d
TOKEN_FROM_ID	wave/token_ids.hpp	317;"	d
TOKEN_FROM_ID	wave/token_ids.hpp	318;"	d
TOKEN_FROM_ID	wave/token_ids.hpp	40;"	d
TOKEN_IDS_HPP_414E9A58_F079_4789_8AFF_513815CE475B_INCLUDED	wave/token_ids.hpp	14;"	d
TRACE_CHLIT_GRAMMAR	wave/grammars/cpp_chlit_grammar.hpp	126;"	d
TRACE_CHLIT_GRAMMAR	wave/grammars/cpp_chlit_grammar.hpp	286;"	d
TRACE_CPP_DEFINED_GRAMMAR	wave/grammars/cpp_defined_grammar.hpp	116;"	d
TRACE_CPP_DEFINED_GRAMMAR	wave/grammars/cpp_defined_grammar.hpp	43;"	d
TRACE_CPP_EXPR_GRAMMAR	wave/grammars/cpp_expression_grammar.hpp	285;"	d
TRACE_CPP_EXPR_GRAMMAR	wave/grammars/cpp_expression_grammar.hpp	740;"	d
TRACE_CPP_GRAMMAR	wave/grammars/cpp_grammar.hpp	148;"	d
TRACE_CPP_GRAMMAR	wave/grammars/cpp_grammar.hpp	684;"	d
TRACE_CPP_TIME_CONVERSION	wave/util/time_conversion_helper.hpp	137;"	d
TRACE_CPP_TIME_CONVERSION	wave/util/time_conversion_helper.hpp	44;"	d
TRACE_INTLIT_GRAMMAR	wave/grammars/cpp_intlit_grammar.hpp	140;"	d
TRACE_INTLIT_GRAMMAR	wave/grammars/cpp_intlit_grammar.hpp	59;"	d
TRACE_PREDEF_MACROS_GRAMMAR	wave/grammars/cpp_predef_macros_grammar.hpp	140;"	d
TRACE_PREDEF_MACROS_GRAMMAR	wave/grammars/cpp_predef_macros_grammar.hpp	36;"	d
TRANSFORM_ITERATOR_HPP_D492C659_88C7_4258_8C42_192F9AE80EC0_INCLUDED	wave/util/transform_iterator.hpp	12;"	d
T_ALIGNAS	wave/token_ids.hpp	/^    T_ALIGNAS      = TOKEN_FROM_ID(422, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_ALIGNOF	wave/token_ids.hpp	/^    T_ALIGNOF      = TOKEN_FROM_ID(423, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_AND	wave/token_ids.hpp	/^    T_AND          = TOKEN_FROM_ID(T_FIRST_TOKEN, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_ANDAND	wave/token_ids.hpp	/^    T_ANDAND       = TOKEN_FROM_ID(257, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_ANDAND_ALT	wave/token_ids.hpp	/^    T_ANDAND_ALT   = TOKEN_FROM_ID(257, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
T_ANDASSIGN	wave/token_ids.hpp	/^    T_ANDASSIGN    = TOKEN_FROM_ID(259, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_ANDASSIGN_ALT	wave/token_ids.hpp	/^    T_ANDASSIGN_ALT     = TOKEN_FROM_ID(259, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
T_AND_ALT	wave/token_ids.hpp	/^    T_AND_ALT      = TOKEN_FROM_ID(T_FIRST_TOKEN, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
T_ANY	wave/token_ids.hpp	/^    T_ANY          = TOKEN_FROM_ID(397, UnknownTokenType),$/;"	e	enum:boost::wave::token_id
T_ANY_TRIGRAPH	wave/token_ids.hpp	/^    T_ANY_TRIGRAPH = TOKEN_FROM_ID(397, UnknownTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
T_ARROW	wave/token_ids.hpp	/^    T_ARROW        = TOKEN_FROM_ID(290, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_ARROWSTAR	wave/token_ids.hpp	/^    T_ARROWSTAR    = TOKEN_FROM_ID(291, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_ASM	wave/token_ids.hpp	/^    T_ASM          = TOKEN_FROM_ID(305, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_ASSIGN	wave/token_ids.hpp	/^    T_ASSIGN       = TOKEN_FROM_ID(258, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_AUTO	wave/token_ids.hpp	/^    T_AUTO         = TOKEN_FROM_ID(306, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_BOOL	wave/token_ids.hpp	/^    T_BOOL         = TOKEN_FROM_ID(307, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_BREAK	wave/token_ids.hpp	/^    T_BREAK        = TOKEN_FROM_ID(310, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_CASE	wave/token_ids.hpp	/^    T_CASE         = TOKEN_FROM_ID(311, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_CATCH	wave/token_ids.hpp	/^    T_CATCH        = TOKEN_FROM_ID(312, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_CCOMMENT	wave/token_ids.hpp	/^    T_CCOMMENT     = TOKEN_FROM_ID(387, WhiteSpaceTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
T_CHAR	wave/token_ids.hpp	/^    T_CHAR         = TOKEN_FROM_ID(313, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_CHAR16_T	wave/token_ids.hpp	/^    T_CHAR16_T     = TOKEN_FROM_ID(424, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_CHAR32_T	wave/token_ids.hpp	/^    T_CHAR32_T     = TOKEN_FROM_ID(425, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_CHARLIT	wave/token_ids.hpp	/^    T_CHARLIT      = TOKEN_FROM_ID(389, CharacterLiteralTokenType),$/;"	e	enum:boost::wave::token_id
T_CLASS	wave/token_ids.hpp	/^    T_CLASS        = TOKEN_FROM_ID(314, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_COLON	wave/token_ids.hpp	/^    T_COLON        = TOKEN_FROM_ID(265, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_COLON_COLON	wave/token_ids.hpp	/^    T_COLON_COLON  = TOKEN_FROM_ID(296, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_COMMA	wave/token_ids.hpp	/^    T_COMMA        = TOKEN_FROM_ID(264, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_COMPL	wave/token_ids.hpp	/^    T_COMPL        = TOKEN_FROM_ID(303, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_COMPL_ALT	wave/token_ids.hpp	/^    T_COMPL_ALT         = TOKEN_FROM_ID(303, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
T_COMPL_TRIGRAPH	wave/token_ids.hpp	/^    T_COMPL_TRIGRAPH    = TOKEN_FROM_ID(303, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
T_CONST	wave/token_ids.hpp	/^    T_CONST        = TOKEN_FROM_ID(315, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_CONSTCAST	wave/token_ids.hpp	/^    T_CONSTCAST    = TOKEN_FROM_ID(316, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_CONSTEXPR	wave/token_ids.hpp	/^    T_CONSTEXPR    = TOKEN_FROM_ID(426, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_CONTINUE	wave/token_ids.hpp	/^    T_CONTINUE     = TOKEN_FROM_ID(317, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_CONTLINE	wave/token_ids.hpp	/^    T_CONTLINE     = TOKEN_FROM_ID(391, EOLTokenType),$/;"	e	enum:boost::wave::token_id
T_CPPCOMMENT	wave/token_ids.hpp	/^    T_CPPCOMMENT   = TOKEN_FROM_ID(388, WhiteSpaceTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
T_DECIMALINT	wave/token_ids.hpp	/^    T_DECIMALINT   = TOKEN_FROM_ID(382, IntegerLiteralTokenType),$/;"	e	enum:boost::wave::token_id
T_DECLTYPE	wave/token_ids.hpp	/^    T_DECLTYPE     = TOKEN_FROM_ID(427, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_DEFAULT	wave/token_ids.hpp	/^    T_DEFAULT      = TOKEN_FROM_ID(318, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_DELETE	wave/token_ids.hpp	/^    T_DELETE       = TOKEN_FROM_ID(319, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_DIVIDE	wave/token_ids.hpp	/^    T_DIVIDE       = TOKEN_FROM_ID(266, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_DIVIDE	wave/token_ids.hpp	31;"	d
T_DIVIDEASSIGN	wave/token_ids.hpp	/^    T_DIVIDEASSIGN = TOKEN_FROM_ID(267, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_DO	wave/token_ids.hpp	/^    T_DO           = TOKEN_FROM_ID(320, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_DOT	wave/token_ids.hpp	/^    T_DOT          = TOKEN_FROM_ID(268, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_DOTSTAR	wave/token_ids.hpp	/^    T_DOTSTAR      = TOKEN_FROM_ID(269, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_DOUBLE	wave/token_ids.hpp	/^    T_DOUBLE       = TOKEN_FROM_ID(321, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_DYNAMICCAST	wave/token_ids.hpp	/^    T_DYNAMICCAST  = TOKEN_FROM_ID(322, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_ELLIPSIS	wave/token_ids.hpp	/^    T_ELLIPSIS     = TOKEN_FROM_ID(270, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_ELSE	wave/token_ids.hpp	/^    T_ELSE         = TOKEN_FROM_ID(323, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_ENUM	wave/token_ids.hpp	/^    T_ENUM         = TOKEN_FROM_ID(324, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_EOF	wave/token_ids.hpp	/^    T_EOF          = TOKEN_FROM_ID(401, EOFTokenType),      \/\/ end of file reached$/;"	e	enum:boost::wave::token_id
T_EOI	wave/token_ids.hpp	/^    T_EOI          = TOKEN_FROM_ID(402, EOFTokenType),      \/\/ end of input reached$/;"	e	enum:boost::wave::token_id
T_EQUAL	wave/token_ids.hpp	/^    T_EQUAL        = TOKEN_FROM_ID(271, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_EXPLICIT	wave/token_ids.hpp	/^    T_EXPLICIT     = TOKEN_FROM_ID(325, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_EXPORT	wave/token_ids.hpp	/^    T_EXPORT       = TOKEN_FROM_ID(326, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_EXTERN	wave/token_ids.hpp	/^    T_EXTERN       = TOKEN_FROM_ID(327, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_EXTPARAMETERBASE	wave/token_ids.hpp	/^    T_EXTPARAMETERBASE = TOKEN_FROM_ID(T_LAST_TOKEN+4, ExtParameterTokenType)$/;"	e	enum:boost::wave::token_id
T_FALSE	wave/token_ids.hpp	/^    T_FALSE        = TOKEN_FROM_ID(308, BoolLiteralTokenType),$/;"	e	enum:boost::wave::token_id
T_FIRST_TOKEN	wave/token_ids.hpp	/^    T_FIRST_TOKEN  = 256,$/;"	e	enum:boost::wave::token_id
T_FIXEDPOINTLIT	wave/token_ids.hpp	/^    T_FIXEDPOINTLIT = TOKEN_FROM_ID(386, FloatingLiteralTokenType|AltTokenType),  \/\/ IDL specific$/;"	e	enum:boost::wave::token_id
T_FLOAT	wave/token_ids.hpp	/^    T_FLOAT        = TOKEN_FROM_ID(328, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_FLOATLIT	wave/token_ids.hpp	/^    T_FLOATLIT     = TOKEN_FROM_ID(386, FloatingLiteralTokenType),$/;"	e	enum:boost::wave::token_id
T_FOR	wave/token_ids.hpp	/^    T_FOR          = TOKEN_FROM_ID(329, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_FRIEND	wave/token_ids.hpp	/^    T_FRIEND       = TOKEN_FROM_ID(330, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_GENERATEDNEWLINE	wave/token_ids.hpp	/^    T_GENERATEDNEWLINE      = TOKEN_FROM_ID(394, EOLTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
T_GOTO	wave/token_ids.hpp	/^    T_GOTO         = TOKEN_FROM_ID(331, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_GREATER	wave/token_ids.hpp	/^    T_GREATER      = TOKEN_FROM_ID(272, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_GREATEREQUAL	wave/token_ids.hpp	/^    T_GREATEREQUAL = TOKEN_FROM_ID(273, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_HEXAINT	wave/token_ids.hpp	/^    T_HEXAINT      = TOKEN_FROM_ID(383, IntegerLiteralTokenType),$/;"	e	enum:boost::wave::token_id
T_IDENTIFIER	wave/token_ids.hpp	/^    T_IDENTIFIER   = TOKEN_FROM_ID(380, IdentifierTokenType),$/;"	e	enum:boost::wave::token_id
T_IF	wave/token_ids.hpp	/^    T_IF           = TOKEN_FROM_ID(332, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_IMPORT	wave/token_ids.hpp	/^    T_IMPORT       = TOKEN_FROM_ID(421, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_INLINE	wave/token_ids.hpp	/^    T_INLINE       = TOKEN_FROM_ID(333, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_INT	wave/token_ids.hpp	/^    T_INT          = TOKEN_FROM_ID(334, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_INTLIT	wave/token_ids.hpp	/^    T_INTLIT       = TOKEN_FROM_ID(384, IntegerLiteralTokenType),$/;"	e	enum:boost::wave::token_id
T_LAST_TOKEN	wave/token_ids.hpp	/^    T_LAST_TOKEN = ID_FROM_TOKEN(T_LAST_TOKEN_ID & ~PPTokenFlag),$/;"	e	enum:boost::wave::token_id
T_LAST_TOKEN_ID	wave/token_ids.hpp	/^    T_LAST_TOKEN_ID,$/;"	e	enum:boost::wave::token_id
T_LEFTBRACE	wave/token_ids.hpp	/^    T_LEFTBRACE    = TOKEN_FROM_ID(274, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_LEFTBRACE_ALT	wave/token_ids.hpp	/^    T_LEFTBRACE_ALT         = TOKEN_FROM_ID(274, OperatorTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
T_LEFTBRACE_TRIGRAPH	wave/token_ids.hpp	/^    T_LEFTBRACE_TRIGRAPH    = TOKEN_FROM_ID(274, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
T_LEFTBRACKET	wave/token_ids.hpp	/^    T_LEFTBRACKET  = TOKEN_FROM_ID(278, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_LEFTBRACKET_ALT	wave/token_ids.hpp	/^    T_LEFTBRACKET_ALT       = TOKEN_FROM_ID(278, OperatorTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
T_LEFTBRACKET_TRIGRAPH	wave/token_ids.hpp	/^    T_LEFTBRACKET_TRIGRAPH  = TOKEN_FROM_ID(278, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
T_LEFTPAREN	wave/token_ids.hpp	/^    T_LEFTPAREN    = TOKEN_FROM_ID(277, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_LESS	wave/token_ids.hpp	/^    T_LESS         = TOKEN_FROM_ID(275, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_LESSEQUAL	wave/token_ids.hpp	/^    T_LESSEQUAL    = TOKEN_FROM_ID(276, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_LONG	wave/token_ids.hpp	/^    T_LONG         = TOKEN_FROM_ID(335, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_LONGINTLIT	wave/token_ids.hpp	/^    T_LONGINTLIT   = TOKEN_FROM_ID(385, IntegerLiteralTokenType),$/;"	e	enum:boost::wave::token_id
T_MINUS	wave/token_ids.hpp	/^    T_MINUS        = TOKEN_FROM_ID(279, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_MINUSASSIGN	wave/token_ids.hpp	/^    T_MINUSASSIGN  = TOKEN_FROM_ID(280, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_MINUSMINUS	wave/token_ids.hpp	/^    T_MINUSMINUS   = TOKEN_FROM_ID(281, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_ASM	wave/token_ids.hpp	/^    T_MSEXT_ASM    = TOKEN_FROM_ID(418, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_BASED	wave/token_ids.hpp	/^    T_MSEXT_BASED  = TOKEN_FROM_ID(408, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_CDECL	wave/token_ids.hpp	/^    T_MSEXT_CDECL  = TOKEN_FROM_ID(410, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_DECLSPEC	wave/token_ids.hpp	/^    T_MSEXT_DECLSPEC = TOKEN_FROM_ID(409, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_EXCEPT	wave/token_ids.hpp	/^    T_MSEXT_EXCEPT = TOKEN_FROM_ID(414, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_FASTCALL	wave/token_ids.hpp	/^    T_MSEXT_FASTCALL = TOKEN_FROM_ID(411, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_FINALLY	wave/token_ids.hpp	/^    T_MSEXT_FINALLY = TOKEN_FROM_ID(415, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_INLINE	wave/token_ids.hpp	/^    T_MSEXT_INLINE = TOKEN_FROM_ID(417, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_INT16	wave/token_ids.hpp	/^    T_MSEXT_INT16  = TOKEN_FROM_ID(405, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_INT32	wave/token_ids.hpp	/^    T_MSEXT_INT32  = TOKEN_FROM_ID(406, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_INT64	wave/token_ids.hpp	/^    T_MSEXT_INT64  = TOKEN_FROM_ID(407, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_INT8	wave/token_ids.hpp	/^    T_MSEXT_INT8   = TOKEN_FROM_ID(404, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_LEAVE	wave/token_ids.hpp	/^    T_MSEXT_LEAVE  = TOKEN_FROM_ID(416, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_PP_ENDREGION	wave/token_ids.hpp	/^    T_MSEXT_PP_ENDREGION = TOKEN_FROM_ID(420, PPTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_PP_REGION	wave/token_ids.hpp	/^    T_MSEXT_PP_REGION    = TOKEN_FROM_ID(419, PPTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_STDCALL	wave/token_ids.hpp	/^    T_MSEXT_STDCALL = TOKEN_FROM_ID(412, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_MSEXT_TRY	wave/token_ids.hpp	/^    T_MSEXT_TRY    = TOKEN_FROM_ID(413, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_MUTABLE	wave/token_ids.hpp	/^    T_MUTABLE      = TOKEN_FROM_ID(336, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_NAMESPACE	wave/token_ids.hpp	/^    T_NAMESPACE    = TOKEN_FROM_ID(337, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_NEW	wave/token_ids.hpp	/^    T_NEW          = TOKEN_FROM_ID(338, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_NEWLINE	wave/token_ids.hpp	/^    T_NEWLINE      = TOKEN_FROM_ID(394, EOLTokenType),$/;"	e	enum:boost::wave::token_id
T_NOEXCEPT	wave/token_ids.hpp	/^    T_NOEXCEPT     = TOKEN_FROM_ID(428, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_NONREPLACABLE_IDENTIFIER	wave/token_ids.hpp	/^    T_NONREPLACABLE_IDENTIFIER = TOKEN_FROM_ID(T_LAST_TOKEN+1, IdentifierTokenType),$/;"	e	enum:boost::wave::token_id
T_NOT	wave/token_ids.hpp	/^    T_NOT          = TOKEN_FROM_ID(284, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_NOTEQUAL	wave/token_ids.hpp	/^    T_NOTEQUAL     = TOKEN_FROM_ID(285, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_NOTEQUAL_ALT	wave/token_ids.hpp	/^    T_NOTEQUAL_ALT      = TOKEN_FROM_ID(285, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
T_NOT_ALT	wave/token_ids.hpp	/^    T_NOT_ALT      = TOKEN_FROM_ID(284, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
T_NULLPTR	wave/token_ids.hpp	/^    T_NULLPTR      = TOKEN_FROM_ID(429, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_OCTALINT	wave/token_ids.hpp	/^    T_OCTALINT     = TOKEN_FROM_ID(381, IntegerLiteralTokenType),$/;"	e	enum:boost::wave::token_id
T_OPERATOR	wave/token_ids.hpp	/^    T_OPERATOR     = TOKEN_FROM_ID(339, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_OR	wave/token_ids.hpp	/^    T_OR           = TOKEN_FROM_ID(260, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_ORASSIGN	wave/token_ids.hpp	/^    T_ORASSIGN     = TOKEN_FROM_ID(261, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_ORASSIGN_ALT	wave/token_ids.hpp	/^    T_ORASSIGN_ALT          = TOKEN_FROM_ID(261, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
T_ORASSIGN_TRIGRAPH	wave/token_ids.hpp	/^    T_ORASSIGN_TRIGRAPH     = TOKEN_FROM_ID(261, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
T_OROR	wave/token_ids.hpp	/^    T_OROR         = TOKEN_FROM_ID(286, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_OROR_ALT	wave/token_ids.hpp	/^    T_OROR_ALT     = TOKEN_FROM_ID(286, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
T_OROR_TRIGRAPH	wave/token_ids.hpp	/^    T_OROR_TRIGRAPH     = TOKEN_FROM_ID(286, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
T_OR_ALT	wave/token_ids.hpp	/^    T_OR_ALT       = TOKEN_FROM_ID(260, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
T_OR_TRIGRAPH	wave/token_ids.hpp	/^    T_OR_TRIGRAPH  = TOKEN_FROM_ID(260, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
T_PARAMETERBASE	wave/token_ids.hpp	/^    T_PARAMETERBASE = TOKEN_FROM_ID(T_LAST_TOKEN+4, ParameterTokenType),$/;"	e	enum:boost::wave::token_id
T_PERCENT	wave/token_ids.hpp	/^    T_PERCENT      = TOKEN_FROM_ID(282, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_PERCENTASSIGN	wave/token_ids.hpp	/^    T_PERCENTASSIGN = TOKEN_FROM_ID(283, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_PLACEHOLDER	wave/token_ids.hpp	/^    T_PLACEHOLDER = TOKEN_FROM_ID(T_LAST_TOKEN+2, WhiteSpaceTokenType),$/;"	e	enum:boost::wave::token_id
T_PLACEMARKER	wave/token_ids.hpp	/^    T_PLACEMARKER = TOKEN_FROM_ID(T_LAST_TOKEN+3, InternalTokenType),$/;"	e	enum:boost::wave::token_id
T_PLUS	wave/token_ids.hpp	/^    T_PLUS         = TOKEN_FROM_ID(287, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_PLUSASSIGN	wave/token_ids.hpp	/^    T_PLUSASSIGN   = TOKEN_FROM_ID(288, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_PLUSPLUS	wave/token_ids.hpp	/^    T_PLUSPLUS     = TOKEN_FROM_ID(289, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_POUND	wave/token_ids.hpp	/^    T_POUND                 = TOKEN_FROM_ID(396, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_POUND_ALT	wave/token_ids.hpp	/^    T_POUND_ALT             = TOKEN_FROM_ID(396, OperatorTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
T_POUND_POUND	wave/token_ids.hpp	/^    T_POUND_POUND           = TOKEN_FROM_ID(395, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_POUND_POUND_ALT	wave/token_ids.hpp	/^    T_POUND_POUND_ALT       = TOKEN_FROM_ID(395, OperatorTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
T_POUND_POUND_TRIGRAPH	wave/token_ids.hpp	/^    T_POUND_POUND_TRIGRAPH  = TOKEN_FROM_ID(395, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
T_POUND_TRIGRAPH	wave/token_ids.hpp	/^    T_POUND_TRIGRAPH        = TOKEN_FROM_ID(396, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_DEFINE	wave/token_ids.hpp	/^    T_PP_DEFINE    = TOKEN_FROM_ID(368, PPTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_ELIF	wave/token_ids.hpp	/^    T_PP_ELIF      = TOKEN_FROM_ID(373, PPConditionalTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_ELSE	wave/token_ids.hpp	/^    T_PP_ELSE      = TOKEN_FROM_ID(372, PPConditionalTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_ENDIF	wave/token_ids.hpp	/^    T_PP_ENDIF     = TOKEN_FROM_ID(374, PPConditionalTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_ERROR	wave/token_ids.hpp	/^    T_PP_ERROR     = TOKEN_FROM_ID(375, PPTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_HHEADER	wave/token_ids.hpp	/^    T_PP_HHEADER   = TOKEN_FROM_ID(400, PPTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_HHEADER_NEXT	wave/token_ids.hpp	/^    T_PP_HHEADER_NEXT   = TOKEN_FROM_ID(400, PPTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_IF	wave/token_ids.hpp	/^    T_PP_IF        = TOKEN_FROM_ID(369, PPConditionalTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_IFDEF	wave/token_ids.hpp	/^    T_PP_IFDEF     = TOKEN_FROM_ID(370, PPConditionalTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_IFNDEF	wave/token_ids.hpp	/^    T_PP_IFNDEF    = TOKEN_FROM_ID(371, PPConditionalTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_INCLUDE	wave/token_ids.hpp	/^    T_PP_INCLUDE   = TOKEN_FROM_ID(398, PPTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_INCLUDE_NEXT	wave/token_ids.hpp	/^    T_PP_INCLUDE_NEXT   = TOKEN_FROM_ID(398, PPTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_LINE	wave/token_ids.hpp	/^    T_PP_LINE      = TOKEN_FROM_ID(376, PPTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_NUMBER	wave/token_ids.hpp	/^    T_PP_NUMBER    = TOKEN_FROM_ID(403, InternalTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_PRAGMA	wave/token_ids.hpp	/^    T_PP_PRAGMA    = TOKEN_FROM_ID(377, PPTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_QHEADER	wave/token_ids.hpp	/^    T_PP_QHEADER   = TOKEN_FROM_ID(399, PPTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_QHEADER_NEXT	wave/token_ids.hpp	/^    T_PP_QHEADER_NEXT   = TOKEN_FROM_ID(399, PPTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_UNDEF	wave/token_ids.hpp	/^    T_PP_UNDEF     = TOKEN_FROM_ID(378, PPTokenType),$/;"	e	enum:boost::wave::token_id
T_PP_WARNING	wave/token_ids.hpp	/^    T_PP_WARNING   = TOKEN_FROM_ID(379, PPTokenType),$/;"	e	enum:boost::wave::token_id
T_PRIVATE	wave/token_ids.hpp	/^    T_PRIVATE      = TOKEN_FROM_ID(340, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_PROTECTED	wave/token_ids.hpp	/^    T_PROTECTED    = TOKEN_FROM_ID(341, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_PUBLIC	wave/token_ids.hpp	/^    T_PUBLIC       = TOKEN_FROM_ID(342, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_QUESTION_MARK	wave/token_ids.hpp	/^    T_QUESTION_MARK = TOKEN_FROM_ID(292, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_RAWSTRINGLIT	wave/token_ids.hpp	/^    T_RAWSTRINGLIT = TOKEN_FROM_ID(432, StringLiteralTokenType),$/;"	e	enum:boost::wave::token_id
T_REGISTER	wave/token_ids.hpp	/^    T_REGISTER     = TOKEN_FROM_ID(343, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_REINTERPRETCAST	wave/token_ids.hpp	/^    T_REINTERPRETCAST = TOKEN_FROM_ID(344, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_RETURN	wave/token_ids.hpp	/^    T_RETURN       = TOKEN_FROM_ID(345, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_RIGHTBRACE	wave/token_ids.hpp	/^    T_RIGHTBRACE   = TOKEN_FROM_ID(293, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_RIGHTBRACE_ALT	wave/token_ids.hpp	/^    T_RIGHTBRACE_ALT        = TOKEN_FROM_ID(293, OperatorTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
T_RIGHTBRACE_TRIGRAPH	wave/token_ids.hpp	/^    T_RIGHTBRACE_TRIGRAPH   = TOKEN_FROM_ID(293, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
T_RIGHTBRACKET	wave/token_ids.hpp	/^    T_RIGHTBRACKET = TOKEN_FROM_ID(295, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_RIGHTBRACKET_ALT	wave/token_ids.hpp	/^    T_RIGHTBRACKET_ALT      = TOKEN_FROM_ID(295, OperatorTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
T_RIGHTBRACKET_TRIGRAPH	wave/token_ids.hpp	/^    T_RIGHTBRACKET_TRIGRAPH = TOKEN_FROM_ID(295, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
T_RIGHTPAREN	wave/token_ids.hpp	/^    T_RIGHTPAREN   = TOKEN_FROM_ID(294, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_SEMICOLON	wave/token_ids.hpp	/^    T_SEMICOLON    = TOKEN_FROM_ID(297, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_SHIFTLEFT	wave/token_ids.hpp	/^    T_SHIFTLEFT    = TOKEN_FROM_ID(298, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_SHIFTLEFTASSIGN	wave/token_ids.hpp	/^    T_SHIFTLEFTASSIGN = TOKEN_FROM_ID(299, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_SHIFTRIGHT	wave/token_ids.hpp	/^    T_SHIFTRIGHT   = TOKEN_FROM_ID(300, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_SHIFTRIGHTASSIGN	wave/token_ids.hpp	/^    T_SHIFTRIGHTASSIGN = TOKEN_FROM_ID(301, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_SHORT	wave/token_ids.hpp	/^    T_SHORT        = TOKEN_FROM_ID(346, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_SIGNED	wave/token_ids.hpp	/^    T_SIGNED       = TOKEN_FROM_ID(347, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_SIZEOF	wave/token_ids.hpp	/^    T_SIZEOF       = TOKEN_FROM_ID(348, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_SPACE	wave/token_ids.hpp	/^    T_SPACE        = TOKEN_FROM_ID(392, WhiteSpaceTokenType),$/;"	e	enum:boost::wave::token_id
T_SPACE2	wave/token_ids.hpp	/^    T_SPACE2       = TOKEN_FROM_ID(393, WhiteSpaceTokenType),$/;"	e	enum:boost::wave::token_id
T_STAR	wave/token_ids.hpp	/^    T_STAR         = TOKEN_FROM_ID(302, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_STARASSIGN	wave/token_ids.hpp	/^    T_STARASSIGN   = TOKEN_FROM_ID(304, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_STATIC	wave/token_ids.hpp	/^    T_STATIC       = TOKEN_FROM_ID(349, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_STATICASSERT	wave/token_ids.hpp	/^    T_STATICASSERT = TOKEN_FROM_ID(430, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_STATICCAST	wave/token_ids.hpp	/^    T_STATICCAST   = TOKEN_FROM_ID(350, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_STRINGLIT	wave/token_ids.hpp	/^    T_STRINGLIT    = TOKEN_FROM_ID(390, StringLiteralTokenType),$/;"	e	enum:boost::wave::token_id
T_STRUCT	wave/token_ids.hpp	/^    T_STRUCT       = TOKEN_FROM_ID(351, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_SWITCH	wave/token_ids.hpp	/^    T_SWITCH       = TOKEN_FROM_ID(352, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_TEMPLATE	wave/token_ids.hpp	/^    T_TEMPLATE     = TOKEN_FROM_ID(353, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_THIS	wave/token_ids.hpp	/^    T_THIS         = TOKEN_FROM_ID(354, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_THREADLOCAL	wave/token_ids.hpp	/^    T_THREADLOCAL  = TOKEN_FROM_ID(431, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_THROW	wave/token_ids.hpp	/^    T_THROW        = TOKEN_FROM_ID(355, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_TRUE	wave/token_ids.hpp	/^    T_TRUE         = TOKEN_FROM_ID(309, BoolLiteralTokenType),$/;"	e	enum:boost::wave::token_id
T_TRY	wave/token_ids.hpp	/^    T_TRY          = TOKEN_FROM_ID(356, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_TYPEDEF	wave/token_ids.hpp	/^    T_TYPEDEF      = TOKEN_FROM_ID(357, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_TYPEID	wave/token_ids.hpp	/^    T_TYPEID       = TOKEN_FROM_ID(358, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_TYPENAME	wave/token_ids.hpp	/^    T_TYPENAME     = TOKEN_FROM_ID(359, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_UNION	wave/token_ids.hpp	/^    T_UNION        = TOKEN_FROM_ID(360, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_UNKNOWN	wave/token_ids.hpp	/^    T_UNKNOWN      = 0,$/;"	e	enum:boost::wave::token_id
T_UNSIGNED	wave/token_ids.hpp	/^    T_UNSIGNED     = TOKEN_FROM_ID(361, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_USING	wave/token_ids.hpp	/^    T_USING        = TOKEN_FROM_ID(362, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_VIRTUAL	wave/token_ids.hpp	/^    T_VIRTUAL      = TOKEN_FROM_ID(363, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_VOID	wave/token_ids.hpp	/^    T_VOID         = TOKEN_FROM_ID(364, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_VOLATILE	wave/token_ids.hpp	/^    T_VOLATILE     = TOKEN_FROM_ID(365, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_WCHART	wave/token_ids.hpp	/^    T_WCHART       = TOKEN_FROM_ID(366, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_WHILE	wave/token_ids.hpp	/^    T_WHILE        = TOKEN_FROM_ID(367, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
T_XOR	wave/token_ids.hpp	/^    T_XOR          = TOKEN_FROM_ID(262, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_XORASSIGN	wave/token_ids.hpp	/^    T_XORASSIGN    = TOKEN_FROM_ID(263, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
T_XORASSIGN_ALT	wave/token_ids.hpp	/^    T_XORASSIGN_ALT         = TOKEN_FROM_ID(263, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
T_XORASSIGN_TRIGRAPH	wave/token_ids.hpp	/^    T_XORASSIGN_TRIGRAPH    = TOKEN_FROM_ID(263, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
T_XOR_ALT	wave/token_ids.hpp	/^    T_XOR_ALT      = TOKEN_FROM_ID(262, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
T_XOR_TRIGRAPH	wave/token_ids.hpp	/^    T_XOR_TRIGRAPH = TOKEN_FROM_ID(262, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
TokenTypeMask	wave/token_ids.hpp	/^    TokenTypeMask               = 0xFF000000,$/;"	e	enum:boost::wave::token_category
TokenValueMask	wave/token_ids.hpp	/^    TokenValueMask              = 0x000FFFFF,$/;"	e	enum:boost::wave::token_category
TriGraphTokenType	wave/token_ids.hpp	/^    TriGraphTokenType           = 0x00200000,$/;"	e	enum:boost::wave::token_category
UNPUT_QUEUE_ITERATOR_HPP_76DA23D0_4893_4AD5_ABCC_6CED7CFB89BC_INCLUDED	wave/util/unput_queue_iterator.hpp	13;"	d
UnknownTokenType	wave/token_ids.hpp	/^    UnknownTokenType            = 0xA0000000,$/;"	e	enum:boost::wave::token_category
VALIDATE_UNIVERSAL_CHAR_HPP_55F1B811_CD76_4C72_8344_CBC69CF3B339_INCLUDED	wave/cpplexer/validate_universal_char.hpp	13;"	d
VectorStringStorage	wave/util/flex_string.hpp	/^    VectorStringStorage(const A& a) : base(1, E(), a)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(const A& a)
VectorStringStorage	wave/util/flex_string.hpp	/^    VectorStringStorage(const E* s, size_type len, const A& a)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(const E* s, size_type len, const A& a)
VectorStringStorage	wave/util/flex_string.hpp	/^    VectorStringStorage(const VectorStringStorage& s) : base(s)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(const VectorStringStorage& s)
VectorStringStorage	wave/util/flex_string.hpp	/^    VectorStringStorage(size_type len, E c, const A& a)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(size_type len, E c, const A& a)
VectorStringStorage	wave/util/flex_string.hpp	/^class VectorStringStorage : protected std::vector<E, A>$/;"	c	namespace:boost::wave::util	inherits:std::vector
WAVE_CONFIG_HPP_F143F90A_A63F_4B27_AC41_9CA4F14F538D_INCLUDED	wave/wave_config.hpp	14;"	d
WAVE_VERSION_H_9D79ABDB_AC54_4C0A_89B1_F70A2DCFE21E_INCLUDED	wave/wave_version.hpp	14;"	d
WHITESPACE_HANDLING_HPP_INCLUDED	wave/whitespace_handling.hpp	14;"	d
WhiteSpaceTokenType	wave/token_ids.hpp	/^    WhiteSpaceTokenType         = 0xD0000000,$/;"	e	enum:boost::wave::token_category
act	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* act;     \/* act position of input buffer *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
act_in_c99_mode	wave/cpplexer/re2clex/scanner.hpp	/^    bool act_in_c99_mode;        \/* lexer works in C99 mode *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
act_in_cpp0x_mode	wave/cpplexer/re2clex/scanner.hpp	/^    bool act_in_cpp0x_mode;      \/* lexer works in C++11 mode *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
act_pos	wave/util/cpp_iterator.hpp	/^    typename result_type::position_type &act_pos;   \/\/ current fileposition (references the macromap)$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
act_token	wave/util/cpp_iterator.hpp	/^    result_type act_token;          \/\/ current token$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
act_token	wave/util/cpp_macromap.hpp	/^    token_type act_token;       \/\/ current token$/;"	m	class:boost::wave::util::macromap	access:private
action_policy_t	wave/grammars/cpp_grammar.hpp	/^        typedef typename ScannerT::action_policy_t action_policy_t;$/;"	t	struct:boost::wave::grammars::cpp_grammar::definition	access:public
actual_context_type	wave/cpp_context.hpp	/^        >::type actual_context_type;$/;"	t	class:boost::wave::context	access:private
add_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t add_exp, multiply_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
add_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t add_exp_nocalc, multiply_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
add_include_path	wave/cpp_context.hpp	/^    bool add_include_path(char const *path_)$/;"	f	class:boost::wave::context	access:public	signature:(char const *path_)
add_include_path	wave/util/cpp_include_paths.hpp	/^    bool add_include_path(char const *path_, bool is_system = false)$/;"	f	class:boost::wave::util::include_paths	access:public	signature:(char const *path_, bool is_system = false)
add_include_path	wave/util/cpp_include_paths.hpp	/^    bool add_include_path(char const *path_, include_list_type &pathes_);$/;"	p	class:boost::wave::util::include_paths	access:protected	signature:(char const *path_, include_list_type &pathes_)
add_include_path	wave/util/cpp_include_paths.hpp	/^bool include_paths::add_include_path ($/;"	f	class:boost::wave::util::include_paths	signature:( char const *path_, include_list_type &pathes_)
add_macro	wave/util/cpp_macromap.hpp	/^    bool add_macro(token_type const &name, bool has_parameters,$/;"	p	class:boost::wave::util::macromap	access:public	signature:(token_type const &name, bool has_parameters, parameter_container_type &parameters, definition_container_type &definition, bool is_predefined = false, defined_macros_type *scope = 0)
add_macro	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::add_macro(token_type const &name, bool has_parameters,$/;"	f	class:boost::wave::util::macromap	signature:(token_type const &name, bool has_parameters, parameter_container_type &parameters, definition_container_type &definition, bool is_predefined, defined_macros_type *scope)
add_macro_definition	wave/cpp_context.hpp	/^    bool add_macro_definition(StringT const &name, position_type const& pos, $/;"	f	class:boost::wave::context	access:public	signature:(StringT const &name, position_type const& pos, bool has_params, std::vector<token_type> &parameters, token_sequence_type &definition, bool is_predefined = false)
add_macro_definition	wave/cpp_context.hpp	/^    bool add_macro_definition(StringT macrostring, bool is_predefined = false)$/;"	f	class:boost::wave::context	access:public	signature:(StringT macrostring, bool is_predefined = false)
add_macro_definition	wave/cpp_context.hpp	/^    bool add_macro_definition(token_type const &name, bool has_params,$/;"	f	class:boost::wave::context	access:public	signature:(token_type const &name, bool has_params, std::vector<token_type> &parameters, token_sequence_type &definition, bool is_predefined = false)
add_macro_definition	wave/util/cpp_iterator.hpp	/^bool add_macro_definition(ContextT &ctx, std::string macrostring,$/;"	f	namespace:boost::wave::util	signature:(ContextT &ctx, std::string macrostring, bool is_predefined, boost::wave::language_support language)
add_pragma_once_header	wave/cpp_context.hpp	/^    bool add_pragma_once_header(std::string const &filename_,$/;"	f	class:boost::wave::context	access:public	signature:(std::string const &filename_, std::string const& guard_name)
add_pragma_once_header	wave/cpp_context.hpp	/^    bool add_pragma_once_header(token_type const &pragma_, $/;"	f	class:boost::wave::context	access:public	signature:(token_type const &pragma_, std::string const &filename_)
add_pragma_once_header	wave/util/cpp_include_paths.hpp	/^    bool add_pragma_once_header(std::string const &filename, $/;"	f	class:boost::wave::util::include_paths	access:public	signature:(std::string const &filename, std::string const& guard_name)
add_sysinclude_path	wave/cpp_context.hpp	/^    bool add_sysinclude_path(char const *path_)$/;"	f	class:boost::wave::context	access:public	signature:(char const *path_)
addref	wave/cpplexer/cpp_lex_token.hpp	/^    std::size_t addref() { return ++refcnt; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:()
address	wave/util/flex_string.hpp	/^    const_pointer address(const_reference x) const $/;"	f	class:boost::wave::util::mallocator	access:public	signature:(const_reference x) const
address	wave/util/flex_string.hpp	/^    pointer address(reference x) const { return &x; }$/;"	f	class:boost::wave::util::mallocator	access:public	signature:(reference x) const
advance_input	wave/util/functor_input.hpp	/^        void advance_input()$/;"	f	class:boost::wave::util::functor_input::inner	access:public	signature:()
align_	wave/util/flex_string.hpp	/^        Align align_;$/;"	m	union:boost::wave::util::CowString::__anon6	access:public
align_	wave/util/flex_string.hpp	/^        Align align_;$/;"	m	union:boost::wave::util::SmallStringOpt::__anon5	access:public
allocate	wave/util/flex_string.hpp	/^    pointer allocate(size_type n, const_pointer = 0) $/;"	f	class:boost::wave::util::mallocator	access:public	signature:(size_type n, const_pointer = 0)
allocator_type	wave/util/flex_string.hpp	/^    typedef A allocator_type;$/;"	t	class:boost::wave::util::AllocatorStringStorage	access:public
allocator_type	wave/util/flex_string.hpp	/^    typedef A allocator_type;$/;"	t	class:boost::wave::util::SimpleStringStorage	access:public
allocator_type	wave/util/flex_string.hpp	/^    typedef A allocator_type;$/;"	t	class:boost::wave::util::VectorStringStorage	access:public
allocator_type	wave/util/flex_string.hpp	/^    typedef A allocator_type;$/;"	t	class:boost::wave::util::flex_string	access:public
allocator_type	wave/util/flex_string.hpp	/^    typedef typename Storage::allocator_type allocator_type;$/;"	t	class:boost::wave::util::CowString	access:public
allocator_type	wave/util/flex_string.hpp	/^    typedef typename Storage::allocator_type allocator_type;$/;"	t	class:boost::wave::util::SmallStringOpt	access:public
alreadydefined_name	wave/cpp_exceptions.hpp	/^        alreadydefined_name,$/;"	e	enum:boost::wave::preprocess_exception::error_code
and_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t inclusive_or_exp, exclusive_or_exp, and_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
and_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t inclusive_or_exp_nocalc, exclusive_or_exp_nocalc, and_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
append	wave/util/flex_string.hpp	/^    flex_string& append(InputIterator first, InputIterator last)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(InputIterator first, InputIterator last)
append	wave/util/flex_string.hpp	/^    flex_string& append(const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str)
append	wave/util/flex_string.hpp	/^    flex_string& append(const flex_string& str, const size_type pos,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, const size_type pos, size_type n)
append	wave/util/flex_string.hpp	/^    flex_string& append(const value_type* s)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s)
append	wave/util/flex_string.hpp	/^    flex_string& append(const value_type* s, const size_type n)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, const size_type n)
append	wave/util/flex_string.hpp	/^    flex_string& append(size_type n, value_type c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type n, value_type c)
append	wave/util/flex_string.hpp	/^    void append(ForwardIterator b, ForwardIterator e)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(ForwardIterator b, ForwardIterator e)
append	wave/util/flex_string.hpp	/^    void append(FwdIterator b, FwdIterator e)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(FwdIterator b, FwdIterator e)
append	wave/util/flex_string.hpp	/^    void append(InputIterator b, InputIterator e)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(InputIterator b, InputIterator e)
append	wave/util/flex_string.hpp	/^    void append(InputIterator b, InputIterator e)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(InputIterator b, InputIterator e)
append	wave/util/flex_string.hpp	/^    void append(InputIterator b, InputIterator e)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(InputIterator b, InputIterator e)
append	wave/util/flex_string.hpp	/^    void append(const E* s, size_type sz)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(const E* s, size_type sz)
append	wave/util/flex_string.hpp	/^    void append(const E* s, size_type sz)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(const E* s, size_type sz)
append	wave/util/flex_string.hpp	/^    void append(const value_type* s, size_type sz)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(const value_type* s, size_type sz)
aq_create	wave/cpplexer/re2clex/aq.hpp	/^BOOST_WAVE_DECL aq_queue aq_create(void);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(void)
aq_enqueue	wave/cpplexer/re2clex/aq.hpp	/^int aq_enqueue(aq_queue q, aq_stdelement e);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(aq_queue q, aq_stdelement e)
aq_enqueue_front	wave/cpplexer/re2clex/aq.hpp	/^int aq_enqueue_front(aq_queue q, aq_stdelement e);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(aq_queue q, aq_stdelement e)
aq_grow	wave/cpplexer/re2clex/aq.hpp	/^int aq_grow(aq_queue q);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(aq_queue q)
aq_pop	wave/cpplexer/re2clex/aq.hpp	/^int aq_pop(aq_queue q);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(aq_queue q)
aq_queue	wave/cpplexer/re2clex/aq.hpp	/^typedef aq_queuetype* aq_queue;$/;"	t	namespace:boost::wave::cpplexer::re2clex
aq_queuetype	wave/cpplexer/re2clex/aq.hpp	/^} aq_queuetype;$/;"	t	namespace:boost::wave::cpplexer::re2clex	typeref:struct:boost::wave::cpplexer::re2clex::tag_aq_queuetype
aq_serve	wave/cpplexer/re2clex/aq.hpp	/^int aq_serve(aq_queue q, aq_stdelement *e);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(aq_queue q, aq_stdelement *e)
aq_stdelement	wave/cpplexer/re2clex/aq.hpp	/^typedef std::size_t aq_stdelement;$/;"	t	namespace:boost::wave::cpplexer::re2clex
aq_terminate	wave/cpplexer/re2clex/aq.hpp	/^BOOST_WAVE_DECL void aq_terminate(aq_queue q);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(aq_queue q)
argument_type	wave/util/transform_iterator.hpp	/^        typedef ParseTreeNodeT const &argument_type;$/;"	t	struct:boost::wave::impl::get_token_value	access:public
argument_type	wave/util/transform_iterator.hpp	/^        typedef typename AdaptableUnaryFunctionT::argument_type argument_type;$/;"	t	class:boost::wave::impl::ref_transform_iterator_generator	access:private
as_bool	wave/grammars/cpp_expression_grammar.hpp	/^    phoenix::function<operator_as_bool> const as_bool;$/;"	m	class:boost::wave::grammars::impl::phoenix
as_bool	wave/grammars/cpp_expression_value.hpp	/^    friend bool as_bool(closure_value const& v)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const& v)
as_bool	wave/grammars/cpp_expression_value.hpp	/^inline bool as_bool(closure_value const& v);$/;"	p	namespace:boost::wave::grammars::closures	signature:(closure_value const& v)
as_chlit	wave/grammars/cpp_expression_grammar.hpp	/^    phoenix::function<convert_chlit> const as_chlit;$/;"	m	class:boost::wave::grammars::impl::phoenix
as_int	wave/grammars/cpp_expression_value.hpp	/^    friend int_literal_type as_int(closure_value const& v)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const& v)
as_intlit	wave/grammars/cpp_expression_grammar.hpp	/^    phoenix::function<convert_intlit> const as_intlit;$/;"	m	class:boost::wave::grammars::impl::phoenix
as_long	wave/grammars/cpp_expression_value.hpp	/^    friend int_literal_type as_long(closure_value const& v) $/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const& v)
as_relative_to	wave/util/cpp_include_paths.hpp	/^as_relative_to(boost::filesystem::path const& path, $/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& path, boost::filesystem::path const& base, boost::filesystem::path& result)
as_string	wave/util/macro_helpers.hpp	/^    as_string (ContainerT const &token_sequence)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT const &token_sequence)
as_string	wave/util/macro_helpers.hpp	/^    as_string(IteratorT it, IteratorT const& end)$/;"	f	namespace:boost::wave::util::impl	signature:(IteratorT it, IteratorT const& end)
as_stringlit	wave/util/macro_helpers.hpp	/^    as_stringlit (ContainerT const &token_sequence, PositionT const &pos)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT const &token_sequence, PositionT const &pos)
as_stringlit	wave/util/macro_helpers.hpp	/^    as_stringlit (std::vector<ContainerT> const &arguments, $/;"	f	namespace:boost::wave::util::impl	signature:(std::vector<ContainerT> const &arguments, typename std::vector<ContainerT>::size_type i, PositionT const &pos)
as_uint	wave/grammars/cpp_expression_value.hpp	/^    friend uint_literal_type as_uint(closure_value const& v)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const& v)
as_ulong	wave/grammars/cpp_expression_value.hpp	/^    friend uint_literal_type as_ulong(closure_value const& v)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const& v)
assign	wave/util/cpp_macromap_utils.hpp	/^        assign(IteratorT &it_, IteratorT const &uit_) $/;"	f	class:boost::wave::util::on_exit::assign	access:public	signature:(IteratorT &it_, IteratorT const &uit_)
assign	wave/util/cpp_macromap_utils.hpp	/^        assign(IteratorT &it_, UnputIteratorT const &uit_) $/;"	f	class:boost::wave::util::on_exit::assign	access:public	signature:(IteratorT &it_, UnputIteratorT const &uit_)
assign	wave/util/cpp_macromap_utils.hpp	/^    class assign$/;"	c	namespace:boost::wave::util::on_exit
assign	wave/util/cpp_macromap_utils.hpp	/^    class assign<IteratorT, IteratorT> {$/;"	c	namespace:boost::wave::util::on_exit
assign	wave/util/flex_string.hpp	/^    flex_string& assign(ItOrLength first_or_n, ItOrChar last_or_c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(ItOrLength first_or_n, ItOrChar last_or_c)
assign	wave/util/flex_string.hpp	/^    flex_string& assign(const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str)
assign	wave/util/flex_string.hpp	/^    flex_string& assign(const flex_string& str, size_type pos,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos, size_type n)
assign	wave/util/flex_string.hpp	/^    flex_string& assign(const value_type* s)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s)
assign	wave/util/flex_string.hpp	/^    flex_string& assign(const value_type* s, size_type n)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type n)
assign_iterator	wave/util/unput_queue_iterator.hpp	/^    struct assign_iterator $/;"	s	namespace:boost::wave::util::impl
at	wave/util/flex_string.hpp	/^    const_reference at(size_type n) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type n) const
at	wave/util/flex_string.hpp	/^    reference at(size_type n)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type n)
at_eof	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    bool at_eof;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
b	wave/grammars/cpp_expression_value.hpp	/^        bool b;$/;"	m	union:boost::wave::grammars::closures::closure_value::__anon7	access:public
back	wave/util/flex_string.hpp	/^    value_type & back() { return *(begin()+size()-1); }$/;"	f	class:boost::wave::util::flex_string	access:public	signature:()
back	wave/util/flex_string.hpp	/^    value_type const& back() const { return *(begin()+size()-1); }$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
bad_define_statement	wave/cpp_exceptions.hpp	/^        bad_define_statement,$/;"	e	enum:boost::wave::preprocess_exception::error_code
bad_define_statement_va_args	wave/cpp_exceptions.hpp	/^        bad_define_statement_va_args,$/;"	e	enum:boost::wave::preprocess_exception::error_code
bad_include_file	wave/cpp_exceptions.hpp	/^        bad_include_file,$/;"	e	enum:boost::wave::preprocess_exception::error_code
bad_include_statement	wave/cpp_exceptions.hpp	/^        bad_include_statement,$/;"	e	enum:boost::wave::preprocess_exception::error_code
bad_line_filename	wave/cpp_exceptions.hpp	/^        bad_line_filename,$/;"	e	enum:boost::wave::preprocess_exception::error_code
bad_line_number	wave/cpp_exceptions.hpp	/^        bad_line_number,$/;"	e	enum:boost::wave::preprocess_exception::error_code
bad_line_statement	wave/cpp_exceptions.hpp	/^        bad_line_statement,$/;"	e	enum:boost::wave::preprocess_exception::error_code
bad_macro_definition	wave/cpp_exceptions.hpp	/^        bad_macro_definition,$/;"	e	enum:boost::wave::preprocess_exception::error_code
bad_undefine_statement	wave/cpp_exceptions.hpp	/^        bad_undefine_statement,$/;"	e	enum:boost::wave::preprocess_exception::error_code
base	wave/util/flex_string.hpp	/^    typedef std::vector<E, A> base;$/;"	t	class:boost::wave::util::VectorStringStorage	access:private
base_iteration_context	wave/cpp_iteration_context.hpp	/^    base_iteration_context(ContextT& ctx_,$/;"	f	struct:boost::wave::base_iteration_context	access:public	signature:(ContextT& ctx_, BOOST_WAVE_STRINGTYPE const &fname, std::size_t if_block_depth = 0)
base_iteration_context	wave/cpp_iteration_context.hpp	/^    base_iteration_context(ContextT& ctx_,$/;"	f	struct:boost::wave::base_iteration_context	access:public	signature:(ContextT& ctx_, IteratorT const &first_, IteratorT const &last_, BOOST_WAVE_STRINGTYPE const &fname, std::size_t if_block_depth = 0, file_type type_ = main_file)
base_iteration_context	wave/cpp_iteration_context.hpp	/^struct base_iteration_context$/;"	s	namespace:boost::wave
base_iteration_context_type	wave/util/cpp_iterator.hpp	/^        base_iteration_context_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
base_name	wave/util/cpp_macromap.hpp	/^    string_type base_name;      \/\/ the name to be expanded by __BASE_FILE__$/;"	m	class:boost::wave::util::macromap	access:private
base_type	wave/cpp_iteration_context.hpp	/^    typedef base_iteration_context<ContextT, IteratorT> base_type;$/;"	t	struct:boost::wave::iteration_context	access:public
base_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef typename make_multi_pass<input_policy_type>::type base_type;$/;"	t	class:boost::wave::cpplexer::lex_iterator	access:private
base_type	wave/grammars/cpp_grammar.hpp	/^        typedef std::map<boost::spirit::classic::parser_id, std::string> base_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar::map_ruleid_to_name	access:public
base_type	wave/util/cpp_iterator.hpp	/^        base_type;$/;"	t	class:boost::wave::pp_iterator	access:private
base_type	wave/util/file_position.hpp	/^    typedef boost::spirit::classic::position_iterator<IteratorT, PositionT> base_type;$/;"	t	struct:boost::wave::util::position_iterator	access:public
base_type	wave/util/iteration_context.hpp	/^    typedef std::stack<IterationContextT> base_type;$/;"	t	class:boost::wave::util::iteration_context_stack	access:private
base_type	wave/util/symbol_table.hpp	/^    typedef std::map<StringT, boost::shared_ptr<MacroDefT> > base_type;$/;"	t	struct:boost::wave::util::symbol_table	access:public
base_type	wave/util/unput_queue_iterator.hpp	/^        base_type;$/;"	t	class:boost::wave::util::unput_queue_iterator	access:private
beforeprev	wave/util/insert_whitespace_detection.hpp	/^    boost::wave::token_id beforeprev;  \/\/ the token before the previous$/;"	m	class:boost::wave::util::insert_whitespace_detection	access:private
begin	wave/cpp_context.hpp	/^    iterator_type begin($/;"	f	class:boost::wave::context	access:public	signature:( target_iterator_type const &first_, target_iterator_type const &last_)
begin	wave/cpp_context.hpp	/^    iterator_type begin() $/;"	f	class:boost::wave::context	access:public	signature:()
begin	wave/util/cpp_macromap.hpp	/^    const_name_iterator begin() const$/;"	f	class:boost::wave::util::macromap	access:public	signature:() const
begin	wave/util/cpp_macromap.hpp	/^    name_iterator begin()$/;"	f	class:boost::wave::util::macromap	access:public	signature:()
begin	wave/util/flex_string.hpp	/^    const_iterator begin() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
begin	wave/util/flex_string.hpp	/^    const_iterator begin() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
begin	wave/util/flex_string.hpp	/^    const_iterator begin() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
begin	wave/util/flex_string.hpp	/^    const_iterator begin() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
begin	wave/util/flex_string.hpp	/^    const_iterator begin() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
begin	wave/util/flex_string.hpp	/^    const_iterator begin() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
begin	wave/util/flex_string.hpp	/^    iterator begin()$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:()
begin	wave/util/flex_string.hpp	/^    iterator begin()$/;"	f	class:boost::wave::util::CowString	access:public	signature:()
begin	wave/util/flex_string.hpp	/^    iterator begin()$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:()
begin	wave/util/flex_string.hpp	/^    iterator begin()$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:()
begin	wave/util/flex_string.hpp	/^    iterator begin()$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:()
begin	wave/util/flex_string.hpp	/^    iterator begin()$/;"	f	class:boost::wave::util::flex_string	access:public	signature:()
bidirectional_map	wave/util/cpp_include_paths.hpp	/^struct bidirectional_map$/;"	s	namespace:boost::wave::util
bol_whitespace	wave/whitespace_handling.hpp	/^    state_t general, newline, newline_2nd, whitespace, bol_whitespace;$/;"	m	class:boost::wave::context_policies::eat_whitespace	access:private
bol_whitespace	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::bol_whitespace(TokenT &token, bool &skipped_newline) $/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:(TokenT &token, bool &skipped_newline)
boost	wave/cpp_context.hpp	/^namespace boost { namespace serialization {$/;"	n
boost	wave/cpp_context.hpp	/^namespace boost {$/;"	n
boost	wave/cpp_exceptions.hpp	/^namespace boost {$/;"	n
boost	wave/cpp_iteration_context.hpp	/^namespace boost {$/;"	n
boost	wave/cpp_throw.hpp	/^namespace boost { namespace wave { namespace util$/;"	n
boost	wave/cpplexer/convert_trigraphs.hpp	/^namespace boost {$/;"	n
boost	wave/cpplexer/cpp_lex_interface.hpp	/^namespace boost {$/;"	n
boost	wave/cpplexer/cpp_lex_interface_generator.hpp	/^namespace boost {$/;"	n
boost	wave/cpplexer/cpp_lex_iterator.hpp	/^namespace boost {$/;"	n
boost	wave/cpplexer/cpp_lex_token.hpp	/^namespace boost {$/;"	n
boost	wave/cpplexer/cpplexer_exceptions.hpp	/^namespace boost {$/;"	n
boost	wave/cpplexer/detect_include_guards.hpp	/^namespace boost {$/;"	n
boost	wave/cpplexer/re2clex/aq.hpp	/^namespace boost {$/;"	n
boost	wave/cpplexer/re2clex/cpp_re.hpp	/^namespace boost {$/;"	n
boost	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^namespace boost {$/;"	n
boost	wave/cpplexer/re2clex/scanner.hpp	/^namespace boost {$/;"	n
boost	wave/cpplexer/token_cache.hpp	/^namespace boost {$/;"	n
boost	wave/cpplexer/validate_universal_char.hpp	/^namespace boost {$/;"	n
boost	wave/grammars/cpp_chlit_grammar.hpp	/^namespace boost {$/;"	n
boost	wave/grammars/cpp_defined_grammar.hpp	/^namespace boost {$/;"	n
boost	wave/grammars/cpp_defined_grammar_gen.hpp	/^namespace boost {$/;"	n
boost	wave/grammars/cpp_expression_grammar.hpp	/^namespace boost {$/;"	n
boost	wave/grammars/cpp_expression_grammar_gen.hpp	/^namespace boost {$/;"	n
boost	wave/grammars/cpp_expression_value.hpp	/^namespace boost {$/;"	n
boost	wave/grammars/cpp_grammar.hpp	/^namespace boost {$/;"	n
boost	wave/grammars/cpp_grammar_gen.hpp	/^namespace boost {$/;"	n
boost	wave/grammars/cpp_intlit_grammar.hpp	/^namespace boost {$/;"	n
boost	wave/grammars/cpp_literal_grammar_gen.hpp	/^namespace boost {$/;"	n
boost	wave/grammars/cpp_predef_macros_gen.hpp	/^namespace boost {$/;"	n
boost	wave/grammars/cpp_predef_macros_grammar.hpp	/^namespace boost {$/;"	n
boost	wave/grammars/cpp_value_error.hpp	/^namespace boost {$/;"	n
boost	wave/language_support.hpp	/^namespace boost {$/;"	n
boost	wave/preprocessing_hooks.hpp	/^namespace boost {$/;"	n
boost	wave/token_ids.hpp	/^namespace boost {$/;"	n
boost	wave/util/cpp_ifblock.hpp	/^namespace boost {$/;"	n
boost	wave/util/cpp_include_paths.hpp	/^namespace boost { namespace serialization {$/;"	n
boost	wave/util/cpp_include_paths.hpp	/^namespace boost { namespace wave { namespace util {$/;"	n
boost	wave/util/cpp_iterator.hpp	/^namespace boost {$/;"	n
boost	wave/util/cpp_macromap.hpp	/^namespace boost { namespace serialization {$/;"	n
boost	wave/util/cpp_macromap.hpp	/^namespace boost { namespace wave { namespace util {$/;"	n
boost	wave/util/cpp_macromap_predef.hpp	/^namespace boost {$/;"	n
boost	wave/util/cpp_macromap_utils.hpp	/^namespace boost {$/;"	n
boost	wave/util/file_position.hpp	/^namespace boost {$/;"	n
boost	wave/util/filesystem_compatibility.hpp	/^namespace boost { namespace wave { namespace util$/;"	n
boost	wave/util/flex_string.hpp	/^namespace boost { namespace serialization {$/;"	n
boost	wave/util/flex_string.hpp	/^namespace boost {$/;"	n
boost	wave/util/functor_input.hpp	/^namespace boost {$/;"	n
boost	wave/util/insert_whitespace_detection.hpp	/^namespace boost {$/;"	n
boost	wave/util/interpret_pragma.hpp	/^namespace boost {$/;"	n
boost	wave/util/iteration_context.hpp	/^namespace boost {$/;"	n
boost	wave/util/macro_definition.hpp	/^namespace boost {$/;"	n
boost	wave/util/macro_helpers.hpp	/^namespace boost {$/;"	n
boost	wave/util/pattern_parser.hpp	/^namespace boost {$/;"	n
boost	wave/util/symbol_table.hpp	/^namespace boost {$/;"	n
boost	wave/util/time_conversion_helper.hpp	/^namespace boost {$/;"	n
boost	wave/util/transform_iterator.hpp	/^namespace boost {$/;"	n
boost	wave/util/unput_queue_iterator.hpp	/^namespace boost {$/;"	n
boost	wave/wave_config.hpp	/^namespace boost { namespace wave $/;"	n
boost	wave/wave_config_constant.hpp	/^namespace boost { namespace wave {$/;"	n
boost	wave/whitespace_handling.hpp	/^namespace boost {$/;"	n
boost::serialization	wave/cpp_context.hpp	/^namespace boost { namespace serialization {$/;"	n	namespace:boost
boost::serialization	wave/util/cpp_include_paths.hpp	/^namespace boost { namespace serialization {$/;"	n	namespace:boost
boost::serialization	wave/util/cpp_macromap.hpp	/^namespace boost { namespace serialization {$/;"	n	namespace:boost
boost::serialization	wave/util/flex_string.hpp	/^namespace boost { namespace serialization {$/;"	n	namespace:boost
boost::serialization::implementation_level	wave/util/flex_string.hpp	/^struct implementation_level<boost::wave::util::flex_string<E, T, A, S> >$/;"	s	namespace:boost::serialization
boost::serialization::implementation_level::BOOST_STATIC_CONSTANT	wave/util/flex_string.hpp	/^    BOOST_STATIC_CONSTANT($/;"	p	struct:boost::serialization::implementation_level	access:public	signature:( int, value = implementation_level::type::value )
boost::serialization::implementation_level::tag	wave/util/flex_string.hpp	/^    typedef mpl::integral_c_tag tag;$/;"	t	struct:boost::serialization::implementation_level	access:public
boost::serialization::implementation_level::type	wave/util/flex_string.hpp	/^    typedef mpl::int_<boost::serialization::primitive_type> type;$/;"	t	struct:boost::serialization::implementation_level	access:public
boost::serialization::load	wave/util/cpp_include_paths.hpp	/^inline void load (Archive & ar, boost::filesystem::path &p,$/;"	f	namespace:boost::serialization	signature:(Archive & ar, boost::filesystem::path &p, const unsigned int )
boost::serialization::load	wave/util/cpp_include_paths.hpp	/^inline void load (Archive & ar,$/;"	f	namespace:boost::serialization	signature:(Archive & ar, typename boost::wave::util::bidirectional_map<std::string, std::string>::type &t, const unsigned int )
boost::serialization::save	wave/util/cpp_include_paths.hpp	/^inline void save (Archive & ar, boost::filesystem::path const& p, $/;"	f	namespace:boost::serialization	signature:(Archive & ar, boost::filesystem::path const& p, const unsigned int )
boost::serialization::save	wave/util/cpp_include_paths.hpp	/^inline void save (Archive & ar,$/;"	f	namespace:boost::serialization	signature:(Archive & ar, const typename boost::wave::util::bidirectional_map< std::string, std::string >::type &t, const unsigned int )
boost::serialization::serialize	wave/util/cpp_include_paths.hpp	/^inline void serialize (Archive & ar, $/;"	f	namespace:boost::serialization	signature:(Archive & ar, typename boost::wave::util::bidirectional_map< std::string, std::string >::type &t, const unsigned int file_version)
boost::serialization::serialize	wave/util/cpp_include_paths.hpp	/^inline void serialize (Archive & ar, boost::filesystem::path &p,$/;"	f	namespace:boost::serialization	signature:(Archive & ar, boost::filesystem::path &p, const unsigned int file_version)
boost::serialization::tracking_level	wave/cpp_context.hpp	/^struct tracking_level<boost::wave::context<Iterator, LexIterator, InputPolicy, Hooks> >$/;"	s	namespace:boost::serialization
boost::serialization::tracking_level::BOOST_STATIC_CONSTANT	wave/cpp_context.hpp	/^    BOOST_STATIC_CONSTANT($/;"	p	struct:boost::serialization::tracking_level	access:public	signature:( int, value = tracking_level::type::value )
boost::serialization::tracking_level::tag	wave/cpp_context.hpp	/^    typedef mpl::integral_c_tag tag;$/;"	t	struct:boost::serialization::tracking_level	access:public
boost::serialization::tracking_level::type	wave/cpp_context.hpp	/^    typedef mpl::int_<track_never> type;$/;"	t	struct:boost::serialization::tracking_level	access:public
boost::serialization::version	wave/cpp_context.hpp	/^struct version<boost::wave::context<Iterator, LexIterator, InputPolicy, Hooks> >$/;"	s	namespace:boost::serialization
boost::serialization::version	wave/util/cpp_macromap.hpp	/^struct version<boost::wave::util::macromap<ContextT> >$/;"	s	namespace:boost::serialization
boost::serialization::version::BOOST_STATIC_CONSTANT	wave/cpp_context.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, value = version::type::value);$/;"	p	struct:boost::serialization::version	access:public	signature:(unsigned int, value = version::type::value)
boost::serialization::version::BOOST_STATIC_CONSTANT	wave/util/cpp_macromap.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, value = version::type::value);$/;"	p	struct:boost::serialization::version	access:public	signature:(unsigned int, value = version::type::value)
boost::serialization::version::tag	wave/cpp_context.hpp	/^    typedef mpl::integral_c_tag tag;$/;"	t	struct:boost::serialization::version	access:public
boost::serialization::version::tag	wave/util/cpp_macromap.hpp	/^    typedef mpl::integral_c_tag tag;$/;"	t	struct:boost::serialization::version	access:public
boost::serialization::version::target_type	wave/cpp_context.hpp	/^        target_type;$/;"	t	struct:boost::serialization::version	access:public
boost::serialization::version::target_type	wave/util/cpp_macromap.hpp	/^    typedef boost::wave::util::macromap<ContextT> target_type;$/;"	t	struct:boost::serialization::version	access:public
boost::serialization::version::type	wave/cpp_context.hpp	/^    typedef mpl::int_<target_type::version> type;$/;"	t	struct:boost::serialization::version	access:public
boost::serialization::version::type	wave/util/cpp_macromap.hpp	/^    typedef mpl::int_<target_type::version> type;$/;"	t	struct:boost::serialization::version	access:public
boost::spirit	wave/util/file_position.hpp	/^namespace spirit { namespace classic {$/;"	n	namespace:boost
boost::spirit::classic	wave/util/file_position.hpp	/^namespace spirit { namespace classic {$/;"	n	namespace:boost::spirit
boost::spirit::classic::position_policy	wave/util/file_position.hpp	/^    class position_policy<boost::wave::util::file_position_type> {$/;"	c	namespace:boost::spirit::classic
boost::spirit::classic::position_policy::m_CharsPerTab	wave/util/file_position.hpp	/^        unsigned int m_CharsPerTab;$/;"	m	class:boost::spirit::classic::position_policy	access:private
boost::spirit::classic::position_policy::next_char	wave/util/file_position.hpp	/^        void next_char(boost::wave::util::file_position_type &pos)$/;"	f	class:boost::spirit::classic::position_policy	access:public	signature:(boost::wave::util::file_position_type &pos)
boost::spirit::classic::position_policy::next_line	wave/util/file_position.hpp	/^        void next_line(boost::wave::util::file_position_type &pos)$/;"	f	class:boost::spirit::classic::position_policy	access:public	signature:(boost::wave::util::file_position_type &pos)
boost::spirit::classic::position_policy::position_policy	wave/util/file_position.hpp	/^        position_policy()$/;"	f	class:boost::spirit::classic::position_policy	access:public	signature:()
boost::spirit::classic::position_policy::set_tab_chars	wave/util/file_position.hpp	/^        void set_tab_chars(unsigned int chars)$/;"	f	class:boost::spirit::classic::position_policy	access:public	signature:(unsigned int chars)
boost::spirit::classic::position_policy::tabulation	wave/util/file_position.hpp	/^        void tabulation(boost::wave::util::file_position_type &pos)   $/;"	f	class:boost::spirit::classic::position_policy	access:public	signature:(boost::wave::util::file_position_type &pos)
boost::wave	wave/cpp_context.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/cpp_exceptions.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/cpp_iteration_context.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/cpp_throw.hpp	/^namespace boost { namespace wave { namespace util$/;"	n	namespace:boost
boost::wave	wave/cpplexer/convert_trigraphs.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/cpplexer/cpp_lex_interface.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/cpplexer/cpp_lex_interface_generator.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/cpplexer/cpp_lex_iterator.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/cpplexer/cpp_lex_token.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/cpplexer/cpplexer_exceptions.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/cpplexer/detect_include_guards.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/cpplexer/re2clex/aq.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/cpplexer/re2clex/cpp_re.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/cpplexer/re2clex/scanner.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/cpplexer/token_cache.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/cpplexer/validate_universal_char.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/grammars/cpp_chlit_grammar.hpp	/^namespace wave { $/;"	n	namespace:boost
boost::wave	wave/grammars/cpp_defined_grammar.hpp	/^namespace wave { $/;"	n	namespace:boost
boost::wave	wave/grammars/cpp_defined_grammar_gen.hpp	/^namespace wave { $/;"	n	namespace:boost
boost::wave	wave/grammars/cpp_expression_grammar.hpp	/^namespace wave { $/;"	n	namespace:boost
boost::wave	wave/grammars/cpp_expression_grammar_gen.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/grammars/cpp_expression_value.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/grammars/cpp_grammar.hpp	/^namespace wave { $/;"	n	namespace:boost
boost::wave	wave/grammars/cpp_grammar_gen.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/grammars/cpp_intlit_grammar.hpp	/^namespace wave { $/;"	n	namespace:boost
boost::wave	wave/grammars/cpp_literal_grammar_gen.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/grammars/cpp_predef_macros_gen.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/grammars/cpp_predef_macros_grammar.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/grammars/cpp_value_error.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/language_support.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/preprocessing_hooks.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/token_ids.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/cpp_ifblock.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/cpp_include_paths.hpp	/^namespace boost { namespace wave { namespace util {$/;"	n	namespace:boost
boost::wave	wave/util/cpp_iterator.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/cpp_macromap.hpp	/^namespace boost { namespace wave { namespace util {$/;"	n	namespace:boost
boost::wave	wave/util/cpp_macromap_predef.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/cpp_macromap_utils.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/file_position.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/filesystem_compatibility.hpp	/^namespace boost { namespace wave { namespace util$/;"	n	namespace:boost
boost::wave	wave/util/flex_string.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/functor_input.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/insert_whitespace_detection.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/interpret_pragma.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/iteration_context.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/macro_definition.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/macro_helpers.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/pattern_parser.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/symbol_table.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/time_conversion_helper.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/util/transform_iterator.hpp	/^namespace wave { $/;"	n	namespace:boost
boost::wave	wave/util/unput_queue_iterator.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave	wave/wave_config.hpp	/^namespace boost { namespace wave $/;"	n	namespace:boost
boost::wave	wave/wave_config_constant.hpp	/^namespace boost { namespace wave {$/;"	n	namespace:boost
boost::wave	wave/whitespace_handling.hpp	/^namespace wave {$/;"	n	namespace:boost
boost::wave::AltExtTokenType	wave/token_ids.hpp	/^    AltExtTokenType             = 0x00500000,   \/\/ and, bit_and etc.$/;"	e	enum:boost::wave::token_category
boost::wave::AltTokenType	wave/token_ids.hpp	/^    AltTokenType                = 0x00100000,$/;"	e	enum:boost::wave::token_category
boost::wave::BoolLiteralTokenType	wave/token_ids.hpp	/^    BoolLiteralTokenType        = 0x45080000,$/;"	e	enum:boost::wave::token_category
boost::wave::CharacterLiteralTokenType	wave/token_ids.hpp	/^    CharacterLiteralTokenType   = 0x44080000,$/;"	e	enum:boost::wave::token_category
boost::wave::EOFTokenType	wave/token_ids.hpp	/^    EOFTokenType                = 0xC0000000,$/;"	e	enum:boost::wave::token_category
boost::wave::EOLTokenType	wave/token_ids.hpp	/^    EOLTokenType                = 0xB0000000,$/;"	e	enum:boost::wave::token_category
boost::wave::ExtParameterTokenType	wave/token_ids.hpp	/^    ExtParameterTokenType       = 0x11180000,$/;"	e	enum:boost::wave::token_category
boost::wave::ExtTokenOnlyMask	wave/token_ids.hpp	/^    ExtTokenOnlyMask            = 0x00F00000,$/;"	e	enum:boost::wave::token_category
boost::wave::ExtTokenTypeMask	wave/token_ids.hpp	/^    ExtTokenTypeMask            = 0xFFF00000,$/;"	e	enum:boost::wave::token_category
boost::wave::FloatingLiteralTokenType	wave/token_ids.hpp	/^    FloatingLiteralTokenType    = 0x42080000,$/;"	e	enum:boost::wave::token_category
boost::wave::IdentifierTokenType	wave/token_ids.hpp	/^    IdentifierTokenType         = 0x10080000,$/;"	e	enum:boost::wave::token_category
boost::wave::IntegerLiteralTokenType	wave/token_ids.hpp	/^    IntegerLiteralTokenType     = 0x41080000,$/;"	e	enum:boost::wave::token_category
boost::wave::InternalTokenType	wave/token_ids.hpp	/^    InternalTokenType           = 0xE0080000,$/;"	e	enum:boost::wave::token_category
boost::wave::KeywordTokenType	wave/token_ids.hpp	/^    KeywordTokenType            = 0x20080000,$/;"	e	enum:boost::wave::token_category
boost::wave::LiteralTokenType	wave/token_ids.hpp	/^    LiteralTokenType            = 0x40080000,$/;"	e	enum:boost::wave::token_category
boost::wave::MainTokenMask	wave/token_ids.hpp	/^    MainTokenMask               = 0xFF0FFFFF    \/\/ TokenTypeMask|TokenValueMask$/;"	e	enum:boost::wave::token_category
boost::wave::OperatorTokenType	wave/token_ids.hpp	/^    OperatorTokenType           = 0x30080000,$/;"	e	enum:boost::wave::token_category
boost::wave::PPConditionalTokenType	wave/token_ids.hpp	/^    PPConditionalTokenType      = 0x50880000,$/;"	e	enum:boost::wave::token_category
boost::wave::PPTokenFlag	wave/token_ids.hpp	/^    PPTokenFlag                 = 0x00080000,   \/\/ these are 'real' pp-tokens$/;"	e	enum:boost::wave::token_category
boost::wave::PPTokenType	wave/token_ids.hpp	/^    PPTokenType                 = 0x50080000,$/;"	e	enum:boost::wave::token_category
boost::wave::ParameterTokenType	wave/token_ids.hpp	/^    ParameterTokenType          = 0x11080000,$/;"	e	enum:boost::wave::token_category
boost::wave::StringLiteralTokenType	wave/token_ids.hpp	/^    StringLiteralTokenType      = 0x43080000,$/;"	e	enum:boost::wave::token_category
boost::wave::T_ALIGNAS	wave/token_ids.hpp	/^    T_ALIGNAS      = TOKEN_FROM_ID(422, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ALIGNOF	wave/token_ids.hpp	/^    T_ALIGNOF      = TOKEN_FROM_ID(423, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_AND	wave/token_ids.hpp	/^    T_AND          = TOKEN_FROM_ID(T_FIRST_TOKEN, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ANDAND	wave/token_ids.hpp	/^    T_ANDAND       = TOKEN_FROM_ID(257, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ANDAND_ALT	wave/token_ids.hpp	/^    T_ANDAND_ALT   = TOKEN_FROM_ID(257, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ANDASSIGN	wave/token_ids.hpp	/^    T_ANDASSIGN    = TOKEN_FROM_ID(259, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ANDASSIGN_ALT	wave/token_ids.hpp	/^    T_ANDASSIGN_ALT     = TOKEN_FROM_ID(259, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_AND_ALT	wave/token_ids.hpp	/^    T_AND_ALT      = TOKEN_FROM_ID(T_FIRST_TOKEN, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ANY	wave/token_ids.hpp	/^    T_ANY          = TOKEN_FROM_ID(397, UnknownTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ANY_TRIGRAPH	wave/token_ids.hpp	/^    T_ANY_TRIGRAPH = TOKEN_FROM_ID(397, UnknownTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ARROW	wave/token_ids.hpp	/^    T_ARROW        = TOKEN_FROM_ID(290, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ARROWSTAR	wave/token_ids.hpp	/^    T_ARROWSTAR    = TOKEN_FROM_ID(291, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ASM	wave/token_ids.hpp	/^    T_ASM          = TOKEN_FROM_ID(305, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ASSIGN	wave/token_ids.hpp	/^    T_ASSIGN       = TOKEN_FROM_ID(258, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_AUTO	wave/token_ids.hpp	/^    T_AUTO         = TOKEN_FROM_ID(306, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_BOOL	wave/token_ids.hpp	/^    T_BOOL         = TOKEN_FROM_ID(307, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_BREAK	wave/token_ids.hpp	/^    T_BREAK        = TOKEN_FROM_ID(310, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_CASE	wave/token_ids.hpp	/^    T_CASE         = TOKEN_FROM_ID(311, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_CATCH	wave/token_ids.hpp	/^    T_CATCH        = TOKEN_FROM_ID(312, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_CCOMMENT	wave/token_ids.hpp	/^    T_CCOMMENT     = TOKEN_FROM_ID(387, WhiteSpaceTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_CHAR	wave/token_ids.hpp	/^    T_CHAR         = TOKEN_FROM_ID(313, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_CHAR16_T	wave/token_ids.hpp	/^    T_CHAR16_T     = TOKEN_FROM_ID(424, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_CHAR32_T	wave/token_ids.hpp	/^    T_CHAR32_T     = TOKEN_FROM_ID(425, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_CHARLIT	wave/token_ids.hpp	/^    T_CHARLIT      = TOKEN_FROM_ID(389, CharacterLiteralTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_CLASS	wave/token_ids.hpp	/^    T_CLASS        = TOKEN_FROM_ID(314, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_COLON	wave/token_ids.hpp	/^    T_COLON        = TOKEN_FROM_ID(265, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_COLON_COLON	wave/token_ids.hpp	/^    T_COLON_COLON  = TOKEN_FROM_ID(296, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_COMMA	wave/token_ids.hpp	/^    T_COMMA        = TOKEN_FROM_ID(264, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_COMPL	wave/token_ids.hpp	/^    T_COMPL        = TOKEN_FROM_ID(303, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_COMPL_ALT	wave/token_ids.hpp	/^    T_COMPL_ALT         = TOKEN_FROM_ID(303, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_COMPL_TRIGRAPH	wave/token_ids.hpp	/^    T_COMPL_TRIGRAPH    = TOKEN_FROM_ID(303, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_CONST	wave/token_ids.hpp	/^    T_CONST        = TOKEN_FROM_ID(315, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_CONSTCAST	wave/token_ids.hpp	/^    T_CONSTCAST    = TOKEN_FROM_ID(316, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_CONSTEXPR	wave/token_ids.hpp	/^    T_CONSTEXPR    = TOKEN_FROM_ID(426, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_CONTINUE	wave/token_ids.hpp	/^    T_CONTINUE     = TOKEN_FROM_ID(317, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_CONTLINE	wave/token_ids.hpp	/^    T_CONTLINE     = TOKEN_FROM_ID(391, EOLTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_CPPCOMMENT	wave/token_ids.hpp	/^    T_CPPCOMMENT   = TOKEN_FROM_ID(388, WhiteSpaceTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_DECIMALINT	wave/token_ids.hpp	/^    T_DECIMALINT   = TOKEN_FROM_ID(382, IntegerLiteralTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_DECLTYPE	wave/token_ids.hpp	/^    T_DECLTYPE     = TOKEN_FROM_ID(427, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_DEFAULT	wave/token_ids.hpp	/^    T_DEFAULT      = TOKEN_FROM_ID(318, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_DELETE	wave/token_ids.hpp	/^    T_DELETE       = TOKEN_FROM_ID(319, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_DIVIDE	wave/token_ids.hpp	/^    T_DIVIDE       = TOKEN_FROM_ID(266, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_DIVIDEASSIGN	wave/token_ids.hpp	/^    T_DIVIDEASSIGN = TOKEN_FROM_ID(267, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_DO	wave/token_ids.hpp	/^    T_DO           = TOKEN_FROM_ID(320, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_DOT	wave/token_ids.hpp	/^    T_DOT          = TOKEN_FROM_ID(268, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_DOTSTAR	wave/token_ids.hpp	/^    T_DOTSTAR      = TOKEN_FROM_ID(269, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_DOUBLE	wave/token_ids.hpp	/^    T_DOUBLE       = TOKEN_FROM_ID(321, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_DYNAMICCAST	wave/token_ids.hpp	/^    T_DYNAMICCAST  = TOKEN_FROM_ID(322, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ELLIPSIS	wave/token_ids.hpp	/^    T_ELLIPSIS     = TOKEN_FROM_ID(270, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ELSE	wave/token_ids.hpp	/^    T_ELSE         = TOKEN_FROM_ID(323, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ENUM	wave/token_ids.hpp	/^    T_ENUM         = TOKEN_FROM_ID(324, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_EOF	wave/token_ids.hpp	/^    T_EOF          = TOKEN_FROM_ID(401, EOFTokenType),      \/\/ end of file reached$/;"	e	enum:boost::wave::token_id
boost::wave::T_EOI	wave/token_ids.hpp	/^    T_EOI          = TOKEN_FROM_ID(402, EOFTokenType),      \/\/ end of input reached$/;"	e	enum:boost::wave::token_id
boost::wave::T_EQUAL	wave/token_ids.hpp	/^    T_EQUAL        = TOKEN_FROM_ID(271, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_EXPLICIT	wave/token_ids.hpp	/^    T_EXPLICIT     = TOKEN_FROM_ID(325, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_EXPORT	wave/token_ids.hpp	/^    T_EXPORT       = TOKEN_FROM_ID(326, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_EXTERN	wave/token_ids.hpp	/^    T_EXTERN       = TOKEN_FROM_ID(327, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_EXTPARAMETERBASE	wave/token_ids.hpp	/^    T_EXTPARAMETERBASE = TOKEN_FROM_ID(T_LAST_TOKEN+4, ExtParameterTokenType)$/;"	e	enum:boost::wave::token_id
boost::wave::T_FALSE	wave/token_ids.hpp	/^    T_FALSE        = TOKEN_FROM_ID(308, BoolLiteralTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_FIRST_TOKEN	wave/token_ids.hpp	/^    T_FIRST_TOKEN  = 256,$/;"	e	enum:boost::wave::token_id
boost::wave::T_FIXEDPOINTLIT	wave/token_ids.hpp	/^    T_FIXEDPOINTLIT = TOKEN_FROM_ID(386, FloatingLiteralTokenType|AltTokenType),  \/\/ IDL specific$/;"	e	enum:boost::wave::token_id
boost::wave::T_FLOAT	wave/token_ids.hpp	/^    T_FLOAT        = TOKEN_FROM_ID(328, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_FLOATLIT	wave/token_ids.hpp	/^    T_FLOATLIT     = TOKEN_FROM_ID(386, FloatingLiteralTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_FOR	wave/token_ids.hpp	/^    T_FOR          = TOKEN_FROM_ID(329, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_FRIEND	wave/token_ids.hpp	/^    T_FRIEND       = TOKEN_FROM_ID(330, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_GENERATEDNEWLINE	wave/token_ids.hpp	/^    T_GENERATEDNEWLINE      = TOKEN_FROM_ID(394, EOLTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_GOTO	wave/token_ids.hpp	/^    T_GOTO         = TOKEN_FROM_ID(331, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_GREATER	wave/token_ids.hpp	/^    T_GREATER      = TOKEN_FROM_ID(272, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_GREATEREQUAL	wave/token_ids.hpp	/^    T_GREATEREQUAL = TOKEN_FROM_ID(273, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_HEXAINT	wave/token_ids.hpp	/^    T_HEXAINT      = TOKEN_FROM_ID(383, IntegerLiteralTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_IDENTIFIER	wave/token_ids.hpp	/^    T_IDENTIFIER   = TOKEN_FROM_ID(380, IdentifierTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_IF	wave/token_ids.hpp	/^    T_IF           = TOKEN_FROM_ID(332, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_IMPORT	wave/token_ids.hpp	/^    T_IMPORT       = TOKEN_FROM_ID(421, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_INLINE	wave/token_ids.hpp	/^    T_INLINE       = TOKEN_FROM_ID(333, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_INT	wave/token_ids.hpp	/^    T_INT          = TOKEN_FROM_ID(334, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_INTLIT	wave/token_ids.hpp	/^    T_INTLIT       = TOKEN_FROM_ID(384, IntegerLiteralTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_LAST_TOKEN	wave/token_ids.hpp	/^    T_LAST_TOKEN = ID_FROM_TOKEN(T_LAST_TOKEN_ID & ~PPTokenFlag),$/;"	e	enum:boost::wave::token_id
boost::wave::T_LAST_TOKEN_ID	wave/token_ids.hpp	/^    T_LAST_TOKEN_ID,$/;"	e	enum:boost::wave::token_id
boost::wave::T_LEFTBRACE	wave/token_ids.hpp	/^    T_LEFTBRACE    = TOKEN_FROM_ID(274, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_LEFTBRACE_ALT	wave/token_ids.hpp	/^    T_LEFTBRACE_ALT         = TOKEN_FROM_ID(274, OperatorTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_LEFTBRACE_TRIGRAPH	wave/token_ids.hpp	/^    T_LEFTBRACE_TRIGRAPH    = TOKEN_FROM_ID(274, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_LEFTBRACKET	wave/token_ids.hpp	/^    T_LEFTBRACKET  = TOKEN_FROM_ID(278, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_LEFTBRACKET_ALT	wave/token_ids.hpp	/^    T_LEFTBRACKET_ALT       = TOKEN_FROM_ID(278, OperatorTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_LEFTBRACKET_TRIGRAPH	wave/token_ids.hpp	/^    T_LEFTBRACKET_TRIGRAPH  = TOKEN_FROM_ID(278, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_LEFTPAREN	wave/token_ids.hpp	/^    T_LEFTPAREN    = TOKEN_FROM_ID(277, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_LESS	wave/token_ids.hpp	/^    T_LESS         = TOKEN_FROM_ID(275, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_LESSEQUAL	wave/token_ids.hpp	/^    T_LESSEQUAL    = TOKEN_FROM_ID(276, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_LONG	wave/token_ids.hpp	/^    T_LONG         = TOKEN_FROM_ID(335, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_LONGINTLIT	wave/token_ids.hpp	/^    T_LONGINTLIT   = TOKEN_FROM_ID(385, IntegerLiteralTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MINUS	wave/token_ids.hpp	/^    T_MINUS        = TOKEN_FROM_ID(279, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MINUSASSIGN	wave/token_ids.hpp	/^    T_MINUSASSIGN  = TOKEN_FROM_ID(280, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MINUSMINUS	wave/token_ids.hpp	/^    T_MINUSMINUS   = TOKEN_FROM_ID(281, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_ASM	wave/token_ids.hpp	/^    T_MSEXT_ASM    = TOKEN_FROM_ID(418, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_BASED	wave/token_ids.hpp	/^    T_MSEXT_BASED  = TOKEN_FROM_ID(408, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_CDECL	wave/token_ids.hpp	/^    T_MSEXT_CDECL  = TOKEN_FROM_ID(410, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_DECLSPEC	wave/token_ids.hpp	/^    T_MSEXT_DECLSPEC = TOKEN_FROM_ID(409, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_EXCEPT	wave/token_ids.hpp	/^    T_MSEXT_EXCEPT = TOKEN_FROM_ID(414, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_FASTCALL	wave/token_ids.hpp	/^    T_MSEXT_FASTCALL = TOKEN_FROM_ID(411, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_FINALLY	wave/token_ids.hpp	/^    T_MSEXT_FINALLY = TOKEN_FROM_ID(415, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_INLINE	wave/token_ids.hpp	/^    T_MSEXT_INLINE = TOKEN_FROM_ID(417, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_INT16	wave/token_ids.hpp	/^    T_MSEXT_INT16  = TOKEN_FROM_ID(405, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_INT32	wave/token_ids.hpp	/^    T_MSEXT_INT32  = TOKEN_FROM_ID(406, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_INT64	wave/token_ids.hpp	/^    T_MSEXT_INT64  = TOKEN_FROM_ID(407, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_INT8	wave/token_ids.hpp	/^    T_MSEXT_INT8   = TOKEN_FROM_ID(404, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_LEAVE	wave/token_ids.hpp	/^    T_MSEXT_LEAVE  = TOKEN_FROM_ID(416, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_PP_ENDREGION	wave/token_ids.hpp	/^    T_MSEXT_PP_ENDREGION = TOKEN_FROM_ID(420, PPTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_PP_REGION	wave/token_ids.hpp	/^    T_MSEXT_PP_REGION    = TOKEN_FROM_ID(419, PPTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_STDCALL	wave/token_ids.hpp	/^    T_MSEXT_STDCALL = TOKEN_FROM_ID(412, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MSEXT_TRY	wave/token_ids.hpp	/^    T_MSEXT_TRY    = TOKEN_FROM_ID(413, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_MUTABLE	wave/token_ids.hpp	/^    T_MUTABLE      = TOKEN_FROM_ID(336, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_NAMESPACE	wave/token_ids.hpp	/^    T_NAMESPACE    = TOKEN_FROM_ID(337, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_NEW	wave/token_ids.hpp	/^    T_NEW          = TOKEN_FROM_ID(338, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_NEWLINE	wave/token_ids.hpp	/^    T_NEWLINE      = TOKEN_FROM_ID(394, EOLTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_NOEXCEPT	wave/token_ids.hpp	/^    T_NOEXCEPT     = TOKEN_FROM_ID(428, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_NONREPLACABLE_IDENTIFIER	wave/token_ids.hpp	/^    T_NONREPLACABLE_IDENTIFIER = TOKEN_FROM_ID(T_LAST_TOKEN+1, IdentifierTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_NOT	wave/token_ids.hpp	/^    T_NOT          = TOKEN_FROM_ID(284, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_NOTEQUAL	wave/token_ids.hpp	/^    T_NOTEQUAL     = TOKEN_FROM_ID(285, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_NOTEQUAL_ALT	wave/token_ids.hpp	/^    T_NOTEQUAL_ALT      = TOKEN_FROM_ID(285, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_NOT_ALT	wave/token_ids.hpp	/^    T_NOT_ALT      = TOKEN_FROM_ID(284, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_NULLPTR	wave/token_ids.hpp	/^    T_NULLPTR      = TOKEN_FROM_ID(429, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_OCTALINT	wave/token_ids.hpp	/^    T_OCTALINT     = TOKEN_FROM_ID(381, IntegerLiteralTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_OPERATOR	wave/token_ids.hpp	/^    T_OPERATOR     = TOKEN_FROM_ID(339, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_OR	wave/token_ids.hpp	/^    T_OR           = TOKEN_FROM_ID(260, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ORASSIGN	wave/token_ids.hpp	/^    T_ORASSIGN     = TOKEN_FROM_ID(261, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ORASSIGN_ALT	wave/token_ids.hpp	/^    T_ORASSIGN_ALT          = TOKEN_FROM_ID(261, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_ORASSIGN_TRIGRAPH	wave/token_ids.hpp	/^    T_ORASSIGN_TRIGRAPH     = TOKEN_FROM_ID(261, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_OROR	wave/token_ids.hpp	/^    T_OROR         = TOKEN_FROM_ID(286, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_OROR_ALT	wave/token_ids.hpp	/^    T_OROR_ALT     = TOKEN_FROM_ID(286, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_OROR_TRIGRAPH	wave/token_ids.hpp	/^    T_OROR_TRIGRAPH     = TOKEN_FROM_ID(286, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_OR_ALT	wave/token_ids.hpp	/^    T_OR_ALT       = TOKEN_FROM_ID(260, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_OR_TRIGRAPH	wave/token_ids.hpp	/^    T_OR_TRIGRAPH  = TOKEN_FROM_ID(260, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PARAMETERBASE	wave/token_ids.hpp	/^    T_PARAMETERBASE = TOKEN_FROM_ID(T_LAST_TOKEN+4, ParameterTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PERCENT	wave/token_ids.hpp	/^    T_PERCENT      = TOKEN_FROM_ID(282, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PERCENTASSIGN	wave/token_ids.hpp	/^    T_PERCENTASSIGN = TOKEN_FROM_ID(283, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PLACEHOLDER	wave/token_ids.hpp	/^    T_PLACEHOLDER = TOKEN_FROM_ID(T_LAST_TOKEN+2, WhiteSpaceTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PLACEMARKER	wave/token_ids.hpp	/^    T_PLACEMARKER = TOKEN_FROM_ID(T_LAST_TOKEN+3, InternalTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PLUS	wave/token_ids.hpp	/^    T_PLUS         = TOKEN_FROM_ID(287, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PLUSASSIGN	wave/token_ids.hpp	/^    T_PLUSASSIGN   = TOKEN_FROM_ID(288, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PLUSPLUS	wave/token_ids.hpp	/^    T_PLUSPLUS     = TOKEN_FROM_ID(289, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_POUND	wave/token_ids.hpp	/^    T_POUND                 = TOKEN_FROM_ID(396, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_POUND_ALT	wave/token_ids.hpp	/^    T_POUND_ALT             = TOKEN_FROM_ID(396, OperatorTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_POUND_POUND	wave/token_ids.hpp	/^    T_POUND_POUND           = TOKEN_FROM_ID(395, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_POUND_POUND_ALT	wave/token_ids.hpp	/^    T_POUND_POUND_ALT       = TOKEN_FROM_ID(395, OperatorTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_POUND_POUND_TRIGRAPH	wave/token_ids.hpp	/^    T_POUND_POUND_TRIGRAPH  = TOKEN_FROM_ID(395, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_POUND_TRIGRAPH	wave/token_ids.hpp	/^    T_POUND_TRIGRAPH        = TOKEN_FROM_ID(396, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_DEFINE	wave/token_ids.hpp	/^    T_PP_DEFINE    = TOKEN_FROM_ID(368, PPTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_ELIF	wave/token_ids.hpp	/^    T_PP_ELIF      = TOKEN_FROM_ID(373, PPConditionalTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_ELSE	wave/token_ids.hpp	/^    T_PP_ELSE      = TOKEN_FROM_ID(372, PPConditionalTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_ENDIF	wave/token_ids.hpp	/^    T_PP_ENDIF     = TOKEN_FROM_ID(374, PPConditionalTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_ERROR	wave/token_ids.hpp	/^    T_PP_ERROR     = TOKEN_FROM_ID(375, PPTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_HHEADER	wave/token_ids.hpp	/^    T_PP_HHEADER   = TOKEN_FROM_ID(400, PPTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_HHEADER_NEXT	wave/token_ids.hpp	/^    T_PP_HHEADER_NEXT   = TOKEN_FROM_ID(400, PPTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_IF	wave/token_ids.hpp	/^    T_PP_IF        = TOKEN_FROM_ID(369, PPConditionalTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_IFDEF	wave/token_ids.hpp	/^    T_PP_IFDEF     = TOKEN_FROM_ID(370, PPConditionalTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_IFNDEF	wave/token_ids.hpp	/^    T_PP_IFNDEF    = TOKEN_FROM_ID(371, PPConditionalTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_INCLUDE	wave/token_ids.hpp	/^    T_PP_INCLUDE   = TOKEN_FROM_ID(398, PPTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_INCLUDE_NEXT	wave/token_ids.hpp	/^    T_PP_INCLUDE_NEXT   = TOKEN_FROM_ID(398, PPTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_LINE	wave/token_ids.hpp	/^    T_PP_LINE      = TOKEN_FROM_ID(376, PPTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_NUMBER	wave/token_ids.hpp	/^    T_PP_NUMBER    = TOKEN_FROM_ID(403, InternalTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_PRAGMA	wave/token_ids.hpp	/^    T_PP_PRAGMA    = TOKEN_FROM_ID(377, PPTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_QHEADER	wave/token_ids.hpp	/^    T_PP_QHEADER   = TOKEN_FROM_ID(399, PPTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_QHEADER_NEXT	wave/token_ids.hpp	/^    T_PP_QHEADER_NEXT   = TOKEN_FROM_ID(399, PPTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_UNDEF	wave/token_ids.hpp	/^    T_PP_UNDEF     = TOKEN_FROM_ID(378, PPTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PP_WARNING	wave/token_ids.hpp	/^    T_PP_WARNING   = TOKEN_FROM_ID(379, PPTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PRIVATE	wave/token_ids.hpp	/^    T_PRIVATE      = TOKEN_FROM_ID(340, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PROTECTED	wave/token_ids.hpp	/^    T_PROTECTED    = TOKEN_FROM_ID(341, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_PUBLIC	wave/token_ids.hpp	/^    T_PUBLIC       = TOKEN_FROM_ID(342, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_QUESTION_MARK	wave/token_ids.hpp	/^    T_QUESTION_MARK = TOKEN_FROM_ID(292, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_RAWSTRINGLIT	wave/token_ids.hpp	/^    T_RAWSTRINGLIT = TOKEN_FROM_ID(432, StringLiteralTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_REGISTER	wave/token_ids.hpp	/^    T_REGISTER     = TOKEN_FROM_ID(343, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_REINTERPRETCAST	wave/token_ids.hpp	/^    T_REINTERPRETCAST = TOKEN_FROM_ID(344, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_RETURN	wave/token_ids.hpp	/^    T_RETURN       = TOKEN_FROM_ID(345, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_RIGHTBRACE	wave/token_ids.hpp	/^    T_RIGHTBRACE   = TOKEN_FROM_ID(293, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_RIGHTBRACE_ALT	wave/token_ids.hpp	/^    T_RIGHTBRACE_ALT        = TOKEN_FROM_ID(293, OperatorTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_RIGHTBRACE_TRIGRAPH	wave/token_ids.hpp	/^    T_RIGHTBRACE_TRIGRAPH   = TOKEN_FROM_ID(293, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_RIGHTBRACKET	wave/token_ids.hpp	/^    T_RIGHTBRACKET = TOKEN_FROM_ID(295, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_RIGHTBRACKET_ALT	wave/token_ids.hpp	/^    T_RIGHTBRACKET_ALT      = TOKEN_FROM_ID(295, OperatorTokenType|AltTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_RIGHTBRACKET_TRIGRAPH	wave/token_ids.hpp	/^    T_RIGHTBRACKET_TRIGRAPH = TOKEN_FROM_ID(295, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_RIGHTPAREN	wave/token_ids.hpp	/^    T_RIGHTPAREN   = TOKEN_FROM_ID(294, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_SEMICOLON	wave/token_ids.hpp	/^    T_SEMICOLON    = TOKEN_FROM_ID(297, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_SHIFTLEFT	wave/token_ids.hpp	/^    T_SHIFTLEFT    = TOKEN_FROM_ID(298, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_SHIFTLEFTASSIGN	wave/token_ids.hpp	/^    T_SHIFTLEFTASSIGN = TOKEN_FROM_ID(299, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_SHIFTRIGHT	wave/token_ids.hpp	/^    T_SHIFTRIGHT   = TOKEN_FROM_ID(300, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_SHIFTRIGHTASSIGN	wave/token_ids.hpp	/^    T_SHIFTRIGHTASSIGN = TOKEN_FROM_ID(301, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_SHORT	wave/token_ids.hpp	/^    T_SHORT        = TOKEN_FROM_ID(346, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_SIGNED	wave/token_ids.hpp	/^    T_SIGNED       = TOKEN_FROM_ID(347, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_SIZEOF	wave/token_ids.hpp	/^    T_SIZEOF       = TOKEN_FROM_ID(348, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_SPACE	wave/token_ids.hpp	/^    T_SPACE        = TOKEN_FROM_ID(392, WhiteSpaceTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_SPACE2	wave/token_ids.hpp	/^    T_SPACE2       = TOKEN_FROM_ID(393, WhiteSpaceTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_STAR	wave/token_ids.hpp	/^    T_STAR         = TOKEN_FROM_ID(302, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_STARASSIGN	wave/token_ids.hpp	/^    T_STARASSIGN   = TOKEN_FROM_ID(304, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_STATIC	wave/token_ids.hpp	/^    T_STATIC       = TOKEN_FROM_ID(349, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_STATICASSERT	wave/token_ids.hpp	/^    T_STATICASSERT = TOKEN_FROM_ID(430, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_STATICCAST	wave/token_ids.hpp	/^    T_STATICCAST   = TOKEN_FROM_ID(350, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_STRINGLIT	wave/token_ids.hpp	/^    T_STRINGLIT    = TOKEN_FROM_ID(390, StringLiteralTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_STRUCT	wave/token_ids.hpp	/^    T_STRUCT       = TOKEN_FROM_ID(351, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_SWITCH	wave/token_ids.hpp	/^    T_SWITCH       = TOKEN_FROM_ID(352, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_TEMPLATE	wave/token_ids.hpp	/^    T_TEMPLATE     = TOKEN_FROM_ID(353, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_THIS	wave/token_ids.hpp	/^    T_THIS         = TOKEN_FROM_ID(354, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_THREADLOCAL	wave/token_ids.hpp	/^    T_THREADLOCAL  = TOKEN_FROM_ID(431, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_THROW	wave/token_ids.hpp	/^    T_THROW        = TOKEN_FROM_ID(355, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_TRUE	wave/token_ids.hpp	/^    T_TRUE         = TOKEN_FROM_ID(309, BoolLiteralTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_TRY	wave/token_ids.hpp	/^    T_TRY          = TOKEN_FROM_ID(356, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_TYPEDEF	wave/token_ids.hpp	/^    T_TYPEDEF      = TOKEN_FROM_ID(357, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_TYPEID	wave/token_ids.hpp	/^    T_TYPEID       = TOKEN_FROM_ID(358, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_TYPENAME	wave/token_ids.hpp	/^    T_TYPENAME     = TOKEN_FROM_ID(359, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_UNION	wave/token_ids.hpp	/^    T_UNION        = TOKEN_FROM_ID(360, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_UNKNOWN	wave/token_ids.hpp	/^    T_UNKNOWN      = 0,$/;"	e	enum:boost::wave::token_id
boost::wave::T_UNSIGNED	wave/token_ids.hpp	/^    T_UNSIGNED     = TOKEN_FROM_ID(361, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_USING	wave/token_ids.hpp	/^    T_USING        = TOKEN_FROM_ID(362, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_VIRTUAL	wave/token_ids.hpp	/^    T_VIRTUAL      = TOKEN_FROM_ID(363, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_VOID	wave/token_ids.hpp	/^    T_VOID         = TOKEN_FROM_ID(364, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_VOLATILE	wave/token_ids.hpp	/^    T_VOLATILE     = TOKEN_FROM_ID(365, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_WCHART	wave/token_ids.hpp	/^    T_WCHART       = TOKEN_FROM_ID(366, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_WHILE	wave/token_ids.hpp	/^    T_WHILE        = TOKEN_FROM_ID(367, KeywordTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_XOR	wave/token_ids.hpp	/^    T_XOR          = TOKEN_FROM_ID(262, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_XORASSIGN	wave/token_ids.hpp	/^    T_XORASSIGN    = TOKEN_FROM_ID(263, OperatorTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_XORASSIGN_ALT	wave/token_ids.hpp	/^    T_XORASSIGN_ALT         = TOKEN_FROM_ID(263, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_XORASSIGN_TRIGRAPH	wave/token_ids.hpp	/^    T_XORASSIGN_TRIGRAPH    = TOKEN_FROM_ID(263, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_XOR_ALT	wave/token_ids.hpp	/^    T_XOR_ALT      = TOKEN_FROM_ID(262, OperatorTokenType|AltExtTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::T_XOR_TRIGRAPH	wave/token_ids.hpp	/^    T_XOR_TRIGRAPH = TOKEN_FROM_ID(262, OperatorTokenType|TriGraphTokenType),$/;"	e	enum:boost::wave::token_id
boost::wave::TokenTypeMask	wave/token_ids.hpp	/^    TokenTypeMask               = 0xFF000000,$/;"	e	enum:boost::wave::token_category
boost::wave::TokenValueMask	wave/token_ids.hpp	/^    TokenValueMask              = 0x000FFFFF,$/;"	e	enum:boost::wave::token_category
boost::wave::TriGraphTokenType	wave/token_ids.hpp	/^    TriGraphTokenType           = 0x00200000,$/;"	e	enum:boost::wave::token_category
boost::wave::UnknownTokenType	wave/token_ids.hpp	/^    UnknownTokenType            = 0xA0000000,$/;"	e	enum:boost::wave::token_category
boost::wave::WhiteSpaceTokenType	wave/token_ids.hpp	/^    WhiteSpaceTokenType         = 0xD0000000,$/;"	e	enum:boost::wave::token_category
boost::wave::base_iteration_context	wave/cpp_iteration_context.hpp	/^struct base_iteration_context$/;"	s	namespace:boost::wave
boost::wave::base_iteration_context::base_iteration_context	wave/cpp_iteration_context.hpp	/^    base_iteration_context(ContextT& ctx_,$/;"	f	struct:boost::wave::base_iteration_context	access:public	signature:(ContextT& ctx_, BOOST_WAVE_STRINGTYPE const &fname, std::size_t if_block_depth = 0)
boost::wave::base_iteration_context::base_iteration_context	wave/cpp_iteration_context.hpp	/^    base_iteration_context(ContextT& ctx_,$/;"	f	struct:boost::wave::base_iteration_context	access:public	signature:(ContextT& ctx_, IteratorT const &first_, IteratorT const &last_, BOOST_WAVE_STRINGTYPE const &fname, std::size_t if_block_depth = 0, file_type type_ = main_file)
boost::wave::base_iteration_context::ctx	wave/cpp_iteration_context.hpp	/^    ContextT& ctx;              \/\/ corresponding context<> object$/;"	m	struct:boost::wave::base_iteration_context	access:public
boost::wave::base_iteration_context::emitted_lines	wave/cpp_iteration_context.hpp	/^    std::size_t emitted_lines;            \/\/ count of emitted newlines$/;"	m	struct:boost::wave::base_iteration_context	access:public
boost::wave::base_iteration_context::file_type	wave/cpp_iteration_context.hpp	/^    enum file_type$/;"	g	struct:boost::wave::base_iteration_context	access:public
boost::wave::base_iteration_context::filename	wave/cpp_iteration_context.hpp	/^    BOOST_WAVE_STRINGTYPE filename;       \/\/ actual processed file$/;"	m	struct:boost::wave::base_iteration_context	access:public
boost::wave::base_iteration_context::first	wave/cpp_iteration_context.hpp	/^    IteratorT first;            \/\/ actual input stream position$/;"	m	struct:boost::wave::base_iteration_context	access:public
boost::wave::base_iteration_context::if_block_depth	wave/cpp_iteration_context.hpp	/^    std::size_t if_block_depth; \/\/ depth of #if block recursion$/;"	m	struct:boost::wave::base_iteration_context	access:public
boost::wave::base_iteration_context::last	wave/cpp_iteration_context.hpp	/^    IteratorT last;             \/\/ end of input stream$/;"	m	struct:boost::wave::base_iteration_context	access:public
boost::wave::base_iteration_context::line	wave/cpp_iteration_context.hpp	/^    std::size_t line;                     \/\/ line counter of underlying stream$/;"	m	struct:boost::wave::base_iteration_context	access:public
boost::wave::base_iteration_context::main_file	wave/cpp_iteration_context.hpp	/^        main_file,      \/\/ ... the main preprocessed file$/;"	e	enum:boost::wave::base_iteration_context::file_type
boost::wave::base_iteration_context::real_filename	wave/cpp_iteration_context.hpp	/^    BOOST_WAVE_STRINGTYPE real_filename;  \/\/ real name of the current file$/;"	m	struct:boost::wave::base_iteration_context	access:public
boost::wave::base_iteration_context::real_relative_filename	wave/cpp_iteration_context.hpp	/^    BOOST_WAVE_STRINGTYPE real_relative_filename;  \/\/ real relative name of the current file$/;"	m	struct:boost::wave::base_iteration_context	access:public
boost::wave::base_iteration_context::system_header	wave/cpp_iteration_context.hpp	/^        system_header,  \/\/ ... a header file included used #include  <>$/;"	e	enum:boost::wave::base_iteration_context::file_type
boost::wave::base_iteration_context::type	wave/cpp_iteration_context.hpp	/^    file_type type;             \/\/ the type of the handled file$/;"	m	struct:boost::wave::base_iteration_context	access:public
boost::wave::base_iteration_context::user_header	wave/cpp_iteration_context.hpp	/^        user_header     \/\/ ... a header file included using #include ""$/;"	e	enum:boost::wave::base_iteration_context::file_type
boost::wave::context	wave/cpp_context.hpp	/^class context : private boost::noncopyable$/;"	c	namespace:boost::wave	inherits:boost::noncopyable
boost::wave::context::BOOST_CLASS_REQUIRE	wave/cpp_context.hpp	/^    BOOST_CLASS_REQUIRE(IteratorT, boost, ForwardIteratorConcept);$/;"	p	class:boost::wave::context	access:public	signature:(IteratorT, boost, ForwardIteratorConcept)
boost::wave::context::BOOST_STATIC_CONSTANT	wave/cpp_context.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, version = 0x10);$/;"	p	class:boost::wave::context	access:public	signature:(unsigned int, version = 0x10)
boost::wave::context::BOOST_STATIC_CONSTANT	wave/cpp_context.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, version_mask = 0x0f);$/;"	p	class:boost::wave::context	access:public	signature:(unsigned int, version_mask = 0x0f)
boost::wave::context::actual_context_type	wave/cpp_context.hpp	/^        >::type actual_context_type;$/;"	t	class:boost::wave::context	access:private
boost::wave::context::add_include_path	wave/cpp_context.hpp	/^    bool add_include_path(char const *path_)$/;"	f	class:boost::wave::context	access:public	signature:(char const *path_)
boost::wave::context::add_macro_definition	wave/cpp_context.hpp	/^    bool add_macro_definition(StringT const &name, position_type const& pos, $/;"	f	class:boost::wave::context	access:public	signature:(StringT const &name, position_type const& pos, bool has_params, std::vector<token_type> &parameters, token_sequence_type &definition, bool is_predefined = false)
boost::wave::context::add_macro_definition	wave/cpp_context.hpp	/^    bool add_macro_definition(StringT macrostring, bool is_predefined = false)$/;"	f	class:boost::wave::context	access:public	signature:(StringT macrostring, bool is_predefined = false)
boost::wave::context::add_macro_definition	wave/cpp_context.hpp	/^    bool add_macro_definition(token_type const &name, bool has_params,$/;"	f	class:boost::wave::context	access:public	signature:(token_type const &name, bool has_params, std::vector<token_type> &parameters, token_sequence_type &definition, bool is_predefined = false)
boost::wave::context::add_pragma_once_header	wave/cpp_context.hpp	/^    bool add_pragma_once_header(std::string const &filename_,$/;"	f	class:boost::wave::context	access:public	signature:(std::string const &filename_, std::string const& guard_name)
boost::wave::context::add_pragma_once_header	wave/cpp_context.hpp	/^    bool add_pragma_once_header(token_type const &pragma_, $/;"	f	class:boost::wave::context	access:public	signature:(token_type const &pragma_, std::string const &filename_)
boost::wave::context::add_sysinclude_path	wave/cpp_context.hpp	/^    bool add_sysinclude_path(char const *path_)$/;"	f	class:boost::wave::context	access:public	signature:(char const *path_)
boost::wave::context::begin	wave/cpp_context.hpp	/^    iterator_type begin($/;"	f	class:boost::wave::context	access:public	signature:( target_iterator_type const &first_, target_iterator_type const &last_)
boost::wave::context::begin	wave/cpp_context.hpp	/^    iterator_type begin() $/;"	f	class:boost::wave::context	access:public	signature:()
boost::wave::context::const_name_iterator	wave/cpp_context.hpp	/^    typedef typename macromap_type::const_name_iterator const_name_iterator;$/;"	t	class:boost::wave::context	access:public
boost::wave::context::context	wave/cpp_context.hpp	/^    context(target_iterator_type const &first_, target_iterator_type const &last_, $/;"	f	class:boost::wave::context	access:public	signature:(target_iterator_type const &first_, target_iterator_type const &last_, char const *fname = , HooksT const &hooks_ = HooksT())
boost::wave::context::current_filename	wave/cpp_context.hpp	/^    std::string current_filename;       \/\/ real name of current preprocessed file$/;"	m	class:boost::wave::context	access:private
boost::wave::context::current_relative_filename	wave/cpp_context.hpp	/^    std::string current_relative_filename;        \/\/ real relative name of current preprocessed file$/;"	m	class:boost::wave::context	access:private
boost::wave::context::derived	wave/cpp_context.hpp	/^    actual_context_type const& derived() const$/;"	f	class:boost::wave::context	access:public	signature:() const
boost::wave::context::derived	wave/cpp_context.hpp	/^    actual_context_type& derived() $/;"	f	class:boost::wave::context	access:public	signature:()
boost::wave::context::end	wave/cpp_context.hpp	/^    iterator_type end() const $/;"	f	class:boost::wave::context	access:public	signature:() const
boost::wave::context::enter_elif_block	wave/cpp_context.hpp	/^    bool enter_elif_block(bool new_status) $/;"	f	class:boost::wave::context	access:protected	signature:(bool new_status)
boost::wave::context::enter_else_block	wave/cpp_context.hpp	/^    bool enter_else_block() { return ifblocks.enter_else_block(); }$/;"	f	class:boost::wave::context	access:protected	signature:()
boost::wave::context::enter_if_block	wave/cpp_context.hpp	/^    void enter_if_block(bool new_status) $/;"	f	class:boost::wave::context	access:protected	signature:(bool new_status)
boost::wave::context::exit_if_block	wave/cpp_context.hpp	/^    bool exit_if_block() { return ifblocks.exit_if_block(); }$/;"	f	class:boost::wave::context	access:protected	signature:()
boost::wave::context::expand_tokensequence	wave/cpp_context.hpp	/^    token_type expand_tokensequence(IteratorT2 &first_, IteratorT2 const &last_, $/;"	f	class:boost::wave::context	access:protected	signature:(IteratorT2 &first_, IteratorT2 const &last_, token_sequence_type &pending, token_sequence_type &expanded, bool& seen_newline, bool expand_undefined = false)
boost::wave::context::expand_whole_tokensequence	wave/cpp_context.hpp	/^    void expand_whole_tokensequence(IteratorT2 &first_, IteratorT2 const &last_, $/;"	f	class:boost::wave::context	access:protected	signature:(IteratorT2 &first_, IteratorT2 const &last_, token_sequence_type &expanded, bool expand_undefined = true)
boost::wave::context::filename	wave/cpp_context.hpp	/^    std::string filename;               \/\/ associated main filename$/;"	m	class:boost::wave::context	access:private
boost::wave::context::find_include_file	wave/cpp_context.hpp	/^    bool find_include_file (std::string &s, std::string &d, bool is_system, $/;"	f	class:boost::wave::context	access:public	signature:(std::string &s, std::string &d, bool is_system, char const *current_file) const
boost::wave::context::first	wave/cpp_context.hpp	/^    target_iterator_type first;         \/\/ underlying input stream$/;"	m	class:boost::wave::context	access:private
boost::wave::context::get_current_directory	wave/cpp_context.hpp	/^    boost::filesystem::path get_current_directory() const$/;"	f	class:boost::wave::context	access:public	signature:() const
boost::wave::context::get_enclosing_if_block_status	wave/cpp_context.hpp	/^    bool get_enclosing_if_block_status() const$/;"	f	class:boost::wave::context	access:protected	signature:() const
boost::wave::context::get_hooks	wave/cpp_context.hpp	/^    hook_policy_type &get_hooks() { return hooks; }$/;"	f	class:boost::wave::context	access:public	signature:()
boost::wave::context::get_hooks	wave/cpp_context.hpp	/^    hook_policy_type const &get_hooks() const { return hooks; }$/;"	f	class:boost::wave::context	access:public	signature:() const
boost::wave::context::get_if_block_depth	wave/cpp_context.hpp	/^    typename boost::wave::util::if_block_stack::size_type get_if_block_depth() const $/;"	f	class:boost::wave::context	access:protected	signature:() const
boost::wave::context::get_if_block_some_part_status	wave/cpp_context.hpp	/^    bool get_if_block_some_part_status() const $/;"	f	class:boost::wave::context	access:protected	signature:() const
boost::wave::context::get_if_block_status	wave/cpp_context.hpp	/^    bool get_if_block_status() const { return ifblocks.get_status(); }$/;"	f	class:boost::wave::context	access:protected	signature:() const
boost::wave::context::get_iteration_depth	wave/cpp_context.hpp	/^    typename iteration_context_stack_type::size_type get_iteration_depth() const $/;"	f	class:boost::wave::context	access:public	signature:() const
boost::wave::context::get_language	wave/cpp_context.hpp	/^    boost::wave::language_support get_language() const { return language; }$/;"	f	class:boost::wave::context	access:public	signature:() const
boost::wave::context::get_macro_definition	wave/cpp_context.hpp	/^    bool get_macro_definition(StringT const &name, $/;"	f	class:boost::wave::context	access:public	signature:(StringT const &name, bool &has_params, bool &is_predefined, position_type &pos, std::vector<token_type> &parameters, token_sequence_type &definition) const
boost::wave::context::get_main_pos	wave/cpp_context.hpp	/^    position_type &get_main_pos() { return macros.get_main_pos(); }$/;"	f	class:boost::wave::context	access:public	signature:()
boost::wave::context::get_main_pos	wave/cpp_context.hpp	/^    position_type const& get_main_pos() const { return macros.get_main_pos(); }$/;"	f	class:boost::wave::context	access:public	signature:() const
boost::wave::context::get_max_include_nesting_depth	wave/cpp_context.hpp	/^    iter_size_type get_max_include_nesting_depth() const$/;"	f	class:boost::wave::context	access:public	signature:() const
boost::wave::context::get_version	wave/cpp_context.hpp	/^    static std::string get_version()  $/;"	f	class:boost::wave::context	access:public	signature:()
boost::wave::context::get_version_string	wave/cpp_context.hpp	/^    static std::string get_version_string()  $/;"	f	class:boost::wave::context	access:public	signature:()
boost::wave::context::has_been_initialized	wave/cpp_context.hpp	/^    bool has_been_initialized;          \/\/ set cwd once$/;"	m	class:boost::wave::context	access:private
boost::wave::context::has_pragma_once	wave/cpp_context.hpp	/^    bool has_pragma_once(std::string const &filename_)$/;"	f	class:boost::wave::context	access:public	signature:(std::string const &filename_)
boost::wave::context::hook_policy_type	wave/cpp_context.hpp	/^    typedef HooksT                                  hook_policy_type;$/;"	t	class:boost::wave::context	access:public
boost::wave::context::hooks	wave/cpp_context.hpp	/^    hook_policy_type hooks;                       \/\/ hook policy instance$/;"	m	class:boost::wave::context	access:private
boost::wave::context::ifblocks	wave/cpp_context.hpp	/^    boost::wave::util::if_block_stack ifblocks;   \/\/ conditional compilation contexts$/;"	m	class:boost::wave::context	access:private
boost::wave::context::includes	wave/cpp_context.hpp	/^    boost::wave::util::include_paths includes;    \/\/ lists of include directories to search$/;"	m	class:boost::wave::context	access:private
boost::wave::context::init_context	wave/cpp_context.hpp	/^    void init_context()$/;"	f	class:boost::wave::context	access:protected	signature:()
boost::wave::context::input_policy_type	wave/cpp_context.hpp	/^    typedef InputPolicyT                            input_policy_type;$/;"	t	class:boost::wave::context	access:public
boost::wave::context::is_defined_macro	wave/cpp_context.hpp	/^    bool is_defined_macro(IteratorT2 const &begin, IteratorT2 const &end) const$/;"	f	class:boost::wave::context	access:protected	signature:(IteratorT2 const &begin, IteratorT2 const &end) const
boost::wave::context::is_defined_macro	wave/cpp_context.hpp	/^    bool is_defined_macro(StringT const &str) const$/;"	f	class:boost::wave::context	access:public	signature:(StringT const &str) const
boost::wave::context::iter_ctxs	wave/cpp_context.hpp	/^    iteration_context_stack_type iter_ctxs;       \/\/ iteration contexts$/;"	m	class:boost::wave::context	access:private
boost::wave::context::iter_size_type	wave/cpp_context.hpp	/^    typedef typename iteration_context_stack_type::size_type iter_size_type;$/;"	t	class:boost::wave::context	access:private
boost::wave::context::iteration_context_stack_type	wave/cpp_context.hpp	/^            iteration_context_stack_type;$/;"	t	class:boost::wave::context	access:private
boost::wave::context::iteration_ptr_type	wave/cpp_context.hpp	/^        iteration_ptr_type;$/;"	t	class:boost::wave::context	access:private
boost::wave::context::iterator_type	wave/cpp_context.hpp	/^    typedef pp_iterator<context>                    iterator_type;$/;"	t	class:boost::wave::context	access:public
boost::wave::context::language	wave/cpp_context.hpp	/^    boost::wave::language_support language;       \/\/ supported language\/extensions$/;"	m	class:boost::wave::context	access:private
boost::wave::context::last	wave/cpp_context.hpp	/^    target_iterator_type last;$/;"	m	class:boost::wave::context	access:private
boost::wave::context::lexer_type	wave/cpp_context.hpp	/^    typedef LexIteratorT                            lexer_type;$/;"	t	class:boost::wave::context	access:public
boost::wave::context::load	wave/cpp_context.hpp	/^    void load(Archive & ar, const unsigned int loaded_version)$/;"	f	class:boost::wave::context	access:private	signature:(Archive & ar, const unsigned int loaded_version)
boost::wave::context::macro_names_begin	wave/cpp_context.hpp	/^    const_name_iterator macro_names_begin() const { return macros.begin(); }$/;"	f	class:boost::wave::context	access:public	signature:() const
boost::wave::context::macro_names_begin	wave/cpp_context.hpp	/^    name_iterator macro_names_begin() { return macros.begin(); }$/;"	f	class:boost::wave::context	access:public	signature:()
boost::wave::context::macro_names_end	wave/cpp_context.hpp	/^    const_name_iterator macro_names_end() const { return macros.end(); }$/;"	f	class:boost::wave::context	access:public	signature:() const
boost::wave::context::macro_names_end	wave/cpp_context.hpp	/^    name_iterator macro_names_end() { return macros.end(); }$/;"	f	class:boost::wave::context	access:public	signature:()
boost::wave::context::macromap_type	wave/cpp_context.hpp	/^    typedef boost::wave::util::macromap<context> macromap_type;$/;"	t	class:boost::wave::context	access:public
boost::wave::context::macros	wave/cpp_context.hpp	/^    macromap_type macros;                         \/\/ map of defined macros$/;"	m	class:boost::wave::context	access:private
boost::wave::context::name_iterator	wave/cpp_context.hpp	/^    typedef typename macromap_type::name_iterator name_iterator;$/;"	t	class:boost::wave::context	access:public
boost::wave::context::pop_iteration_context	wave/cpp_context.hpp	/^    iteration_ptr_type pop_iteration_context()$/;"	f	class:boost::wave::context	access:protected	signature:()
boost::wave::context::position_type	wave/cpp_context.hpp	/^    typedef typename token_type::position_type      position_type;$/;"	t	class:boost::wave::context	access:public
boost::wave::context::push_iteration_context	wave/cpp_context.hpp	/^    void push_iteration_context(position_type const &act_pos, iteration_ptr_type iter_ctx)$/;"	f	class:boost::wave::context	access:protected	signature:(position_type const &act_pos, iteration_ptr_type iter_ctx)
boost::wave::context::remove_macro_definition	wave/cpp_context.hpp	/^    bool remove_macro_definition(StringT const& undefname, bool even_predefined = false)$/;"	f	class:boost::wave::context	access:public	signature:(StringT const& undefname, bool even_predefined = false)
boost::wave::context::reset_macro_definitions	wave/cpp_context.hpp	/^    void reset_macro_definitions() $/;"	f	class:boost::wave::context	access:public	signature:()
boost::wave::context::save	wave/cpp_context.hpp	/^    void save(Archive & ar, const unsigned int version) const$/;"	f	class:boost::wave::context	access:private	signature:(Archive & ar, const unsigned int version) const
boost::wave::context::set_current_directory	wave/cpp_context.hpp	/^    void set_current_directory(char const *path_) $/;"	f	class:boost::wave::context	access:protected	signature:(char const *path_)
boost::wave::context::set_current_filename	wave/cpp_context.hpp	/^    void set_current_filename(char const *real_name)$/;"	f	class:boost::wave::context	access:public	signature:(char const *real_name)
boost::wave::context::set_current_relative_filename	wave/cpp_context.hpp	/^    void set_current_relative_filename(char const *real_name)$/;"	f	class:boost::wave::context	access:public	signature:(char const *real_name)
boost::wave::context::set_language	wave/cpp_context.hpp	/^    void set_language(boost::wave::language_support language_,$/;"	f	class:boost::wave::context	access:public	signature:(boost::wave::language_support language_, bool reset_macros = true)
boost::wave::context::set_max_include_nesting_depth	wave/cpp_context.hpp	/^    void set_max_include_nesting_depth(iter_size_type new_depth)$/;"	f	class:boost::wave::context	access:public	signature:(iter_size_type new_depth)
boost::wave::context::set_sysinclude_delimiter	wave/cpp_context.hpp	/^    void set_sysinclude_delimiter() { includes.set_sys_include_delimiter(); }$/;"	f	class:boost::wave::context	access:public	signature:()
boost::wave::context::std::get_current_filename	wave/cpp_context.hpp	/^    std::string const &get_current_filename() const $/;"	f	class:boost::wave::context::std	access:public	signature:() const
boost::wave::context::std::get_current_relative_filename	wave/cpp_context.hpp	/^    std::string const &get_current_relative_filename() const $/;"	f	class:boost::wave::context::std	access:public	signature:() const
boost::wave::context::string_type	wave/cpp_context.hpp	/^    typedef typename token_type::string_type        string_type;$/;"	t	class:boost::wave::context	access:public
boost::wave::context::target_iterator_type	wave/cpp_context.hpp	/^    typedef IteratorT                               target_iterator_type;$/;"	t	class:boost::wave::context	access:public
boost::wave::context::this_	wave/cpp_context.hpp	/^    context *this_() { return this; }           \/\/ avoid warning in constructor$/;"	f	class:boost::wave::context	access:private	signature:()
boost::wave::context::token_sequence_type	wave/cpp_context.hpp	/^        token_sequence_type;$/;"	t	class:boost::wave::context	access:public
boost::wave::context::token_type	wave/cpp_context.hpp	/^    typedef typename LexIteratorT::token_type       token_type;$/;"	t	class:boost::wave::context	access:public
boost::wave::context_policies	wave/preprocessing_hooks.hpp	/^namespace context_policies {$/;"	n	namespace:boost::wave
boost::wave::context_policies	wave/whitespace_handling.hpp	/^namespace context_policies {$/;"	n	namespace:boost::wave
boost::wave::context_policies::default_preprocessing_hooks	wave/preprocessing_hooks.hpp	/^struct default_preprocessing_hooks $/;"	s	namespace:boost::wave::context_policies
boost::wave::context_policies::default_preprocessing_hooks::defined_macro	wave/preprocessing_hooks.hpp	/^    defined_macro(ContextT const& ctx, TokenT const& macro_name, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& macro_name, bool is_functionlike, ParametersT const& parameters, DefinitionT const& definition, bool is_predefined)
boost::wave::context_policies::default_preprocessing_hooks::defined_macro	wave/preprocessing_hooks.hpp	/^    defined_macro(TokenT const& macro_name, bool is_functionlike, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(TokenT const& macro_name, bool is_functionlike, ParametersT const& parameters, DefinitionT const& definition, bool is_predefined)
boost::wave::context_policies::default_preprocessing_hooks::detected_include_guard	wave/preprocessing_hooks.hpp	/^    detected_include_guard(ContextT const& ctx, std::string const& filename,$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, std::string const& filename, std::string const& include_guard)
boost::wave::context_policies::default_preprocessing_hooks::detected_pragma_once	wave/preprocessing_hooks.hpp	/^    detected_pragma_once(ContextT const& ctx, TokenT const& pragma_token,$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& pragma_token, std::string const& filename)
boost::wave::context_policies::default_preprocessing_hooks::emit_line_directive	wave/preprocessing_hooks.hpp	/^    emit_line_directive(ContextT const& ctx, ContainerT &pending, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT &pending, typename ContextT::token_type const& act_token)
boost::wave::context_policies::default_preprocessing_hooks::evaluated_conditional_expression	wave/preprocessing_hooks.hpp	/^    evaluated_conditional_expression(ContainerT const& expression, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContainerT const& expression, bool expression_value)
boost::wave::context_policies::default_preprocessing_hooks::evaluated_conditional_expression	wave/preprocessing_hooks.hpp	/^    evaluated_conditional_expression(ContextT const& ctx, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& directive, ContainerT const& expression, bool expression_value)
boost::wave::context_policies::default_preprocessing_hooks::expanded_macro	wave/preprocessing_hooks.hpp	/^    void expanded_macro(ContainerT const& result)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContainerT const& result)
boost::wave::context_policies::default_preprocessing_hooks::expanded_macro	wave/preprocessing_hooks.hpp	/^    void expanded_macro(ContextT const& ctx, ContainerT const& result)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT const& result)
boost::wave::context_policies::default_preprocessing_hooks::expanding_function_like_macro	wave/preprocessing_hooks.hpp	/^    void expanding_function_like_macro($/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:( TokenT const& macrodef, std::vector<TokenT> const& formal_args, ContainerT const& definition, TokenT const& macrocall, std::vector<ContainerT> const& arguments)
boost::wave::context_policies::default_preprocessing_hooks::expanding_object_like_macro	wave/preprocessing_hooks.hpp	/^    expanding_object_like_macro(ContextT const& ctx, TokenT const& macro, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& macro, ContainerT const& definition, TokenT const& macrocall)
boost::wave::context_policies::default_preprocessing_hooks::expanding_object_like_macro	wave/preprocessing_hooks.hpp	/^    void expanding_object_like_macro(TokenT const& macro, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(TokenT const& macro, ContainerT const& definition, TokenT const& macrocall)
boost::wave::context_policies::default_preprocessing_hooks::found_directive	wave/preprocessing_hooks.hpp	/^    found_directive(ContextT const& ctx, TokenT const& directive)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& directive)
boost::wave::context_policies::default_preprocessing_hooks::found_directive	wave/preprocessing_hooks.hpp	/^    found_directive(TokenT const& directive)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(TokenT const& directive)
boost::wave::context_policies::default_preprocessing_hooks::found_error_directive	wave/preprocessing_hooks.hpp	/^    found_error_directive(ContextT const& ctx, ContainerT const& message)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT const& message)
boost::wave::context_policies::default_preprocessing_hooks::found_include_directive	wave/preprocessing_hooks.hpp	/^    found_include_directive(ContextT const& ctx, std::string const& filename, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, std::string const& filename, bool include_next)
boost::wave::context_policies::default_preprocessing_hooks::found_include_directive	wave/preprocessing_hooks.hpp	/^    found_include_directive(std::string const& filename, bool include_next) $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(std::string const& filename, bool include_next)
boost::wave::context_policies::default_preprocessing_hooks::found_line_directive	wave/preprocessing_hooks.hpp	/^    found_line_directive(ContextT const& ctx, ContainerT const& arguments,$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT const& arguments, unsigned int line, std::string const& filename)
boost::wave::context_policies::default_preprocessing_hooks::found_unknown_directive	wave/preprocessing_hooks.hpp	/^    found_unknown_directive(ContextT const& ctx, ContainerT const& line, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT const& line, ContainerT& pending)
boost::wave::context_policies::default_preprocessing_hooks::found_warning_directive	wave/preprocessing_hooks.hpp	/^    found_warning_directive(ContextT const& ctx, ContainerT const& message)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT const& message)
boost::wave::context_policies::default_preprocessing_hooks::generated_token	wave/preprocessing_hooks.hpp	/^    generated_token(ContextT const& ctx, TokenT const& t)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& t)
boost::wave::context_policies::default_preprocessing_hooks::interpret_pragma	wave/preprocessing_hooks.hpp	/^    interpret_pragma(ContextT const& ctx, ContainerT &pending, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT &pending, typename ContextT::token_type const& option, ContainerT const& values, typename ContextT::token_type const& act_token)
boost::wave::context_policies::default_preprocessing_hooks::locate_include_file	wave/preprocessing_hooks.hpp	/^    locate_include_file(ContextT& ctx, std::string &file_path, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT& ctx, std::string &file_path, bool is_system, char const *current_name, std::string &dir_path, std::string &native_name)
boost::wave::context_policies::default_preprocessing_hooks::may_skip_whitespace	wave/preprocessing_hooks.hpp	/^    may_skip_whitespace(ContextT const& ctx, TokenT& token, bool& skipped_newline)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT& token, bool& skipped_newline)
boost::wave::context_policies::default_preprocessing_hooks::opened_include_file	wave/preprocessing_hooks.hpp	/^    opened_include_file(ContextT const& ctx, std::string const& relname, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, std::string const& relname, std::string const& absname, bool is_system_include)
boost::wave::context_policies::default_preprocessing_hooks::opened_include_file	wave/preprocessing_hooks.hpp	/^    opened_include_file(std::string const& relname, std::string const& absname, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(std::string const& relname, std::string const& absname, std::size_t include_depth, bool is_system_include)
boost::wave::context_policies::default_preprocessing_hooks::rescanned_macro	wave/preprocessing_hooks.hpp	/^    void rescanned_macro(ContainerT const& result)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContainerT const& result)
boost::wave::context_policies::default_preprocessing_hooks::rescanned_macro	wave/preprocessing_hooks.hpp	/^    void rescanned_macro(ContextT const& ctx, ContainerT const& result)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT const& result)
boost::wave::context_policies::default_preprocessing_hooks::returning_from_include_file	wave/preprocessing_hooks.hpp	/^    returning_from_include_file() $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:()
boost::wave::context_policies::default_preprocessing_hooks::returning_from_include_file	wave/preprocessing_hooks.hpp	/^    returning_from_include_file(ContextT const& ctx) $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx)
boost::wave::context_policies::default_preprocessing_hooks::skipped_token	wave/preprocessing_hooks.hpp	/^    skipped_token(ContextT const& ctx, TokenT const& token)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& token)
boost::wave::context_policies::default_preprocessing_hooks::skipped_token	wave/preprocessing_hooks.hpp	/^    skipped_token(TokenT const& token)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(TokenT const& token)
boost::wave::context_policies::default_preprocessing_hooks::throw_exception	wave/preprocessing_hooks.hpp	/^    throw_exception(ContextT const& ctx, ExceptionT const& e)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ExceptionT const& e)
boost::wave::context_policies::default_preprocessing_hooks::undefined_macro	wave/preprocessing_hooks.hpp	/^    undefined_macro(ContextT const& ctx, TokenT const& macro_name)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& macro_name)
boost::wave::context_policies::default_preprocessing_hooks::undefined_macro	wave/preprocessing_hooks.hpp	/^    undefined_macro(TokenT const& macro_name)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(TokenT const& macro_name)
boost::wave::context_policies::eat_whitespace	wave/whitespace_handling.hpp	/^class eat_whitespace $/;"	c	namespace:boost::wave::context_policies	inherits:default_preprocessing_hooks
boost::wave::context_policies::eat_whitespace::bol_whitespace	wave/whitespace_handling.hpp	/^    state_t general, newline, newline_2nd, whitespace, bol_whitespace;$/;"	m	class:boost::wave::context_policies::eat_whitespace	access:private
boost::wave::context_policies::eat_whitespace::bol_whitespace	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::bol_whitespace(TokenT &token, bool &skipped_newline) $/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:(TokenT &token, bool &skipped_newline)
boost::wave::context_policies::eat_whitespace::eat_whitespace	wave/whitespace_handling.hpp	/^    eat_whitespace();$/;"	p	class:boost::wave::context_policies::eat_whitespace	access:public	signature:()
boost::wave::context_policies::eat_whitespace::eat_whitespace	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::eat_whitespace()$/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:()
boost::wave::context_policies::eat_whitespace::eat_whitespace::state	wave/whitespace_handling.hpp	/^    state_t eat_whitespace::* state;$/;"	m	class:boost::wave::context_policies::eat_whitespace::eat_whitespace	access:private
boost::wave::context_policies::eat_whitespace::general	wave/whitespace_handling.hpp	/^    state_t general, newline, newline_2nd, whitespace, bol_whitespace;$/;"	m	class:boost::wave::context_policies::eat_whitespace	access:private
boost::wave::context_policies::eat_whitespace::general	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::general(TokenT &token, bool &skipped_newline) $/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:(TokenT &token, bool &skipped_newline)
boost::wave::context_policies::eat_whitespace::may_skip_whitespace	wave/whitespace_handling.hpp	/^    bool may_skip_whitespace(ContextT const& ctx, TokenT &token, $/;"	p	class:boost::wave::context_policies::eat_whitespace	access:public	signature:(ContextT const& ctx, TokenT &token, bool &skipped_newline)
boost::wave::context_policies::eat_whitespace::may_skip_whitespace	wave/whitespace_handling.hpp	/^    bool may_skip_whitespace(ContextT const& ctx, TokenT &token, $/;"	p	class:boost::wave::context_policies::eat_whitespace	access:public	signature:(ContextT const& ctx, TokenT &token, bool preserve_comments_, bool preserve_bol_whitespace_, bool &skipped_newline)
boost::wave::context_policies::eat_whitespace::may_skip_whitespace	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::may_skip_whitespace(ContextT const& ctx, TokenT &token, $/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:(ContextT const& ctx, TokenT &token, bool &skipped_newline)
boost::wave::context_policies::eat_whitespace::may_skip_whitespace	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::may_skip_whitespace(ContextT const& ctx, TokenT &token, $/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:(ContextT const& ctx, TokenT &token, bool preserve_comments_, bool preserve_bol_whitespace_, bool &skipped_newline)
boost::wave::context_policies::eat_whitespace::newline	wave/whitespace_handling.hpp	/^    state_t general, newline, newline_2nd, whitespace, bol_whitespace;$/;"	m	class:boost::wave::context_policies::eat_whitespace	access:private
boost::wave::context_policies::eat_whitespace::newline	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::newline(TokenT &token, bool &skipped_newline) $/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:(TokenT &token, bool &skipped_newline)
boost::wave::context_policies::eat_whitespace::newline_2nd	wave/whitespace_handling.hpp	/^    state_t general, newline, newline_2nd, whitespace, bol_whitespace;$/;"	m	class:boost::wave::context_policies::eat_whitespace	access:private
boost::wave::context_policies::eat_whitespace::newline_2nd	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::newline_2nd(TokenT &token, bool &skipped_newline) $/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:(TokenT &token, bool &skipped_newline)
boost::wave::context_policies::eat_whitespace::preserve_bol_whitespace	wave/whitespace_handling.hpp	/^    bool preserve_bol_whitespace;$/;"	m	class:boost::wave::context_policies::eat_whitespace	access:private
boost::wave::context_policies::eat_whitespace::preserve_comments	wave/whitespace_handling.hpp	/^    bool preserve_comments;$/;"	m	class:boost::wave::context_policies::eat_whitespace	access:private
boost::wave::context_policies::eat_whitespace::skip_cppcomment	wave/whitespace_handling.hpp	/^    bool skip_cppcomment(boost::wave::token_id id)$/;"	f	class:boost::wave::context_policies::eat_whitespace	access:protected	signature:(boost::wave::token_id id)
boost::wave::context_policies::eat_whitespace::state_t	wave/whitespace_handling.hpp	/^    typedef bool state_t(TokenT &token, bool &skipped_newline);$/;"	t	class:boost::wave::context_policies::eat_whitespace	access:private
boost::wave::context_policies::eat_whitespace::whitespace	wave/whitespace_handling.hpp	/^    state_t general, newline, newline_2nd, whitespace, bol_whitespace;$/;"	m	class:boost::wave::context_policies::eat_whitespace	access:private
boost::wave::context_policies::eat_whitespace::whitespace	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::whitespace(TokenT &token, bool &skipped_newline) $/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:(TokenT &token, bool &skipped_newline)
boost::wave::context_policies::util	wave/whitespace_handling.hpp	/^namespace util {$/;"	n	namespace:boost::wave::context_policies
boost::wave::context_policies::util::ccomment_count_newlines	wave/whitespace_handling.hpp	/^    int ccomment_count_newlines(TokenT const& token)$/;"	f	namespace:boost::wave::context_policies::util	signature:(TokenT const& token)
boost::wave::context_policies::util::ccomment_has_newline	wave/whitespace_handling.hpp	/^    bool ccomment_has_newline(TokenT const& token)$/;"	f	namespace:boost::wave::context_policies::util	signature:(TokenT const& token)
boost::wave::context_policies::util::rawstring_count_newlines	wave/whitespace_handling.hpp	/^    int rawstring_count_newlines(TokenT const& token)$/;"	f	namespace:boost::wave::context_policies::util	signature:(TokenT const& token)
boost::wave::cpp_exception	wave/cpp_exceptions.hpp	/^class BOOST_SYMBOL_VISIBLE cpp_exception$/;"	c	namespace:boost::wave	inherits:std::exception
boost::wave::cpp_exception::column	wave/cpp_exceptions.hpp	/^    std::size_t column;$/;"	m	class:boost::wave::cpp_exception	access:protected
boost::wave::cpp_exception::column_no	wave/cpp_exceptions.hpp	/^    std::size_t column_no() const throw() { return column; }$/;"	f	class:boost::wave::cpp_exception	access:public	signature:() const
boost::wave::cpp_exception::cpp_exception	wave/cpp_exceptions.hpp	/^    cpp_exception(std::size_t line_, std::size_t column_, char const *filename_) throw()$/;"	f	class:boost::wave::cpp_exception	access:public	signature:(std::size_t line_, std::size_t column_, char const *filename_)
boost::wave::cpp_exception::description	wave/cpp_exceptions.hpp	/^    virtual char const *description() const throw() = 0;$/;"	p	class:boost::wave::cpp_exception	access:public	signature:() const
boost::wave::cpp_exception::file_name	wave/cpp_exceptions.hpp	/^    char const *file_name() const throw() { return filename; }$/;"	f	class:boost::wave::cpp_exception	access:public	signature:() const
boost::wave::cpp_exception::filename	wave/cpp_exceptions.hpp	/^    char filename[512];$/;"	m	class:boost::wave::cpp_exception	access:protected
boost::wave::cpp_exception::get_errorcode	wave/cpp_exceptions.hpp	/^    virtual int get_errorcode() const throw() = 0;$/;"	p	class:boost::wave::cpp_exception	access:public	signature:() const
boost::wave::cpp_exception::get_related_name	wave/cpp_exceptions.hpp	/^    virtual char const* get_related_name() const throw() = 0;$/;"	p	class:boost::wave::cpp_exception	access:public	signature:() const
boost::wave::cpp_exception::get_severity	wave/cpp_exceptions.hpp	/^    virtual int get_severity() const throw() = 0;$/;"	p	class:boost::wave::cpp_exception	access:public	signature:() const
boost::wave::cpp_exception::is_recoverable	wave/cpp_exceptions.hpp	/^    virtual bool is_recoverable() const throw() = 0;$/;"	p	class:boost::wave::cpp_exception	access:public	signature:() const
boost::wave::cpp_exception::line	wave/cpp_exceptions.hpp	/^    std::size_t line;$/;"	m	class:boost::wave::cpp_exception	access:protected
boost::wave::cpp_exception::line_no	wave/cpp_exceptions.hpp	/^    std::size_t line_no() const throw() { return line; }$/;"	f	class:boost::wave::cpp_exception	access:public	signature:() const
boost::wave::cpp_exception::what	wave/cpp_exceptions.hpp	/^    virtual char const *what() const throw() = 0;           \/\/ to be overloaded$/;"	p	class:boost::wave::cpp_exception	access:public	signature:() const
boost::wave::cpp_exception::~cpp_exception	wave/cpp_exceptions.hpp	/^    ~cpp_exception() throw() {}$/;"	f	class:boost::wave::cpp_exception	access:public	signature:()
boost::wave::cpplexer	wave/cpplexer/convert_trigraphs.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
boost::wave::cpplexer	wave/cpplexer/cpp_lex_interface.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
boost::wave::cpplexer	wave/cpplexer/cpp_lex_interface_generator.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
boost::wave::cpplexer	wave/cpplexer/cpp_lex_iterator.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
boost::wave::cpplexer	wave/cpplexer/cpp_lex_token.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
boost::wave::cpplexer	wave/cpplexer/cpplexer_exceptions.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
boost::wave::cpplexer	wave/cpplexer/detect_include_guards.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
boost::wave::cpplexer	wave/cpplexer/re2clex/aq.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
boost::wave::cpplexer	wave/cpplexer/re2clex/cpp_re.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
boost::wave::cpplexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
boost::wave::cpplexer	wave/cpplexer/re2clex/scanner.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
boost::wave::cpplexer	wave/cpplexer/token_cache.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
boost::wave::cpplexer	wave/cpplexer/validate_universal_char.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
boost::wave::cpplexer::cpplexer_exception	wave/cpplexer/cpplexer_exceptions.hpp	/^class BOOST_SYMBOL_VISIBLE cpplexer_exception$/;"	c	namespace:boost::wave::cpplexer	inherits:std::exception
boost::wave::cpplexer::cpplexer_exception::column	wave/cpplexer/cpplexer_exceptions.hpp	/^    std::size_t column;$/;"	m	class:boost::wave::cpplexer::cpplexer_exception	access:protected
boost::wave::cpplexer::cpplexer_exception::column_no	wave/cpplexer/cpplexer_exceptions.hpp	/^    std::size_t column_no() const throw() { return column; }$/;"	f	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
boost::wave::cpplexer::cpplexer_exception::cpplexer_exception	wave/cpplexer/cpplexer_exceptions.hpp	/^    cpplexer_exception(std::size_t line_, std::size_t column_, char const *filename_) throw()$/;"	f	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:(std::size_t line_, std::size_t column_, char const *filename_)
boost::wave::cpplexer::cpplexer_exception::description	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual char const *description() const throw() = 0;$/;"	p	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
boost::wave::cpplexer::cpplexer_exception::file_name	wave/cpplexer/cpplexer_exceptions.hpp	/^    char const *file_name() const throw() { return filename; }$/;"	f	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
boost::wave::cpplexer::cpplexer_exception::filename	wave/cpplexer/cpplexer_exceptions.hpp	/^    char filename[512];$/;"	m	class:boost::wave::cpplexer::cpplexer_exception	access:protected
boost::wave::cpplexer::cpplexer_exception::get_errorcode	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual int get_errorcode() const throw() = 0;$/;"	p	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
boost::wave::cpplexer::cpplexer_exception::get_severity	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual int get_severity() const throw() = 0;$/;"	p	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
boost::wave::cpplexer::cpplexer_exception::is_recoverable	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual bool is_recoverable() const throw() = 0;$/;"	p	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
boost::wave::cpplexer::cpplexer_exception::line	wave/cpplexer/cpplexer_exceptions.hpp	/^    std::size_t line;$/;"	m	class:boost::wave::cpplexer::cpplexer_exception	access:protected
boost::wave::cpplexer::cpplexer_exception::line_no	wave/cpplexer/cpplexer_exceptions.hpp	/^    std::size_t line_no() const throw() { return line; }$/;"	f	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
boost::wave::cpplexer::cpplexer_exception::what	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual char const *what() const throw() = 0;   \/\/ to be overloaded$/;"	p	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
boost::wave::cpplexer::cpplexer_exception::~cpplexer_exception	wave/cpplexer/cpplexer_exceptions.hpp	/^    ~cpplexer_exception() throw() {}$/;"	f	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:()
boost::wave::cpplexer::impl	wave/cpplexer/convert_trigraphs.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::cpplexer
boost::wave::cpplexer::impl	wave/cpplexer/cpp_lex_iterator.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::cpplexer
boost::wave::cpplexer::impl	wave/cpplexer/cpp_lex_token.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::cpplexer
boost::wave::cpplexer::impl	wave/cpplexer/validate_universal_char.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::cpplexer
boost::wave::cpplexer::impl::classify_universal_char	wave/cpplexer/validate_universal_char.hpp	/^classify_universal_char (unsigned long ch)$/;"	f	namespace:boost::wave::cpplexer::impl	signature:(unsigned long ch)
boost::wave::cpplexer::impl::convert_trigraph	wave/cpplexer/convert_trigraphs.hpp	/^convert_trigraph(StringT const &trigraph)$/;"	f	namespace:boost::wave::cpplexer::impl	signature:(StringT const &trigraph)
boost::wave::cpplexer::impl::convert_trigraphs	wave/cpplexer/convert_trigraphs.hpp	/^convert_trigraphs(StringT const &value)$/;"	f	namespace:boost::wave::cpplexer::impl	signature:(StringT const &value)
boost::wave::cpplexer::impl::in_range	wave/cpplexer/validate_universal_char.hpp	/^in_range(unsigned long ch, unsigned long l, unsigned long u)$/;"	f	namespace:boost::wave::cpplexer::impl	signature:(unsigned long ch, unsigned long l, unsigned long u)
boost::wave::cpplexer::impl::is_trigraph	wave/cpplexer/convert_trigraphs.hpp	/^is_trigraph(StringT const& trigraph)$/;"	f	namespace:boost::wave::cpplexer::impl	signature:(StringT const& trigraph)
boost::wave::cpplexer::impl::lex_iterator_functor_shim	wave/cpplexer/cpp_lex_iterator.hpp	/^class lex_iterator_functor_shim $/;"	c	namespace:boost::wave::cpplexer::impl
boost::wave::cpplexer::impl::lex_iterator_functor_shim::destroy	wave/cpplexer/cpp_lex_iterator.hpp	/^    static void destroy(MultiPass& mp)$/;"	f	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public	signature:(MultiPass& mp)
boost::wave::cpplexer::impl::lex_iterator_functor_shim::eof	wave/cpplexer/cpp_lex_iterator.hpp	/^    BOOST_WAVE_EOF_PREFIX result_type const eof;$/;"	m	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public
boost::wave::cpplexer::impl::lex_iterator_functor_shim::get_next	wave/cpplexer/cpp_lex_iterator.hpp	/^    static result_type& get_next(MultiPass& mp, result_type& result)$/;"	f	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public	signature:(MultiPass& mp, result_type& result)
boost::wave::cpplexer::impl::lex_iterator_functor_shim::has_include_guards	wave/cpplexer/cpp_lex_iterator.hpp	/^    static bool has_include_guards(MultiPass& mp, std::string& guard_name) $/;"	f	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public	signature:(MultiPass& mp, std::string& guard_name)
boost::wave::cpplexer::impl::lex_iterator_functor_shim::lex_iterator_functor_shim	wave/cpplexer/cpp_lex_iterator.hpp	/^    lex_iterator_functor_shim() $/;"	f	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public	signature:()
boost::wave::cpplexer::impl::lex_iterator_functor_shim::operator =	wave/cpplexer/cpp_lex_iterator.hpp	/^    lex_iterator_functor_shim& operator= (lex_iterator_functor_shim const& rhs)$/;"	f	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public	signature:(lex_iterator_functor_shim const& rhs)
boost::wave::cpplexer::impl::lex_iterator_functor_shim::position_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef typename TokenT::position_type  position_type;$/;"	t	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:private
boost::wave::cpplexer::impl::lex_iterator_functor_shim::result_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef TokenT result_type;$/;"	t	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public
boost::wave::cpplexer::impl::lex_iterator_functor_shim::set_position	wave/cpplexer/cpp_lex_iterator.hpp	/^    static void set_position(MultiPass& mp, position_type const &pos)$/;"	f	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public	signature:(MultiPass& mp, position_type const &pos)
boost::wave::cpplexer::impl::lex_iterator_functor_shim::shared	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef lex_input_interface<TokenT>* shared;$/;"	t	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public
boost::wave::cpplexer::impl::lex_iterator_functor_shim::unique	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef lex_iterator_functor_shim unique;$/;"	t	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public
boost::wave::cpplexer::impl::token_data	wave/cpplexer/cpp_lex_token.hpp	/^class token_data$/;"	c	namespace:boost::wave::cpplexer::impl
boost::wave::cpplexer::impl::token_data::addref	wave/cpplexer/cpp_lex_token.hpp	/^    std::size_t addref() { return ++refcnt; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:()
boost::wave::cpplexer::impl::token_data::get_position	wave/cpplexer/cpp_lex_token.hpp	/^    position_type const &get_position() const { return pos; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:() const
boost::wave::cpplexer::impl::token_data::get_refcnt	wave/cpplexer/cpp_lex_token.hpp	/^    std::size_t get_refcnt() const { return refcnt; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:() const
boost::wave::cpplexer::impl::token_data::get_value	wave/cpplexer/cpp_lex_token.hpp	/^    string_type const &get_value() const { return value; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:() const
boost::wave::cpplexer::impl::token_data::id	wave/cpplexer/cpp_lex_token.hpp	/^    token_id id;                \/\/ the token id$/;"	m	class:boost::wave::cpplexer::impl::token_data	access:private
boost::wave::cpplexer::impl::token_data::init	wave/cpplexer/cpp_lex_token.hpp	/^    void init(token_data const& rhs)$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(token_data const& rhs)
boost::wave::cpplexer::impl::token_data::init	wave/cpplexer/cpp_lex_token.hpp	/^    void init(token_id id_, string_type const &value_, position_type const &pos_)$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(token_id id_, string_type const &value_, position_type const &pos_)
boost::wave::cpplexer::impl::token_data::operator ==	wave/cpplexer/cpp_lex_token.hpp	/^    friend bool operator== (token_data const& lhs, token_data const& rhs)$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:friend	signature:(token_data const& lhs, token_data const& rhs)
boost::wave::cpplexer::impl::token_data::operator delete	wave/cpplexer/cpp_lex_token.hpp	/^    static void operator delete(void *p, std::size_t size);$/;"	p	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(void *p, std::size_t size)
boost::wave::cpplexer::impl::token_data::operator delete	wave/cpplexer/cpp_lex_token.hpp	/^token_data<StringTypeT, PositionT>::operator delete(void *p, std::size_t size)$/;"	f	class:boost::wave::cpplexer::impl::token_data	signature:(void *p, std::size_t size)
boost::wave::cpplexer::impl::token_data::operator new	wave/cpplexer/cpp_lex_token.hpp	/^    static void *operator new(std::size_t size);$/;"	p	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(std::size_t size)
boost::wave::cpplexer::impl::token_data::operator new	wave/cpplexer/cpp_lex_token.hpp	/^token_data<StringTypeT, PositionT>::operator new(std::size_t size)$/;"	f	class:boost::wave::cpplexer::impl::token_data	signature:(std::size_t size)
boost::wave::cpplexer::impl::token_data::operator token_id	wave/cpplexer/cpp_lex_token.hpp	/^    operator token_id() const { return id; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:() const
boost::wave::cpplexer::impl::token_data::pos	wave/cpplexer/cpp_lex_token.hpp	/^    position_type pos;          \/\/ the original file position$/;"	m	class:boost::wave::cpplexer::impl::token_data	access:private
boost::wave::cpplexer::impl::token_data::position_type	wave/cpplexer/cpp_lex_token.hpp	/^    typedef PositionT   position_type;$/;"	t	class:boost::wave::cpplexer::impl::token_data	access:public
boost::wave::cpplexer::impl::token_data::print	wave/cpplexer/cpp_lex_token.hpp	/^    void print (std::ostream &stream) const$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(std::ostream &stream) const
boost::wave::cpplexer::impl::token_data::refcnt	wave/cpplexer/cpp_lex_token.hpp	/^    boost::detail::atomic_count refcnt;$/;"	m	class:boost::wave::cpplexer::impl::token_data	access:private
boost::wave::cpplexer::impl::token_data::release	wave/cpplexer/cpp_lex_token.hpp	/^    std::size_t release() { return --refcnt; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:()
boost::wave::cpplexer::impl::token_data::serialize	wave/cpplexer/cpp_lex_token.hpp	/^    void serialize(Archive &ar, const unsigned int version)$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(Archive &ar, const unsigned int version)
boost::wave::cpplexer::impl::token_data::set_position	wave/cpplexer/cpp_lex_token.hpp	/^    void set_position (position_type const &pos_) { pos = pos_; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(position_type const &pos_)
boost::wave::cpplexer::impl::token_data::set_token_id	wave/cpplexer/cpp_lex_token.hpp	/^    void set_token_id (token_id id_) { id = id_; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(token_id id_)
boost::wave::cpplexer::impl::token_data::set_value	wave/cpplexer/cpp_lex_token.hpp	/^    void set_value (string_type const &value_) { value = value_; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(string_type const &value_)
boost::wave::cpplexer::impl::token_data::string_type	wave/cpplexer/cpp_lex_token.hpp	/^    typedef StringTypeT string_type;$/;"	t	class:boost::wave::cpplexer::impl::token_data	access:public
boost::wave::cpplexer::impl::token_data::token_data	wave/cpplexer/cpp_lex_token.hpp	/^    explicit token_data(int)$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(int)
boost::wave::cpplexer::impl::token_data::token_data	wave/cpplexer/cpp_lex_token.hpp	/^    token_data()$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:()
boost::wave::cpplexer::impl::token_data::token_data	wave/cpplexer/cpp_lex_token.hpp	/^    token_data(token_data const& rhs)$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(token_data const& rhs)
boost::wave::cpplexer::impl::token_data::token_data	wave/cpplexer/cpp_lex_token.hpp	/^    token_data(token_id id_, string_type const &value_, position_type const &pos_)$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(token_id id_, string_type const &value_, position_type const &pos_)
boost::wave::cpplexer::impl::token_data::value	wave/cpplexer/cpp_lex_token.hpp	/^    string_type value;          \/\/ the text, which was parsed into this token$/;"	m	class:boost::wave::cpplexer::impl::token_data	access:private
boost::wave::cpplexer::impl::token_data::~token_data	wave/cpplexer/cpp_lex_token.hpp	/^    ~token_data()$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:()
boost::wave::cpplexer::impl::token_data_tag	wave/cpplexer/cpp_lex_token.hpp	/^struct token_data_tag {};$/;"	s	namespace:boost::wave::cpplexer::impl
boost::wave::cpplexer::impl::universal_char_type	wave/cpplexer/validate_universal_char.hpp	/^enum universal_char_type {$/;"	g	namespace:boost::wave::cpplexer::impl
boost::wave::cpplexer::impl::universal_char_type_base_charset	wave/cpplexer/validate_universal_char.hpp	/^    universal_char_type_base_charset = 2,$/;"	e	enum:boost::wave::cpplexer::impl::universal_char_type
boost::wave::cpplexer::impl::universal_char_type_invalid	wave/cpplexer/validate_universal_char.hpp	/^    universal_char_type_invalid = 1,$/;"	e	enum:boost::wave::cpplexer::impl::universal_char_type
boost::wave::cpplexer::impl::universal_char_type_not_allowed_for_identifiers	wave/cpplexer/validate_universal_char.hpp	/^    universal_char_type_not_allowed_for_identifiers = 3$/;"	e	enum:boost::wave::cpplexer::impl::universal_char_type
boost::wave::cpplexer::impl::universal_char_type_valid	wave/cpplexer/validate_universal_char.hpp	/^    universal_char_type_valid = 0,$/;"	e	enum:boost::wave::cpplexer::impl::universal_char_type
boost::wave::cpplexer::impl::validate_identifier_name	wave/cpplexer/validate_universal_char.hpp	/^validate_identifier_name (StringT const &name, std::size_t line, $/;"	f	namespace:boost::wave::cpplexer::impl	signature:(StringT const &name, std::size_t line, std::size_t column, StringT const &file_name)
boost::wave::cpplexer::impl::validate_literal	wave/cpplexer/validate_universal_char.hpp	/^validate_literal (StringT const &name, std::size_t line, std::size_t column,$/;"	f	namespace:boost::wave::cpplexer::impl	signature:(StringT const &name, std::size_t line, std::size_t column, StringT const &file_name)
boost::wave::cpplexer::include_guards	wave/cpplexer/detect_include_guards.hpp	/^class include_guards$/;"	c	namespace:boost::wave::cpplexer
boost::wave::cpplexer::include_guards::current_state	wave/cpplexer/detect_include_guards.hpp	/^    bool current_state;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::include_guards::detect_guard	wave/cpplexer/detect_include_guards.hpp	/^    Token& detect_guard(Token& t) $/;"	f	class:boost::wave::cpplexer::include_guards	access:public	signature:(Token& t)
boost::wave::cpplexer::include_guards::detected	wave/cpplexer/detect_include_guards.hpp	/^    bool detected(std::string& guard_name_) const $/;"	f	class:boost::wave::cpplexer::include_guards	access:public	signature:(std::string& guard_name_) const
boost::wave::cpplexer::include_guards::detected_guards	wave/cpplexer/detect_include_guards.hpp	/^    bool detected_guards;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::include_guards::guard_name	wave/cpplexer/detect_include_guards.hpp	/^    typename Token::string_type guard_name;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::include_guards::if_depth	wave/cpplexer/detect_include_guards.hpp	/^    int if_depth;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::include_guards::include_guards	wave/cpplexer/detect_include_guards.hpp	/^    include_guards()$/;"	f	class:boost::wave::cpplexer::include_guards	access:public	signature:()
boost::wave::cpplexer::include_guards::include_guards::state	wave/cpplexer/detect_include_guards.hpp	/^    state_type include_guards::* state;$/;"	m	class:boost::wave::cpplexer::include_guards::include_guards	access:private
boost::wave::cpplexer::include_guards::is_skippable	wave/cpplexer/detect_include_guards.hpp	/^    bool is_skippable(token_id id) const$/;"	f	class:boost::wave::cpplexer::include_guards	access:private	signature:(token_id id) const
boost::wave::cpplexer::include_guards::state_0	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_0, state_1, state_2, state_3, state_4, state_5;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::include_guards::state_0	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_0(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
boost::wave::cpplexer::include_guards::state_1	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_0, state_1, state_2, state_3, state_4, state_5;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::include_guards::state_1	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_1(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
boost::wave::cpplexer::include_guards::state_1a	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_1a, state_1b, state_1c, state_1d, state_1e;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::include_guards::state_1a	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_1a(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
boost::wave::cpplexer::include_guards::state_1b	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_1a, state_1b, state_1c, state_1d, state_1e;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::include_guards::state_1b	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_1b(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
boost::wave::cpplexer::include_guards::state_1c	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_1a, state_1b, state_1c, state_1d, state_1e;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::include_guards::state_1c	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_1c(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
boost::wave::cpplexer::include_guards::state_1d	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_1a, state_1b, state_1c, state_1d, state_1e;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::include_guards::state_1d	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_1d(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
boost::wave::cpplexer::include_guards::state_1e	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_1a, state_1b, state_1c, state_1d, state_1e;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::include_guards::state_1e	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_1e(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
boost::wave::cpplexer::include_guards::state_2	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_0, state_1, state_2, state_3, state_4, state_5;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::include_guards::state_2	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_2(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
boost::wave::cpplexer::include_guards::state_3	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_0, state_1, state_2, state_3, state_4, state_5;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::include_guards::state_3	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_3(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
boost::wave::cpplexer::include_guards::state_4	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_0, state_1, state_2, state_3, state_4, state_5;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::include_guards::state_4	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_4(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
boost::wave::cpplexer::include_guards::state_5	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_0, state_1, state_2, state_3, state_4, state_5;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::include_guards::state_5	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_5(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
boost::wave::cpplexer::include_guards::state_type	wave/cpplexer/detect_include_guards.hpp	/^    typedef Token& state_type(Token& t);$/;"	t	class:boost::wave::cpplexer::include_guards	access:private
boost::wave::cpplexer::is_recoverable	wave/cpplexer/cpplexer_exceptions.hpp	/^is_recoverable(lexing_exception const& e)$/;"	f	namespace:boost::wave::cpplexer	signature:(lexing_exception const& e)
boost::wave::cpplexer::lex_input_interface	wave/cpplexer/cpp_lex_interface.hpp	/^struct lex_input_interface $/;"	s	namespace:boost::wave::cpplexer
boost::wave::cpplexer::lex_input_interface::get	wave/cpplexer/cpp_lex_interface.hpp	/^    virtual TokenT& get(TokenT&) = 0;$/;"	p	struct:boost::wave::cpplexer::lex_input_interface	access:public	signature:(TokenT&)
boost::wave::cpplexer::lex_input_interface::has_include_guards	wave/cpplexer/cpp_lex_interface.hpp	/^    virtual bool has_include_guards(std::string& guard_name) const = 0;$/;"	p	struct:boost::wave::cpplexer::lex_input_interface	access:public	signature:(std::string& guard_name) const
boost::wave::cpplexer::lex_input_interface::lex_input_interface	wave/cpplexer/cpp_lex_interface.hpp	/^    lex_input_interface() {}$/;"	f	struct:boost::wave::cpplexer::lex_input_interface	access:public	signature:()
boost::wave::cpplexer::lex_input_interface::position_type	wave/cpplexer/cpp_lex_interface.hpp	/^    typedef typename TokenT::position_type position_type;$/;"	t	struct:boost::wave::cpplexer::lex_input_interface	access:public
boost::wave::cpplexer::lex_input_interface::set_position	wave/cpplexer/cpp_lex_interface.hpp	/^    virtual void set_position(position_type const &pos) = 0;$/;"	p	struct:boost::wave::cpplexer::lex_input_interface	access:public	signature:(position_type const &pos)
boost::wave::cpplexer::lex_input_interface::~lex_input_interface	wave/cpplexer/cpp_lex_interface.hpp	/^    virtual ~lex_input_interface() {}$/;"	f	struct:boost::wave::cpplexer::lex_input_interface	access:public	signature:()
boost::wave::cpplexer::lex_input_interface_generator	wave/cpplexer/cpp_lex_interface_generator.hpp	/^struct lex_input_interface_generator$/;"	s	namespace:boost::wave::cpplexer	inherits:lex_input_interface
boost::wave::cpplexer::lex_input_interface_generator::lex_input_interface_generator	wave/cpplexer/cpp_lex_interface_generator.hpp	/^    lex_input_interface_generator() {}$/;"	f	struct:boost::wave::cpplexer::lex_input_interface_generator	access:public	signature:()
boost::wave::cpplexer::lex_input_interface_generator::new_lexer	wave/cpplexer/cpp_lex_interface_generator.hpp	/^    new_lexer(IteratorT const &first, IteratorT const &last, $/;"	f	struct:boost::wave::cpplexer::lex_input_interface_generator	access:public	signature:(IteratorT const &first, IteratorT const &last, position_type const &pos, boost::wave::language_support language)
boost::wave::cpplexer::lex_input_interface_generator::position_type	wave/cpplexer/cpp_lex_interface_generator.hpp	/^    typedef typename lex_input_interface<TokenT>::position_type position_type;$/;"	t	struct:boost::wave::cpplexer::lex_input_interface_generator	access:public
boost::wave::cpplexer::lex_input_interface_generator::~lex_input_interface_generator	wave/cpplexer/cpp_lex_interface_generator.hpp	/^    ~lex_input_interface_generator() {}$/;"	f	struct:boost::wave::cpplexer::lex_input_interface_generator	access:public	signature:()
boost::wave::cpplexer::lex_iterator	wave/cpplexer/cpp_lex_iterator.hpp	/^class lex_iterator $/;"	c	namespace:boost::wave::cpplexer	inherits:make_multi_pass::type
boost::wave::cpplexer::lex_iterator::base_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef typename make_multi_pass<input_policy_type>::type base_type;$/;"	t	class:boost::wave::cpplexer::lex_iterator	access:private
boost::wave::cpplexer::lex_iterator::functor_data_type	wave/cpplexer/cpp_lex_iterator.hpp	/^        functor_data_type;$/;"	t	class:boost::wave::cpplexer::lex_iterator	access:private
boost::wave::cpplexer::lex_iterator::has_include_guards	wave/cpplexer/cpp_lex_iterator.hpp	/^    bool has_include_guards(std::string& guard_name) const$/;"	f	class:boost::wave::cpplexer::lex_iterator	access:public	signature:(std::string& guard_name) const
boost::wave::cpplexer::lex_iterator::input_policy_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef impl::lex_iterator_functor_shim<TokenT> input_policy_type;$/;"	t	class:boost::wave::cpplexer::lex_iterator	access:private
boost::wave::cpplexer::lex_iterator::lex_iterator	wave/cpplexer/cpp_lex_iterator.hpp	/^    lex_iterator()$/;"	f	class:boost::wave::cpplexer::lex_iterator	access:public	signature:()
boost::wave::cpplexer::lex_iterator::lex_iterator	wave/cpplexer/cpp_lex_iterator.hpp	/^    lex_iterator(IteratorT const &first, IteratorT const &last, $/;"	f	class:boost::wave::cpplexer::lex_iterator	access:public	signature:(IteratorT const &first, IteratorT const &last, typename TokenT::position_type const &pos, boost::wave::language_support language)
boost::wave::cpplexer::lex_iterator::set_position	wave/cpplexer/cpp_lex_iterator.hpp	/^    void set_position(typename TokenT::position_type const &pos)$/;"	f	class:boost::wave::cpplexer::lex_iterator	access:public	signature:(typename TokenT::position_type const &pos)
boost::wave::cpplexer::lex_iterator::shared_functor_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef typename input_policy_type::shared shared_functor_type;$/;"	t	class:boost::wave::cpplexer::lex_iterator	access:private
boost::wave::cpplexer::lex_iterator::token_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef TokenT token_type;$/;"	t	class:boost::wave::cpplexer::lex_iterator	access:public
boost::wave::cpplexer::lex_iterator::unique_functor_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef typename input_policy_type::unique unique_functor_type;$/;"	t	class:boost::wave::cpplexer::lex_iterator	access:private
boost::wave::cpplexer::lex_token	wave/cpplexer/cpp_lex_token.hpp	/^class lex_token $/;"	c	namespace:boost::wave::cpplexer
boost::wave::cpplexer::lex_token::data	wave/cpplexer/cpp_lex_token.hpp	/^    data_type* data;$/;"	m	class:boost::wave::cpplexer::lex_token	access:private
boost::wave::cpplexer::lex_token::data_type	wave/cpplexer/cpp_lex_token.hpp	/^    typedef impl::token_data<string_type, position_type> data_type;$/;"	t	class:boost::wave::cpplexer::lex_token	access:private
boost::wave::cpplexer::lex_token::get_position	wave/cpplexer/cpp_lex_token.hpp	/^    position_type const &get_position() const { return data->get_position(); }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:() const
boost::wave::cpplexer::lex_token::get_token_id	wave/cpplexer/cpp_lex_token.hpp	/^    static int get_token_id(lex_token const &t) $/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(lex_token const &t)
boost::wave::cpplexer::lex_token::get_token_value	wave/cpplexer/cpp_lex_token.hpp	/^    static string_type get_token_value(lex_token const &t) $/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(lex_token const &t)
boost::wave::cpplexer::lex_token::get_value	wave/cpplexer/cpp_lex_token.hpp	/^    string_type const &get_value() const { return data->get_value(); }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:() const
boost::wave::cpplexer::lex_token::is_eoi	wave/cpplexer/cpp_lex_token.hpp	/^    bool is_eoi() const { return 0 == data || token_id(*data) == T_EOI; }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:() const
boost::wave::cpplexer::lex_token::is_valid	wave/cpplexer/cpp_lex_token.hpp	/^    bool is_valid() const { return 0 != data && token_id(*data) != T_UNKNOWN; }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:() const
boost::wave::cpplexer::lex_token::lex_token	wave/cpplexer/cpp_lex_token.hpp	/^    explicit lex_token(int)$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(int)
boost::wave::cpplexer::lex_token::lex_token	wave/cpplexer/cpp_lex_token.hpp	/^    lex_token()$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:()
boost::wave::cpplexer::lex_token::lex_token	wave/cpplexer/cpp_lex_token.hpp	/^    lex_token(lex_token const& rhs)$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(lex_token const& rhs)
boost::wave::cpplexer::lex_token::lex_token	wave/cpplexer/cpp_lex_token.hpp	/^    lex_token(token_id id_, string_type const &value_, PositionT const &pos_)$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(token_id id_, string_type const &value_, PositionT const &pos_)
boost::wave::cpplexer::lex_token::make_unique	wave/cpplexer/cpp_lex_token.hpp	/^    void make_unique()$/;"	f	class:boost::wave::cpplexer::lex_token	access:private	signature:()
boost::wave::cpplexer::lex_token::operator =	wave/cpplexer/cpp_lex_token.hpp	/^    lex_token& operator=(lex_token const& rhs)$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(lex_token const& rhs)
boost::wave::cpplexer::lex_token::operator ==	wave/cpplexer/cpp_lex_token.hpp	/^    friend bool operator== (lex_token const& lhs, lex_token const& rhs)$/;"	f	class:boost::wave::cpplexer::lex_token	access:friend	signature:(lex_token const& lhs, lex_token const& rhs)
boost::wave::cpplexer::lex_token::operator token_id	wave/cpplexer/cpp_lex_token.hpp	/^    operator token_id() const { return 0 != data ? token_id(*data) : T_EOI; }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:() const
boost::wave::cpplexer::lex_token::position_type	wave/cpplexer/cpp_lex_token.hpp	/^    typedef PositionT               position_type;$/;"	t	class:boost::wave::cpplexer::lex_token	access:public
boost::wave::cpplexer::lex_token::print	wave/cpplexer/cpp_lex_token.hpp	/^    void print (std::ostream &stream) const$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(std::ostream &stream) const
boost::wave::cpplexer::lex_token::serialize	wave/cpplexer/cpp_lex_token.hpp	/^    void serialize(Archive &ar, const unsigned int version)$/;"	f	class:boost::wave::cpplexer::lex_token	access:private	signature:(Archive &ar, const unsigned int version)
boost::wave::cpplexer::lex_token::set_position	wave/cpplexer/cpp_lex_token.hpp	/^    void set_position (position_type const &pos_) { make_unique(); data->set_position(pos_); }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(position_type const &pos_)
boost::wave::cpplexer::lex_token::set_token_id	wave/cpplexer/cpp_lex_token.hpp	/^    void set_token_id (token_id id_) { make_unique(); data->set_token_id(id_); }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(token_id id_)
boost::wave::cpplexer::lex_token::set_value	wave/cpplexer/cpp_lex_token.hpp	/^    void set_value (string_type const &value_) { make_unique(); data->set_value(value_); }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(string_type const &value_)
boost::wave::cpplexer::lex_token::string_type	wave/cpplexer/cpp_lex_token.hpp	/^    typedef BOOST_WAVE_STRINGTYPE   string_type;$/;"	t	class:boost::wave::cpplexer::lex_token	access:public
boost::wave::cpplexer::lex_token::~lex_token	wave/cpplexer/cpp_lex_token.hpp	/^    ~lex_token()$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:()
boost::wave::cpplexer::lexing_exception	wave/cpplexer/cpplexer_exceptions.hpp	/^class BOOST_SYMBOL_VISIBLE lexing_exception :$/;"	c	namespace:boost::wave::cpplexer	inherits:cpplexer_exception
boost::wave::cpplexer::lexing_exception::buffer	wave/cpplexer/cpplexer_exceptions.hpp	/^    char buffer[512];$/;"	m	class:boost::wave::cpplexer::lexing_exception	access:private
boost::wave::cpplexer::lexing_exception::code	wave/cpplexer/cpplexer_exceptions.hpp	/^    error_code code;$/;"	m	class:boost::wave::cpplexer::lexing_exception	access:private
boost::wave::cpplexer::lexing_exception::description	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual char const *description() const throw()$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:() const
boost::wave::cpplexer::lexing_exception::error_code	wave/cpplexer/cpplexer_exceptions.hpp	/^    enum error_code {$/;"	g	class:boost::wave::cpplexer::lexing_exception	access:public
boost::wave::cpplexer::lexing_exception::error_text	wave/cpplexer/cpplexer_exceptions.hpp	/^    static char const *error_text(int code)$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:(int code)
boost::wave::cpplexer::lexing_exception::generic_lexing_error	wave/cpplexer/cpplexer_exceptions.hpp	/^        generic_lexing_error = 5,$/;"	e	enum:boost::wave::cpplexer::lexing_exception::error_code
boost::wave::cpplexer::lexing_exception::generic_lexing_warning	wave/cpplexer/cpplexer_exceptions.hpp	/^        generic_lexing_warning = 6$/;"	e	enum:boost::wave::cpplexer::lexing_exception::error_code
boost::wave::cpplexer::lexing_exception::get_errorcode	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual int get_errorcode() const throw()$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:() const
boost::wave::cpplexer::lexing_exception::get_severity	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual int get_severity() const throw()$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:() const
boost::wave::cpplexer::lexing_exception::invalid_long_long_literal	wave/cpplexer/cpplexer_exceptions.hpp	/^        invalid_long_long_literal = 4,$/;"	e	enum:boost::wave::cpplexer::lexing_exception::error_code
boost::wave::cpplexer::lexing_exception::is_recoverable	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual bool is_recoverable() const throw()$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:() const
boost::wave::cpplexer::lexing_exception::level	wave/cpplexer/cpplexer_exceptions.hpp	/^    util::severity level;$/;"	m	class:boost::wave::cpplexer::lexing_exception	access:private
boost::wave::cpplexer::lexing_exception::lexing_exception	wave/cpplexer/cpplexer_exceptions.hpp	/^    lexing_exception(char const *what_, error_code code, std::size_t line_,$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:(char const *what_, error_code code, std::size_t line_, std::size_t column_, char const *filename_)
boost::wave::cpplexer::lexing_exception::severity_level	wave/cpplexer/cpplexer_exceptions.hpp	/^    static util::severity severity_level(int code)$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:(int code)
boost::wave::cpplexer::lexing_exception::severity_text	wave/cpplexer/cpplexer_exceptions.hpp	/^    static char const *severity_text(int code)$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:(int code)
boost::wave::cpplexer::lexing_exception::unexpected_error	wave/cpplexer/cpplexer_exceptions.hpp	/^        unexpected_error = 0,$/;"	e	enum:boost::wave::cpplexer::lexing_exception::error_code
boost::wave::cpplexer::lexing_exception::universal_char_base_charset	wave/cpplexer/cpplexer_exceptions.hpp	/^        universal_char_base_charset = 2,$/;"	e	enum:boost::wave::cpplexer::lexing_exception::error_code
boost::wave::cpplexer::lexing_exception::universal_char_invalid	wave/cpplexer/cpplexer_exceptions.hpp	/^        universal_char_invalid = 1,$/;"	e	enum:boost::wave::cpplexer::lexing_exception::error_code
boost::wave::cpplexer::lexing_exception::universal_char_not_allowed	wave/cpplexer/cpplexer_exceptions.hpp	/^        universal_char_not_allowed = 3,$/;"	e	enum:boost::wave::cpplexer::lexing_exception::error_code
boost::wave::cpplexer::lexing_exception::what	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual char const *what() const throw()$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:() const
boost::wave::cpplexer::lexing_exception::~lexing_exception	wave/cpplexer/cpplexer_exceptions.hpp	/^    ~lexing_exception() throw() {}$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:()
boost::wave::cpplexer::make_multi_pass	wave/cpplexer/cpp_lex_iterator.hpp	/^struct make_multi_pass$/;"	s	namespace:boost::wave::cpplexer
boost::wave::cpplexer::make_multi_pass::check_policy	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef boost::spirit::iterator_policies::buf_id_check check_policy;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
boost::wave::cpplexer::make_multi_pass::check_policy	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef boost::spirit::iterator_policies::no_check check_policy;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
boost::wave::cpplexer::make_multi_pass::functor_data_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    functor_data_type;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
boost::wave::cpplexer::make_multi_pass::input_policy	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef boost::spirit::iterator_policies::split_functor_input input_policy;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
boost::wave::cpplexer::make_multi_pass::ownership_policy	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef boost::spirit::iterator_policies::ref_counted ownership_policy;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
boost::wave::cpplexer::make_multi_pass::policy_type	wave/cpplexer/cpp_lex_iterator.hpp	/^        policy_type;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
boost::wave::cpplexer::make_multi_pass::result_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef typename FunctorData::result_type result_type;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
boost::wave::cpplexer::make_multi_pass::storage_policy	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef boost::spirit::iterator_policies::split_std_deque storage_policy;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
boost::wave::cpplexer::make_multi_pass::type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef boost::spirit::multi_pass<functor_data_type, policy_type> type;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
boost::wave::cpplexer::new_lexer_gen	wave/cpplexer/cpp_lex_interface_generator.hpp	/^struct BOOST_WAVE_NEW_LEXER_DECL new_lexer_gen$/;"	s	namespace:boost::wave::cpplexer
boost::wave::cpplexer::new_lexer_gen::new_lexer	wave/cpplexer/cpp_lex_interface_generator.hpp	/^    new_lexer(IteratorT const &first, IteratorT const &last, $/;"	p	struct:boost::wave::cpplexer::new_lexer_gen	access:public	signature:(IteratorT const &first, IteratorT const &last, PositionT const &pos, boost::wave::language_support language)
boost::wave::cpplexer::new_lexer_gen::new_lexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^new_lexer_gen<IteratorT, PositionT, TokenT>::new_lexer(IteratorT const &first,$/;"	f	class:boost::wave::cpplexer::new_lexer_gen	signature:(IteratorT const &first, IteratorT const &last, PositionT const &pos, boost::wave::language_support language)
boost::wave::cpplexer::operator <<	wave/cpplexer/cpp_lex_token.hpp	/^operator<< (std::ostream &stream, lex_token<PositionT> const &object)$/;"	f	namespace:boost::wave::cpplexer	signature:(std::ostream &stream, lex_token<PositionT> const &object)
boost::wave::cpplexer::re2clex	wave/cpplexer/re2clex/aq.hpp	/^namespace re2clex {$/;"	n	namespace:boost::wave::cpplexer
boost::wave::cpplexer::re2clex	wave/cpplexer/re2clex/cpp_re.hpp	/^namespace re2clex {$/;"	n	namespace:boost::wave::cpplexer
boost::wave::cpplexer::re2clex	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^namespace re2clex {$/;"	n	namespace:boost::wave::cpplexer
boost::wave::cpplexer::re2clex	wave/cpplexer/re2clex/scanner.hpp	/^namespace re2clex {$/;"	n	namespace:boost::wave::cpplexer
boost::wave::cpplexer::re2clex::ReportErrorProc	wave/cpplexer/re2clex/scanner.hpp	/^typedef int (* ReportErrorProc)(struct Scanner const *, int errorcode,$/;"	t	namespace:boost::wave::cpplexer::re2clex
boost::wave::cpplexer::re2clex::Scanner	wave/cpplexer/re2clex/scanner.hpp	/^typedef struct Scanner {$/;"	s	namespace:boost::wave::cpplexer::re2clex
boost::wave::cpplexer::re2clex::Scanner	wave/cpplexer/re2clex/scanner.hpp	/^} Scanner;$/;"	t	namespace:boost::wave::cpplexer::re2clex	typeref:struct:boost::wave::cpplexer::re2clex::Scanner
boost::wave::cpplexer::re2clex::Scanner::act	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* act;     \/* act position of input buffer *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::act_in_c99_mode	wave/cpplexer/re2clex/scanner.hpp	/^    bool act_in_c99_mode;        \/* lexer works in C99 mode *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::act_in_cpp0x_mode	wave/cpplexer/re2clex/scanner.hpp	/^    bool act_in_cpp0x_mode;      \/* lexer works in C++11 mode *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::bot	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* bot;     \/* beginning of the current buffer *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::column	wave/cpplexer/re2clex/scanner.hpp	/^    std::size_t column;         \/* current token start column position *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::cur	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* cur;     \/* saves the cursor (maybe is redundant with tok?) *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::curr_column	wave/cpplexer/re2clex/scanner.hpp	/^    std::size_t curr_column;    \/* current column position *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::detect_pp_numbers	wave/cpplexer/re2clex/scanner.hpp	/^    bool detect_pp_numbers;      \/* lexer should prefer to detect pp-numbers *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::enable_import_keyword	wave/cpplexer/re2clex/scanner.hpp	/^    bool enable_import_keyword;  \/* recognize import as a keyword *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::enable_ms_extensions	wave/cpplexer/re2clex/scanner.hpp	/^    bool enable_ms_extensions;   \/* enable MS extensions *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::eof	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* eof;     \/* when we read in the last buffer, will point 1 past the$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::eol_offsets	wave/cpplexer/re2clex/scanner.hpp	/^    aq_queue eol_offsets;$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::error_proc	wave/cpplexer/re2clex/scanner.hpp	/^    ReportErrorProc error_proc; \/* must be != 0, this function is called to$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::file_name	wave/cpplexer/re2clex/scanner.hpp	/^    char const *file_name;      \/* name of the lex'ed file *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::first	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* first;   \/* start of input buffer *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::last	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* last;    \/* end (one past last char) of input buffer *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::lim	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* lim;     \/* used for YYLIMIT - points to the end of the buffer *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::line	wave/cpplexer/re2clex/scanner.hpp	/^    std::size_t line;           \/* current line being lex'ed *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::ptr	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* ptr;     \/* used for YYMARKER - saves backtracking info *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::single_line_only	wave/cpplexer/re2clex/scanner.hpp	/^    bool single_line_only;       \/* don't report missing eol's in C++ comments *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::tok	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* tok;     \/* points to the beginning of the current token *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::Scanner::top	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* top;     \/* top of the current buffer *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
boost::wave::cpplexer::re2clex::aq_create	wave/cpplexer/re2clex/aq.hpp	/^BOOST_WAVE_DECL aq_queue aq_create(void);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(void)
boost::wave::cpplexer::re2clex::aq_enqueue	wave/cpplexer/re2clex/aq.hpp	/^int aq_enqueue(aq_queue q, aq_stdelement e);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(aq_queue q, aq_stdelement e)
boost::wave::cpplexer::re2clex::aq_enqueue_front	wave/cpplexer/re2clex/aq.hpp	/^int aq_enqueue_front(aq_queue q, aq_stdelement e);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(aq_queue q, aq_stdelement e)
boost::wave::cpplexer::re2clex::aq_grow	wave/cpplexer/re2clex/aq.hpp	/^int aq_grow(aq_queue q);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(aq_queue q)
boost::wave::cpplexer::re2clex::aq_pop	wave/cpplexer/re2clex/aq.hpp	/^int aq_pop(aq_queue q);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(aq_queue q)
boost::wave::cpplexer::re2clex::aq_queue	wave/cpplexer/re2clex/aq.hpp	/^typedef aq_queuetype* aq_queue;$/;"	t	namespace:boost::wave::cpplexer::re2clex
boost::wave::cpplexer::re2clex::aq_queuetype	wave/cpplexer/re2clex/aq.hpp	/^} aq_queuetype;$/;"	t	namespace:boost::wave::cpplexer::re2clex	typeref:struct:boost::wave::cpplexer::re2clex::tag_aq_queuetype
boost::wave::cpplexer::re2clex::aq_serve	wave/cpplexer/re2clex/aq.hpp	/^int aq_serve(aq_queue q, aq_stdelement *e);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(aq_queue q, aq_stdelement *e)
boost::wave::cpplexer::re2clex::aq_stdelement	wave/cpplexer/re2clex/aq.hpp	/^typedef std::size_t aq_stdelement;$/;"	t	namespace:boost::wave::cpplexer::re2clex
boost::wave::cpplexer::re2clex::aq_terminate	wave/cpplexer/re2clex/aq.hpp	/^BOOST_WAVE_DECL void aq_terminate(aq_queue q);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(aq_queue q)
boost::wave::cpplexer::re2clex::lex_functor	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^class lex_functor$/;"	c	namespace:boost::wave::cpplexer::re2clex	inherits:lex_input_interface_generator
boost::wave::cpplexer::re2clex::lex_functor::get	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    token_type& get(token_type& result) { return re2c_lexer.get(result); }$/;"	f	class:boost::wave::cpplexer::re2clex::lex_functor	access:public	signature:(token_type& result)
boost::wave::cpplexer::re2clex::lex_functor::has_include_guards	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    bool has_include_guards(std::string& guard_name) const$/;"	f	class:boost::wave::cpplexer::re2clex::lex_functor	access:public	signature:(std::string& guard_name) const
boost::wave::cpplexer::re2clex::lex_functor::lex_functor	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    lex_functor(IteratorT const &first, IteratorT const &last,$/;"	f	class:boost::wave::cpplexer::re2clex::lex_functor	access:public	signature:(IteratorT const &first, IteratorT const &last, PositionT const &pos, boost::wave::language_support language)
boost::wave::cpplexer::re2clex::lex_functor::re2c_lexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    lexer<IteratorT, PositionT, TokenT> re2c_lexer;$/;"	m	class:boost::wave::cpplexer::re2clex::lex_functor	access:private
boost::wave::cpplexer::re2clex::lex_functor::set_position	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    void set_position(PositionT const &pos) { re2c_lexer.set_position(pos); }$/;"	f	class:boost::wave::cpplexer::re2clex::lex_functor	access:public	signature:(PositionT const &pos)
boost::wave::cpplexer::re2clex::lex_functor::token_type	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    typedef TokenT token_type;$/;"	t	class:boost::wave::cpplexer::re2clex::lex_functor	access:public
boost::wave::cpplexer::re2clex::lex_functor::~lex_functor	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    virtual ~lex_functor() {}$/;"	f	class:boost::wave::cpplexer::re2clex::lex_functor	access:public	signature:()
boost::wave::cpplexer::re2clex::lexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^class lexer$/;"	c	namespace:boost::wave::cpplexer::re2clex
boost::wave::cpplexer::re2clex::lexer::at_eof	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    bool at_eof;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
boost::wave::cpplexer::re2clex::lexer::cache	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    lexer<IteratorT, PositionT, TokenT>::cache =$/;"	m	class:boost::wave::cpplexer::re2clex::lexer
boost::wave::cpplexer::re2clex::lexer::cache	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    static token_cache<string_type> const cache;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
boost::wave::cpplexer::re2clex::lexer::cache	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    token_cache<string_type> const cache;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
boost::wave::cpplexer::re2clex::lexer::filename	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    string_type filename;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
boost::wave::cpplexer::re2clex::lexer::get	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    token_type& get(token_type&);$/;"	p	class:boost::wave::cpplexer::re2clex::lexer	access:public	signature:(token_type&)
boost::wave::cpplexer::re2clex::lexer::get	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^lexer<IteratorT, PositionT, TokenT>::get(TokenT& result)$/;"	f	class:boost::wave::cpplexer::re2clex::lexer	signature:(TokenT& result)
boost::wave::cpplexer::re2clex::lexer::guards	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    include_guards<token_type> guards;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
boost::wave::cpplexer::re2clex::lexer::has_include_guards	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    bool has_include_guards(std::string& guard_name) const$/;"	f	class:boost::wave::cpplexer::re2clex::lexer	access:public	signature:(std::string& guard_name) const
boost::wave::cpplexer::re2clex::lexer::language	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    boost::wave::language_support language;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
boost::wave::cpplexer::re2clex::lexer::lexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    lexer(IteratorT const &first, IteratorT const &last,$/;"	p	class:boost::wave::cpplexer::re2clex::lexer	access:public	signature:(IteratorT const &first, IteratorT const &last, PositionT const &pos, boost::wave::language_support language_)
boost::wave::cpplexer::re2clex::lexer::lexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^lexer<IteratorT, PositionT, TokenT>::lexer(IteratorT const &first,$/;"	f	class:boost::wave::cpplexer::re2clex::lexer	signature:(IteratorT const &first, IteratorT const &last, PositionT const &pos, boost::wave::language_support language_)
boost::wave::cpplexer::re2clex::lexer::report_error	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    static int report_error(Scanner const* s, int code, char const *, ...);$/;"	p	class:boost::wave::cpplexer::re2clex::lexer	access:public	signature:(Scanner const* s, int code, char const *, ...)
boost::wave::cpplexer::re2clex::lexer::report_error	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^lexer<IteratorT, PositionT, TokenT>::report_error(Scanner const *s, int errcode,$/;"	f	class:boost::wave::cpplexer::re2clex::lexer	signature:(Scanner const *s, int errcode, char const *msg, ...)
boost::wave::cpplexer::re2clex::lexer::scanner	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    Scanner scanner;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
boost::wave::cpplexer::re2clex::lexer::set_position	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    void set_position(PositionT const &pos)$/;"	f	class:boost::wave::cpplexer::re2clex::lexer	access:public	signature:(PositionT const &pos)
boost::wave::cpplexer::re2clex::lexer::string_type	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    typedef typename token_type::string_type  string_type;$/;"	t	class:boost::wave::cpplexer::re2clex::lexer	access:public
boost::wave::cpplexer::re2clex::lexer::tok_names	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    static char const *tok_names[];$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
boost::wave::cpplexer::re2clex::lexer::token_type	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    typedef TokenT token_type;$/;"	t	class:boost::wave::cpplexer::re2clex::lexer	access:public
boost::wave::cpplexer::re2clex::lexer::value	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    string_type value;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
boost::wave::cpplexer::re2clex::lexer::~lexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    ~lexer();$/;"	p	class:boost::wave::cpplexer::re2clex::lexer	access:public	signature:()
boost::wave::cpplexer::re2clex::lexer::~lexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^lexer<IteratorT, PositionT, TokenT>::~lexer()$/;"	f	class:boost::wave::cpplexer::re2clex::lexer	signature:()
boost::wave::cpplexer::re2clex::scan	wave/cpplexer/re2clex/cpp_re.hpp	/^BOOST_WAVE_DECL boost::wave::token_id scan(Scanner *s);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(Scanner *s)
boost::wave::cpplexer::re2clex::tag_aq_queuetype	wave/cpplexer/re2clex/aq.hpp	/^typedef struct tag_aq_queuetype$/;"	s	namespace:boost::wave::cpplexer::re2clex
boost::wave::cpplexer::re2clex::tag_aq_queuetype::head	wave/cpplexer/re2clex/aq.hpp	/^    std::size_t head;$/;"	m	struct:boost::wave::cpplexer::re2clex::tag_aq_queuetype	access:public
boost::wave::cpplexer::re2clex::tag_aq_queuetype::max_size	wave/cpplexer/re2clex/aq.hpp	/^    std::size_t max_size;$/;"	m	struct:boost::wave::cpplexer::re2clex::tag_aq_queuetype	access:public
boost::wave::cpplexer::re2clex::tag_aq_queuetype::queue	wave/cpplexer/re2clex/aq.hpp	/^    aq_stdelement* queue;$/;"	m	struct:boost::wave::cpplexer::re2clex::tag_aq_queuetype	access:public
boost::wave::cpplexer::re2clex::tag_aq_queuetype::size	wave/cpplexer/re2clex/aq.hpp	/^    std::size_t size;$/;"	m	struct:boost::wave::cpplexer::re2clex::tag_aq_queuetype	access:public
boost::wave::cpplexer::re2clex::tag_aq_queuetype::tail	wave/cpplexer/re2clex/aq.hpp	/^    std::size_t tail;$/;"	m	struct:boost::wave::cpplexer::re2clex::tag_aq_queuetype	access:public
boost::wave::cpplexer::re2clex::uchar	wave/cpplexer/re2clex/scanner.hpp	/^typedef unsigned char uchar;$/;"	t	namespace:boost::wave::cpplexer::re2clex
boost::wave::cpplexer::token_cache	wave/cpplexer/token_cache.hpp	/^class token_cache $/;"	c	namespace:boost::wave::cpplexer
boost::wave::cpplexer::token_cache::cache	wave/cpplexer/token_cache.hpp	/^    std::vector<StringT> cache;$/;"	m	class:boost::wave::cpplexer::token_cache	access:private
boost::wave::cpplexer::token_cache::get_token_value	wave/cpplexer/token_cache.hpp	/^    StringT const &get_token_value(token_id id) const$/;"	f	class:boost::wave::cpplexer::token_cache	access:public	signature:(token_id id) const
boost::wave::cpplexer::token_cache::token_cache	wave/cpplexer/token_cache.hpp	/^    token_cache()$/;"	f	class:boost::wave::cpplexer::token_cache	access:public	signature:()
boost::wave::cpplexer::token_is_valid	wave/cpplexer/cpp_lex_token.hpp	/^token_is_valid(lex_token<Position> const& t)$/;"	f	namespace:boost::wave::cpplexer	signature:(lex_token<Position> const& t)
boost::wave::cpplexer::util	wave/cpplexer/cpplexer_exceptions.hpp	/^namespace util {$/;"	n	namespace:boost::wave::cpplexer
boost::wave::cpplexer::util::get_severity	wave/cpplexer/cpplexer_exceptions.hpp	/^    get_severity(severity level)$/;"	f	namespace:boost::wave::cpplexer::util	signature:(severity level)
boost::wave::cpplexer::util::severity	wave/cpplexer/cpplexer_exceptions.hpp	/^    enum severity {$/;"	g	namespace:boost::wave::cpplexer::util
boost::wave::cpplexer::util::severity_error	wave/cpplexer/cpplexer_exceptions.hpp	/^        severity_error,$/;"	e	enum:boost::wave::cpplexer::util::severity
boost::wave::cpplexer::util::severity_fatal	wave/cpplexer/cpplexer_exceptions.hpp	/^        severity_fatal$/;"	e	enum:boost::wave::cpplexer::util::severity
boost::wave::cpplexer::util::severity_remark	wave/cpplexer/cpplexer_exceptions.hpp	/^        severity_remark = 0,$/;"	e	enum:boost::wave::cpplexer::util::severity
boost::wave::cpplexer::util::severity_warning	wave/cpplexer/cpplexer_exceptions.hpp	/^        severity_warning,$/;"	e	enum:boost::wave::cpplexer::util::severity
boost::wave::enable_variadics	wave/language_support.hpp	/^enable_variadics(language_support language, bool enable = true)$/;"	f	namespace:boost::wave	signature:(language_support language, bool enable = true)
boost::wave::get_support_options	wave/language_support.hpp	/^get_support_options(language_support language)$/;"	f	namespace:boost::wave	signature:(language_support language)
boost::wave::get_token_name	wave/token_ids.hpp	/^BOOST_WAVE_STRINGTYPE get_token_name(token_id tokid);$/;"	p	namespace:boost::wave	signature:(token_id tokid)
boost::wave::get_token_value	wave/token_ids.hpp	/^char const *get_token_value(token_id tokid);$/;"	p	namespace:boost::wave	signature:(token_id tokid)
boost::wave::grammars	wave/grammars/cpp_chlit_grammar.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
boost::wave::grammars	wave/grammars/cpp_defined_grammar.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
boost::wave::grammars	wave/grammars/cpp_defined_grammar_gen.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
boost::wave::grammars	wave/grammars/cpp_expression_grammar.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
boost::wave::grammars	wave/grammars/cpp_expression_grammar_gen.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
boost::wave::grammars	wave/grammars/cpp_expression_value.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
boost::wave::grammars	wave/grammars/cpp_grammar.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
boost::wave::grammars	wave/grammars/cpp_grammar_gen.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
boost::wave::grammars	wave/grammars/cpp_intlit_grammar.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
boost::wave::grammars	wave/grammars/cpp_literal_grammar_gen.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
boost::wave::grammars	wave/grammars/cpp_predef_macros_gen.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
boost::wave::grammars	wave/grammars/cpp_predef_macros_grammar.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
boost::wave::grammars	wave/grammars/cpp_value_error.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
boost::wave::grammars::chlit_grammar	wave/grammars/cpp_chlit_grammar.hpp	/^struct chlit_grammar :$/;"	s	namespace:boost::wave::grammars	inherits:boost::spirit::classic::grammar
boost::wave::grammars::chlit_grammar::chlit_grammar	wave/grammars/cpp_chlit_grammar.hpp	/^    chlit_grammar()$/;"	f	struct:boost::wave::grammars::chlit_grammar	access:public	signature:()
boost::wave::grammars::chlit_grammar::chlit_grammar	wave/grammars/cpp_chlit_grammar.hpp	/^    chlit_grammar(chlit_grammar const&);$/;"	p	struct:boost::wave::grammars::chlit_grammar	access:public	signature:(chlit_grammar const&)
boost::wave::grammars::chlit_grammar::definition	wave/grammars/cpp_chlit_grammar.hpp	/^    struct definition$/;"	s	struct:boost::wave::grammars::chlit_grammar	access:public
boost::wave::grammars::chlit_grammar::definition::ch_lit	wave/grammars/cpp_chlit_grammar.hpp	/^        rule_t ch_lit;$/;"	m	struct:boost::wave::grammars::chlit_grammar::definition	access:public
boost::wave::grammars::chlit_grammar::definition::definition	wave/grammars/cpp_chlit_grammar.hpp	/^        definition(chlit_grammar const &self)$/;"	f	struct:boost::wave::grammars::chlit_grammar::definition	access:public	signature:(chlit_grammar const &self)
boost::wave::grammars::chlit_grammar::definition::rule_t	wave/grammars/cpp_chlit_grammar.hpp	/^            rule_t;$/;"	t	struct:boost::wave::grammars::chlit_grammar::definition	access:public
boost::wave::grammars::chlit_grammar::definition::start	wave/grammars/cpp_chlit_grammar.hpp	/^        rule_t const& start() const$/;"	f	struct:boost::wave::grammars::chlit_grammar::definition	access:public	signature:() const
boost::wave::grammars::chlit_grammar::operator =	wave/grammars/cpp_chlit_grammar.hpp	/^    chlit_grammar& operator=(chlit_grammar const&);$/;"	p	struct:boost::wave::grammars::chlit_grammar	access:public	signature:(chlit_grammar const&)
boost::wave::grammars::chlit_grammar::overflow	wave/grammars/cpp_chlit_grammar.hpp	/^    mutable bool overflow;$/;"	m	struct:boost::wave::grammars::chlit_grammar	access:public
boost::wave::grammars::chlit_grammar_gen	wave/grammars/cpp_literal_grammar_gen.hpp	/^struct BOOST_WAVE_DECL chlit_grammar_gen {$/;"	s	namespace:boost::wave::grammars
boost::wave::grammars::chlit_grammar_gen::evaluate	wave/grammars/cpp_chlit_grammar.hpp	/^chlit_grammar_gen<IntegralResult, TokenT>::evaluate(TokenT const &token, value_error &status)$/;"	f	class:boost::wave::grammars::chlit_grammar_gen	signature:(TokenT const &token, value_error &status)
boost::wave::grammars::chlit_grammar_gen::evaluate	wave/grammars/cpp_literal_grammar_gen.hpp	/^    static IntegralResult evaluate(TokenT const &tok, value_error& status);$/;"	p	struct:boost::wave::grammars::chlit_grammar_gen	access:public	signature:(TokenT const &tok, value_error& status)
boost::wave::grammars::closures	wave/grammars/cpp_chlit_grammar.hpp	/^namespace closures {$/;"	n	namespace:boost::wave::grammars
boost::wave::grammars::closures	wave/grammars/cpp_expression_grammar.hpp	/^namespace closures {$/;"	n	namespace:boost::wave::grammars
boost::wave::grammars::closures	wave/grammars/cpp_expression_value.hpp	/^namespace closures {$/;"	n	namespace:boost::wave::grammars
boost::wave::grammars::closures	wave/grammars/cpp_intlit_grammar.hpp	/^namespace closures {$/;"	n	namespace:boost::wave::grammars
boost::wave::grammars::closures::as_bool	wave/grammars/cpp_expression_value.hpp	/^inline bool as_bool(closure_value const& v);$/;"	p	namespace:boost::wave::grammars::closures	signature:(closure_value const& v)
boost::wave::grammars::closures::chlit_closure	wave/grammars/cpp_chlit_grammar.hpp	/^    struct chlit_closure $/;"	s	namespace:boost::wave::grammars::closures	inherits:boost::spirit::classic::closure
boost::wave::grammars::closures::chlit_closure::long_lit	wave/grammars/cpp_chlit_grammar.hpp	/^        member2 long_lit;$/;"	m	struct:boost::wave::grammars::closures::chlit_closure	access:public
boost::wave::grammars::closures::chlit_closure::value	wave/grammars/cpp_chlit_grammar.hpp	/^        member1 value;$/;"	m	struct:boost::wave::grammars::closures::chlit_closure	access:public
boost::wave::grammars::closures::closure_value	wave/grammars/cpp_expression_value.hpp	/^class closure_value {$/;"	c	namespace:boost::wave::grammars::closures
boost::wave::grammars::closures::closure_value::__anon7::b	wave/grammars/cpp_expression_value.hpp	/^        bool b;$/;"	m	union:boost::wave::grammars::closures::closure_value::__anon7	access:public
boost::wave::grammars::closures::closure_value::__anon7::i	wave/grammars/cpp_expression_value.hpp	/^        int_literal_type i;$/;"	m	union:boost::wave::grammars::closures::closure_value::__anon7	access:public
boost::wave::grammars::closures::closure_value::__anon7::ui	wave/grammars/cpp_expression_value.hpp	/^        uint_literal_type ui;$/;"	m	union:boost::wave::grammars::closures::closure_value::__anon7	access:public
boost::wave::grammars::closures::closure_value::as_bool	wave/grammars/cpp_expression_value.hpp	/^    friend bool as_bool(closure_value const& v)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const& v)
boost::wave::grammars::closures::closure_value::as_int	wave/grammars/cpp_expression_value.hpp	/^    friend int_literal_type as_int(closure_value const& v)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const& v)
boost::wave::grammars::closures::closure_value::as_long	wave/grammars/cpp_expression_value.hpp	/^    friend int_literal_type as_long(closure_value const& v) $/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const& v)
boost::wave::grammars::closures::closure_value::as_uint	wave/grammars/cpp_expression_value.hpp	/^    friend uint_literal_type as_uint(closure_value const& v)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const& v)
boost::wave::grammars::closures::closure_value::as_ulong	wave/grammars/cpp_expression_value.hpp	/^    friend uint_literal_type as_ulong(closure_value const& v)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const& v)
boost::wave::grammars::closures::closure_value::closure_value	wave/grammars/cpp_expression_value.hpp	/^    closure_value(value_error valid_ = error_noerror) $/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(value_error valid_ = error_noerror)
boost::wave::grammars::closures::closure_value::closure_value	wave/grammars/cpp_expression_value.hpp	/^    explicit closure_value(bool b, value_error valid_ = error_noerror) $/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(bool b, value_error valid_ = error_noerror)
boost::wave::grammars::closures::closure_value::closure_value	wave/grammars/cpp_expression_value.hpp	/^    explicit closure_value(int i, value_error valid_ = error_noerror) $/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(int i, value_error valid_ = error_noerror)
boost::wave::grammars::closures::closure_value::closure_value	wave/grammars/cpp_expression_value.hpp	/^    explicit closure_value(int_literal_type i, value_error valid_ = error_noerror) $/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(int_literal_type i, value_error valid_ = error_noerror)
boost::wave::grammars::closures::closure_value::closure_value	wave/grammars/cpp_expression_value.hpp	/^    explicit closure_value(uint_literal_type ui, value_error valid_ = error_noerror) $/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(uint_literal_type ui, value_error valid_ = error_noerror)
boost::wave::grammars::closures::closure_value::closure_value	wave/grammars/cpp_expression_value.hpp	/^    explicit closure_value(unsigned int ui, value_error valid_ = error_noerror) $/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(unsigned int ui, value_error valid_ = error_noerror)
boost::wave::grammars::closures::closure_value::get_type	wave/grammars/cpp_expression_value.hpp	/^    value_type get_type() const { return type; }$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:() const
boost::wave::grammars::closures::closure_value::handle_questionmark	wave/grammars/cpp_expression_value.hpp	/^    handle_questionmark(closure_value const &cond, closure_value const &val2)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &cond, closure_value const &val2)
boost::wave::grammars::closures::closure_value::is_bool	wave/grammars/cpp_expression_value.hpp	/^        is_bool = 3$/;"	e	enum:boost::wave::grammars::closures::closure_value::value_type
boost::wave::grammars::closures::closure_value::is_int	wave/grammars/cpp_expression_value.hpp	/^        is_int = 1,$/;"	e	enum:boost::wave::grammars::closures::closure_value::value_type
boost::wave::grammars::closures::closure_value::is_uint	wave/grammars/cpp_expression_value.hpp	/^        is_uint = 2,$/;"	e	enum:boost::wave::grammars::closures::closure_value::value_type
boost::wave::grammars::closures::closure_value::is_valid	wave/grammars/cpp_expression_value.hpp	/^    value_error is_valid() const { return valid; }$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:() const
boost::wave::grammars::closures::closure_value::operator !	wave/grammars/cpp_expression_value.hpp	/^    operator! (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator !=	wave/grammars/cpp_expression_value.hpp	/^    operator!= (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator %=	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator%= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator &	wave/grammars/cpp_expression_value.hpp	/^    operator& (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator &&	wave/grammars/cpp_expression_value.hpp	/^    operator&& (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator *=	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator*= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator +=	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator+= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator -	wave/grammars/cpp_expression_value.hpp	/^    operator- (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator -=	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator-= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator /=	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator\/= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator <	wave/grammars/cpp_expression_value.hpp	/^    operator< (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator <<	wave/grammars/cpp_expression_value.hpp	/^    operator<< (std::ostream &o, closure_value const &val)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(std::ostream &o, closure_value const &val)
boost::wave::grammars::closures::closure_value::operator <<=	wave/grammars/cpp_expression_value.hpp	/^    operator<<= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator <=	wave/grammars/cpp_expression_value.hpp	/^    operator<= (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator =	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator= (bool rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(bool rhs)
boost::wave::grammars::closures::closure_value::operator =	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator =	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator= (int rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(int rhs)
boost::wave::grammars::closures::closure_value::operator =	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator= (int_literal_type rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(int_literal_type rhs)
boost::wave::grammars::closures::closure_value::operator =	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator= (uint_literal_type rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(uint_literal_type rhs)
boost::wave::grammars::closures::closure_value::operator =	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator= (unsigned int rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(unsigned int rhs)
boost::wave::grammars::closures::closure_value::operator ==	wave/grammars/cpp_expression_value.hpp	/^    operator== (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator >	wave/grammars/cpp_expression_value.hpp	/^    operator> (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator >=	wave/grammars/cpp_expression_value.hpp	/^    operator>= (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator >>=	wave/grammars/cpp_expression_value.hpp	/^    operator>>= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator ^	wave/grammars/cpp_expression_value.hpp	/^    operator^ (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator |	wave/grammars/cpp_expression_value.hpp	/^    operator| (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator ||	wave/grammars/cpp_expression_value.hpp	/^    operator|| (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
boost::wave::grammars::closures::closure_value::operator ~	wave/grammars/cpp_expression_value.hpp	/^    operator~ (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &rhs)
boost::wave::grammars::closures::closure_value::type	wave/grammars/cpp_expression_value.hpp	/^    value_type type;$/;"	m	class:boost::wave::grammars::closures::closure_value	access:private
boost::wave::grammars::closures::closure_value::valid	wave/grammars/cpp_expression_value.hpp	/^    value_error valid;$/;"	m	class:boost::wave::grammars::closures::closure_value	access:private
boost::wave::grammars::closures::closure_value::value	wave/grammars/cpp_expression_value.hpp	/^    } value;$/;"	m	class:boost::wave::grammars::closures::closure_value	typeref:union:boost::wave::grammars::closures::closure_value::__anon7	access:private
boost::wave::grammars::closures::closure_value::value_type	wave/grammars/cpp_expression_value.hpp	/^    enum value_type {$/;"	g	class:boost::wave::grammars::closures::closure_value	access:public
boost::wave::grammars::closures::cpp_expr_closure	wave/grammars/cpp_expression_grammar.hpp	/^    struct cpp_expr_closure $/;"	s	namespace:boost::wave::grammars::closures	inherits:boost::spirit::classic::closure
boost::wave::grammars::closures::cpp_expr_closure::val	wave/grammars/cpp_expression_grammar.hpp	/^        member1 val;$/;"	m	struct:boost::wave::grammars::closures::cpp_expr_closure	access:public
boost::wave::grammars::closures::intlit_closure	wave/grammars/cpp_intlit_grammar.hpp	/^    struct intlit_closure $/;"	s	namespace:boost::wave::grammars::closures	inherits:boost::spirit::classic::closure
boost::wave::grammars::closures::intlit_closure::val	wave/grammars/cpp_intlit_grammar.hpp	/^        member1 val;$/;"	m	struct:boost::wave::grammars::closures::intlit_closure	access:public
boost::wave::grammars::cpp_grammar	wave/grammars/cpp_grammar.hpp	/^struct cpp_grammar : $/;"	s	namespace:boost::wave::grammars	inherits:boost::spirit::classic::grammar
boost::wave::grammars::cpp_grammar::cpp_grammar	wave/grammars/cpp_grammar.hpp	/^    cpp_grammar(bool &found_eof_, TokenT &found_directive_, $/;"	f	struct:boost::wave::grammars::cpp_grammar	access:public	signature:(bool &found_eof_, TokenT &found_directive_, ContainerT &found_eoltokens_)
boost::wave::grammars::cpp_grammar::definition	wave/grammars/cpp_grammar.hpp	/^    struct definition$/;"	s	struct:boost::wave::grammars::cpp_grammar	access:public
boost::wave::grammars::cpp_grammar::definition::action_policy_t	wave/grammars/cpp_grammar.hpp	/^        typedef typename ScannerT::action_policy_t action_policy_t;$/;"	t	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::definition	wave/grammars/cpp_grammar.hpp	/^        definition(cpp_grammar const &self) $/;"	f	struct:boost::wave::grammars::cpp_grammar::definition	access:public	signature:(cpp_grammar const &self)
boost::wave::grammars::cpp_grammar::definition::eol_tokens	wave/grammars/cpp_grammar.hpp	/^        rule_type eol_tokens;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::illformed	wave/grammars/cpp_grammar.hpp	/^        rule_type illformed;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::iteration_policy_t	wave/grammars/cpp_grammar.hpp	/^        typedef typename ScannerT::iteration_policy_t iteration_policy_t;$/;"	t	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::macro_definition	wave/grammars/cpp_grammar.hpp	/^        rule_type plain_define, macro_definition, macro_parameters;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::macro_include_file	wave/grammars/cpp_grammar.hpp	/^        rule_type pp_statement, macro_include_file;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::macro_parameters	wave/grammars/cpp_grammar.hpp	/^        rule_type plain_define, macro_definition, macro_parameters;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::match_policy_t	wave/grammars/cpp_grammar.hpp	/^        typedef boost::spirit::classic::match_policy match_policy_t;$/;"	t	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::no_tree_rule_type	wave/grammars/cpp_grammar.hpp	/^            no_tree_rule_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::non_tree_scanner_t	wave/grammars/cpp_grammar.hpp	/^            non_tree_scanner_t;$/;"	t	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::plain_define	wave/grammars/cpp_grammar.hpp	/^        rule_type plain_define, macro_definition, macro_parameters;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::policies_t	wave/grammars/cpp_grammar.hpp	/^            policies_t;$/;"	t	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::pp_statement	wave/grammars/cpp_grammar.hpp	/^        rule_type pp_statement, macro_include_file;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::ppelif	wave/grammars/cpp_grammar.hpp	/^        rule_type ppifdef, ppifndef, ppif, ppelif;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::ppendregion	wave/grammars/cpp_grammar.hpp	/^        rule_type ppendregion;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::pperror	wave/grammars/cpp_grammar.hpp	/^        rule_type pperror;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::ppif	wave/grammars/cpp_grammar.hpp	/^        rule_type ppifdef, ppifndef, ppif, ppelif;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::ppifdef	wave/grammars/cpp_grammar.hpp	/^        rule_type ppifdef, ppifndef, ppif, ppelif;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::ppifndef	wave/grammars/cpp_grammar.hpp	/^        rule_type ppifdef, ppifndef, ppif, ppelif;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::ppline	wave/grammars/cpp_grammar.hpp	/^        rule_type ppline; $/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::pppragma	wave/grammars/cpp_grammar.hpp	/^        rule_type pppragma;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::ppqualifiedname	wave/grammars/cpp_grammar.hpp	/^        rule_type ppqualifiedname;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::ppregion	wave/grammars/cpp_grammar.hpp	/^        rule_type ppregion;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::ppsp	wave/grammars/cpp_grammar.hpp	/^        no_tree_rule_type ppsp;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::ppwarning	wave/grammars/cpp_grammar.hpp	/^        rule_type ppwarning;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::rule_type	wave/grammars/cpp_grammar.hpp	/^            rule_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::definition::start	wave/grammars/cpp_grammar.hpp	/^        rule_type const& start() const$/;"	f	struct:boost::wave::grammars::cpp_grammar::definition	access:public	signature:() const
boost::wave::grammars::cpp_grammar::definition::undefine	wave/grammars/cpp_grammar.hpp	/^        rule_type undefine;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
boost::wave::grammars::cpp_grammar::found_directive	wave/grammars/cpp_grammar.hpp	/^    TokenT &found_directive;$/;"	m	struct:boost::wave::grammars::cpp_grammar	access:public
boost::wave::grammars::cpp_grammar::found_eof	wave/grammars/cpp_grammar.hpp	/^    bool &found_eof;$/;"	m	struct:boost::wave::grammars::cpp_grammar	access:public
boost::wave::grammars::cpp_grammar::found_eoltokens	wave/grammars/cpp_grammar.hpp	/^    ContainerT &found_eoltokens;$/;"	m	struct:boost::wave::grammars::cpp_grammar	access:public
boost::wave::grammars::cpp_grammar::grammar_type	wave/grammars/cpp_grammar.hpp	/^    typedef cpp_grammar<TokenT, ContainerT> grammar_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar	access:public
boost::wave::grammars::cpp_grammar::map_rule_id_to_name	wave/grammars/cpp_grammar.hpp	/^    mutable map_ruleid_to_name map_rule_id_to_name;$/;"	m	struct:boost::wave::grammars::cpp_grammar	access:public
boost::wave::grammars::cpp_grammar::map_ruleid_to_name	wave/grammars/cpp_grammar.hpp	/^    struct map_ruleid_to_name :$/;"	s	struct:boost::wave::grammars::cpp_grammar	inherits:std::map	access:public
boost::wave::grammars::cpp_grammar::map_ruleid_to_name::base_type	wave/grammars/cpp_grammar.hpp	/^        typedef std::map<boost::spirit::classic::parser_id, std::string> base_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar::map_ruleid_to_name	access:public
boost::wave::grammars::cpp_grammar::map_ruleid_to_name::init_rule_id_to_name_map	wave/grammars/cpp_grammar.hpp	/^        void init_rule_id_to_name_map(cpp_grammar const &self)$/;"	f	struct:boost::wave::grammars::cpp_grammar::map_ruleid_to_name	access:public	signature:(cpp_grammar const &self)
boost::wave::grammars::cpp_grammar::position_type	wave/grammars/cpp_grammar.hpp	/^    typedef typename TokenT::position_type  position_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar	access:public
boost::wave::grammars::cpp_grammar::store_found_directive_type	wave/grammars/cpp_grammar.hpp	/^    typedef impl::store_found_directive<TokenT>     store_found_directive_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar	access:public
boost::wave::grammars::cpp_grammar::store_found_eof_type	wave/grammars/cpp_grammar.hpp	/^    typedef impl::store_found_eof           store_found_eof_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar	access:public
boost::wave::grammars::cpp_grammar::store_found_eoltokens_type	wave/grammars/cpp_grammar.hpp	/^    typedef impl::store_found_eoltokens<ContainerT> store_found_eoltokens_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar	access:public
boost::wave::grammars::cpp_grammar_gen	wave/grammars/cpp_grammar_gen.hpp	/^struct BOOST_WAVE_DECL cpp_grammar_gen$/;"	s	namespace:boost::wave::grammars
boost::wave::grammars::cpp_grammar_gen::iterator_type	wave/grammars/cpp_grammar_gen.hpp	/^    typedef LexIteratorT                          iterator_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar_gen	access:public
boost::wave::grammars::cpp_grammar_gen::node_factory_type	wave/grammars/cpp_grammar_gen.hpp	/^        > node_factory_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar_gen	access:public
boost::wave::grammars::cpp_grammar_gen::parse_cpp_grammar	wave/grammars/cpp_grammar.hpp	/^cpp_grammar_gen<LexIteratorT, TokenContainerT>::parse_cpp_grammar ($/;"	f	class:boost::wave::grammars::cpp_grammar_gen	signature:( LexIteratorT const &first, LexIteratorT const &last, position_type const &act_pos, bool &found_eof, token_type &found_directive, token_container_type &found_eoltokens)
boost::wave::grammars::cpp_grammar_gen::parse_cpp_grammar	wave/grammars/cpp_grammar_gen.hpp	/^    parse_cpp_grammar (iterator_type const &first, iterator_type const &last,$/;"	p	struct:boost::wave::grammars::cpp_grammar_gen	access:public	signature:(iterator_type const &first, iterator_type const &last, position_type const &act_pos, bool &found_eof, token_type &found_directive, token_container_type &found_eoltokens)
boost::wave::grammars::cpp_grammar_gen::position_type	wave/grammars/cpp_grammar_gen.hpp	/^    typedef typename token_type::position_type    position_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar_gen	access:public
boost::wave::grammars::cpp_grammar_gen::token_container_type	wave/grammars/cpp_grammar_gen.hpp	/^    typedef TokenContainerT                       token_container_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar_gen	access:public
boost::wave::grammars::cpp_grammar_gen::token_type	wave/grammars/cpp_grammar_gen.hpp	/^    typedef typename LexIteratorT::token_type     token_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar_gen	access:public
boost::wave::grammars::defined_grammar	wave/grammars/cpp_defined_grammar.hpp	/^struct defined_grammar :$/;"	s	namespace:boost::wave::grammars	inherits:boost::spirit::classic::grammar
boost::wave::grammars::defined_grammar::defined_grammar	wave/grammars/cpp_defined_grammar.hpp	/^    defined_grammar(ContainerT &result_seq_)$/;"	f	struct:boost::wave::grammars::defined_grammar	access:public	signature:(ContainerT &result_seq_)
boost::wave::grammars::defined_grammar::definition	wave/grammars/cpp_defined_grammar.hpp	/^    struct definition$/;"	s	struct:boost::wave::grammars::defined_grammar	access:public
boost::wave::grammars::defined_grammar::definition::defined_op	wave/grammars/cpp_defined_grammar.hpp	/^        rule_t defined_op;$/;"	m	struct:boost::wave::grammars::defined_grammar::definition	access:public
boost::wave::grammars::defined_grammar::definition::definition	wave/grammars/cpp_defined_grammar.hpp	/^        definition(defined_grammar const &self)$/;"	f	struct:boost::wave::grammars::defined_grammar::definition	access:public	signature:(defined_grammar const &self)
boost::wave::grammars::defined_grammar::definition::identifier	wave/grammars/cpp_defined_grammar.hpp	/^        rule_t identifier;$/;"	m	struct:boost::wave::grammars::defined_grammar::definition	access:public
boost::wave::grammars::defined_grammar::definition::rule_t	wave/grammars/cpp_defined_grammar.hpp	/^        typedef boost::spirit::classic::rule<ScannerT> rule_t;$/;"	t	struct:boost::wave::grammars::defined_grammar::definition	access:public
boost::wave::grammars::defined_grammar::definition::start	wave/grammars/cpp_defined_grammar.hpp	/^        rule_t const& start() const$/;"	f	struct:boost::wave::grammars::defined_grammar::definition	access:public	signature:() const
boost::wave::grammars::defined_grammar::result_seq	wave/grammars/cpp_defined_grammar.hpp	/^    ContainerT &result_seq;$/;"	m	struct:boost::wave::grammars::defined_grammar	access:public
boost::wave::grammars::defined_grammar_gen	wave/grammars/cpp_defined_grammar_gen.hpp	/^struct BOOST_WAVE_DECL defined_grammar_gen$/;"	s	namespace:boost::wave::grammars
boost::wave::grammars::defined_grammar_gen::iterator1_type	wave/grammars/cpp_defined_grammar_gen.hpp	/^        iterator1_type;$/;"	t	struct:boost::wave::grammars::defined_grammar_gen	access:public
boost::wave::grammars::defined_grammar_gen::iterator2_type	wave/grammars/cpp_defined_grammar_gen.hpp	/^        iterator2_type;$/;"	t	struct:boost::wave::grammars::defined_grammar_gen	access:public
boost::wave::grammars::defined_grammar_gen::parse_operator_defined	wave/grammars/cpp_defined_grammar.hpp	/^defined_grammar_gen<LexIteratorT>::parse_operator_defined ($/;"	f	class:boost::wave::grammars::defined_grammar_gen	signature:( iterator1_type const &first, iterator1_type const &last, token_sequence_type &found_qualified_name)
boost::wave::grammars::defined_grammar_gen::parse_operator_defined	wave/grammars/cpp_defined_grammar.hpp	/^defined_grammar_gen<LexIteratorT>::parse_operator_defined ($/;"	f	class:boost::wave::grammars::defined_grammar_gen	signature:( iterator2_type const &first, iterator2_type const &last, token_sequence_type &found_qualified_name)
boost::wave::grammars::defined_grammar_gen::parse_operator_defined	wave/grammars/cpp_defined_grammar_gen.hpp	/^    parse_operator_defined (iterator1_type const &first, $/;"	p	struct:boost::wave::grammars::defined_grammar_gen	access:public	signature:(iterator1_type const &first, iterator1_type const &last, token_sequence_type &found_qualified_name)
boost::wave::grammars::defined_grammar_gen::parse_operator_defined	wave/grammars/cpp_defined_grammar_gen.hpp	/^    parse_operator_defined (iterator2_type const &first, $/;"	p	struct:boost::wave::grammars::defined_grammar_gen	access:public	signature:(iterator2_type const &first, iterator2_type const &last, token_sequence_type &found_qualified_name)
boost::wave::grammars::defined_grammar_gen::token_sequence_type	wave/grammars/cpp_defined_grammar_gen.hpp	/^        token_sequence_type;$/;"	t	struct:boost::wave::grammars::defined_grammar_gen	access:public
boost::wave::grammars::defined_grammar_gen::token_type	wave/grammars/cpp_defined_grammar_gen.hpp	/^    typedef typename LexIteratorT::token_type token_type;$/;"	t	struct:boost::wave::grammars::defined_grammar_gen	access:public
boost::wave::grammars::error_character_overflow	wave/grammars/cpp_value_error.hpp	/^    error_character_overflow = 0x4$/;"	e	enum:boost::wave::grammars::value_error
boost::wave::grammars::error_division_by_zero	wave/grammars/cpp_value_error.hpp	/^    error_division_by_zero = 0x1,$/;"	e	enum:boost::wave::grammars::value_error
boost::wave::grammars::error_integer_overflow	wave/grammars/cpp_value_error.hpp	/^    error_integer_overflow = 0x2,$/;"	e	enum:boost::wave::grammars::value_error
boost::wave::grammars::error_noerror	wave/grammars/cpp_value_error.hpp	/^    error_noerror = 0x0,$/;"	e	enum:boost::wave::grammars::value_error
boost::wave::grammars::expression_grammar	wave/grammars/cpp_expression_grammar.hpp	/^struct expression_grammar :$/;"	s	namespace:boost::wave::grammars	inherits:boost::spirit::classic::grammar
boost::wave::grammars::expression_grammar::definition	wave/grammars/cpp_expression_grammar.hpp	/^    struct definition$/;"	s	struct:boost::wave::grammars::expression_grammar	access:public
boost::wave::grammars::expression_grammar::definition::add_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t add_exp, multiply_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::add_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t add_exp_nocalc, multiply_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::and_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t inclusive_or_exp, exclusive_or_exp, and_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::and_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t inclusive_or_exp_nocalc, exclusive_or_exp_nocalc, and_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::closure_type	wave/grammars/cpp_expression_grammar.hpp	/^        typedef closures::cpp_expr_closure closure_type;$/;"	t	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::cmp_equality	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t cmp_equality, cmp_relational;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::cmp_equality_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t cmp_equality_nocalc, cmp_relational_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::cmp_relational	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t cmp_equality, cmp_relational;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::cmp_relational_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t cmp_equality_nocalc, cmp_relational_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::const_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t const_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::const_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t const_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::const_exp_subrule	wave/grammars/cpp_expression_grammar.hpp	/^        boost::spirit::classic::subrule<0, closure_type::context_t> const_exp_subrule;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::constant	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t unary_exp, primary_exp, constant;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::constant_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t unary_exp_nocalc, primary_exp_nocalc, constant_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::definition	wave/grammars/cpp_expression_grammar.hpp	/^        definition(expression_grammar const &self)$/;"	f	struct:boost::wave::grammars::expression_grammar::definition	access:public	signature:(expression_grammar const &self)
boost::wave::grammars::expression_grammar::definition::exclusive_or_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t inclusive_or_exp, exclusive_or_exp, and_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::exclusive_or_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t inclusive_or_exp_nocalc, exclusive_or_exp_nocalc, and_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::inclusive_or_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t inclusive_or_exp, exclusive_or_exp, and_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::inclusive_or_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t inclusive_or_exp_nocalc, exclusive_or_exp_nocalc, and_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::logical_and_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t logical_or_exp, logical_and_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::logical_and_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t logical_or_exp_nocalc, logical_and_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::logical_or_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t logical_or_exp, logical_and_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::logical_or_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t logical_or_exp_nocalc, logical_and_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::multiply_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t add_exp, multiply_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::multiply_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t add_exp_nocalc, multiply_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::pp_expression	wave/grammars/cpp_expression_grammar.hpp	/^        simple_rule_t pp_expression;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::primary_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t unary_exp, primary_exp, constant;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::primary_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t unary_exp_nocalc, primary_exp_nocalc, constant_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::rule_t	wave/grammars/cpp_expression_grammar.hpp	/^        typedef boost::spirit::classic::rule<ScannerT, closure_type::context_t> rule_t;$/;"	t	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::shift_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t shift_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::shift_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t shift_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::simple_rule_t	wave/grammars/cpp_expression_grammar.hpp	/^        typedef boost::spirit::classic::rule<ScannerT> simple_rule_t;$/;"	t	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::start	wave/grammars/cpp_expression_grammar.hpp	/^        simple_rule_t const& start() const$/;"	f	struct:boost::wave::grammars::expression_grammar::definition	access:public	signature:() const
boost::wave::grammars::expression_grammar::definition::unary_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t unary_exp, primary_exp, constant;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::definition::unary_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t unary_exp_nocalc, primary_exp_nocalc, constant_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
boost::wave::grammars::expression_grammar::expression_grammar	wave/grammars/cpp_expression_grammar.hpp	/^    expression_grammar()$/;"	f	struct:boost::wave::grammars::expression_grammar	access:public	signature:()
boost::wave::grammars::expression_grammar::expression_grammar	wave/grammars/cpp_expression_grammar.hpp	/^    expression_grammar(expression_grammar const&);$/;"	p	struct:boost::wave::grammars::expression_grammar	access:public	signature:(expression_grammar const&)
boost::wave::grammars::expression_grammar::operator =	wave/grammars/cpp_expression_grammar.hpp	/^    expression_grammar& operator= (expression_grammar const&);$/;"	p	struct:boost::wave::grammars::expression_grammar	access:public	signature:(expression_grammar const&)
boost::wave::grammars::expression_grammar_gen	wave/grammars/cpp_expression_grammar_gen.hpp	/^struct BOOST_WAVE_DECL expression_grammar_gen {$/;"	s	namespace:boost::wave::grammars
boost::wave::grammars::expression_grammar_gen::evaluate	wave/grammars/cpp_expression_grammar.hpp	/^expression_grammar_gen<TokenT>::evaluate($/;"	f	class:boost::wave::grammars::expression_grammar_gen	signature:( typename token_sequence_type::const_iterator const &first, typename token_sequence_type::const_iterator const &last, typename token_type::position_type const &act_pos, bool if_block_status, value_error &status)
boost::wave::grammars::expression_grammar_gen::evaluate	wave/grammars/cpp_expression_grammar_gen.hpp	/^    static bool evaluate($/;"	p	struct:boost::wave::grammars::expression_grammar_gen	access:public	signature:( typename token_sequence_type::const_iterator const &first, typename token_sequence_type::const_iterator const &last, typename token_type::position_type const &tok, bool if_block_status, value_error &status)
boost::wave::grammars::expression_grammar_gen::token_sequence_type	wave/grammars/cpp_expression_grammar_gen.hpp	/^        token_sequence_type;$/;"	t	struct:boost::wave::grammars::expression_grammar_gen	access:public
boost::wave::grammars::expression_grammar_gen::token_type	wave/grammars/cpp_expression_grammar_gen.hpp	/^    typedef TokenT token_type;$/;"	t	struct:boost::wave::grammars::expression_grammar_gen	access:public
boost::wave::grammars::impl	wave/grammars/cpp_chlit_grammar.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::grammars
boost::wave::grammars::impl	wave/grammars/cpp_expression_grammar.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::grammars
boost::wave::grammars::impl	wave/grammars/cpp_grammar.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::grammars
boost::wave::grammars::impl::BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(and, &&);$/;"	p	namespace:boost::wave::grammars::impl	signature:(and, &&)
boost::wave::grammars::impl::BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(bitand, &);$/;"	p	namespace:boost::wave::grammars::impl	signature:(bitand, &)
boost::wave::grammars::impl::BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(bitor, |);$/;"	p	namespace:boost::wave::grammars::impl	signature:(bitor, |)
boost::wave::grammars::impl::BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(bitxor, ^);$/;"	p	namespace:boost::wave::grammars::impl	signature:(bitxor, ^)
boost::wave::grammars::impl::BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(eq, ==);$/;"	p	namespace:boost::wave::grammars::impl	signature:(eq, ==)
boost::wave::grammars::impl::BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(greateq, >=);$/;"	p	namespace:boost::wave::grammars::impl	signature:(greateq, >=)
boost::wave::grammars::impl::BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(greater, >);$/;"	p	namespace:boost::wave::grammars::impl	signature:(greater, >)
boost::wave::grammars::impl::BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(less, <);$/;"	p	namespace:boost::wave::grammars::impl	signature:(less, <)
boost::wave::grammars::impl::BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(lesseq, <=);$/;"	p	namespace:boost::wave::grammars::impl	signature:(lesseq, <=)
boost::wave::grammars::impl::BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(ne, !=);$/;"	p	namespace:boost::wave::grammars::impl	signature:(ne, !=)
boost::wave::grammars::impl::BOOST_WAVE_BINARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_BINARYOP(or, ||);$/;"	p	namespace:boost::wave::grammars::impl	signature:(or, ||)
boost::wave::grammars::impl::BOOST_WAVE_UNARYOP	wave/grammars/cpp_expression_grammar.hpp	/^    BOOST_WAVE_UNARYOP(neg, !);$/;"	p	namespace:boost::wave::grammars::impl	signature:(neg, !)
boost::wave::grammars::impl::compose_character_literal	wave/grammars/cpp_chlit_grammar.hpp	/^    struct compose_character_literal {$/;"	s	namespace:boost::wave::grammars::impl
boost::wave::grammars::impl::compose_character_literal::operator ()	wave/grammars/cpp_chlit_grammar.hpp	/^        operator()(boost::uint32_t& value, bool long_lit, bool& overflow,$/;"	f	struct:boost::wave::grammars::impl::compose_character_literal	access:public	signature:(boost::uint32_t& value, bool long_lit, bool& overflow, boost::uint32_t character) const
boost::wave::grammars::impl::compose_character_literal::result	wave/grammars/cpp_chlit_grammar.hpp	/^        struct result $/;"	s	struct:boost::wave::grammars::impl::compose_character_literal	access:public
boost::wave::grammars::impl::compose_character_literal::result::type	wave/grammars/cpp_chlit_grammar.hpp	/^            typedef void type; $/;"	t	struct:boost::wave::grammars::impl::compose_character_literal::result	access:public
boost::wave::grammars::impl::convert_chlit	wave/grammars/cpp_expression_grammar.hpp	/^    struct convert_chlit {$/;"	s	namespace:boost::wave::grammars::impl
boost::wave::grammars::impl::convert_chlit::operator ()	wave/grammars/cpp_expression_grammar.hpp	/^        operator()(TokenT const &token) const$/;"	f	struct:boost::wave::grammars::impl::convert_chlit	access:public	signature:(TokenT const &token) const
boost::wave::grammars::impl::convert_chlit::result	wave/grammars/cpp_expression_grammar.hpp	/^        struct result { $/;"	s	struct:boost::wave::grammars::impl::convert_chlit	access:public
boost::wave::grammars::impl::convert_chlit::result::type	wave/grammars/cpp_expression_grammar.hpp	/^            typedef boost::wave::grammars::closures::closure_value type; $/;"	t	struct:boost::wave::grammars::impl::convert_chlit::result	access:public
boost::wave::grammars::impl::convert_intlit	wave/grammars/cpp_expression_grammar.hpp	/^    struct convert_intlit {$/;"	s	namespace:boost::wave::grammars::impl
boost::wave::grammars::impl::convert_intlit::operator ()	wave/grammars/cpp_expression_grammar.hpp	/^        operator()(TokenT const &token) const$/;"	f	struct:boost::wave::grammars::impl::convert_intlit	access:public	signature:(TokenT const &token) const
boost::wave::grammars::impl::convert_intlit::result	wave/grammars/cpp_expression_grammar.hpp	/^        struct result { $/;"	s	struct:boost::wave::grammars::impl::convert_intlit	access:public
boost::wave::grammars::impl::convert_intlit::result::type	wave/grammars/cpp_expression_grammar.hpp	/^            typedef boost::wave::grammars::closures::closure_value type; $/;"	t	struct:boost::wave::grammars::impl::convert_intlit::result	access:public
boost::wave::grammars::impl::flush_underlying_parser	wave/grammars/cpp_grammar.hpp	/^    struct flush_underlying_parser$/;"	s	namespace:boost::wave::grammars::impl	inherits:boost::spirit::classic::parser
boost::wave::grammars::impl::flush_underlying_parser::parse	wave/grammars/cpp_grammar.hpp	/^        parse(ScannerT const& scan) const$/;"	f	struct:boost::wave::grammars::impl::flush_underlying_parser	access:public	signature:(ScannerT const& scan) const
boost::wave::grammars::impl::flush_underlying_parser::this_t	wave/grammars/cpp_grammar.hpp	/^        typedef flush_underlying_parser this_t;$/;"	t	struct:boost::wave::grammars::impl::flush_underlying_parser	access:public
boost::wave::grammars::impl::flush_underlying_parser_p	wave/grammars/cpp_grammar.hpp	/^        flush_underlying_parser_p = flush_underlying_parser();$/;"	m	namespace:boost::wave::grammars::impl
boost::wave::grammars::impl::operator_as_bool	wave/grammars/cpp_expression_grammar.hpp	/^    struct operator_as_bool {$/;"	s	namespace:boost::wave::grammars::impl
boost::wave::grammars::impl::operator_as_bool::operator ()	wave/grammars/cpp_expression_grammar.hpp	/^        operator()(ArgT &val) const$/;"	f	struct:boost::wave::grammars::impl::operator_as_bool	access:public	signature:(ArgT &val) const
boost::wave::grammars::impl::operator_as_bool::result	wave/grammars/cpp_expression_grammar.hpp	/^        struct result { $/;"	s	struct:boost::wave::grammars::impl::operator_as_bool	access:public
boost::wave::grammars::impl::operator_as_bool::result::type	wave/grammars/cpp_expression_grammar.hpp	/^            typedef bool type; $/;"	t	struct:boost::wave::grammars::impl::operator_as_bool::result	access:public
boost::wave::grammars::impl::operator_questionmark	wave/grammars/cpp_expression_grammar.hpp	/^    struct operator_questionmark {$/;"	s	namespace:boost::wave::grammars::impl
boost::wave::grammars::impl::operator_questionmark::operator ()	wave/grammars/cpp_expression_grammar.hpp	/^        operator()(CondT const &cond, Arg1T &val1, Arg2T const &val2) const$/;"	f	struct:boost::wave::grammars::impl::operator_questionmark	access:public	signature:(CondT const &cond, Arg1T &val1, Arg2T const &val2) const
boost::wave::grammars::impl::operator_questionmark::result	wave/grammars/cpp_expression_grammar.hpp	/^        struct result { $/;"	s	struct:boost::wave::grammars::impl::operator_questionmark	access:public
boost::wave::grammars::impl::operator_questionmark::result::type	wave/grammars/cpp_expression_grammar.hpp	/^            typedef boost::wave::grammars::closures::closure_value type; $/;"	t	struct:boost::wave::grammars::impl::operator_questionmark::result	access:public
boost::wave::grammars::impl::operator_to_bool	wave/grammars/cpp_expression_grammar.hpp	/^    struct operator_to_bool {$/;"	s	namespace:boost::wave::grammars::impl
boost::wave::grammars::impl::operator_to_bool::operator ()	wave/grammars/cpp_expression_grammar.hpp	/^        operator()(ArgT &val) const$/;"	f	struct:boost::wave::grammars::impl::operator_to_bool	access:public	signature:(ArgT &val) const
boost::wave::grammars::impl::operator_to_bool::result	wave/grammars/cpp_expression_grammar.hpp	/^        struct result { $/;"	s	struct:boost::wave::grammars::impl::operator_to_bool	access:public
boost::wave::grammars::impl::operator_to_bool::result::type	wave/grammars/cpp_expression_grammar.hpp	/^            typedef boost::wave::grammars::closures::closure_value type; $/;"	t	struct:boost::wave::grammars::impl::operator_to_bool::result	access:public
boost::wave::grammars::impl::phoenix::as_bool	wave/grammars/cpp_expression_grammar.hpp	/^    phoenix::function<operator_as_bool> const as_bool;$/;"	m	class:boost::wave::grammars::impl::phoenix
boost::wave::grammars::impl::phoenix::as_chlit	wave/grammars/cpp_expression_grammar.hpp	/^    phoenix::function<convert_chlit> const as_chlit;$/;"	m	class:boost::wave::grammars::impl::phoenix
boost::wave::grammars::impl::phoenix::as_intlit	wave/grammars/cpp_expression_grammar.hpp	/^    phoenix::function<convert_intlit> const as_intlit;$/;"	m	class:boost::wave::grammars::impl::phoenix
boost::wave::grammars::impl::phoenix::compose	wave/grammars/cpp_chlit_grammar.hpp	/^    phoenix::function<compose_character_literal> const compose;$/;"	m	class:boost::wave::grammars::impl::phoenix
boost::wave::grammars::impl::phoenix::questionmark	wave/grammars/cpp_expression_grammar.hpp	/^    phoenix::function<operator_questionmark> const questionmark;$/;"	m	class:boost::wave::grammars::impl::phoenix
boost::wave::grammars::impl::phoenix::to_bool	wave/grammars/cpp_expression_grammar.hpp	/^    phoenix::function<operator_to_bool> const to_bool;$/;"	m	class:boost::wave::grammars::impl::phoenix
boost::wave::grammars::impl::store_found_directive	wave/grammars/cpp_grammar.hpp	/^    struct store_found_directive {$/;"	s	namespace:boost::wave::grammars::impl
boost::wave::grammars::impl::store_found_directive::found_directive	wave/grammars/cpp_grammar.hpp	/^        TokenT &found_directive;$/;"	m	struct:boost::wave::grammars::impl::store_found_directive	access:public
boost::wave::grammars::impl::store_found_directive::operator ()	wave/grammars/cpp_grammar.hpp	/^        void operator()(TokenT const &token) const$/;"	f	struct:boost::wave::grammars::impl::store_found_directive	access:public	signature:(TokenT const &token) const
boost::wave::grammars::impl::store_found_directive::store_found_directive	wave/grammars/cpp_grammar.hpp	/^        store_found_directive(TokenT &found_directive_) $/;"	f	struct:boost::wave::grammars::impl::store_found_directive	access:public	signature:(TokenT &found_directive_)
boost::wave::grammars::impl::store_found_eof	wave/grammars/cpp_grammar.hpp	/^    struct store_found_eof {$/;"	s	namespace:boost::wave::grammars::impl
boost::wave::grammars::impl::store_found_eof::found_eof	wave/grammars/cpp_grammar.hpp	/^        bool &found_eof;$/;"	m	struct:boost::wave::grammars::impl::store_found_eof	access:public
boost::wave::grammars::impl::store_found_eof::operator ()	wave/grammars/cpp_grammar.hpp	/^        void operator()(TokenT const &\/*token*\/) const$/;"	f	struct:boost::wave::grammars::impl::store_found_eof	access:public	signature:(TokenT const & ) const
boost::wave::grammars::impl::store_found_eof::store_found_eof	wave/grammars/cpp_grammar.hpp	/^        store_found_eof(bool &found_eof_) : found_eof(found_eof_) {}$/;"	f	struct:boost::wave::grammars::impl::store_found_eof	access:public	signature:(bool &found_eof_)
boost::wave::grammars::impl::store_found_eoltokens	wave/grammars/cpp_grammar.hpp	/^    struct store_found_eoltokens {$/;"	s	namespace:boost::wave::grammars::impl
boost::wave::grammars::impl::store_found_eoltokens::found_eoltokens	wave/grammars/cpp_grammar.hpp	/^        ContainerT &found_eoltokens;$/;"	m	struct:boost::wave::grammars::impl::store_found_eoltokens	access:public
boost::wave::grammars::impl::store_found_eoltokens::operator ()	wave/grammars/cpp_grammar.hpp	/^        void operator()(IteratorT const &first, IteratorT const& last) const$/;"	f	struct:boost::wave::grammars::impl::store_found_eoltokens	access:public	signature:(IteratorT const &first, IteratorT const& last) const
boost::wave::grammars::impl::store_found_eoltokens::store_found_eoltokens	wave/grammars/cpp_grammar.hpp	/^        store_found_eoltokens(ContainerT &found_eoltokens_) $/;"	f	struct:boost::wave::grammars::impl::store_found_eoltokens	access:public	signature:(ContainerT &found_eoltokens_)
boost::wave::grammars::intlit_grammar	wave/grammars/cpp_intlit_grammar.hpp	/^struct intlit_grammar :$/;"	s	namespace:boost::wave::grammars	inherits:boost::spirit::classic::grammar
boost::wave::grammars::intlit_grammar::definition	wave/grammars/cpp_intlit_grammar.hpp	/^    struct definition$/;"	s	struct:boost::wave::grammars::intlit_grammar	access:public
boost::wave::grammars::intlit_grammar::definition::dec_lit	wave/grammars/cpp_intlit_grammar.hpp	/^        boost::spirit::classic::subrule<3> dec_lit;$/;"	m	struct:boost::wave::grammars::intlit_grammar::definition	access:public
boost::wave::grammars::intlit_grammar::definition::definition	wave/grammars/cpp_intlit_grammar.hpp	/^        definition(intlit_grammar const &self)$/;"	f	struct:boost::wave::grammars::intlit_grammar::definition	access:public	signature:(intlit_grammar const &self)
boost::wave::grammars::intlit_grammar::definition::hex_lit	wave/grammars/cpp_intlit_grammar.hpp	/^        boost::spirit::classic::subrule<2> hex_lit;$/;"	m	struct:boost::wave::grammars::intlit_grammar::definition	access:public
boost::wave::grammars::intlit_grammar::definition::int_lit	wave/grammars/cpp_intlit_grammar.hpp	/^        rule_t int_lit;$/;"	m	struct:boost::wave::grammars::intlit_grammar::definition	access:public
boost::wave::grammars::intlit_grammar::definition::oct_lit	wave/grammars/cpp_intlit_grammar.hpp	/^        boost::spirit::classic::subrule<1> oct_lit;$/;"	m	struct:boost::wave::grammars::intlit_grammar::definition	access:public
boost::wave::grammars::intlit_grammar::definition::rule_t	wave/grammars/cpp_intlit_grammar.hpp	/^        typedef boost::spirit::classic::rule<ScannerT> rule_t;$/;"	t	struct:boost::wave::grammars::intlit_grammar::definition	access:public
boost::wave::grammars::intlit_grammar::definition::start	wave/grammars/cpp_intlit_grammar.hpp	/^        rule_t const& start() const$/;"	f	struct:boost::wave::grammars::intlit_grammar::definition	access:public	signature:() const
boost::wave::grammars::intlit_grammar::definition::sub_int_lit	wave/grammars/cpp_intlit_grammar.hpp	/^        boost::spirit::classic::subrule<0> sub_int_lit;$/;"	m	struct:boost::wave::grammars::intlit_grammar::definition	access:public
boost::wave::grammars::intlit_grammar::intlit_grammar	wave/grammars/cpp_intlit_grammar.hpp	/^    intlit_grammar(bool &is_unsigned_) : is_unsigned(is_unsigned_)$/;"	f	struct:boost::wave::grammars::intlit_grammar	access:public	signature:(bool &is_unsigned_)
boost::wave::grammars::intlit_grammar::is_unsigned	wave/grammars/cpp_intlit_grammar.hpp	/^    bool &is_unsigned;$/;"	m	struct:boost::wave::grammars::intlit_grammar	access:public
boost::wave::grammars::intlit_grammar_gen	wave/grammars/cpp_literal_grammar_gen.hpp	/^struct BOOST_WAVE_DECL intlit_grammar_gen {$/;"	s	namespace:boost::wave::grammars
boost::wave::grammars::intlit_grammar_gen::evaluate	wave/grammars/cpp_intlit_grammar.hpp	/^intlit_grammar_gen<TokenT>::evaluate(TokenT const &token, $/;"	f	class:boost::wave::grammars::intlit_grammar_gen	signature:(TokenT const &token, bool &is_unsigned)
boost::wave::grammars::intlit_grammar_gen::evaluate	wave/grammars/cpp_literal_grammar_gen.hpp	/^    static uint_literal_type evaluate(TokenT const &tok, bool &is_unsigned);$/;"	p	struct:boost::wave::grammars::intlit_grammar_gen	access:public	signature:(TokenT const &tok, bool &is_unsigned)
boost::wave::grammars::parsetree_parse	wave/grammars/cpp_grammar.hpp	/^parsetree_parse(IteratorT const& first_, IteratorT const& last,$/;"	f	namespace:boost::wave::grammars	signature:(IteratorT const& first_, IteratorT const& last, boost::spirit::classic::parser<ParserT> const& p)
boost::wave::grammars::predefined_macros_grammar	wave/grammars/cpp_predef_macros_grammar.hpp	/^struct predefined_macros_grammar : $/;"	s	namespace:boost::wave::grammars	inherits:boost::spirit::classic::grammar
boost::wave::grammars::predefined_macros_grammar::definition	wave/grammars/cpp_predef_macros_grammar.hpp	/^    struct definition$/;"	s	struct:boost::wave::grammars::predefined_macros_grammar	access:public
boost::wave::grammars::predefined_macros_grammar::definition::definition	wave/grammars/cpp_predef_macros_grammar.hpp	/^        definition(predefined_macros_grammar const &\/*self*\/) $/;"	f	struct:boost::wave::grammars::predefined_macros_grammar::definition	access:public	signature:(predefined_macros_grammar const & )
boost::wave::grammars::predefined_macros_grammar::definition::macro_definition	wave/grammars/cpp_predef_macros_grammar.hpp	/^        rule_type plain_define, macro_definition, macro_parameters;$/;"	m	struct:boost::wave::grammars::predefined_macros_grammar::definition	access:public
boost::wave::grammars::predefined_macros_grammar::definition::macro_parameters	wave/grammars/cpp_predef_macros_grammar.hpp	/^        rule_type plain_define, macro_definition, macro_parameters;$/;"	m	struct:boost::wave::grammars::predefined_macros_grammar::definition	access:public
boost::wave::grammars::predefined_macros_grammar::definition::plain_define	wave/grammars/cpp_predef_macros_grammar.hpp	/^        rule_type plain_define, macro_definition, macro_parameters;$/;"	m	struct:boost::wave::grammars::predefined_macros_grammar::definition	access:public
boost::wave::grammars::predefined_macros_grammar::definition::rule_type	wave/grammars/cpp_predef_macros_grammar.hpp	/^            rule_type;$/;"	t	struct:boost::wave::grammars::predefined_macros_grammar::definition	access:public
boost::wave::grammars::predefined_macros_grammar::definition::start	wave/grammars/cpp_predef_macros_grammar.hpp	/^        rule_type const& start() const$/;"	f	struct:boost::wave::grammars::predefined_macros_grammar::definition	access:public	signature:() const
boost::wave::grammars::predefined_macros_grammar::predefined_macros_grammar	wave/grammars/cpp_predef_macros_grammar.hpp	/^    predefined_macros_grammar() $/;"	f	struct:boost::wave::grammars::predefined_macros_grammar	access:public	signature:()
boost::wave::grammars::predefined_macros_grammar_gen	wave/grammars/cpp_predef_macros_gen.hpp	/^struct BOOST_WAVE_DECL predefined_macros_grammar_gen$/;"	s	namespace:boost::wave::grammars
boost::wave::grammars::predefined_macros_grammar_gen::iterator_type	wave/grammars/cpp_predef_macros_gen.hpp	/^    typedef LexIteratorT iterator_type;$/;"	t	struct:boost::wave::grammars::predefined_macros_grammar_gen	access:public
boost::wave::grammars::predefined_macros_grammar_gen::parse_predefined_macro	wave/grammars/cpp_predef_macros_gen.hpp	/^    parse_predefined_macro (iterator_type const &first, iterator_type const &last);$/;"	p	struct:boost::wave::grammars::predefined_macros_grammar_gen	access:public	signature:(iterator_type const &first, iterator_type const &last)
boost::wave::grammars::predefined_macros_grammar_gen::parse_predefined_macro	wave/grammars/cpp_predef_macros_grammar.hpp	/^predefined_macros_grammar_gen<LexIteratorT>::parse_predefined_macro ($/;"	f	class:boost::wave::grammars::predefined_macros_grammar_gen	signature:( LexIteratorT const &first, LexIteratorT const &last)
boost::wave::grammars::value_error	wave/grammars/cpp_value_error.hpp	/^enum value_error {$/;"	g	namespace:boost::wave::grammars
boost::wave::impl	wave/util/cpp_iterator.hpp	/^namespace impl {$/;"	n	namespace:boost::wave
boost::wave::impl	wave/util/transform_iterator.hpp	/^namespace impl {$/;"	n	namespace:boost::wave
boost::wave::impl::get_token_value	wave/util/transform_iterator.hpp	/^    struct get_token_value {$/;"	s	namespace:boost::wave::impl
boost::wave::impl::get_token_value::argument_type	wave/util/transform_iterator.hpp	/^        typedef ParseTreeNodeT const &argument_type;$/;"	t	struct:boost::wave::impl::get_token_value	access:public
boost::wave::impl::get_token_value::result_type	wave/util/transform_iterator.hpp	/^        typedef TokenT const &result_type;$/;"	t	struct:boost::wave::impl::get_token_value	access:public
boost::wave::impl::get_token_value::transform	wave/util/transform_iterator.hpp	/^        transform (argument_type node) $/;"	f	struct:boost::wave::impl::get_token_value	access:public	signature:(argument_type node)
boost::wave::impl::impl	wave/util/cpp_iterator.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::impl
boost::wave::impl::impl::call_found_directive_hook	wave/util/cpp_iterator.hpp	/^    bool call_found_directive_hook(ContextT& ctx,$/;"	f	namespace:boost::wave::impl::impl	signature:(ContextT& ctx, typename ContextT::token_type const& found_directive)
boost::wave::impl::impl::consider_emitting_line_directive	wave/util/cpp_iterator.hpp	/^    bool consider_emitting_line_directive(ContextT const& ctx, token_id id)$/;"	f	namespace:boost::wave::impl::impl	signature:(ContextT const& ctx, token_id id)
boost::wave::impl::impl::next_token_is_pp_directive	wave/util/cpp_iterator.hpp	/^    bool next_token_is_pp_directive(ContextT &ctx, IteratorT &it, IteratorT const &end)$/;"	f	namespace:boost::wave::impl::impl	signature:(ContextT &ctx, IteratorT &it, IteratorT const &end)
boost::wave::impl::impl::pp_is_last_on_line	wave/util/cpp_iterator.hpp	/^    bool pp_is_last_on_line(ContextT &ctx, IteratorT &it, IteratorT const &end,$/;"	f	namespace:boost::wave::impl::impl	signature:(ContextT &ctx, IteratorT &it, IteratorT const &end, bool call_hook = true)
boost::wave::impl::impl::remove_leading_whitespace	wave/util/cpp_iterator.hpp	/^    remove_leading_whitespace(ContextT &ctx, ContainerT& c, bool call_hook = true)$/;"	f	namespace:boost::wave::impl::impl	signature:(ContextT &ctx, ContainerT& c, bool call_hook = true)
boost::wave::impl::impl::retrieve_line_info	wave/util/cpp_iterator.hpp	/^    bool retrieve_line_info (IteratorT first, IteratorT const &last,$/;"	f	namespace:boost::wave::impl::impl	signature:(IteratorT first, IteratorT const &last, unsigned int &line, StringT &file, boost::wave::preprocess_exception::error_code& error)
boost::wave::impl::impl::skip_to_eol	wave/util/cpp_iterator.hpp	/^    bool skip_to_eol(ContextT &ctx, IteratorT &it, IteratorT const &end,$/;"	f	namespace:boost::wave::impl::impl	signature:(ContextT &ctx, IteratorT &it, IteratorT const &end, bool call_hook = true)
boost::wave::impl::impl::trim_whitespace	wave/util/cpp_iterator.hpp	/^    trim_whitespace(StringT const &s)$/;"	f	namespace:boost::wave::impl::impl	signature:(StringT const &s)
boost::wave::impl::make_ref_transform_iterator	wave/util/transform_iterator.hpp	/^    make_ref_transform_iterator($/;"	f	namespace:boost::wave::impl	signature:( IteratorT base, AdaptableUnaryFunctionT const &f)
boost::wave::impl::pp_iterator_functor	wave/util/cpp_iterator.hpp	/^class pp_iterator_functor {$/;"	c	namespace:boost::wave::impl
boost::wave::impl::pp_iterator_functor::act_pos	wave/util/cpp_iterator.hpp	/^    typename result_type::position_type &act_pos;   \/\/ current fileposition (references the macromap)$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::act_token	wave/util/cpp_iterator.hpp	/^    result_type act_token;          \/\/ current token$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::base_iteration_context_type	wave/util/cpp_iterator.hpp	/^        base_iteration_context_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::cpp_grammar_type	wave/util/cpp_iterator.hpp	/^        cpp_grammar_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::ctx	wave/util/cpp_iterator.hpp	/^    ContextT &ctx;              \/\/ context, this iterator is associated with$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::current_token	wave/util/cpp_iterator.hpp	/^    result_type const &current_token() const { return act_token; }$/;"	f	class:boost::wave::impl::pp_iterator_functor	access:public	signature:() const
boost::wave::impl::pp_iterator_functor::dispatch_directive	wave/util/cpp_iterator.hpp	/^    bool dispatch_directive(tree_parse_info_type const &hit,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(tree_parse_info_type const &hit, result_type const& found_directive, token_sequence_type const& found_eoltokens)
boost::wave::impl::pp_iterator_functor::dispatch_directive	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::dispatch_directive($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( tree_parse_info_type const &hit, result_type const& found_directive, token_sequence_type const& found_eoltokens)
boost::wave::impl::pp_iterator_functor::emit_line_directive	wave/util/cpp_iterator.hpp	/^    bool emit_line_directive();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:()
boost::wave::impl::pp_iterator_functor::emit_line_directive	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::emit_line_directive()$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:()
boost::wave::impl::pp_iterator_functor::ensure_is_last_on_line	wave/util/cpp_iterator.hpp	/^    bool ensure_is_last_on_line(IteratorT& it, bool call_hook = true);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(IteratorT& it, bool call_hook = true)
boost::wave::impl::pp_iterator_functor::ensure_is_last_on_line	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::ensure_is_last_on_line(IteratorT& it, bool call_hook)$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(IteratorT& it, bool call_hook)
boost::wave::impl::pp_iterator_functor::eof	wave/util/cpp_iterator.hpp	/^    static result_type const eof;$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:public
boost::wave::impl::pp_iterator_functor::extract_identifier	wave/util/cpp_iterator.hpp	/^    bool extract_identifier(IteratorT &it);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(IteratorT &it)
boost::wave::impl::pp_iterator_functor::extract_identifier	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::extract_identifier(IteratorT &it)$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(IteratorT &it)
boost::wave::impl::pp_iterator_functor::get_next_token	wave/util/cpp_iterator.hpp	/^    result_type const &get_next_token();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:()
boost::wave::impl::pp_iterator_functor::handle_pp_directive	wave/util/cpp_iterator.hpp	/^    bool handle_pp_directive(IteratorT &it);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(IteratorT &it)
boost::wave::impl::pp_iterator_functor::handle_pp_directive	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::handle_pp_directive(IteratorT &it)$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(IteratorT &it)
boost::wave::impl::pp_iterator_functor::interpret_pragma	wave/util/cpp_iterator.hpp	/^    bool interpret_pragma(token_sequence_type const &pragma_body,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(token_sequence_type const &pragma_body, token_sequence_type &result)
boost::wave::impl::pp_iterator_functor::interpret_pragma	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::interpret_pragma($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( token_sequence_type const &pragma_body, token_sequence_type &result)
boost::wave::impl::pp_iterator_functor::iter_ctx	wave/util/cpp_iterator.hpp	/^    boost::shared_ptr<base_iteration_context_type> iter_ctx;$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::iteration_context_type	wave/util/cpp_iterator.hpp	/^    typedef iteration_context<ContextT, lexer_type> iteration_context_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::lexer_type	wave/util/cpp_iterator.hpp	/^    typedef typename ContextT::lexer_type               lexer_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::must_emit_line_directive	wave/util/cpp_iterator.hpp	/^    bool must_emit_line_directive;  \/\/ must emit a line directive$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::node_factory_type	wave/util/cpp_iterator.hpp	/^    typedef typename cpp_grammar_type::node_factory_type node_factory_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::on_define	wave/util/cpp_iterator.hpp	/^    void on_define(parse_node_type const &node);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(parse_node_type const &node)
boost::wave::impl::pp_iterator_functor::on_define	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_define (parse_node_type const &node)$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(parse_node_type const &node)
boost::wave::impl::pp_iterator_functor::on_elif	wave/util/cpp_iterator.hpp	/^    void on_elif(result_type const& found_directive,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(result_type const& found_directive, typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
boost::wave::impl::pp_iterator_functor::on_elif	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_elif($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( result_type const& found_directive, typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
boost::wave::impl::pp_iterator_functor::on_else	wave/util/cpp_iterator.hpp	/^    void on_else();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:()
boost::wave::impl::pp_iterator_functor::on_else	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_else()$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:()
boost::wave::impl::pp_iterator_functor::on_endif	wave/util/cpp_iterator.hpp	/^    void on_endif();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:()
boost::wave::impl::pp_iterator_functor::on_endif	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_endif()$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:()
boost::wave::impl::pp_iterator_functor::on_error	wave/util/cpp_iterator.hpp	/^    void on_error(typename parse_tree_type::const_iterator const &begin,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
boost::wave::impl::pp_iterator_functor::on_error	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_error($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
boost::wave::impl::pp_iterator_functor::on_if	wave/util/cpp_iterator.hpp	/^    void on_if(result_type const& found_directive,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(result_type const& found_directive, typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
boost::wave::impl::pp_iterator_functor::on_if	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_if($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( result_type const& found_directive, typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
boost::wave::impl::pp_iterator_functor::on_ifdef	wave/util/cpp_iterator.hpp	/^    void on_ifdef(result_type const& found_directive, lexer_type const &it);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(result_type const& found_directive, lexer_type const &it)
boost::wave::impl::pp_iterator_functor::on_ifdef	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_ifdef($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( result_type const& found_directive, lexer_type const &it)
boost::wave::impl::pp_iterator_functor::on_ifndef	wave/util/cpp_iterator.hpp	/^    void on_ifndef(result_type const& found_directive, lexer_type const& it);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(result_type const& found_directive, lexer_type const& it)
boost::wave::impl::pp_iterator_functor::on_ifndef	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_ifndef($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( result_type const& found_directive, lexer_type const &it)
boost::wave::impl::pp_iterator_functor::on_illformed	wave/util/cpp_iterator.hpp	/^    void on_illformed(typename result_type::string_type s);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(typename result_type::string_type s)
boost::wave::impl::pp_iterator_functor::on_illformed	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_illformed($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( typename result_type::string_type s)
boost::wave::impl::pp_iterator_functor::on_include	wave/util/cpp_iterator.hpp	/^    void on_include(string_type const &s, bool is_system, bool include_next);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(string_type const &s, bool is_system, bool include_next)
boost::wave::impl::pp_iterator_functor::on_include	wave/util/cpp_iterator.hpp	/^    void on_include(typename parse_tree_type::const_iterator const &begin,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end, bool include_next)
boost::wave::impl::pp_iterator_functor::on_include	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_include (string_type const &s,$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(string_type const &s, bool is_system, bool include_next)
boost::wave::impl::pp_iterator_functor::on_include	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_include($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end, bool include_next)
boost::wave::impl::pp_iterator_functor::on_include_helper	wave/util/cpp_iterator.hpp	/^    bool on_include_helper(char const *t, char const *s, bool is_system,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(char const *t, char const *s, bool is_system, bool include_next)
boost::wave::impl::pp_iterator_functor::on_include_helper	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_include_helper (char const *f, char const *s,$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(char const *f, char const *s, bool is_system, bool include_next)
boost::wave::impl::pp_iterator_functor::on_line	wave/util/cpp_iterator.hpp	/^    void on_line(typename parse_tree_type::const_iterator const &begin,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
boost::wave::impl::pp_iterator_functor::on_line	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_line($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
boost::wave::impl::pp_iterator_functor::on_pragma	wave/util/cpp_iterator.hpp	/^    bool on_pragma(typename parse_tree_type::const_iterator const &begin,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
boost::wave::impl::pp_iterator_functor::on_pragma	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_pragma($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
boost::wave::impl::pp_iterator_functor::on_undefine	wave/util/cpp_iterator.hpp	/^    void on_undefine(lexer_type const &it);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(lexer_type const &it)
boost::wave::impl::pp_iterator_functor::on_undefine	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_undefine (lexer_type const &it)$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(lexer_type const &it)
boost::wave::impl::pp_iterator_functor::on_warning	wave/util/cpp_iterator.hpp	/^    void on_warning(typename parse_tree_type::const_iterator const &begin,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
boost::wave::impl::pp_iterator_functor::on_warning	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_warning($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
boost::wave::impl::pp_iterator_functor::operator ()	wave/util/cpp_iterator.hpp	/^    result_type const &operator()();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:public	signature:()
boost::wave::impl::pp_iterator_functor::parse_node_type	wave/util/cpp_iterator.hpp	/^    typedef typename parse_tree_match_type::node_t       parse_node_type;       \/\/ tree_node<node_val_data<> >$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::parse_node_value_type	wave/util/cpp_iterator.hpp	/^    typedef typename parse_tree_match_type::parse_node_t parse_node_value_type; \/\/ node_val_data<>$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::parse_tree_match_type	wave/util/cpp_iterator.hpp	/^        parse_tree_match_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::parse_tree_type	wave/util/cpp_iterator.hpp	/^    typedef typename parse_tree_match_type::container_t  parse_tree_type;       \/\/ parse_node_type::children_t$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::pending_queue	wave/util/cpp_iterator.hpp	/^    token_sequence_type pending_queue;   \/\/ tokens already preprocessed$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::position_type	wave/util/cpp_iterator.hpp	/^    typedef typename result_type::position_type         position_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::pp_directive	wave/util/cpp_iterator.hpp	/^    bool pp_directive();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:()
boost::wave::impl::pp_iterator_functor::pp_directive	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::pp_directive()$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:()
boost::wave::impl::pp_iterator_functor::pp_iterator_functor	wave/util/cpp_iterator.hpp	/^    pp_iterator_functor(ContextT &ctx_, IteratorT const &first_,$/;"	f	class:boost::wave::impl::pp_iterator_functor	access:public	signature:(ContextT &ctx_, IteratorT const &first_, IteratorT const &last_, typename ContextT::position_type const &pos_)
boost::wave::impl::pp_iterator_functor::pp_iterator_functor::eof	wave/util/cpp_iterator.hpp	/^    pp_iterator_functor<ContextT>::eof;$/;"	m	class:boost::wave::impl::pp_iterator_functor::pp_iterator_functor
boost::wave::impl::pp_iterator_functor::pp_iterator_functor::get_next_token	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::get_next_token()$/;"	f	class:boost::wave::impl::pp_iterator_functor::pp_iterator_functor	signature:()
boost::wave::impl::pp_iterator_functor::pp_iterator_functor::operator ()	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::operator()()$/;"	f	class:boost::wave::impl::pp_iterator_functor::pp_iterator_functor	signature:()
boost::wave::impl::pp_iterator_functor::pp_iterator_functor::pp_token	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::pp_token()$/;"	f	class:boost::wave::impl::pp_iterator_functor::pp_iterator_functor	signature:()
boost::wave::impl::pp_iterator_functor::pp_token	wave/util/cpp_iterator.hpp	/^    result_type const &pp_token();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:()
boost::wave::impl::pp_iterator_functor::replace_undefined_identifiers	wave/util/cpp_iterator.hpp	/^    void replace_undefined_identifiers(token_sequence_type &expanded);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(token_sequence_type &expanded)
boost::wave::impl::pp_iterator_functor::replace_undefined_identifiers	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::replace_undefined_identifiers($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( token_sequence_type &expanded)
boost::wave::impl::pp_iterator_functor::result_type	wave/util/cpp_iterator.hpp	/^    typedef typename ContextT::token_type               result_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:public
boost::wave::impl::pp_iterator_functor::returned_from_include	wave/util/cpp_iterator.hpp	/^    bool returned_from_include();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:()
boost::wave::impl::pp_iterator_functor::returned_from_include	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::returned_from_include()$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:()
boost::wave::impl::pp_iterator_functor::seen_newline	wave/util/cpp_iterator.hpp	/^    bool seen_newline;              \/\/ needed for recognizing begin of line$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::skip_to_eol_with_check	wave/util/cpp_iterator.hpp	/^    bool skip_to_eol_with_check(IteratorT &it, bool call_hook = true);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(IteratorT &it, bool call_hook = true)
boost::wave::impl::pp_iterator_functor::skip_to_eol_with_check	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::skip_to_eol_with_check(IteratorT &it, bool call_hook)$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(IteratorT &it, bool call_hook)
boost::wave::impl::pp_iterator_functor::skipped_newline	wave/util/cpp_iterator.hpp	/^    bool skipped_newline;           \/\/ a newline has been skipped since last one$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::string_type	wave/util/cpp_iterator.hpp	/^    typedef typename result_type::string_type           string_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::token_sequence_type	wave/util/cpp_iterator.hpp	/^    typedef typename ContextT::token_sequence_type      token_sequence_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::tree_parse_info_type	wave/util/cpp_iterator.hpp	/^        tree_parse_info_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::unput_queue	wave/util/cpp_iterator.hpp	/^    token_sequence_type unput_queue;     \/\/ tokens to be preprocessed again$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::pp_iterator_functor::whitespace	wave/util/cpp_iterator.hpp	/^    boost::wave::util::insert_whitespace_detection whitespace;$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
boost::wave::impl::ref_transform_iterator_generator	wave/util/transform_iterator.hpp	/^    class ref_transform_iterator_generator$/;"	c	namespace:boost::wave::impl
boost::wave::impl::ref_transform_iterator_generator::argument_type	wave/util/transform_iterator.hpp	/^        typedef typename AdaptableUnaryFunctionT::argument_type argument_type;$/;"	t	class:boost::wave::impl::ref_transform_iterator_generator	access:private
boost::wave::impl::ref_transform_iterator_generator::return_type	wave/util/transform_iterator.hpp	/^        typedef typename AdaptableUnaryFunctionT::result_type   return_type;$/;"	t	class:boost::wave::impl::ref_transform_iterator_generator	access:private
boost::wave::impl::ref_transform_iterator_generator::type	wave/util/transform_iterator.hpp	/^            type;$/;"	t	class:boost::wave::impl::ref_transform_iterator_generator	access:public
boost::wave::int_literal_type	wave/wave_config.hpp	/^    typedef boost::long_long_type int_literal_type;$/;"	t	namespace:boost::wave
boost::wave::is_pp_token	wave/token_ids.hpp	/^inline bool is_pp_token(TokenT const& tok)$/;"	f	namespace:boost::wave	signature:(TokenT const& tok)
boost::wave::is_pp_token	wave/token_ids.hpp	/^inline bool is_pp_token(boost::wave::token_id id)$/;"	f	namespace:boost::wave	signature:(boost::wave::token_id id)
boost::wave::is_recoverable	wave/cpp_exceptions.hpp	/^is_recoverable(cpp_exception const& e)$/;"	f	namespace:boost::wave	signature:(cpp_exception const& e)
boost::wave::iteration_context	wave/cpp_iteration_context.hpp	/^struct iteration_context$/;"	s	namespace:boost::wave	inherits:base_iteration_context,InputPolicyT::,inner
boost::wave::iteration_context::base_type	wave/cpp_iteration_context.hpp	/^    typedef base_iteration_context<ContextT, IteratorT> base_type;$/;"	t	struct:boost::wave::iteration_context	access:public
boost::wave::iteration_context::iteration_context	wave/cpp_iteration_context.hpp	/^    iteration_context(ContextT& ctx, BOOST_WAVE_STRINGTYPE const &fname,$/;"	f	struct:boost::wave::iteration_context	access:public	signature:(ContextT& ctx, BOOST_WAVE_STRINGTYPE const &fname, position_type const &act_pos, boost::wave::language_support language_, typename base_type::file_type type = base_type::main_file)
boost::wave::iteration_context::iterator_type	wave/cpp_iteration_context.hpp	/^    typedef IteratorT iterator_type;$/;"	t	struct:boost::wave::iteration_context	access:public
boost::wave::iteration_context::position_type	wave/cpp_iteration_context.hpp	/^    typedef typename IteratorT::token_type::position_type position_type;$/;"	t	struct:boost::wave::iteration_context	access:public
boost::wave::iteration_context::self_type	wave/cpp_iteration_context.hpp	/^    typedef iteration_context<ContextT, IteratorT, InputPolicyT> self_type;$/;"	t	struct:boost::wave::iteration_context	access:public
boost::wave::iteration_context_policies	wave/cpp_iteration_context.hpp	/^namespace iteration_context_policies {$/;"	n	namespace:boost::wave
boost::wave::iteration_context_policies::load_file_to_string	wave/cpp_iteration_context.hpp	/^    struct load_file_to_string$/;"	s	namespace:boost::wave::iteration_context_policies
boost::wave::iteration_context_policies::load_file_to_string::inner	wave/cpp_iteration_context.hpp	/^        class inner$/;"	c	struct:boost::wave::iteration_context_policies::load_file_to_string	access:public
boost::wave::iteration_context_policies::load_file_to_string::inner::init_iterators	wave/cpp_iteration_context.hpp	/^            static void init_iterators(IterContextT &iter_ctx,$/;"	f	class:boost::wave::iteration_context_policies::load_file_to_string::inner	access:public	signature:(IterContextT &iter_ctx, PositionT const &act_pos, language_support language)
boost::wave::iteration_context_policies::load_file_to_string::inner::instring	wave/cpp_iteration_context.hpp	/^            std::string instring;$/;"	m	class:boost::wave::iteration_context_policies::load_file_to_string::inner	access:private
boost::wave::language_support	wave/language_support.hpp	/^enum language_support {$/;"	g	namespace:boost::wave
boost::wave::macro_handling_exception	wave/cpp_exceptions.hpp	/^class BOOST_SYMBOL_VISIBLE macro_handling_exception :$/;"	c	namespace:boost::wave	inherits:preprocess_exception
boost::wave::macro_handling_exception::get_related_name	wave/cpp_exceptions.hpp	/^    char const* get_related_name() const throw()$/;"	f	class:boost::wave::macro_handling_exception	access:public	signature:() const
boost::wave::macro_handling_exception::macro_handling_exception	wave/cpp_exceptions.hpp	/^    macro_handling_exception(char const *what_, error_code code, std::size_t line_,$/;"	f	class:boost::wave::macro_handling_exception	access:public	signature:(char const *what_, error_code code, std::size_t line_, std::size_t column_, char const *filename_, char const *macroname)
boost::wave::macro_handling_exception::name	wave/cpp_exceptions.hpp	/^    char name[512];$/;"	m	class:boost::wave::macro_handling_exception	access:private
boost::wave::macro_handling_exception::what	wave/cpp_exceptions.hpp	/^    virtual char const *what() const throw()$/;"	f	class:boost::wave::macro_handling_exception	access:public	signature:() const
boost::wave::macro_handling_exception::~macro_handling_exception	wave/cpp_exceptions.hpp	/^    ~macro_handling_exception() throw() {}$/;"	f	class:boost::wave::macro_handling_exception	access:public	signature:()
boost::wave::need_c99	wave/language_support.hpp	/^need_c99(language_support language)$/;"	f	namespace:boost::wave	signature:(language_support language)
boost::wave::need_cpp	wave/language_support.hpp	/^need_cpp(language_support language)$/;"	f	namespace:boost::wave	signature:(language_support language)
boost::wave::need_cpp0x	wave/language_support.hpp	/^need_cpp0x(language_support language)$/;"	f	namespace:boost::wave	signature:(language_support language)
boost::wave::need_variadics	wave/language_support.hpp	/^need_variadics(language_support language)$/;"	f	namespace:boost::wave	signature:(language_support language)
boost::wave::pp_iterator	wave/util/cpp_iterator.hpp	/^class pp_iterator$/;"	c	namespace:boost::wave	inherits:boost::spirit::classic::multi_pass
boost::wave::pp_iterator::base_type	wave/util/cpp_iterator.hpp	/^        base_type;$/;"	t	class:boost::wave::pp_iterator	access:private
boost::wave::pp_iterator::force_include	wave/util/cpp_iterator.hpp	/^    bool force_include(char const *path_, bool is_last)$/;"	f	class:boost::wave::pp_iterator	access:public	signature:(char const *path_, bool is_last)
boost::wave::pp_iterator::functor_input_type	wave/util/cpp_iterator.hpp	/^    typedef boost::wave::util::functor_input functor_input_type;$/;"	t	class:boost::wave::pp_iterator	access:private
boost::wave::pp_iterator::input_policy_type	wave/util/cpp_iterator.hpp	/^    typedef boost::wave::impl::pp_iterator_functor<ContextT> input_policy_type;$/;"	t	class:boost::wave::pp_iterator	access:public
boost::wave::pp_iterator::pp_iterator	wave/util/cpp_iterator.hpp	/^    pp_iterator()$/;"	f	class:boost::wave::pp_iterator	access:public	signature:()
boost::wave::pp_iterator::pp_iterator	wave/util/cpp_iterator.hpp	/^    pp_iterator(ContextT &ctx, IteratorT const &first, IteratorT const &last,$/;"	f	class:boost::wave::pp_iterator	access:public	signature:(ContextT &ctx, IteratorT const &first, IteratorT const &last, typename ContextT::position_type const &pos)
boost::wave::pp_iterator::self_type	wave/util/cpp_iterator.hpp	/^    typedef pp_iterator<ContextT> self_type;$/;"	t	class:boost::wave::pp_iterator	access:private
boost::wave::preprocess_exception	wave/cpp_exceptions.hpp	/^class BOOST_SYMBOL_VISIBLE preprocess_exception :$/;"	c	namespace:boost::wave	inherits:cpp_exception
boost::wave::preprocess_exception::alreadydefined_name	wave/cpp_exceptions.hpp	/^        alreadydefined_name,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::bad_define_statement	wave/cpp_exceptions.hpp	/^        bad_define_statement,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::bad_define_statement_va_args	wave/cpp_exceptions.hpp	/^        bad_define_statement_va_args,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::bad_include_file	wave/cpp_exceptions.hpp	/^        bad_include_file,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::bad_include_statement	wave/cpp_exceptions.hpp	/^        bad_include_statement,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::bad_line_filename	wave/cpp_exceptions.hpp	/^        bad_line_filename,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::bad_line_number	wave/cpp_exceptions.hpp	/^        bad_line_number,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::bad_line_statement	wave/cpp_exceptions.hpp	/^        bad_line_statement,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::bad_macro_definition	wave/cpp_exceptions.hpp	/^        bad_macro_definition,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::bad_undefine_statement	wave/cpp_exceptions.hpp	/^        bad_undefine_statement,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::buffer	wave/cpp_exceptions.hpp	/^    char buffer[512];$/;"	m	class:boost::wave::preprocess_exception	access:private
boost::wave::preprocess_exception::character_literal_out_of_range	wave/cpp_exceptions.hpp	/^        character_literal_out_of_range,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::code	wave/cpp_exceptions.hpp	/^    error_code code;$/;"	m	class:boost::wave::preprocess_exception	access:private
boost::wave::preprocess_exception::could_not_open_output_file	wave/cpp_exceptions.hpp	/^        could_not_open_output_file,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::description	wave/cpp_exceptions.hpp	/^    virtual char const *description() const throw()$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:() const
boost::wave::preprocess_exception::division_by_zero	wave/cpp_exceptions.hpp	/^        division_by_zero,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::duplicate_parameter_name	wave/cpp_exceptions.hpp	/^        duplicate_parameter_name,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::empty_macroarguments	wave/cpp_exceptions.hpp	/^        empty_macroarguments,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::error_code	wave/cpp_exceptions.hpp	/^    enum error_code {$/;"	g	class:boost::wave::preprocess_exception	access:public
boost::wave::preprocess_exception::error_directive	wave/cpp_exceptions.hpp	/^        error_directive,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::error_text	wave/cpp_exceptions.hpp	/^    static char const *error_text(int code)$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:(int code)
boost::wave::preprocess_exception::get_errorcode	wave/cpp_exceptions.hpp	/^    virtual int get_errorcode() const throw()$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:() const
boost::wave::preprocess_exception::get_related_name	wave/cpp_exceptions.hpp	/^    virtual char const* get_related_name() const throw()$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:() const
boost::wave::preprocess_exception::get_severity	wave/cpp_exceptions.hpp	/^    virtual int get_severity() const throw()$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:() const
boost::wave::preprocess_exception::ill_formed_character_literal	wave/cpp_exceptions.hpp	/^        ill_formed_character_literal,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::ill_formed_directive	wave/cpp_exceptions.hpp	/^        ill_formed_directive,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::ill_formed_expression	wave/cpp_exceptions.hpp	/^        ill_formed_expression,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::ill_formed_integer_literal	wave/cpp_exceptions.hpp	/^        ill_formed_integer_literal,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::ill_formed_operator	wave/cpp_exceptions.hpp	/^        ill_formed_operator,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::ill_formed_pragma_message	wave/cpp_exceptions.hpp	/^        ill_formed_pragma_message,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::ill_formed_pragma_option	wave/cpp_exceptions.hpp	/^        ill_formed_pragma_option,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::illegal_operator_redefinition	wave/cpp_exceptions.hpp	/^        illegal_operator_redefinition,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::illegal_redefinition	wave/cpp_exceptions.hpp	/^        illegal_redefinition,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::improperly_terminated_macro	wave/cpp_exceptions.hpp	/^        improperly_terminated_macro,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::include_nesting_too_deep	wave/cpp_exceptions.hpp	/^        include_nesting_too_deep,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::incompatible_config	wave/cpp_exceptions.hpp	/^        incompatible_config,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::integer_overflow	wave/cpp_exceptions.hpp	/^        integer_overflow,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::invalid_concat	wave/cpp_exceptions.hpp	/^        invalid_concat,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::invalid_macroname	wave/cpp_exceptions.hpp	/^        invalid_macroname,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::is_recoverable	wave/cpp_exceptions.hpp	/^    virtual bool is_recoverable() const throw()$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:() const
boost::wave::preprocess_exception::last_error_number	wave/cpp_exceptions.hpp	/^        last_error_number = pragma_message_directive$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::last_line_not_terminated	wave/cpp_exceptions.hpp	/^        last_line_not_terminated,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::macro_insertion_error	wave/cpp_exceptions.hpp	/^        macro_insertion_error,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::macro_redefinition	wave/cpp_exceptions.hpp	/^        macro_redefinition,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::misplaced_operator	wave/cpp_exceptions.hpp	/^        misplaced_operator,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::missing_matching_endif	wave/cpp_exceptions.hpp	/^        missing_matching_endif,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::missing_matching_if	wave/cpp_exceptions.hpp	/^        missing_matching_if,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::no_error	wave/cpp_exceptions.hpp	/^        no_error = 0,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::pragma_message_directive	wave/cpp_exceptions.hpp	/^        pragma_message_directive,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::preprocess_exception	wave/cpp_exceptions.hpp	/^    preprocess_exception(char const *what_, error_code code, std::size_t line_,$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:(char const *what_, error_code code, std::size_t line_, std::size_t column_, char const *filename_)
boost::wave::preprocess_exception::severity_level	wave/cpp_exceptions.hpp	/^    static util::severity severity_level(int code)$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:(int code)
boost::wave::preprocess_exception::severity_text	wave/cpp_exceptions.hpp	/^    static char const *severity_text(int code)$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:(int code)
boost::wave::preprocess_exception::too_few_macroarguments	wave/cpp_exceptions.hpp	/^        too_few_macroarguments,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::too_many_macroarguments	wave/cpp_exceptions.hpp	/^        too_many_macroarguments,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::unbalanced_if_endif	wave/cpp_exceptions.hpp	/^        unbalanced_if_endif,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::undefined_macroname	wave/cpp_exceptions.hpp	/^        undefined_macroname,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::unexpected_error	wave/cpp_exceptions.hpp	/^        unexpected_error,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::unexpected_qualified_name	wave/cpp_exceptions.hpp	/^        unexpected_qualified_name,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::warning_directive	wave/cpp_exceptions.hpp	/^        warning_directive,$/;"	e	enum:boost::wave::preprocess_exception::error_code
boost::wave::preprocess_exception::what	wave/cpp_exceptions.hpp	/^    virtual char const *what() const throw()$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:() const
boost::wave::preprocess_exception::~preprocess_exception	wave/cpp_exceptions.hpp	/^    ~preprocess_exception() throw() {}$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:()
boost::wave::set_support_options	wave/language_support.hpp	/^set_support_options(language_support language, language_support option)$/;"	f	namespace:boost::wave	signature:(language_support language, language_support option)
boost::wave::support_c99	wave/language_support.hpp	/^    support_c99 = support_option_variadics | support_option_long_long | 0x08,$/;"	e	enum:boost::wave::language_support
boost::wave::support_cpp	wave/language_support.hpp	/^    support_cpp = support_normal,$/;"	e	enum:boost::wave::language_support
boost::wave::support_cpp0x	wave/language_support.hpp	/^    support_cpp0x = support_option_variadics | support_option_long_long | 0x10,$/;"	e	enum:boost::wave::language_support
boost::wave::support_cpp11	wave/language_support.hpp	/^    support_cpp11 = support_cpp0x,$/;"	e	enum:boost::wave::language_support
boost::wave::support_normal	wave/language_support.hpp	/^    support_normal = 0x01,$/;"	e	enum:boost::wave::language_support
boost::wave::support_option_convert_trigraphs	wave/language_support.hpp	/^    support_option_convert_trigraphs = 0x0400,$/;"	e	enum:boost::wave::language_support
boost::wave::support_option_emit_contnewlines	wave/language_support.hpp	/^    support_option_emit_contnewlines = 0x0040,$/;"	e	enum:boost::wave::language_support
boost::wave::support_option_emit_line_directives	wave/language_support.hpp	/^    support_option_emit_line_directives = 0x2000,$/;"	e	enum:boost::wave::language_support
boost::wave::support_option_emit_pragma_directives	wave/language_support.hpp	/^    support_option_emit_pragma_directives = 0x8000$/;"	e	enum:boost::wave::language_support
boost::wave::support_option_include_guard_detection	wave/language_support.hpp	/^    support_option_include_guard_detection = 0x4000,$/;"	e	enum:boost::wave::language_support
boost::wave::support_option_insert_whitespace	wave/language_support.hpp	/^    support_option_insert_whitespace = 0x0080,$/;"	e	enum:boost::wave::language_support
boost::wave::support_option_long_long	wave/language_support.hpp	/^    support_option_long_long = 0x02,$/;"	e	enum:boost::wave::language_support
boost::wave::support_option_mask	wave/language_support.hpp	/^    support_option_mask = 0xFFC0,$/;"	e	enum:boost::wave::language_support
boost::wave::support_option_no_character_validation	wave/language_support.hpp	/^    support_option_no_character_validation = 0x0200,$/;"	e	enum:boost::wave::language_support
boost::wave::support_option_prefer_pp_numbers	wave/language_support.hpp	/^    support_option_prefer_pp_numbers = 0x1000,$/;"	e	enum:boost::wave::language_support
boost::wave::support_option_preserve_comments	wave/language_support.hpp	/^    support_option_preserve_comments = 0x0100,$/;"	e	enum:boost::wave::language_support
boost::wave::support_option_single_line	wave/language_support.hpp	/^    support_option_single_line = 0x0800,$/;"	e	enum:boost::wave::language_support
boost::wave::support_option_variadics	wave/language_support.hpp	/^    support_option_variadics = 0x04,$/;"	e	enum:boost::wave::language_support
boost::wave::test_configuration	wave/wave_config_constant.hpp	/^    BOOST_WAVE_DECL bool test_configuration(unsigned int config, $/;"	p	namespace:boost::wave	signature:(unsigned int config, char const* pragma_keyword, char const* string_type)
boost::wave::this_type	wave/cpp_context.hpp	/^struct this_type {};$/;"	s	namespace:boost::wave
boost::wave::token_category	wave/token_ids.hpp	/^enum token_category {$/;"	g	namespace:boost::wave
boost::wave::token_id	wave/token_ids.hpp	/^enum token_id {$/;"	g	namespace:boost::wave
boost::wave::uint_literal_type	wave/wave_config.hpp	/^    typedef boost::ulong_long_type uint_literal_type;$/;"	t	namespace:boost::wave
boost::wave::util	wave/cpp_exceptions.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/cpp_throw.hpp	/^namespace boost { namespace wave { namespace util$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/cpp_ifblock.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/cpp_include_paths.hpp	/^namespace boost { namespace wave { namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/cpp_iterator.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/cpp_macromap.hpp	/^namespace boost { namespace wave { namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/cpp_macromap_predef.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/cpp_macromap_utils.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/file_position.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/filesystem_compatibility.hpp	/^namespace boost { namespace wave { namespace util$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/flex_string.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/functor_input.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/insert_whitespace_detection.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/interpret_pragma.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/iteration_context.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/macro_definition.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/macro_helpers.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/pattern_parser.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/symbol_table.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/time_conversion_helper.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util	wave/util/unput_queue_iterator.hpp	/^namespace util {$/;"	n	namespace:boost::wave
boost::wave::util::AllocatorStringStorage	wave/util/flex_string.hpp	/^class AllocatorStringStorage : public A$/;"	c	namespace:boost::wave::util	inherits:A
boost::wave::util::AllocatorStringStorage::Alloc	wave/util/flex_string.hpp	/^    void* Alloc(size_type sz, const void* p = 0)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:private	signature:(size_type sz, const void* p = 0)
boost::wave::util::AllocatorStringStorage::AllocatorStringStorage	wave/util/flex_string.hpp	/^    AllocatorStringStorage() $/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:()
boost::wave::util::AllocatorStringStorage::AllocatorStringStorage	wave/util/flex_string.hpp	/^    AllocatorStringStorage(const A& a) : A(a)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(const A& a)
boost::wave::util::AllocatorStringStorage::AllocatorStringStorage	wave/util/flex_string.hpp	/^    AllocatorStringStorage(const AllocatorStringStorage& rhs) $/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(const AllocatorStringStorage& rhs)
boost::wave::util::AllocatorStringStorage::AllocatorStringStorage	wave/util/flex_string.hpp	/^    AllocatorStringStorage(const AllocatorStringStorage& s, $/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(const AllocatorStringStorage& s, flex_string_details::Shallow)
boost::wave::util::AllocatorStringStorage::AllocatorStringStorage	wave/util/flex_string.hpp	/^    AllocatorStringStorage(const E* s, size_type len, const A& a)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(const E* s, size_type len, const A& a)
boost::wave::util::AllocatorStringStorage::AllocatorStringStorage	wave/util/flex_string.hpp	/^    AllocatorStringStorage(size_type len, E c, const A& a)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(size_type len, E c, const A& a)
boost::wave::util::AllocatorStringStorage::Data	wave/util/flex_string.hpp	/^    typedef typename SimpleStringStorage<E, A>::Data Data;$/;"	t	class:boost::wave::util::AllocatorStringStorage	access:private
boost::wave::util::AllocatorStringStorage::Free	wave/util/flex_string.hpp	/^    void Free(void* p, size_type sz)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:private	signature:(void* p, size_type sz)
boost::wave::util::AllocatorStringStorage::Init	wave/util/flex_string.hpp	/^    void Init(size_type size, size_type cap)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:private	signature:(size_type size, size_type cap)
boost::wave::util::AllocatorStringStorage::Realloc	wave/util/flex_string.hpp	/^    void* Realloc(void* p, size_type oldSz, size_type newSz)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:private	signature:(void* p, size_type oldSz, size_type newSz)
boost::wave::util::AllocatorStringStorage::allocator_type	wave/util/flex_string.hpp	/^    typedef A allocator_type;$/;"	t	class:boost::wave::util::AllocatorStringStorage	access:public
boost::wave::util::AllocatorStringStorage::append	wave/util/flex_string.hpp	/^    void append(ForwardIterator b, ForwardIterator e)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(ForwardIterator b, ForwardIterator e)
boost::wave::util::AllocatorStringStorage::begin	wave/util/flex_string.hpp	/^    const_iterator begin() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
boost::wave::util::AllocatorStringStorage::begin	wave/util/flex_string.hpp	/^    iterator begin()$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:()
boost::wave::util::AllocatorStringStorage::c_str	wave/util/flex_string.hpp	/^    const E* c_str() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
boost::wave::util::AllocatorStringStorage::capacity	wave/util/flex_string.hpp	/^    size_type capacity() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
boost::wave::util::AllocatorStringStorage::const_iterator	wave/util/flex_string.hpp	/^    typedef const E* const_iterator;$/;"	t	class:boost::wave::util::AllocatorStringStorage	access:public
boost::wave::util::AllocatorStringStorage::data	wave/util/flex_string.hpp	/^    const E* data() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
boost::wave::util::AllocatorStringStorage::end	wave/util/flex_string.hpp	/^    const_iterator end() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
boost::wave::util::AllocatorStringStorage::end	wave/util/flex_string.hpp	/^    iterator end()$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:()
boost::wave::util::AllocatorStringStorage::get_allocator	wave/util/flex_string.hpp	/^    A get_allocator() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
boost::wave::util::AllocatorStringStorage::iterator	wave/util/flex_string.hpp	/^    typedef E* iterator;$/;"	t	class:boost::wave::util::AllocatorStringStorage	access:public
boost::wave::util::AllocatorStringStorage::max_size	wave/util/flex_string.hpp	/^    size_type max_size() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
boost::wave::util::AllocatorStringStorage::operator =	wave/util/flex_string.hpp	/^    AllocatorStringStorage& operator=(const AllocatorStringStorage& rhs)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(const AllocatorStringStorage& rhs)
boost::wave::util::AllocatorStringStorage::pData_	wave/util/flex_string.hpp	/^    Data* pData_;$/;"	m	class:boost::wave::util::AllocatorStringStorage	access:private
boost::wave::util::AllocatorStringStorage::reserve	wave/util/flex_string.hpp	/^    void reserve(size_type res_arg)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(size_type res_arg)
boost::wave::util::AllocatorStringStorage::resize	wave/util/flex_string.hpp	/^    void resize(size_type n, E c)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(size_type n, E c)
boost::wave::util::AllocatorStringStorage::size	wave/util/flex_string.hpp	/^    size_type size() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
boost::wave::util::AllocatorStringStorage::size_type	wave/util/flex_string.hpp	/^    typedef typename A::size_type size_type;$/;"	t	class:boost::wave::util::AllocatorStringStorage	access:private
boost::wave::util::AllocatorStringStorage::swap	wave/util/flex_string.hpp	/^    void swap(AllocatorStringStorage& rhs)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(AllocatorStringStorage& rhs)
boost::wave::util::AllocatorStringStorage::value_type	wave/util/flex_string.hpp	/^    typedef E value_type;$/;"	t	class:boost::wave::util::AllocatorStringStorage	access:public
boost::wave::util::AllocatorStringStorage::~AllocatorStringStorage	wave/util/flex_string.hpp	/^    ~AllocatorStringStorage()$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:()
boost::wave::util::ContextT::macromap::expand_tokensequence	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::expand_tokensequence(IteratorT &first,$/;"	f	class:boost::wave::util::ContextT::macromap	signature:(IteratorT &first, IteratorT const &last, ContainerT &pending, ContainerT &expanded, bool& seen_newline, bool expand_operator_defined)
boost::wave::util::ContextT::macromap::expand_tokensequence_worker	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::expand_tokensequence_worker($/;"	f	class:boost::wave::util::ContextT::macromap	signature:( ContainerT &pending, unput_queue_iterator<IteratorT, token_type, ContainerT> &first, unput_queue_iterator<IteratorT, token_type, ContainerT> const &last, bool& seen_newline, bool expand_operator_defined)
boost::wave::util::ContextT::macromap::resolve_defined	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::resolve_defined(IteratorT &first,$/;"	f	class:boost::wave::util::ContextT::macromap	signature:(IteratorT &first, IteratorT const &last, ContainerT &pending)
boost::wave::util::CowString	wave/util/flex_string.hpp	/^class CowString$/;"	c	namespace:boost::wave::util
boost::wave::util::CowString::CowString	wave/util/flex_string.hpp	/^    CowString(const CowString& s)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(const CowString& s)
boost::wave::util::CowString::CowString	wave/util/flex_string.hpp	/^    CowString(const E* s, size_type len, const allocator_type& a)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(const E* s, size_type len, const allocator_type& a)
boost::wave::util::CowString::CowString	wave/util/flex_string.hpp	/^    CowString(const allocator_type& a)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(const allocator_type& a)
boost::wave::util::CowString::CowString	wave/util/flex_string.hpp	/^    CowString(size_type len, E c, const allocator_type& a)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(size_type len, E c, const allocator_type& a)
boost::wave::util::CowString::Data	wave/util/flex_string.hpp	/^    Storage& Data() const$/;"	f	class:boost::wave::util::CowString	access:private	signature:() const
boost::wave::util::CowString::E	wave/util/flex_string.hpp	/^    typedef typename Storage::value_type E;$/;"	t	class:boost::wave::util::CowString	access:private
boost::wave::util::CowString::GetRefs	wave/util/flex_string.hpp	/^    RefCountType GetRefs() const$/;"	f	class:boost::wave::util::CowString	access:private	signature:() const
boost::wave::util::CowString::MakeUnique	wave/util/flex_string.hpp	/^    void MakeUnique() const$/;"	f	class:boost::wave::util::CowString	access:private	signature:() const
boost::wave::util::CowString::RefCountType	wave/util/flex_string.hpp	/^    typedef typename flex_string_details::get_unsigned<E>::result RefCountType;$/;"	t	class:boost::wave::util::CowString	access:private
boost::wave::util::CowString::Refs	wave/util/flex_string.hpp	/^    RefCountType& Refs()$/;"	f	class:boost::wave::util::CowString	access:private	signature:()
boost::wave::util::CowString::__anon6::align_	wave/util/flex_string.hpp	/^        Align align_;$/;"	m	union:boost::wave::util::CowString::__anon6	access:public
boost::wave::util::CowString::__anon6::buf_	wave/util/flex_string.hpp	/^        mutable char buf_[sizeof(Storage)];$/;"	m	union:boost::wave::util::CowString::__anon6	access:public
boost::wave::util::CowString::allocator_type	wave/util/flex_string.hpp	/^    typedef typename Storage::allocator_type allocator_type;$/;"	t	class:boost::wave::util::CowString	access:public
boost::wave::util::CowString::append	wave/util/flex_string.hpp	/^    void append(FwdIterator b, FwdIterator e)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(FwdIterator b, FwdIterator e)
boost::wave::util::CowString::begin	wave/util/flex_string.hpp	/^    const_iterator begin() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
boost::wave::util::CowString::begin	wave/util/flex_string.hpp	/^    iterator begin()$/;"	f	class:boost::wave::util::CowString	access:public	signature:()
boost::wave::util::CowString::c_str	wave/util/flex_string.hpp	/^    const E* c_str() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
boost::wave::util::CowString::capacity	wave/util/flex_string.hpp	/^    size_type capacity() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
boost::wave::util::CowString::const_iterator	wave/util/flex_string.hpp	/^    typedef typename Storage::const_iterator const_iterator;$/;"	t	class:boost::wave::util::CowString	access:public
boost::wave::util::CowString::data	wave/util/flex_string.hpp	/^    const E* data() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
boost::wave::util::CowString::end	wave/util/flex_string.hpp	/^    const_iterator end() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
boost::wave::util::CowString::end	wave/util/flex_string.hpp	/^    iterator end()$/;"	f	class:boost::wave::util::CowString	access:public	signature:()
boost::wave::util::CowString::get_allocator	wave/util/flex_string.hpp	/^    allocator_type get_allocator() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
boost::wave::util::CowString::iterator	wave/util/flex_string.hpp	/^    typedef typename Storage::iterator iterator;$/;"	t	class:boost::wave::util::CowString	access:public
boost::wave::util::CowString::max_size	wave/util/flex_string.hpp	/^    size_type max_size() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
boost::wave::util::CowString::operator =	wave/util/flex_string.hpp	/^    CowString& operator=(const CowString& rhs)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(const CowString& rhs)
boost::wave::util::CowString::reference	wave/util/flex_string.hpp	/^    typedef typename Storage::reference reference;$/;"	t	class:boost::wave::util::CowString	access:public
boost::wave::util::CowString::reserve	wave/util/flex_string.hpp	/^    void reserve(size_type res_arg)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(size_type res_arg)
boost::wave::util::CowString::resize	wave/util/flex_string.hpp	/^    void resize(size_type n, E c)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(size_type n, E c)
boost::wave::util::CowString::size	wave/util/flex_string.hpp	/^    size_type size() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
boost::wave::util::CowString::size_type	wave/util/flex_string.hpp	/^    typedef typename allocator_type::size_type size_type;$/;"	t	class:boost::wave::util::CowString	access:public
boost::wave::util::CowString::swap	wave/util/flex_string.hpp	/^    void swap(CowString& rhs)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(CowString& rhs)
boost::wave::util::CowString::value_type	wave/util/flex_string.hpp	/^    typedef E value_type;$/;"	t	class:boost::wave::util::CowString	access:public
boost::wave::util::CowString::~CowString	wave/util/flex_string.hpp	/^    ~CowString()$/;"	f	class:boost::wave::util::CowString	access:public	signature:()
boost::wave::util::Reallocate	wave/util/flex_string.hpp	/^typename Allocator::pointer Reallocate($/;"	f	namespace:boost::wave::util	signature:( Allocator& alloc, typename Allocator::pointer p, typename Allocator::size_type oldObjCount, typename Allocator::size_type newObjCount, mallocator<void>*)
boost::wave::util::Reallocate	wave/util/flex_string.hpp	/^typename Allocator::pointer Reallocate($/;"	f	namespace:boost::wave::util	signature:( Allocator& alloc, typename Allocator::pointer p, typename Allocator::size_type oldObjCount, typename Allocator::size_type newObjCount, void*)
boost::wave::util::SimpleStringStorage	wave/util/flex_string.hpp	/^class SimpleStringStorage$/;"	c	namespace:boost::wave::util
boost::wave::util::SimpleStringStorage::Data	wave/util/flex_string.hpp	/^    struct Data$/;"	s	class:boost::wave::util::SimpleStringStorage	access:public
boost::wave::util::SimpleStringStorage::Data::Data	wave/util/flex_string.hpp	/^        Data() : pEnd_(buffer_), pEndOfMem_(buffer_) { buffer_[0] = E(0); }$/;"	f	struct:boost::wave::util::SimpleStringStorage::Data	access:public	signature:()
boost::wave::util::SimpleStringStorage::Data::buffer_	wave/util/flex_string.hpp	/^        E buffer_[1];$/;"	m	struct:boost::wave::util::SimpleStringStorage::Data	access:public
boost::wave::util::SimpleStringStorage::Data::pEndOfMem_	wave/util/flex_string.hpp	/^        E* pEndOfMem_;$/;"	m	struct:boost::wave::util::SimpleStringStorage::Data	access:public
boost::wave::util::SimpleStringStorage::Data::pEnd_	wave/util/flex_string.hpp	/^        E* pEnd_;$/;"	m	struct:boost::wave::util::SimpleStringStorage::Data	access:public
boost::wave::util::SimpleStringStorage::Init	wave/util/flex_string.hpp	/^    void Init(size_type size, size_type capacity)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:private	signature:(size_type size, size_type capacity)
boost::wave::util::SimpleStringStorage::SimpleStringStorage	wave/util/flex_string.hpp	/^    SimpleStringStorage()$/;"	f	class:boost::wave::util::SimpleStringStorage	access:private	signature:()
boost::wave::util::SimpleStringStorage::SimpleStringStorage	wave/util/flex_string.hpp	/^    SimpleStringStorage(const A&)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(const A&)
boost::wave::util::SimpleStringStorage::SimpleStringStorage	wave/util/flex_string.hpp	/^    SimpleStringStorage(const E* s, size_type len, const A&)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(const E* s, size_type len, const A&)
boost::wave::util::SimpleStringStorage::SimpleStringStorage	wave/util/flex_string.hpp	/^    SimpleStringStorage(const SimpleStringStorage& rhs) $/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(const SimpleStringStorage& rhs)
boost::wave::util::SimpleStringStorage::SimpleStringStorage	wave/util/flex_string.hpp	/^    SimpleStringStorage(const SimpleStringStorage& s, $/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(const SimpleStringStorage& s, flex_string_details::Shallow)
boost::wave::util::SimpleStringStorage::SimpleStringStorage	wave/util/flex_string.hpp	/^    SimpleStringStorage(size_type len, E c, const A&)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(size_type len, E c, const A&)
boost::wave::util::SimpleStringStorage::allocator_type	wave/util/flex_string.hpp	/^    typedef A allocator_type;$/;"	t	class:boost::wave::util::SimpleStringStorage	access:public
boost::wave::util::SimpleStringStorage::append	wave/util/flex_string.hpp	/^    void append(InputIterator b, InputIterator e)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(InputIterator b, InputIterator e)
boost::wave::util::SimpleStringStorage::append	wave/util/flex_string.hpp	/^    void append(const E* s, size_type sz)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(const E* s, size_type sz)
boost::wave::util::SimpleStringStorage::begin	wave/util/flex_string.hpp	/^    const_iterator begin() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
boost::wave::util::SimpleStringStorage::begin	wave/util/flex_string.hpp	/^    iterator begin()$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:()
boost::wave::util::SimpleStringStorage::c_str	wave/util/flex_string.hpp	/^    const E* c_str() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
boost::wave::util::SimpleStringStorage::capacity	wave/util/flex_string.hpp	/^    size_type capacity() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
boost::wave::util::SimpleStringStorage::const_iterator	wave/util/flex_string.hpp	/^    typedef const E* const_iterator;$/;"	t	class:boost::wave::util::SimpleStringStorage	access:public
boost::wave::util::SimpleStringStorage::data	wave/util/flex_string.hpp	/^    const E* data() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
boost::wave::util::SimpleStringStorage::emptyString_	wave/util/flex_string.hpp	/^    static const Data emptyString_;$/;"	m	class:boost::wave::util::SimpleStringStorage	access:public
boost::wave::util::SimpleStringStorage::emptyString_	wave/util/flex_string.hpp	/^SimpleStringStorage<E, A>::emptyString_ = $/;"	m	class:boost::wave::util::SimpleStringStorage
boost::wave::util::SimpleStringStorage::end	wave/util/flex_string.hpp	/^    const_iterator end() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
boost::wave::util::SimpleStringStorage::end	wave/util/flex_string.hpp	/^    iterator end()$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:()
boost::wave::util::SimpleStringStorage::get_allocator	wave/util/flex_string.hpp	/^    A get_allocator() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
boost::wave::util::SimpleStringStorage::iterator	wave/util/flex_string.hpp	/^    typedef E* iterator;$/;"	t	class:boost::wave::util::SimpleStringStorage	access:public
boost::wave::util::SimpleStringStorage::max_size	wave/util/flex_string.hpp	/^    size_type max_size() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
boost::wave::util::SimpleStringStorage::operator =	wave/util/flex_string.hpp	/^    SimpleStringStorage& operator=(const SimpleStringStorage& rhs)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(const SimpleStringStorage& rhs)
boost::wave::util::SimpleStringStorage::pData_	wave/util/flex_string.hpp	/^    Data* pData_;$/;"	m	class:boost::wave::util::SimpleStringStorage	access:private
boost::wave::util::SimpleStringStorage::reserve	wave/util/flex_string.hpp	/^    void reserve(size_type res_arg)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(size_type res_arg)
boost::wave::util::SimpleStringStorage::resize	wave/util/flex_string.hpp	/^    void resize(size_type newSize, E fill)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(size_type newSize, E fill)
boost::wave::util::SimpleStringStorage::size	wave/util/flex_string.hpp	/^    size_type size() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
boost::wave::util::SimpleStringStorage::size_type	wave/util/flex_string.hpp	/^    typedef typename A::size_type size_type;$/;"	t	class:boost::wave::util::SimpleStringStorage	access:public
boost::wave::util::SimpleStringStorage::swap	wave/util/flex_string.hpp	/^    void swap(SimpleStringStorage& rhs)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(SimpleStringStorage& rhs)
boost::wave::util::SimpleStringStorage::value_type	wave/util/flex_string.hpp	/^    typedef E value_type;$/;"	t	class:boost::wave::util::SimpleStringStorage	access:public
boost::wave::util::SimpleStringStorage::~SimpleStringStorage	wave/util/flex_string.hpp	/^    ~SimpleStringStorage()$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:()
boost::wave::util::SmallStringOpt	wave/util/flex_string.hpp	/^class SmallStringOpt$/;"	c	namespace:boost::wave::util
boost::wave::util::SmallStringOpt::GetStorage	wave/util/flex_string.hpp	/^    Storage& GetStorage()$/;"	f	class:boost::wave::util::SmallStringOpt	access:private	signature:()
boost::wave::util::SmallStringOpt::GetStorage	wave/util/flex_string.hpp	/^    const Storage& GetStorage() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:private	signature:() const
boost::wave::util::SmallStringOpt::Small	wave/util/flex_string.hpp	/^    bool Small() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:private	signature:() const
boost::wave::util::SmallStringOpt::SmallStringOpt	wave/util/flex_string.hpp	/^    SmallStringOpt(const allocator_type&)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(const allocator_type&)
boost::wave::util::SmallStringOpt::SmallStringOpt	wave/util/flex_string.hpp	/^    SmallStringOpt(const value_type* s, size_type len, const allocator_type& a)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(const value_type* s, size_type len, const allocator_type& a)
boost::wave::util::SmallStringOpt::SmallStringOpt	wave/util/flex_string.hpp	/^    SmallStringOpt(size_type len, value_type c, const allocator_type& a)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(size_type len, value_type c, const allocator_type& a)
boost::wave::util::SmallStringOpt::SmallStringOpt	wave/util/flex_string.hpp	/^  SmallStringOpt(const SmallStringOpt& s)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(const SmallStringOpt& s)
boost::wave::util::SmallStringOpt::__anon5::align_	wave/util/flex_string.hpp	/^        Align align_;$/;"	m	union:boost::wave::util::SmallStringOpt::__anon5	access:public
boost::wave::util::SmallStringOpt::__anon5::buf_	wave/util/flex_string.hpp	/^        mutable value_type buf_[maxSmallString + 1];$/;"	m	union:boost::wave::util::SmallStringOpt::__anon5	access:public
boost::wave::util::SmallStringOpt::allocator_type	wave/util/flex_string.hpp	/^    typedef typename Storage::allocator_type allocator_type;$/;"	t	class:boost::wave::util::SmallStringOpt	access:public
boost::wave::util::SmallStringOpt::append	wave/util/flex_string.hpp	/^    void append(InputIterator b, InputIterator e)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(InputIterator b, InputIterator e)
boost::wave::util::SmallStringOpt::append	wave/util/flex_string.hpp	/^    void append(const value_type* s, size_type sz)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(const value_type* s, size_type sz)
boost::wave::util::SmallStringOpt::begin	wave/util/flex_string.hpp	/^    const_iterator begin() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
boost::wave::util::SmallStringOpt::begin	wave/util/flex_string.hpp	/^    iterator begin()$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:()
boost::wave::util::SmallStringOpt::c_str	wave/util/flex_string.hpp	/^    const value_type* c_str() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
boost::wave::util::SmallStringOpt::capacity	wave/util/flex_string.hpp	/^    size_type capacity() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
boost::wave::util::SmallStringOpt::const_iterator	wave/util/flex_string.hpp	/^    typedef const value_type* const_iterator;$/;"	t	class:boost::wave::util::SmallStringOpt	access:public
boost::wave::util::SmallStringOpt::data	wave/util/flex_string.hpp	/^    const value_type* data() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
boost::wave::util::SmallStringOpt::end	wave/util/flex_string.hpp	/^    const_iterator end() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
boost::wave::util::SmallStringOpt::end	wave/util/flex_string.hpp	/^    iterator end()$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:()
boost::wave::util::SmallStringOpt::get_allocator	wave/util/flex_string.hpp	/^    allocator_type get_allocator() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
boost::wave::util::SmallStringOpt::iterator	wave/util/flex_string.hpp	/^    typedef value_type* iterator;$/;"	t	class:boost::wave::util::SmallStringOpt	access:public
boost::wave::util::SmallStringOpt::magic	wave/util/flex_string.hpp	/^    enum { magic = maxSmallString + 1 };$/;"	e	enum:boost::wave::util::SmallStringOpt::__anon4
boost::wave::util::SmallStringOpt::maxSmallString	wave/util/flex_string.hpp	/^    enum { maxSmallString = $/;"	e	enum:boost::wave::util::SmallStringOpt::__anon3
boost::wave::util::SmallStringOpt::max_size	wave/util/flex_string.hpp	/^    size_type max_size() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
boost::wave::util::SmallStringOpt::operator =	wave/util/flex_string.hpp	/^    SmallStringOpt& operator=(const SmallStringOpt& rhs)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(const SmallStringOpt& rhs)
boost::wave::util::SmallStringOpt::reserve	wave/util/flex_string.hpp	/^    void reserve(size_type res_arg)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(size_type res_arg)
boost::wave::util::SmallStringOpt::resize	wave/util/flex_string.hpp	/^    void resize(size_type n, value_type c)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(size_type n, value_type c)
boost::wave::util::SmallStringOpt::size	wave/util/flex_string.hpp	/^    size_type size() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
boost::wave::util::SmallStringOpt::size_type	wave/util/flex_string.hpp	/^    typedef typename allocator_type::size_type size_type;$/;"	t	class:boost::wave::util::SmallStringOpt	access:public
boost::wave::util::SmallStringOpt::swap	wave/util/flex_string.hpp	/^    void swap(SmallStringOpt& rhs)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(SmallStringOpt& rhs)
boost::wave::util::SmallStringOpt::temp1	wave/util/flex_string.hpp	/^  enum { temp1 = threshold * sizeof(value_type) > sizeof(Storage) $/;"	e	enum:boost::wave::util::SmallStringOpt::__anon1
boost::wave::util::SmallStringOpt::temp2	wave/util/flex_string.hpp	/^    enum { temp2 = temp1 > sizeof(Align) ? temp1 : sizeof(Align) };$/;"	e	enum:boost::wave::util::SmallStringOpt::__anon2
boost::wave::util::SmallStringOpt::value_type	wave/util/flex_string.hpp	/^    typedef typename Storage::value_type value_type;$/;"	t	class:boost::wave::util::SmallStringOpt	access:public
boost::wave::util::SmallStringOpt::~SmallStringOpt	wave/util/flex_string.hpp	/^    ~SmallStringOpt()$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:()
boost::wave::util::VectorStringStorage	wave/util/flex_string.hpp	/^class VectorStringStorage : protected std::vector<E, A>$/;"	c	namespace:boost::wave::util	inherits:std::vector
boost::wave::util::VectorStringStorage::VectorStringStorage	wave/util/flex_string.hpp	/^    VectorStringStorage(const A& a) : base(1, E(), a)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(const A& a)
boost::wave::util::VectorStringStorage::VectorStringStorage	wave/util/flex_string.hpp	/^    VectorStringStorage(const E* s, size_type len, const A& a)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(const E* s, size_type len, const A& a)
boost::wave::util::VectorStringStorage::VectorStringStorage	wave/util/flex_string.hpp	/^    VectorStringStorage(const VectorStringStorage& s) : base(s)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(const VectorStringStorage& s)
boost::wave::util::VectorStringStorage::VectorStringStorage	wave/util/flex_string.hpp	/^    VectorStringStorage(size_type len, E c, const A& a)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(size_type len, E c, const A& a)
boost::wave::util::VectorStringStorage::allocator_type	wave/util/flex_string.hpp	/^    typedef A allocator_type;$/;"	t	class:boost::wave::util::VectorStringStorage	access:public
boost::wave::util::VectorStringStorage::append	wave/util/flex_string.hpp	/^    void append(InputIterator b, InputIterator e)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(InputIterator b, InputIterator e)
boost::wave::util::VectorStringStorage::append	wave/util/flex_string.hpp	/^    void append(const E* s, size_type sz)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(const E* s, size_type sz)
boost::wave::util::VectorStringStorage::base	wave/util/flex_string.hpp	/^    typedef std::vector<E, A> base;$/;"	t	class:boost::wave::util::VectorStringStorage	access:private
boost::wave::util::VectorStringStorage::begin	wave/util/flex_string.hpp	/^    const_iterator begin() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
boost::wave::util::VectorStringStorage::begin	wave/util/flex_string.hpp	/^    iterator begin()$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:()
boost::wave::util::VectorStringStorage::c_str	wave/util/flex_string.hpp	/^    const E* c_str() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
boost::wave::util::VectorStringStorage::capacity	wave/util/flex_string.hpp	/^    size_type capacity() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
boost::wave::util::VectorStringStorage::const_iterator	wave/util/flex_string.hpp	/^    typedef typename base::const_iterator const_iterator;$/;"	t	class:boost::wave::util::VectorStringStorage	access:public
boost::wave::util::VectorStringStorage::data	wave/util/flex_string.hpp	/^    const E* data() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
boost::wave::util::VectorStringStorage::end	wave/util/flex_string.hpp	/^    const_iterator end() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
boost::wave::util::VectorStringStorage::end	wave/util/flex_string.hpp	/^    iterator end()$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:()
boost::wave::util::VectorStringStorage::get_allocator	wave/util/flex_string.hpp	/^    A get_allocator() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
boost::wave::util::VectorStringStorage::iterator	wave/util/flex_string.hpp	/^    typedef typename base::iterator iterator;$/;"	t	class:boost::wave::util::VectorStringStorage	access:public
boost::wave::util::VectorStringStorage::max_size	wave/util/flex_string.hpp	/^    size_type max_size() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
boost::wave::util::VectorStringStorage::operator =	wave/util/flex_string.hpp	/^    VectorStringStorage& operator=(const VectorStringStorage& rhs)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(const VectorStringStorage& rhs)
boost::wave::util::VectorStringStorage::reserve	wave/util/flex_string.hpp	/^    void reserve(size_type res_arg)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(size_type res_arg)
boost::wave::util::VectorStringStorage::resize	wave/util/flex_string.hpp	/^    void resize(size_type n, E c)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(size_type n, E c)
boost::wave::util::VectorStringStorage::size	wave/util/flex_string.hpp	/^    size_type size() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
boost::wave::util::VectorStringStorage::size_type	wave/util/flex_string.hpp	/^    typedef typename A::size_type size_type;$/;"	t	class:boost::wave::util::VectorStringStorage	access:public
boost::wave::util::VectorStringStorage::swap	wave/util/flex_string.hpp	/^    void swap(VectorStringStorage& rhs)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(VectorStringStorage& rhs)
boost::wave::util::VectorStringStorage::value_type	wave/util/flex_string.hpp	/^    typedef E value_type;$/;"	t	class:boost::wave::util::VectorStringStorage	access:public
boost::wave::util::add_macro_definition	wave/util/cpp_iterator.hpp	/^bool add_macro_definition(ContextT &ctx, std::string macrostring,$/;"	f	namespace:boost::wave::util	signature:(ContextT &ctx, std::string macrostring, bool is_predefined, boost::wave::language_support language)
boost::wave::util::as_relative_to	wave/util/cpp_include_paths.hpp	/^as_relative_to(boost::filesystem::path const& path, $/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& path, boost::filesystem::path const& base, boost::filesystem::path& result)
boost::wave::util::bidirectional_map	wave/util/cpp_include_paths.hpp	/^struct bidirectional_map$/;"	s	namespace:boost::wave::util
boost::wave::util::bidirectional_map::BOOST_STATIC_CONSTANT	wave/util/cpp_include_paths.hpp	/^    BOOST_STATIC_CONSTANT(unsigned, from_offset = offsetof(value_type, first));$/;"	p	struct:boost::wave::util::bidirectional_map	access:public	signature:(unsigned, from_offset = offsetof(value_type, first))
boost::wave::util::bidirectional_map::BOOST_STATIC_CONSTANT	wave/util/cpp_include_paths.hpp	/^    BOOST_STATIC_CONSTANT(unsigned, to_offset   = offsetof(value_type, second));$/;"	p	struct:boost::wave::util::bidirectional_map	access:public	signature:(unsigned, to_offset = offsetof(value_type, second))
boost::wave::util::bidirectional_map::type	wave/util/cpp_include_paths.hpp	/^    > type;$/;"	t	struct:boost::wave::util::bidirectional_map	access:public
boost::wave::util::bidirectional_map::type	wave/util/cpp_include_paths.hpp	/^  > type;$/;"	t	struct:boost::wave::util::bidirectional_map	access:public
boost::wave::util::bidirectional_map::value_type	wave/util/cpp_include_paths.hpp	/^    typedef std::pair<FromType, ToType> value_type;$/;"	t	struct:boost::wave::util::bidirectional_map	access:public
boost::wave::util::branch_path	wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path branch_path(boost::filesystem::path const& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& p)
boost::wave::util::complete_path	wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path complete_path($/;"	f	namespace:boost::wave::util	signature:( boost::filesystem::path const& p)
boost::wave::util::complete_path	wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path complete_path($/;"	f	namespace:boost::wave::util	signature:( boost::filesystem::path const& p, boost::filesystem::path const& base)
boost::wave::util::create_directories	wave/util/filesystem_compatibility.hpp	/^    inline bool create_directories(boost::filesystem::path const& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& p)
boost::wave::util::create_path	wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path create_path(String const& p)$/;"	f	namespace:boost::wave::util	signature:(String const& p)
boost::wave::util::current_path	wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path current_path()$/;"	f	namespace:boost::wave::util	signature:()
boost::wave::util::file_position	wave/util/file_position.hpp	/^struct file_position {$/;"	s	namespace:boost::wave::util
boost::wave::util::file_position::column	wave/util/file_position.hpp	/^    std::size_t column;$/;"	m	struct:boost::wave::util::file_position	access:private
boost::wave::util::file_position::file	wave/util/file_position.hpp	/^    string_type file;$/;"	m	struct:boost::wave::util::file_position	access:private
boost::wave::util::file_position::file_position	wave/util/file_position.hpp	/^    explicit file_position(string_type const& file_, std::size_t line_ = 1, $/;"	f	struct:boost::wave::util::file_position	access:public	signature:(string_type const& file_, std::size_t line_ = 1, std::size_t column_ = 1)
boost::wave::util::file_position::file_position	wave/util/file_position.hpp	/^    file_position()$/;"	f	struct:boost::wave::util::file_position	access:public	signature:()
boost::wave::util::file_position::get_column	wave/util/file_position.hpp	/^    std::size_t get_column() const { return column; }$/;"	f	struct:boost::wave::util::file_position	access:public	signature:() const
boost::wave::util::file_position::get_file	wave/util/file_position.hpp	/^    string_type const &get_file() const { return file; }$/;"	f	struct:boost::wave::util::file_position	access:public	signature:() const
boost::wave::util::file_position::get_line	wave/util/file_position.hpp	/^    std::size_t get_line() const { return line; }$/;"	f	struct:boost::wave::util::file_position	access:public	signature:() const
boost::wave::util::file_position::line	wave/util/file_position.hpp	/^    std::size_t line;$/;"	m	struct:boost::wave::util::file_position	access:private
boost::wave::util::file_position::serialize	wave/util/file_position.hpp	/^    void serialize(Archive &ar, const unsigned int version)$/;"	f	struct:boost::wave::util::file_position	access:private	signature:(Archive &ar, const unsigned int version)
boost::wave::util::file_position::set_column	wave/util/file_position.hpp	/^    void set_column(std::size_t column_) { column = column_; }$/;"	f	struct:boost::wave::util::file_position	access:public	signature:(std::size_t column_)
boost::wave::util::file_position::set_file	wave/util/file_position.hpp	/^    void set_file(string_type const &file_) $/;"	f	struct:boost::wave::util::file_position	access:public	signature:(string_type const &file_)
boost::wave::util::file_position::set_line	wave/util/file_position.hpp	/^    void set_line(std::size_t line_) { line = line_; }$/;"	f	struct:boost::wave::util::file_position	access:public	signature:(std::size_t line_)
boost::wave::util::file_position::string_type	wave/util/file_position.hpp	/^    typedef StringT string_type;$/;"	t	struct:boost::wave::util::file_position	access:public
boost::wave::util::file_position_type	wave/util/file_position.hpp	/^typedef file_position<BOOST_WAVE_STRINGTYPE> file_position_type;$/;"	t	namespace:boost::wave::util
boost::wave::util::flex_string	wave/util/flex_string.hpp	/^class flex_string : private Storage$/;"	c	namespace:boost::wave::util	inherits:Storage
boost::wave::util::flex_string::DereferenceValidIterator	wave/util/flex_string.hpp	/^    DereferenceValidIterator(Iterator it) const$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(Iterator it) const
boost::wave::util::flex_string::DereferenceValidIterator	wave/util/flex_string.hpp	/^    DereferenceValidIterator(std::reverse_iterator<Iterator> it) const$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(std::reverse_iterator<Iterator> it) const
boost::wave::util::flex_string::Enforce	wave/util/flex_string.hpp	/^    static void Enforce(bool condition, Exception*, const char* msg)$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(bool condition, Exception*, const char* msg)
boost::wave::util::flex_string::InsertImpl	wave/util/flex_string.hpp	/^    void InsertImpl(iterator i,$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator i, FwdIterator s1, FwdIterator s2, std::forward_iterator_tag)
boost::wave::util::flex_string::InsertImpl	wave/util/flex_string.hpp	/^    void InsertImpl(iterator insertPosition,$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator insertPosition, InputIterator inputBegin, InputIterator inputEnd, std::input_iterator_tag)
boost::wave::util::flex_string::InsertImplDiscr	wave/util/flex_string.hpp	/^    flex_string& InsertImplDiscr(iterator i,$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator i, InputIterator b, InputIterator e, Selector<0>)
boost::wave::util::flex_string::InsertImplDiscr	wave/util/flex_string.hpp	/^    flex_string& InsertImplDiscr(iterator p, $/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator p, size_type n, value_type c, Selector<1>)
boost::wave::util::flex_string::Invariant	wave/util/flex_string.hpp	/^    struct Invariant$/;"	s	class:boost::wave::util::flex_string	access:private
boost::wave::util::flex_string::Invariant::Invariant	wave/util/flex_string.hpp	/^        Invariant(const flex_string& s) : s_(s)$/;"	f	struct:boost::wave::util::flex_string::Invariant	access:public	signature:(const flex_string& s)
boost::wave::util::flex_string::Invariant::operator =	wave/util/flex_string.hpp	/^        Invariant& operator=(const Invariant&);$/;"	p	struct:boost::wave::util::flex_string::Invariant	access:private	signature:(const Invariant&)
boost::wave::util::flex_string::Invariant::s_	wave/util/flex_string.hpp	/^        const flex_string& s_;$/;"	m	struct:boost::wave::util::flex_string::Invariant	access:private
boost::wave::util::flex_string::Invariant::~Invariant	wave/util/flex_string.hpp	/^        ~Invariant()$/;"	f	struct:boost::wave::util::flex_string::Invariant	access:public	signature:()
boost::wave::util::flex_string::IsAliasedRange	wave/util/flex_string.hpp	/^    bool IsAliasedRange(Iterator beginIterator, Iterator endIterator)$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(Iterator beginIterator, Iterator endIterator)
boost::wave::util::flex_string::Min	wave/util/flex_string.hpp	/^    static size_type Min(size_type lhs, size_type rhs)$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(size_type lhs, size_type rhs)
boost::wave::util::flex_string::Procust	wave/util/flex_string.hpp	/^    static void Procust(size_type& n, size_type nmax)$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(size_type& n, size_type nmax)
boost::wave::util::flex_string::ReplaceImpl	wave/util/flex_string.hpp	/^    void ReplaceImpl(iterator i1, iterator i2,$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator i1, iterator i2, FwdIterator s1, FwdIterator s2, std::forward_iterator_tag)
boost::wave::util::flex_string::ReplaceImpl	wave/util/flex_string.hpp	/^    void ReplaceImpl(iterator i1, iterator i2,$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator i1, iterator i2, InputIterator b, InputIterator e, std::input_iterator_tag)
boost::wave::util::flex_string::ReplaceImplDiscr	wave/util/flex_string.hpp	/^    flex_string& ReplaceImplDiscr(iterator i1, iterator i2, $/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator i1, iterator i2, const value_type* s, size_type n, Selector<2>)
boost::wave::util::flex_string::ReplaceImplDiscr	wave/util/flex_string.hpp	/^    flex_string& ReplaceImplDiscr(iterator i1, iterator i2,$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator i1, iterator i2, InputIterator b, InputIterator e, Selector<0>)
boost::wave::util::flex_string::ReplaceImplDiscr	wave/util/flex_string.hpp	/^    flex_string& ReplaceImplDiscr(iterator i1, iterator i2,$/;"	f	class:boost::wave::util::flex_string	access:private	signature:(iterator i1, iterator i2, size_type n2, value_type c, Selector<1>)
boost::wave::util::flex_string::Sane	wave/util/flex_string.hpp	/^    bool Sane() const$/;"	f	class:boost::wave::util::flex_string	access:private	signature:() const
boost::wave::util::flex_string::Selector	wave/util/flex_string.hpp	/^    template <int i> class Selector {};$/;"	c	class:boost::wave::util::flex_string	access:private
boost::wave::util::flex_string::allocator_type	wave/util/flex_string.hpp	/^    typedef A allocator_type;$/;"	t	class:boost::wave::util::flex_string	access:public
boost::wave::util::flex_string::append	wave/util/flex_string.hpp	/^    flex_string& append(InputIterator first, InputIterator last)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(InputIterator first, InputIterator last)
boost::wave::util::flex_string::append	wave/util/flex_string.hpp	/^    flex_string& append(const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str)
boost::wave::util::flex_string::append	wave/util/flex_string.hpp	/^    flex_string& append(const flex_string& str, const size_type pos,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, const size_type pos, size_type n)
boost::wave::util::flex_string::append	wave/util/flex_string.hpp	/^    flex_string& append(const value_type* s)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s)
boost::wave::util::flex_string::append	wave/util/flex_string.hpp	/^    flex_string& append(const value_type* s, const size_type n)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, const size_type n)
boost::wave::util::flex_string::append	wave/util/flex_string.hpp	/^    flex_string& append(size_type n, value_type c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type n, value_type c)
boost::wave::util::flex_string::assign	wave/util/flex_string.hpp	/^    flex_string& assign(ItOrLength first_or_n, ItOrChar last_or_c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(ItOrLength first_or_n, ItOrChar last_or_c)
boost::wave::util::flex_string::assign	wave/util/flex_string.hpp	/^    flex_string& assign(const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str)
boost::wave::util::flex_string::assign	wave/util/flex_string.hpp	/^    flex_string& assign(const flex_string& str, size_type pos,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos, size_type n)
boost::wave::util::flex_string::assign	wave/util/flex_string.hpp	/^    flex_string& assign(const value_type* s)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s)
boost::wave::util::flex_string::assign	wave/util/flex_string.hpp	/^    flex_string& assign(const value_type* s, size_type n)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type n)
boost::wave::util::flex_string::at	wave/util/flex_string.hpp	/^    const_reference at(size_type n) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type n) const
boost::wave::util::flex_string::at	wave/util/flex_string.hpp	/^    reference at(size_type n)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type n)
boost::wave::util::flex_string::back	wave/util/flex_string.hpp	/^    value_type & back() { return *(begin()+size()-1); }$/;"	f	class:boost::wave::util::flex_string	access:public	signature:()
boost::wave::util::flex_string::back	wave/util/flex_string.hpp	/^    value_type const& back() const { return *(begin()+size()-1); }$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
boost::wave::util::flex_string::begin	wave/util/flex_string.hpp	/^    const_iterator begin() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
boost::wave::util::flex_string::begin	wave/util/flex_string.hpp	/^    iterator begin()$/;"	f	class:boost::wave::util::flex_string	access:public	signature:()
boost::wave::util::flex_string::c_str	wave/util/flex_string.hpp	/^    const value_type* c_str() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
boost::wave::util::flex_string::capacity	wave/util/flex_string.hpp	/^    size_type capacity() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
boost::wave::util::flex_string::clear	wave/util/flex_string.hpp	/^    void clear()$/;"	f	class:boost::wave::util::flex_string	access:public	signature:()
boost::wave::util::flex_string::compare	wave/util/flex_string.hpp	/^    std::ptrdiff_t compare(const flex_string& str) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str) const
boost::wave::util::flex_string::compare	wave/util/flex_string.hpp	/^    std::ptrdiff_t compare(const value_type* s) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s) const
boost::wave::util::flex_string::compare	wave/util/flex_string.hpp	/^    std::ptrdiff_t compare(size_type pos1, size_type n1,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, size_type n1, const flex_string& str) const
boost::wave::util::flex_string::compare	wave/util/flex_string.hpp	/^    std::ptrdiff_t compare(size_type pos1, size_type n1,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, size_type n1, const flex_string& str, size_type pos2, size_type n2) const
boost::wave::util::flex_string::compare	wave/util/flex_string.hpp	/^    std::ptrdiff_t compare(size_type pos1, size_type n1,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, size_type n1, const value_type* s) const
boost::wave::util::flex_string::compare	wave/util/flex_string.hpp	/^    std::ptrdiff_t compare(size_type pos1, size_type n1,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, size_type n1, const value_type* s, size_type n2) const
boost::wave::util::flex_string::const_iterator	wave/util/flex_string.hpp	/^    typedef typename Storage::const_iterator const_iterator;$/;"	t	class:boost::wave::util::flex_string	access:public
boost::wave::util::flex_string::const_pointer	wave/util/flex_string.hpp	/^    typedef typename A::const_pointer const_pointer;$/;"	t	class:boost::wave::util::flex_string	access:public
boost::wave::util::flex_string::const_reference	wave/util/flex_string.hpp	/^    typedef typename A::const_reference const_reference;$/;"	t	class:boost::wave::util::flex_string	access:public
boost::wave::util::flex_string::const_reverse_iterator	wave/util/flex_string.hpp	/^    typedef boost::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:boost::wave::util::flex_string	access:public
boost::wave::util::flex_string::copy	wave/util/flex_string.hpp	/^    size_type copy(value_type* s, size_type n, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type* s, size_type n, size_type pos = 0) const
boost::wave::util::flex_string::data	wave/util/flex_string.hpp	/^    const value_type* data() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
boost::wave::util::flex_string::difference_type	wave/util/flex_string.hpp	/^    typedef typename A::difference_type difference_type;$/;"	t	class:boost::wave::util::flex_string	access:public
boost::wave::util::flex_string::empty	wave/util/flex_string.hpp	/^    bool empty() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
boost::wave::util::flex_string::end	wave/util/flex_string.hpp	/^    const_iterator end() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
boost::wave::util::flex_string::end	wave/util/flex_string.hpp	/^    iterator end()$/;"	f	class:boost::wave::util::flex_string	access:public	signature:()
boost::wave::util::flex_string::erase	wave/util/flex_string.hpp	/^    flex_string& erase(size_type pos = 0, size_type n = npos)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos = 0, size_type n = npos)
boost::wave::util::flex_string::erase	wave/util/flex_string.hpp	/^    iterator erase(iterator first, iterator last)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(iterator first, iterator last)
boost::wave::util::flex_string::erase	wave/util/flex_string.hpp	/^    iterator erase(iterator position)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(iterator position)
boost::wave::util::flex_string::find	wave/util/flex_string.hpp	/^    size_type find (const value_type* s, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos = 0) const
boost::wave::util::flex_string::find	wave/util/flex_string.hpp	/^    size_type find (const value_type* s, size_type pos, size_type n) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos, size_type n) const
boost::wave::util::flex_string::find	wave/util/flex_string.hpp	/^    size_type find (value_type c, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c, size_type pos = 0) const
boost::wave::util::flex_string::find	wave/util/flex_string.hpp	/^    size_type find(const flex_string& str, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos = 0) const
boost::wave::util::flex_string::find_first_not_of	wave/util/flex_string.hpp	/^    size_type find_first_not_of(const flex_string& str,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos = 0) const
boost::wave::util::flex_string::find_first_not_of	wave/util/flex_string.hpp	/^    size_type find_first_not_of(const value_type* s, $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos = 0) const
boost::wave::util::flex_string::find_first_not_of	wave/util/flex_string.hpp	/^    size_type find_first_not_of(const value_type* s, size_type pos,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos, size_type n) const
boost::wave::util::flex_string::find_first_not_of	wave/util/flex_string.hpp	/^    size_type find_first_not_of(value_type c, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c, size_type pos = 0) const
boost::wave::util::flex_string::find_first_of	wave/util/flex_string.hpp	/^    size_type find_first_of(const flex_string& str, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos = 0) const
boost::wave::util::flex_string::find_first_of	wave/util/flex_string.hpp	/^    size_type find_first_of(const value_type* s, $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos, size_type n) const
boost::wave::util::flex_string::find_first_of	wave/util/flex_string.hpp	/^    size_type find_first_of(const value_type* s, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos = 0) const
boost::wave::util::flex_string::find_first_of	wave/util/flex_string.hpp	/^    size_type find_first_of(value_type c, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c, size_type pos = 0) const
boost::wave::util::flex_string::find_last_not_of	wave/util/flex_string.hpp	/^    size_type find_last_not_of (value_type c, size_type pos = npos) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c, size_type pos = npos) const
boost::wave::util::flex_string::find_last_not_of	wave/util/flex_string.hpp	/^    size_type find_last_not_of(const flex_string& str,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos = npos) const
boost::wave::util::flex_string::find_last_not_of	wave/util/flex_string.hpp	/^    size_type find_last_not_of(const value_type* s, $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos = npos) const
boost::wave::util::flex_string::find_last_not_of	wave/util/flex_string.hpp	/^    size_type find_last_not_of(const value_type* s, size_type pos,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos, size_type n) const
boost::wave::util::flex_string::find_last_of	wave/util/flex_string.hpp	/^    size_type find_last_of (const flex_string& str,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos = npos) const
boost::wave::util::flex_string::find_last_of	wave/util/flex_string.hpp	/^    size_type find_last_of (const value_type* s, $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos = npos) const
boost::wave::util::flex_string::find_last_of	wave/util/flex_string.hpp	/^    size_type find_last_of (const value_type* s, size_type pos, $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos, size_type n) const
boost::wave::util::flex_string::find_last_of	wave/util/flex_string.hpp	/^    size_type find_last_of (value_type c, size_type pos = npos) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c, size_type pos = npos) const
boost::wave::util::flex_string::flex_string	wave/util/flex_string.hpp	/^    explicit flex_string(const A& a = A())$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const A& a = A())
boost::wave::util::flex_string::flex_string	wave/util/flex_string.hpp	/^    flex_string(InputIterator begin, InputIterator end, const A& a = A())$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(InputIterator begin, InputIterator end, const A& a = A())
boost::wave::util::flex_string::flex_string	wave/util/flex_string.hpp	/^    flex_string(const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str)
boost::wave::util::flex_string::flex_string	wave/util/flex_string.hpp	/^    flex_string(const flex_string& str, size_type pos, $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos, size_type n = npos, const A& a = A())
boost::wave::util::flex_string::flex_string	wave/util/flex_string.hpp	/^    flex_string(const value_type* s, const A& a = A())$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, const A& a = A())
boost::wave::util::flex_string::flex_string	wave/util/flex_string.hpp	/^    flex_string(const value_type* s, size_type n, const A& a = A())$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type n, const A& a = A())
boost::wave::util::flex_string::flex_string	wave/util/flex_string.hpp	/^    flex_string(size_type n, value_type c, const A& a = A())$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type n, value_type c, const A& a = A())
boost::wave::util::flex_string::get_allocator	wave/util/flex_string.hpp	/^    allocator_type get_allocator() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
boost::wave::util::flex_string::insert	wave/util/flex_string.hpp	/^    flex_string& insert(size_type pos, const value_type* s)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos, const value_type* s)
boost::wave::util::flex_string::insert	wave/util/flex_string.hpp	/^    flex_string& insert(size_type pos, const value_type* s, size_type n)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos, const value_type* s, size_type n)
boost::wave::util::flex_string::insert	wave/util/flex_string.hpp	/^    flex_string& insert(size_type pos, size_type n, value_type c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos, size_type n, value_type c)
boost::wave::util::flex_string::insert	wave/util/flex_string.hpp	/^    flex_string& insert(size_type pos1, const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, const flex_string& str)
boost::wave::util::flex_string::insert	wave/util/flex_string.hpp	/^    flex_string& insert(size_type pos1, const flex_string& str,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, const flex_string& str, size_type pos2, size_type n)
boost::wave::util::flex_string::insert	wave/util/flex_string.hpp	/^    iterator insert(iterator p, value_type c = value_type()) $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(iterator p, value_type c = value_type())
boost::wave::util::flex_string::insert	wave/util/flex_string.hpp	/^    void insert(iterator p, ItOrLength first_or_n, ItOrChar last_or_c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(iterator p, ItOrLength first_or_n, ItOrChar last_or_c)
boost::wave::util::flex_string::iterator	wave/util/flex_string.hpp	/^    typedef typename Storage::iterator iterator;$/;"	t	class:boost::wave::util::flex_string	access:public
boost::wave::util::flex_string::length	wave/util/flex_string.hpp	/^    size_type length() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
boost::wave::util::flex_string::max_size	wave/util/flex_string.hpp	/^    size_type max_size() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
boost::wave::util::flex_string::npos	wave/util/flex_string.hpp	/^    static const size_type npos;    \/\/ = size_type(-1)$/;"	m	class:boost::wave::util::flex_string	access:public
boost::wave::util::flex_string::npos	wave/util/flex_string.hpp	/^flex_string<E1, T, A, S>::npos = (typename flex_string<E1, T, A, S>::size_type)(-1);$/;"	m	class:boost::wave::util::flex_string
boost::wave::util::flex_string::operator +=	wave/util/flex_string.hpp	/^    flex_string& operator+=(const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str)
boost::wave::util::flex_string::operator +=	wave/util/flex_string.hpp	/^    flex_string& operator+=(const value_type* s)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s)
boost::wave::util::flex_string::operator +=	wave/util/flex_string.hpp	/^    flex_string& operator+=(value_type c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c)
boost::wave::util::flex_string::operator =	wave/util/flex_string.hpp	/^    flex_string& operator=(const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str)
boost::wave::util::flex_string::operator =	wave/util/flex_string.hpp	/^    flex_string& operator=(const value_type* s)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s)
boost::wave::util::flex_string::operator =	wave/util/flex_string.hpp	/^    flex_string& operator=(value_type c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c)
boost::wave::util::flex_string::operator []	wave/util/flex_string.hpp	/^    const_reference operator[](size_type pos) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos) const
boost::wave::util::flex_string::operator []	wave/util/flex_string.hpp	/^    reference operator[](size_type pos)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos)
boost::wave::util::flex_string::pointer	wave/util/flex_string.hpp	/^    typedef typename A::pointer pointer;$/;"	t	class:boost::wave::util::flex_string	access:public
boost::wave::util::flex_string::push_back	wave/util/flex_string.hpp	/^    void push_back(value_type c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c)
boost::wave::util::flex_string::rbegin	wave/util/flex_string.hpp	/^    const_reverse_iterator rbegin() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
boost::wave::util::flex_string::rbegin	wave/util/flex_string.hpp	/^    reverse_iterator rbegin()$/;"	f	class:boost::wave::util::flex_string	access:public	signature:()
boost::wave::util::flex_string::reference	wave/util/flex_string.hpp	/^    typedef typename A::reference reference;$/;"	t	class:boost::wave::util::flex_string	access:public
boost::wave::util::flex_string::rend	wave/util/flex_string.hpp	/^    const_reverse_iterator rend() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
boost::wave::util::flex_string::rend	wave/util/flex_string.hpp	/^    reverse_iterator rend()$/;"	f	class:boost::wave::util::flex_string	access:public	signature:()
boost::wave::util::flex_string::replace	wave/util/flex_string.hpp	/^    flex_string& replace(iterator i1, iterator i2, const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(iterator i1, iterator i2, const flex_string& str)
boost::wave::util::flex_string::replace	wave/util/flex_string.hpp	/^    flex_string& replace(iterator i1, iterator i2, const value_type* s)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(iterator i1, iterator i2, const value_type* s)
boost::wave::util::flex_string::replace	wave/util/flex_string.hpp	/^    flex_string& replace(iterator i1, iterator i2,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(iterator i1, iterator i2, T1 first_or_n_or_s, T2 last_or_c_or_n)
boost::wave::util::flex_string::replace	wave/util/flex_string.hpp	/^    flex_string& replace(size_type pos, size_type n1, $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos, size_type n1, StrOrLength s_or_n2, NumOrChar n_or_c)
boost::wave::util::flex_string::replace	wave/util/flex_string.hpp	/^    flex_string& replace(size_type pos, size_type n1, const value_type* s)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos, size_type n1, const value_type* s)
boost::wave::util::flex_string::replace	wave/util/flex_string.hpp	/^    flex_string& replace(size_type pos1, size_type n1, const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, size_type n1, const flex_string& str)
boost::wave::util::flex_string::replace	wave/util/flex_string.hpp	/^    flex_string& replace(size_type pos1, size_type n1, const flex_string& str,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, size_type n1, const flex_string& str, size_type pos2, size_type n2)
boost::wave::util::flex_string::reserve	wave/util/flex_string.hpp	/^    void reserve(size_type res_arg = 0)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type res_arg = 0)
boost::wave::util::flex_string::resize	wave/util/flex_string.hpp	/^    void resize(size_type n)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type n)
boost::wave::util::flex_string::resize	wave/util/flex_string.hpp	/^    void resize(size_type n, value_type c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type n, value_type c)
boost::wave::util::flex_string::reverse_iterator	wave/util/flex_string.hpp	/^    typedef boost::reverse_iterator<iterator> reverse_iterator;$/;"	t	class:boost::wave::util::flex_string	access:public
boost::wave::util::flex_string::rfind	wave/util/flex_string.hpp	/^    size_type rfind(const flex_string& str, size_type pos = npos) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos = npos) const
boost::wave::util::flex_string::rfind	wave/util/flex_string.hpp	/^    size_type rfind(const value_type* s, size_type pos = npos) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos = npos) const
boost::wave::util::flex_string::rfind	wave/util/flex_string.hpp	/^    size_type rfind(const value_type* s, size_type pos, size_type n) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos, size_type n) const
boost::wave::util::flex_string::rfind	wave/util/flex_string.hpp	/^    size_type rfind(value_type c, size_type pos = npos) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c, size_type pos = npos) const
boost::wave::util::flex_string::size	wave/util/flex_string.hpp	/^    size_type size() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
boost::wave::util::flex_string::size_type	wave/util/flex_string.hpp	/^    typedef typename A::size_type size_type;$/;"	t	class:boost::wave::util::flex_string	access:public
boost::wave::util::flex_string::substr	wave/util/flex_string.hpp	/^    flex_string substr(size_type pos = 0, size_type n = npos) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos = 0, size_type n = npos) const
boost::wave::util::flex_string::swap	wave/util/flex_string.hpp	/^    void swap(flex_string& rhs)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(flex_string& rhs)
boost::wave::util::flex_string::traits_type	wave/util/flex_string.hpp	/^    typedef T traits_type;$/;"	t	class:boost::wave::util::flex_string	access:public
boost::wave::util::flex_string::value_type	wave/util/flex_string.hpp	/^    typedef typename traits_type::char_type value_type;$/;"	t	class:boost::wave::util::flex_string	access:public
boost::wave::util::flex_string::~flex_string	wave/util/flex_string.hpp	/^    ~flex_string()$/;"	f	class:boost::wave::util::flex_string	access:public	signature:()
boost::wave::util::flex_string_details	wave/util/flex_string.hpp	/^namespace flex_string_details$/;"	n	namespace:boost::wave::util
boost::wave::util::flex_string_details::Shallow	wave/util/flex_string.hpp	/^    enum Shallow {};$/;"	g	namespace:boost::wave::util::flex_string_details
boost::wave::util::flex_string_details::copy_n	wave/util/flex_string.hpp	/^    OutIt copy_n(InIt b, $/;"	f	namespace:boost::wave::util::flex_string_details	signature:(InIt b, typename std::iterator_traits<InIt>::difference_type n, OutIt d)
boost::wave::util::flex_string_details::get_unsigned	wave/util/flex_string.hpp	/^    template <> struct get_unsigned<char>$/;"	s	namespace:boost::wave::util::flex_string_details
boost::wave::util::flex_string_details::get_unsigned	wave/util/flex_string.hpp	/^    template <> struct get_unsigned<int>$/;"	s	namespace:boost::wave::util::flex_string_details
boost::wave::util::flex_string_details::get_unsigned	wave/util/flex_string.hpp	/^    template <> struct get_unsigned<long int>$/;"	s	namespace:boost::wave::util::flex_string_details
boost::wave::util::flex_string_details::get_unsigned	wave/util/flex_string.hpp	/^    template <> struct get_unsigned<short int>$/;"	s	namespace:boost::wave::util::flex_string_details
boost::wave::util::flex_string_details::get_unsigned	wave/util/flex_string.hpp	/^    template <> struct get_unsigned<signed char>$/;"	s	namespace:boost::wave::util::flex_string_details
boost::wave::util::flex_string_details::get_unsigned	wave/util/flex_string.hpp	/^    template <typename T> struct get_unsigned$/;"	s	namespace:boost::wave::util::flex_string_details
boost::wave::util::flex_string_details::get_unsigned::result	wave/util/flex_string.hpp	/^        typedef T result;$/;"	t	struct:boost::wave::util::flex_string_details::get_unsigned	access:public
boost::wave::util::flex_string_details::get_unsigned::result	wave/util/flex_string.hpp	/^        typedef unsigned char result;$/;"	t	struct:boost::wave::util::flex_string_details::get_unsigned	access:public
boost::wave::util::flex_string_details::get_unsigned::result	wave/util/flex_string.hpp	/^        typedef unsigned int result;$/;"	t	struct:boost::wave::util::flex_string_details::get_unsigned	access:public
boost::wave::util::flex_string_details::get_unsigned::result	wave/util/flex_string.hpp	/^        typedef unsigned long int result;$/;"	t	struct:boost::wave::util::flex_string_details::get_unsigned	access:public
boost::wave::util::flex_string_details::get_unsigned::result	wave/util/flex_string.hpp	/^        typedef unsigned short int result;$/;"	t	struct:boost::wave::util::flex_string_details::get_unsigned	access:public
boost::wave::util::flex_string_details::pod_copy	wave/util/flex_string.hpp	/^    inline Pod* pod_copy(const Pod* b, const Pod* e, Pod* d)$/;"	f	namespace:boost::wave::util::flex_string_details	signature:(const Pod* b, const Pod* e, Pod* d)
boost::wave::util::flex_string_details::pod_fill	wave/util/flex_string.hpp	/^    inline void pod_fill(Pod* b, Pod* e, T c)$/;"	f	namespace:boost::wave::util::flex_string_details	signature:(Pod* b, Pod* e, T c)
boost::wave::util::flex_string_details::pod_move	wave/util/flex_string.hpp	/^    inline void pod_move(const Pod* b, const Pod* e, Pod* d)$/;"	f	namespace:boost::wave::util::flex_string_details	signature:(const Pod* b, const Pod* e, Pod* d)
boost::wave::util::from	wave/util/cpp_include_paths.hpp	/^struct from {};$/;"	s	namespace:boost::wave::util
boost::wave::util::functor_input	wave/util/functor_input.hpp	/^struct functor_input {$/;"	s	namespace:boost::wave::util
boost::wave::util::functor_input::inner	wave/util/functor_input.hpp	/^    class inner {$/;"	c	struct:boost::wave::util::functor_input	access:public
boost::wave::util::functor_input::inner::Data	wave/util/functor_input.hpp	/^        struct Data {$/;"	s	class:boost::wave::util::functor_input::inner	access:private
boost::wave::util::functor_input::inner::Data::Data	wave/util/functor_input.hpp	/^            Data(FunctorT const &ftor_) $/;"	f	struct:boost::wave::util::functor_input::inner::Data	access:public	signature:(FunctorT const &ftor_)
boost::wave::util::functor_input::inner::Data::curtok	wave/util/functor_input.hpp	/^            value_type curtok;$/;"	m	struct:boost::wave::util::functor_input::inner::Data	access:public
boost::wave::util::functor_input::inner::Data::ftor	wave/util/functor_input.hpp	/^            FunctorT ftor;$/;"	m	struct:boost::wave::util::functor_input::inner::Data	access:public
boost::wave::util::functor_input::inner::Data::was_initialized	wave/util/functor_input.hpp	/^            bool was_initialized;$/;"	m	struct:boost::wave::util::functor_input::inner::Data	access:public
boost::wave::util::functor_input::inner::advance_input	wave/util/functor_input.hpp	/^        void advance_input()$/;"	f	class:boost::wave::util::functor_input::inner	access:public	signature:()
boost::wave::util::functor_input::inner::data	wave/util/functor_input.hpp	/^        mutable Data *data;$/;"	m	class:boost::wave::util::functor_input::inner	access:private
boost::wave::util::functor_input::inner::destroy	wave/util/functor_input.hpp	/^        void destroy()$/;"	f	class:boost::wave::util::functor_input::inner	access:protected	signature:()
boost::wave::util::functor_input::inner::difference_type	wave/util/functor_input.hpp	/^        typedef std::ptrdiff_t difference_type;$/;"	t	class:boost::wave::util::functor_input::inner	access:public
boost::wave::util::functor_input::inner::ensure_initialized	wave/util/functor_input.hpp	/^        void ensure_initialized() const$/;"	f	class:boost::wave::util::functor_input::inner	access:protected	signature:() const
boost::wave::util::functor_input::inner::get_functor	wave/util/functor_input.hpp	/^        FunctorT& get_functor() const$/;"	f	class:boost::wave::util::functor_input::inner	access:public	signature:() const
boost::wave::util::functor_input::inner::get_input	wave/util/functor_input.hpp	/^        reference get_input() const$/;"	f	class:boost::wave::util::functor_input::inner	access:public	signature:() const
boost::wave::util::functor_input::inner::inner	wave/util/functor_input.hpp	/^        inner()$/;"	f	class:boost::wave::util::functor_input::inner	access:protected	signature:()
boost::wave::util::functor_input::inner::inner	wave/util/functor_input.hpp	/^        inner(FunctorT const &x)$/;"	f	class:boost::wave::util::functor_input::inner	access:protected	signature:(FunctorT const &x)
boost::wave::util::functor_input::inner::inner	wave/util/functor_input.hpp	/^        inner(inner const &x)$/;"	f	class:boost::wave::util::functor_input::inner	access:protected	signature:(inner const &x)
boost::wave::util::functor_input::inner::input_at_eof	wave/util/functor_input.hpp	/^        bool input_at_eof() const$/;"	f	class:boost::wave::util::functor_input::inner	access:public	signature:() const
boost::wave::util::functor_input::inner::pointer	wave/util/functor_input.hpp	/^        typedef result_type *pointer;$/;"	t	class:boost::wave::util::functor_input::inner	access:public
boost::wave::util::functor_input::inner::reference	wave/util/functor_input.hpp	/^        typedef result_type &reference;$/;"	t	class:boost::wave::util::functor_input::inner	access:public
boost::wave::util::functor_input::inner::result_type	wave/util/functor_input.hpp	/^        typedef typename FunctorT::result_type result_type;$/;"	t	class:boost::wave::util::functor_input::inner	access:private
boost::wave::util::functor_input::inner::same_input	wave/util/functor_input.hpp	/^        bool same_input(inner const &x) const$/;"	f	class:boost::wave::util::functor_input::inner	access:protected	signature:(inner const &x) const
boost::wave::util::functor_input::inner::swap	wave/util/functor_input.hpp	/^        void swap(inner &x)$/;"	f	class:boost::wave::util::functor_input::inner	access:protected	signature:(inner &x)
boost::wave::util::functor_input::inner::value_type	wave/util/functor_input.hpp	/^        typedef result_type value_type;$/;"	t	class:boost::wave::util::functor_input::inner	access:public
boost::wave::util::get_severity	wave/cpp_exceptions.hpp	/^    get_severity(int level)$/;"	f	namespace:boost::wave::util	signature:(int level)
boost::wave::util::if_block	wave/util/cpp_ifblock.hpp	/^class if_block$/;"	c	namespace:boost::wave::util
boost::wave::util::if_block::enclosing_status	wave/util/cpp_ifblock.hpp	/^   bool enclosing_status;   \/\/ Enclosing #if block is true$/;"	m	class:boost::wave::util::if_block	access:private
boost::wave::util::if_block::get_enclosing_status	wave/util/cpp_ifblock.hpp	/^    bool get_enclosing_status() const { return enclosing_status; }$/;"	f	class:boost::wave::util::if_block	access:public	signature:() const
boost::wave::util::if_block::get_in_else	wave/util/cpp_ifblock.hpp	/^    bool get_in_else() const { return is_in_else; }$/;"	f	class:boost::wave::util::if_block	access:public	signature:() const
boost::wave::util::if_block::get_some_part_status	wave/util/cpp_ifblock.hpp	/^    bool get_some_part_status() const { return some_part_status; }$/;"	f	class:boost::wave::util::if_block	access:public	signature:() const
boost::wave::util::if_block::get_status	wave/util/cpp_ifblock.hpp	/^    bool get_status() const { return status; }$/;"	f	class:boost::wave::util::if_block	access:public	signature:() const
boost::wave::util::if_block::if_block	wave/util/cpp_ifblock.hpp	/^    if_block() :$/;"	f	class:boost::wave::util::if_block	access:public	signature:()
boost::wave::util::if_block::if_block	wave/util/cpp_ifblock.hpp	/^    if_block(bool status_, bool enclosing_status_) : $/;"	f	class:boost::wave::util::if_block	access:public	signature:(bool status_, bool enclosing_status_)
boost::wave::util::if_block::is_in_else	wave/util/cpp_ifblock.hpp	/^   bool is_in_else;         \/\/ Inside the #else part$/;"	m	class:boost::wave::util::if_block	access:private
boost::wave::util::if_block::set_in_else	wave/util/cpp_ifblock.hpp	/^    void set_in_else() { is_in_else = true; }$/;"	f	class:boost::wave::util::if_block	access:public	signature:()
boost::wave::util::if_block::set_status	wave/util/cpp_ifblock.hpp	/^    void set_status(bool status_) $/;"	f	class:boost::wave::util::if_block	access:public	signature:(bool status_)
boost::wave::util::if_block::some_part_status	wave/util/cpp_ifblock.hpp	/^   bool some_part_status;   \/\/ One of the preceding or current #if\/#elif was true$/;"	m	class:boost::wave::util::if_block	access:private
boost::wave::util::if_block::status	wave/util/cpp_ifblock.hpp	/^   bool status;             \/\/ Current block is true$/;"	m	class:boost::wave::util::if_block	access:private
boost::wave::util::if_block_stack	wave/util/cpp_ifblock.hpp	/^class if_block_stack $/;"	c	namespace:boost::wave::util	inherits:std::stack
boost::wave::util::if_block_stack::enter_elif_block	wave/util/cpp_ifblock.hpp	/^    bool enter_elif_block(bool new_status)$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:(bool new_status)
boost::wave::util::if_block_stack::enter_else_block	wave/util/cpp_ifblock.hpp	/^    bool enter_else_block()$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:()
boost::wave::util::if_block_stack::enter_if_block	wave/util/cpp_ifblock.hpp	/^    void enter_if_block(bool new_status)$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:(bool new_status)
boost::wave::util::if_block_stack::exit_if_block	wave/util/cpp_ifblock.hpp	/^    bool exit_if_block()$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:()
boost::wave::util::if_block_stack::get_enclosing_status	wave/util/cpp_ifblock.hpp	/^    bool get_enclosing_status() const$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:() const
boost::wave::util::if_block_stack::get_if_block_depth	wave/util/cpp_ifblock.hpp	/^    size_type get_if_block_depth() const { return this->size(); }$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:() const
boost::wave::util::if_block_stack::get_some_part_status	wave/util/cpp_ifblock.hpp	/^    bool get_some_part_status() const$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:() const
boost::wave::util::if_block_stack::get_status	wave/util/cpp_ifblock.hpp	/^    bool get_status() const$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:() const
boost::wave::util::if_block_stack::is_inside_elsepart	wave/util/cpp_ifblock.hpp	/^    bool is_inside_elsepart() const$/;"	f	class:boost::wave::util::if_block_stack	access:protected	signature:() const
boost::wave::util::if_block_stack::is_inside_ifpart	wave/util/cpp_ifblock.hpp	/^    bool is_inside_ifpart() const$/;"	f	class:boost::wave::util::if_block_stack	access:protected	signature:() const
boost::wave::util::if_block_stack::size_type	wave/util/cpp_ifblock.hpp	/^    typedef std::stack<if_block>::size_type size_type;$/;"	t	class:boost::wave::util::if_block_stack	access:public
boost::wave::util::impl	wave/util/cpp_macromap_utils.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::util
boost::wave::util::impl	wave/util/insert_whitespace_detection.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::util
boost::wave::util::impl	wave/util/macro_helpers.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::util
boost::wave::util::impl	wave/util/unput_queue_iterator.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::util
boost::wave::util::impl::as_string	wave/util/macro_helpers.hpp	/^    as_string (ContainerT const &token_sequence)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT const &token_sequence)
boost::wave::util::impl::as_string	wave/util/macro_helpers.hpp	/^    as_string(IteratorT it, IteratorT const& end)$/;"	f	namespace:boost::wave::util::impl	signature:(IteratorT it, IteratorT const& end)
boost::wave::util::impl::as_stringlit	wave/util/macro_helpers.hpp	/^    as_stringlit (ContainerT const &token_sequence, PositionT const &pos)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT const &token_sequence, PositionT const &pos)
boost::wave::util::impl::as_stringlit	wave/util/macro_helpers.hpp	/^    as_stringlit (std::vector<ContainerT> const &arguments, $/;"	f	namespace:boost::wave::util::impl	signature:(std::vector<ContainerT> const &arguments, typename std::vector<ContainerT>::size_type i, PositionT const &pos)
boost::wave::util::impl::assign_iterator	wave/util/unput_queue_iterator.hpp	/^    struct assign_iterator $/;"	s	namespace:boost::wave::util::impl
boost::wave::util::impl::assign_iterator::do_	wave/util/unput_queue_iterator.hpp	/^        do_ (IteratorT &dest, IteratorT const &src)$/;"	f	struct:boost::wave::util::impl::assign_iterator	access:public	signature:(IteratorT &dest, IteratorT const &src)
boost::wave::util::impl::call_skipped_token_hook	wave/util/cpp_macromap_utils.hpp	/^void call_skipped_token_hook(ContextT& ctx, $/;"	f	namespace:boost::wave::util::impl	signature:(ContextT& ctx, typename ContextT::token_type const& skipped)
boost::wave::util::impl::definition_equals	wave/util/cpp_macromap_utils.hpp	/^definition_equals(ContainerT const &definition, $/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT const &definition, ContainerT const &new_definition)
boost::wave::util::impl::escape_lit	wave/util/macro_helpers.hpp	/^    escape_lit(StringT const &value)$/;"	f	namespace:boost::wave::util::impl	signature:(StringT const &value)
boost::wave::util::impl::find_concat_operator	wave/util/cpp_macromap_utils.hpp	/^class find_concat_operator {$/;"	c	namespace:boost::wave::util::impl
boost::wave::util::impl::find_concat_operator::find_concat_operator	wave/util/cpp_macromap_utils.hpp	/^    find_concat_operator(bool &found_) : found_concat(found_) {}$/;"	f	class:boost::wave::util::impl::find_concat_operator	access:public	signature:(bool &found_)
boost::wave::util::impl::find_concat_operator::found_concat	wave/util/cpp_macromap_utils.hpp	/^    bool &found_concat;$/;"	m	class:boost::wave::util::impl::find_concat_operator	access:private
boost::wave::util::impl::find_concat_operator::operator ()	wave/util/cpp_macromap_utils.hpp	/^    bool operator()(TokenT const &tok)$/;"	f	class:boost::wave::util::impl::find_concat_operator	access:public	signature:(TokenT const &tok)
boost::wave::util::impl::gen_unput_queue_iterator	wave/util/unput_queue_iterator.hpp	/^    struct gen_unput_queue_iterator $/;"	s	namespace:boost::wave::util::impl
boost::wave::util::impl::gen_unput_queue_iterator	wave/util/unput_queue_iterator.hpp	/^    struct gen_unput_queue_iterator<$/;"	s	namespace:boost::wave::util::impl
boost::wave::util::impl::gen_unput_queue_iterator::container_type	wave/util/unput_queue_iterator.hpp	/^        typedef ContainerT  container_type;$/;"	t	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public
boost::wave::util::impl::gen_unput_queue_iterator::generate	wave/util/unput_queue_iterator.hpp	/^        generate(ContainerT &queue, iterator_type &it)$/;"	f	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public	signature:(ContainerT &queue, iterator_type &it)
boost::wave::util::impl::gen_unput_queue_iterator::generate	wave/util/unput_queue_iterator.hpp	/^        generate(ContainerT &queue, iterator_type const &it)$/;"	f	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public	signature:(ContainerT &queue, iterator_type const &it)
boost::wave::util::impl::gen_unput_queue_iterator::generate	wave/util/unput_queue_iterator.hpp	/^        generate(iterator_type &it)$/;"	f	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public	signature:(iterator_type &it)
boost::wave::util::impl::gen_unput_queue_iterator::generate	wave/util/unput_queue_iterator.hpp	/^        generate(iterator_type const &it)$/;"	f	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public	signature:(iterator_type const &it)
boost::wave::util::impl::gen_unput_queue_iterator::iterator_type	wave/util/unput_queue_iterator.hpp	/^            iterator_type;$/;"	t	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public
boost::wave::util::impl::gen_unput_queue_iterator::iterator_type	wave/util/unput_queue_iterator.hpp	/^        typedef IteratorT iterator_type;$/;"	t	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public
boost::wave::util::impl::gen_unput_queue_iterator::last	wave/util/unput_queue_iterator.hpp	/^        gen_unput_queue_iterator<IteratorT, TokenT, ContainerT>::last = $/;"	m	class:boost::wave::util::impl::gen_unput_queue_iterator
boost::wave::util::impl::gen_unput_queue_iterator::last	wave/util/unput_queue_iterator.hpp	/^        static container_type last;$/;"	m	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public
boost::wave::util::impl::gen_unput_queue_iterator::return_type	wave/util/unput_queue_iterator.hpp	/^            return_type;$/;"	t	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public
boost::wave::util::impl::get_full_name	wave/util/cpp_macromap_utils.hpp	/^get_full_name(IteratorT const &begin, IteratorT const &end)$/;"	f	namespace:boost::wave::util::impl	signature:(IteratorT const &begin, IteratorT const &end)
boost::wave::util::impl::handle_alt_leftbrace	wave/util/insert_whitespace_detection.hpp	/^    handle_alt_leftbrace(boost::wave::token_id prev, $/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id )
boost::wave::util::impl::handle_alt_leftbracket	wave/util/insert_whitespace_detection.hpp	/^    handle_alt_leftbracket(boost::wave::token_id prev, $/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id )
boost::wave::util::impl::handle_dot	wave/util/insert_whitespace_detection.hpp	/^    handle_dot(boost::wave::token_id prev, boost::wave::token_id before)$/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id before)
boost::wave::util::impl::handle_fixedpointlit	wave/util/insert_whitespace_detection.hpp	/^    handle_fixedpointlit(boost::wave::token_id prev, $/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id )
boost::wave::util::impl::handle_floatlit	wave/util/insert_whitespace_detection.hpp	/^    handle_floatlit(boost::wave::token_id prev, $/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id )
boost::wave::util::impl::handle_identifier	wave/util/insert_whitespace_detection.hpp	/^    handle_identifier(boost::wave::token_id prev, $/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id before, StringT const &value)
boost::wave::util::impl::handle_intlit	wave/util/insert_whitespace_detection.hpp	/^    handle_intlit(boost::wave::token_id prev, boost::wave::token_id \/*before*\/)$/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id )
boost::wave::util::impl::handle_newline	wave/util/insert_whitespace_detection.hpp	/^    handle_newline(boost::wave::token_id prev, $/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id before)
boost::wave::util::impl::handle_parens	wave/util/insert_whitespace_detection.hpp	/^    handle_parens(boost::wave::token_id prev)$/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev)
boost::wave::util::impl::handle_questionmark	wave/util/insert_whitespace_detection.hpp	/^    handle_questionmark(boost::wave::token_id prev, $/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id )
boost::wave::util::impl::is_special_macroname	wave/util/cpp_macromap_utils.hpp	/^is_special_macroname (StringT const &name)$/;"	f	namespace:boost::wave::util::impl	signature:(StringT const &name)
boost::wave::util::impl::is_whitespace_only	wave/util/cpp_macromap_utils.hpp	/^is_whitespace_only (ContainerT const &argument)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT const &argument)
boost::wave::util::impl::next_token	wave/util/unput_queue_iterator.hpp	/^    struct next_token $/;"	s	namespace:boost::wave::util::impl
boost::wave::util::impl::next_token	wave/util/unput_queue_iterator.hpp	/^    struct next_token<$/;"	s	namespace:boost::wave::util::impl
boost::wave::util::impl::next_token::iterator_type	wave/util/unput_queue_iterator.hpp	/^        typedef unput_queue_iterator<IteratorT, TokenT, ContainerT> iterator_type;$/;"	t	struct:boost::wave::util::impl::next_token	access:public
boost::wave::util::impl::next_token::peek	wave/util/unput_queue_iterator.hpp	/^        peek(IteratorT it, IteratorT end, bool skip_whitespace = true)$/;"	f	struct:boost::wave::util::impl::next_token	access:public	signature:(IteratorT it, IteratorT end, bool skip_whitespace = true)
boost::wave::util::impl::next_token::peek	wave/util/unput_queue_iterator.hpp	/^        peek(iterator_type it, iterator_type end, bool skip_whitespace = true)$/;"	f	struct:boost::wave::util::impl::next_token	access:public	signature:(iterator_type it, iterator_type end, bool skip_whitespace = true)
boost::wave::util::impl::parameters_equal	wave/util/cpp_macromap_utils.hpp	/^parameters_equal(ContainerT const &parameters, ContainerT const &new_parameters)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT const &parameters, ContainerT const &new_parameters)
boost::wave::util::impl::remove_placeholders	wave/util/cpp_macromap_utils.hpp	/^remove_placeholders (ContainerT &replacement_list)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT &replacement_list)
boost::wave::util::impl::replace_ellipsis	wave/util/macro_helpers.hpp	/^    void replace_ellipsis (std::vector<ContainerT> const &arguments,$/;"	f	namespace:boost::wave::util::impl	signature:(std::vector<ContainerT> const &arguments, typename ContainerT::size_type index, ContainerT &expanded, PositionT const &pos)
boost::wave::util::impl::skip_to_token	wave/util/cpp_macromap_utils.hpp	/^skip_to_token(ContextT& ctx, IteratorT &it, IteratorT const &end, $/;"	f	namespace:boost::wave::util::impl	signature:(ContextT& ctx, IteratorT &it, IteratorT const &end, token_id id, bool& seen_newline)
boost::wave::util::impl::skip_whitespace	wave/util/macro_helpers.hpp	/^    skip_whitespace(IteratorT &first, IteratorT const &last)$/;"	f	namespace:boost::wave::util::impl	signature:(IteratorT &first, IteratorT const &last)
boost::wave::util::impl::skip_whitespace	wave/util/macro_helpers.hpp	/^    skip_whitespace(IteratorT &first, IteratorT const &last, ContainerT &queue)$/;"	f	namespace:boost::wave::util::impl	signature:(IteratorT &first, IteratorT const &last, ContainerT &queue)
boost::wave::util::impl::to_string_helper	wave/util/cpp_macromap_utils.hpp	/^struct to_string_helper$/;"	s	namespace:boost::wave::util::impl
boost::wave::util::impl::to_string_helper	wave/util/cpp_macromap_utils.hpp	/^struct to_string_helper<Src, Src>$/;"	s	namespace:boost::wave::util::impl
boost::wave::util::impl::to_string_helper	wave/util/cpp_macromap_utils.hpp	/^struct to_string_helper<Target, char const*>$/;"	s	namespace:boost::wave::util::impl
boost::wave::util::impl::to_string_helper::call	wave/util/cpp_macromap_utils.hpp	/^    static Src const& call(Src const& str)$/;"	f	struct:boost::wave::util::impl::to_string_helper	access:public	signature:(Src const& str)
boost::wave::util::impl::to_string_helper::call	wave/util/cpp_macromap_utils.hpp	/^    static Target call(Src const& str)$/;"	f	struct:boost::wave::util::impl::to_string_helper	access:public	signature:(Src const& str)
boost::wave::util::impl::to_string_helper::call	wave/util/cpp_macromap_utils.hpp	/^    static Target call(char const* str)$/;"	f	struct:boost::wave::util::impl::to_string_helper	access:public	signature:(char const* str)
boost::wave::util::impl::to_string_helper::type	wave/util/cpp_macromap_utils.hpp	/^    typedef Src const& type;$/;"	t	struct:boost::wave::util::impl::to_string_helper	access:public
boost::wave::util::impl::to_string_helper::type	wave/util/cpp_macromap_utils.hpp	/^    typedef Target type;$/;"	t	struct:boost::wave::util::impl::to_string_helper	access:public
boost::wave::util::impl::token_equals	wave/util/cpp_macromap_utils.hpp	/^token_equals(TokenT const &left, TokenT const &right)$/;"	f	namespace:boost::wave::util::impl	signature:(TokenT const &left, TokenT const &right)
boost::wave::util::impl::trim_replacement_list	wave/util/cpp_macromap_utils.hpp	/^trim_replacement_list (ContainerT &replacement_list)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT &replacement_list)
boost::wave::util::impl::trim_sequence	wave/util/cpp_macromap_utils.hpp	/^trim_sequence (ContainerT &argument)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT &argument)
boost::wave::util::impl::trim_sequence_left	wave/util/cpp_macromap_utils.hpp	/^trim_sequence_left (ContainerT &argument)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT &argument)
boost::wave::util::impl::trim_sequence_right	wave/util/cpp_macromap_utils.hpp	/^trim_sequence_right (ContainerT &argument)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT &argument)
boost::wave::util::impl::unescape_lit	wave/util/macro_helpers.hpp	/^    unescape_lit(StringT const &value)$/;"	f	namespace:boost::wave::util::impl	signature:(StringT const &value)
boost::wave::util::impl::would_form_universal_char	wave/util/insert_whitespace_detection.hpp	/^    would_form_universal_char (StringT const &value)$/;"	f	namespace:boost::wave::util::impl	signature:(StringT const &value)
boost::wave::util::include_paths	wave/util/cpp_include_paths.hpp	/^class include_paths$/;"	c	namespace:boost::wave::util
boost::wave::util::include_paths::BOOST_STATIC_CONSTANT	wave/util/cpp_include_paths.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, version = 0x10);$/;"	p	class:boost::wave::util::include_paths	access:public	signature:(unsigned int, version = 0x10)
boost::wave::util::include_paths::BOOST_STATIC_CONSTANT	wave/util/cpp_include_paths.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, version_mask = 0x0f);$/;"	p	class:boost::wave::util::include_paths	access:public	signature:(unsigned int, version_mask = 0x0f)
boost::wave::util::include_paths::add_include_path	wave/util/cpp_include_paths.hpp	/^    bool add_include_path(char const *path_, bool is_system = false)$/;"	f	class:boost::wave::util::include_paths	access:public	signature:(char const *path_, bool is_system = false)
boost::wave::util::include_paths::add_include_path	wave/util/cpp_include_paths.hpp	/^    bool add_include_path(char const *path_, include_list_type &pathes_);$/;"	p	class:boost::wave::util::include_paths	access:protected	signature:(char const *path_, include_list_type &pathes_)
boost::wave::util::include_paths::add_include_path	wave/util/cpp_include_paths.hpp	/^bool include_paths::add_include_path ($/;"	f	class:boost::wave::util::include_paths	signature:( char const *path_, include_list_type &pathes_)
boost::wave::util::include_paths::add_pragma_once_header	wave/util/cpp_include_paths.hpp	/^    bool add_pragma_once_header(std::string const &filename, $/;"	f	class:boost::wave::util::include_paths	access:public	signature:(std::string const &filename, std::string const& guard_name)
boost::wave::util::include_paths::current_dir	wave/util/cpp_include_paths.hpp	/^    boost::filesystem::path current_dir;$/;"	m	class:boost::wave::util::include_paths	access:private
boost::wave::util::include_paths::current_rel_dir	wave/util/cpp_include_paths.hpp	/^    boost::filesystem::path current_rel_dir;$/;"	m	class:boost::wave::util::include_paths	access:private
boost::wave::util::include_paths::find_include_file	wave/util/cpp_include_paths.hpp	/^    bool find_include_file (std::string &s, std::string &dir, $/;"	p	class:boost::wave::util::include_paths	access:protected	signature:(std::string &s, std::string &dir, include_list_type const &pathes, char const *) const
boost::wave::util::include_paths::find_include_file	wave/util/cpp_include_paths.hpp	/^    bool find_include_file (std::string &s, std::string &dir, bool is_system, $/;"	p	class:boost::wave::util::include_paths	access:public	signature:(std::string &s, std::string &dir, bool is_system, char const *current_file) const
boost::wave::util::include_paths::find_include_file	wave/util/cpp_include_paths.hpp	/^bool include_paths::find_include_file (std::string &s, std::string &dir, $/;"	f	class:boost::wave::util::include_paths	signature:(std::string &s, std::string &dir, include_list_type const &pathes, char const *current_file) const
boost::wave::util::include_paths::find_include_file	wave/util/cpp_include_paths.hpp	/^include_paths::find_include_file (std::string &s, std::string &dir, $/;"	f	class:boost::wave::util::include_paths	signature:(std::string &s, std::string &dir, bool is_system, char const *current_file) const
boost::wave::util::include_paths::get_current_directory	wave/util/cpp_include_paths.hpp	/^    boost::filesystem::path get_current_directory() const $/;"	f	class:boost::wave::util::include_paths	access:public	signature:() const
boost::wave::util::include_paths::has_pragma_once	wave/util/cpp_include_paths.hpp	/^    bool has_pragma_once(std::string const &filename)$/;"	f	class:boost::wave::util::include_paths	access:public	signature:(std::string const &filename)
boost::wave::util::include_paths::include_list_type	wave/util/cpp_include_paths.hpp	/^        include_list_type;$/;"	t	class:boost::wave::util::include_paths	access:private
boost::wave::util::include_paths::include_paths	wave/util/cpp_include_paths.hpp	/^    include_paths()$/;"	f	class:boost::wave::util::include_paths	access:public	signature:()
boost::wave::util::include_paths::include_value_type	wave/util/cpp_include_paths.hpp	/^    typedef include_list_type::value_type include_value_type;$/;"	t	class:boost::wave::util::include_paths	access:private
boost::wave::util::include_paths::load	wave/util/cpp_include_paths.hpp	/^    void load(Archive & ar, const unsigned int loaded_version)$/;"	f	class:boost::wave::util::include_paths	access:private	signature:(Archive & ar, const unsigned int loaded_version)
boost::wave::util::include_paths::pragma_once_files	wave/util/cpp_include_paths.hpp	/^    pragma_once_set_type pragma_once_files;$/;"	m	class:boost::wave::util::include_paths	access:private
boost::wave::util::include_paths::pragma_once_set_type	wave/util/cpp_include_paths.hpp	/^        pragma_once_set_type;$/;"	t	class:boost::wave::util::include_paths	access:private
boost::wave::util::include_paths::remove_pragma_once_header	wave/util/cpp_include_paths.hpp	/^    bool remove_pragma_once_header(std::string const& guard_name)$/;"	f	class:boost::wave::util::include_paths	access:public	signature:(std::string const& guard_name)
boost::wave::util::include_paths::save	wave/util/cpp_include_paths.hpp	/^    void save(Archive & ar, const unsigned int version) const$/;"	f	class:boost::wave::util::include_paths	access:private	signature:(Archive & ar, const unsigned int version) const
boost::wave::util::include_paths::set_current_directory	wave/util/cpp_include_paths.hpp	/^    void set_current_directory(char const *path_);$/;"	p	class:boost::wave::util::include_paths	access:public	signature:(char const *path_)
boost::wave::util::include_paths::set_current_directory	wave/util/cpp_include_paths.hpp	/^void include_paths::set_current_directory(char const *path_)$/;"	f	class:boost::wave::util::include_paths	signature:(char const *path_)
boost::wave::util::include_paths::set_sys_include_delimiter	wave/util/cpp_include_paths.hpp	/^    void set_sys_include_delimiter() { was_sys_include_path = true; }$/;"	f	class:boost::wave::util::include_paths	access:public	signature:()
boost::wave::util::include_paths::system_include_paths	wave/util/cpp_include_paths.hpp	/^    include_list_type system_include_paths;$/;"	m	class:boost::wave::util::include_paths	access:private
boost::wave::util::include_paths::user_include_paths	wave/util/cpp_include_paths.hpp	/^    include_list_type user_include_paths;$/;"	m	class:boost::wave::util::include_paths	access:private
boost::wave::util::include_paths::was_sys_include_path	wave/util/cpp_include_paths.hpp	/^    bool was_sys_include_path;          \/\/ saw a set_sys_include_delimiter()$/;"	m	class:boost::wave::util::include_paths	access:private
boost::wave::util::initial_path	wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path initial_path()$/;"	f	namespace:boost::wave::util	signature:()
boost::wave::util::insert_whitespace_detection	wave/util/insert_whitespace_detection.hpp	/^class insert_whitespace_detection $/;"	c	namespace:boost::wave::util
boost::wave::util::insert_whitespace_detection::beforeprev	wave/util/insert_whitespace_detection.hpp	/^    boost::wave::token_id beforeprev;  \/\/ the token before the previous$/;"	m	class:boost::wave::util::insert_whitespace_detection	access:private
boost::wave::util::insert_whitespace_detection::insert_whitespace	wave/util/insert_whitespace_detection.hpp	/^    bool insert_whitespace;            \/\/ enable this component$/;"	m	class:boost::wave::util::insert_whitespace_detection	access:private
boost::wave::util::insert_whitespace_detection::insert_whitespace_detection	wave/util/insert_whitespace_detection.hpp	/^    insert_whitespace_detection(bool insert_whitespace_ = true) $/;"	f	class:boost::wave::util::insert_whitespace_detection	access:public	signature:(bool insert_whitespace_ = true)
boost::wave::util::insert_whitespace_detection::must_insert	wave/util/insert_whitespace_detection.hpp	/^    bool must_insert(boost::wave::token_id current, StringT const &value)$/;"	f	class:boost::wave::util::insert_whitespace_detection	access:public	signature:(boost::wave::token_id current, StringT const &value)
boost::wave::util::insert_whitespace_detection::prev	wave/util/insert_whitespace_detection.hpp	/^    boost::wave::token_id prev;        \/\/ the previous analyzed token$/;"	m	class:boost::wave::util::insert_whitespace_detection	access:private
boost::wave::util::insert_whitespace_detection::shift_tokens	wave/util/insert_whitespace_detection.hpp	/^    void shift_tokens (boost::wave::token_id next_id)$/;"	f	class:boost::wave::util::insert_whitespace_detection	access:public	signature:(boost::wave::token_id next_id)
boost::wave::util::interpret_pragma	wave/util/interpret_pragma.hpp	/^interpret_pragma(ContextT &ctx, typename ContextT::token_type const &act_token,$/;"	f	namespace:boost::wave::util	signature:(ContextT &ctx, typename ContextT::token_type const &act_token, IteratorT it, IteratorT const &end, ContainerT &pending)
boost::wave::util::intrusive_ptr_add_ref	wave/util/macro_definition.hpp	/^intrusive_ptr_add_ref(macro_definition<TokenT, ContainerT>* p)$/;"	f	namespace:boost::wave::util	signature:(macro_definition<TokenT, ContainerT>* p)
boost::wave::util::intrusive_ptr_release	wave/util/macro_definition.hpp	/^intrusive_ptr_release(macro_definition<TokenT, ContainerT>* p)$/;"	f	namespace:boost::wave::util	signature:(macro_definition<TokenT, ContainerT>* p)
boost::wave::util::iteration_context_stack	wave/util/iteration_context.hpp	/^class iteration_context_stack$/;"	c	namespace:boost::wave::util
boost::wave::util::iteration_context_stack::base_type	wave/util/iteration_context.hpp	/^    typedef std::stack<IterationContextT> base_type;$/;"	t	class:boost::wave::util::iteration_context_stack	access:private
boost::wave::util::iteration_context_stack::get_max_include_nesting_depth	wave/util/iteration_context.hpp	/^    size_type get_max_include_nesting_depth() const$/;"	f	class:boost::wave::util::iteration_context_stack	access:public	signature:() const
boost::wave::util::iteration_context_stack::iter_ctx	wave/util/iteration_context.hpp	/^    base_type iter_ctx;$/;"	m	class:boost::wave::util::iteration_context_stack	access:private
boost::wave::util::iteration_context_stack::iteration_context_stack	wave/util/iteration_context.hpp	/^    iteration_context_stack()$/;"	f	class:boost::wave::util::iteration_context_stack	access:public	signature:()
boost::wave::util::iteration_context_stack::max_include_nesting_depth	wave/util/iteration_context.hpp	/^    size_type max_include_nesting_depth;$/;"	m	class:boost::wave::util::iteration_context_stack	access:private
boost::wave::util::iteration_context_stack::pop	wave/util/iteration_context.hpp	/^    void pop() { iter_ctx.pop(); }$/;"	f	class:boost::wave::util::iteration_context_stack	access:public	signature:()
boost::wave::util::iteration_context_stack::push	wave/util/iteration_context.hpp	/^    void push(Context& ctx, PositionT const &pos,$/;"	f	class:boost::wave::util::iteration_context_stack	access:public	signature:(Context& ctx, PositionT const &pos, typename base_type::value_type const &val)
boost::wave::util::iteration_context_stack::set_max_include_nesting_depth	wave/util/iteration_context.hpp	/^    void set_max_include_nesting_depth(size_type new_depth)$/;"	f	class:boost::wave::util::iteration_context_stack	access:public	signature:(size_type new_depth)
boost::wave::util::iteration_context_stack::size	wave/util/iteration_context.hpp	/^    typename base_type::size_type size() const { return iter_ctx.size(); }$/;"	f	class:boost::wave::util::iteration_context_stack	access:public	signature:() const
boost::wave::util::iteration_context_stack::size_type	wave/util/iteration_context.hpp	/^    typedef typename base_type::size_type size_type;$/;"	t	class:boost::wave::util::iteration_context_stack	access:public
boost::wave::util::iteration_context_stack::top	wave/util/iteration_context.hpp	/^    typename base_type::value_type &top() { return iter_ctx.top(); }$/;"	f	class:boost::wave::util::iteration_context_stack	access:public	signature:()
boost::wave::util::last_severity_code	wave/cpp_exceptions.hpp	/^        last_severity_code = severity_commandline_error$/;"	e	enum:boost::wave::util::severity
boost::wave::util::leaf	wave/util/filesystem_compatibility.hpp	/^    inline std::string leaf(boost::filesystem::path const& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& p)
boost::wave::util::load_filepos	wave/util/cpp_include_paths.hpp	/^struct load_filepos$/;"	s	namespace:boost::wave::util
boost::wave::util::load_filepos::get_column	wave/util/cpp_include_paths.hpp	/^    static unsigned int get_column() { return 0; }$/;"	f	struct:boost::wave::util::load_filepos	access:public	signature:()
boost::wave::util::load_filepos::get_file	wave/util/cpp_include_paths.hpp	/^    static std::string get_file() { return "<loading-state>"; }$/;"	f	struct:boost::wave::util::load_filepos	access:public	signature:()
boost::wave::util::load_filepos::get_line	wave/util/cpp_include_paths.hpp	/^    static unsigned int get_line() { return 0; }$/;"	f	struct:boost::wave::util::load_filepos	access:public	signature:()
boost::wave::util::macro_definition	wave/util/macro_definition.hpp	/^struct macro_definition {$/;"	s	namespace:boost::wave::util
boost::wave::util::macro_definition::const_definition_iterator_t	wave/util/macro_definition.hpp	/^        const_definition_iterator_t;$/;"	t	struct:boost::wave::util::macro_definition	access:public
boost::wave::util::macro_definition::const_parameter_iterator_t	wave/util/macro_definition.hpp	/^        const_parameter_iterator_t;$/;"	t	struct:boost::wave::util::macro_definition	access:public
boost::wave::util::macro_definition::definition_container_type	wave/util/macro_definition.hpp	/^    typedef ContainerT          definition_container_type;$/;"	t	struct:boost::wave::util::macro_definition	access:public
boost::wave::util::macro_definition::has_ellipsis	wave/util/macro_definition.hpp	/^    bool has_ellipsis;$/;"	m	struct:boost::wave::util::macro_definition	access:public
boost::wave::util::macro_definition::is_available_for_replacement	wave/util/macro_definition.hpp	/^    bool is_available_for_replacement;$/;"	m	struct:boost::wave::util::macro_definition	access:public
boost::wave::util::macro_definition::is_functionlike	wave/util/macro_definition.hpp	/^    bool is_functionlike;$/;"	m	struct:boost::wave::util::macro_definition	access:public
boost::wave::util::macro_definition::is_predefined	wave/util/macro_definition.hpp	/^    bool is_predefined;$/;"	m	struct:boost::wave::util::macro_definition	access:public
boost::wave::util::macro_definition::macro_definition	wave/util/macro_definition.hpp	/^    macro_definition() $/;"	f	struct:boost::wave::util::macro_definition	access:public	signature:()
boost::wave::util::macro_definition::macro_definition	wave/util/macro_definition.hpp	/^    macro_definition(TokenT const &token_, bool has_parameters, $/;"	f	struct:boost::wave::util::macro_definition	access:public	signature:(TokenT const &token_, bool has_parameters, bool is_predefined_, long uid_)
boost::wave::util::macro_definition::macrodefinition	wave/util/macro_definition.hpp	/^    definition_container_type macrodefinition; \/\/ macro definition token sequence$/;"	m	struct:boost::wave::util::macro_definition	access:public
boost::wave::util::macro_definition::macroname	wave/util/macro_definition.hpp	/^    TokenT macroname;                       \/\/ macro name$/;"	m	struct:boost::wave::util::macro_definition	access:public
boost::wave::util::macro_definition::macroparameters	wave/util/macro_definition.hpp	/^    parameter_container_type macroparameters;  \/\/ formal parameters$/;"	m	struct:boost::wave::util::macro_definition	access:public
boost::wave::util::macro_definition::parameter_container_type	wave/util/macro_definition.hpp	/^    typedef std::vector<TokenT> parameter_container_type;$/;"	t	struct:boost::wave::util::macro_definition	access:public
boost::wave::util::macro_definition::replace_parameters	wave/util/macro_definition.hpp	/^    void replace_parameters()$/;"	f	struct:boost::wave::util::macro_definition	access:public	signature:()
boost::wave::util::macro_definition::replaced_parameters	wave/util/macro_definition.hpp	/^    bool replaced_parameters;$/;"	m	struct:boost::wave::util::macro_definition	access:public
boost::wave::util::macro_definition::serialize	wave/util/macro_definition.hpp	/^    void serialize(Archive &ar, const unsigned int version)$/;"	f	struct:boost::wave::util::macro_definition	access:private	signature:(Archive &ar, const unsigned int version)
boost::wave::util::macro_definition::uid	wave/util/macro_definition.hpp	/^    long uid;                               \/\/ unique id of this macro$/;"	m	struct:boost::wave::util::macro_definition	access:public
boost::wave::util::macro_definition::use_count	wave/util/macro_definition.hpp	/^    boost::detail::atomic_count use_count;$/;"	m	struct:boost::wave::util::macro_definition	access:public
boost::wave::util::macromap	wave/util/cpp_macromap.hpp	/^class macromap {$/;"	c	namespace:boost::wave::util
boost::wave::util::macromap::BOOST_STATIC_CONSTANT	wave/util/cpp_macromap.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, version = 0x10);$/;"	p	class:boost::wave::util::macromap	access:public	signature:(unsigned int, version = 0x10)
boost::wave::util::macromap::BOOST_STATIC_CONSTANT	wave/util/cpp_macromap.hpp	/^    BOOST_STATIC_CONSTANT(unsigned int, version_mask = 0x0f);$/;"	p	class:boost::wave::util::macromap	access:public	signature:(unsigned int, version_mask = 0x0f)
boost::wave::util::macromap::act_token	wave/util/cpp_macromap.hpp	/^    token_type act_token;       \/\/ current token$/;"	m	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::add_macro	wave/util/cpp_macromap.hpp	/^    bool add_macro(token_type const &name, bool has_parameters,$/;"	p	class:boost::wave::util::macromap	access:public	signature:(token_type const &name, bool has_parameters, parameter_container_type &parameters, definition_container_type &definition, bool is_predefined = false, defined_macros_type *scope = 0)
boost::wave::util::macromap::add_macro	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::add_macro(token_type const &name, bool has_parameters,$/;"	f	class:boost::wave::util::macromap	signature:(token_type const &name, bool has_parameters, parameter_container_type &parameters, definition_container_type &definition, bool is_predefined, defined_macros_type *scope)
boost::wave::util::macromap::base_name	wave/util/cpp_macromap.hpp	/^    string_type base_name;      \/\/ the name to be expanded by __BASE_FILE__$/;"	m	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::begin	wave/util/cpp_macromap.hpp	/^    const_name_iterator begin() const$/;"	f	class:boost::wave::util::macromap	access:public	signature:() const
boost::wave::util::macromap::begin	wave/util/cpp_macromap.hpp	/^    name_iterator begin()$/;"	f	class:boost::wave::util::macromap	access:public	signature:()
boost::wave::util::macromap::collect_arguments	wave/util/cpp_macromap.hpp	/^    typename std::vector<ContainerT>::size_type collect_arguments ($/;"	p	class:boost::wave::util::macromap	access:protected	signature:( token_type const curr_token, std::vector<ContainerT> &arguments, IteratorT &next, IteratorT &endparen, IteratorT const &end, SizeT const &parameter_count, bool& seen_newline)
boost::wave::util::macromap::collect_arguments	wave/util/cpp_macromap.hpp	/^    typename std::vector<ContainerT>::size_type collect_arguments ($/;"	p	class:boost::wave::util::macromap	access:protected	signature:( token_type const curr_token, std::vector<ContainerT> &arguments, IteratorT &next, IteratorT const &end, SizeT const &parameter_count, bool& seen_newline)
boost::wave::util::macromap::collect_arguments	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::collect_arguments (token_type const curr_token,$/;"	f	class:boost::wave::util::macromap	signature:(token_type const curr_token, std::vector<ContainerT> &arguments, IteratorT &next, IteratorT const &end, SizeT const &parameter_count, bool& seen_newline)
boost::wave::util::macromap::concat_tokensequence	wave/util/cpp_macromap.hpp	/^    bool concat_tokensequence(ContainerT &expanded);$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(ContainerT &expanded)
boost::wave::util::macromap::concat_tokensequence	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::concat_tokensequence(ContainerT &expanded)$/;"	f	class:boost::wave::util::macromap	signature:(ContainerT &expanded)
boost::wave::util::macromap::const_name_iterator	wave/util/cpp_macromap.hpp	/^    typedef typename defined_macros_type::const_name_iterator const_name_iterator;$/;"	t	class:boost::wave::util::macromap	access:public
boost::wave::util::macromap::ctx	wave/util/cpp_macromap.hpp	/^    ContextT &ctx;              \/\/ context object associated with the macromap$/;"	m	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::current_macros	wave/util/cpp_macromap.hpp	/^    defined_macros_type *current_macros;                   \/\/ current symbol table$/;"	m	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::defined_macros	wave/util/cpp_macromap.hpp	/^    boost::shared_ptr<defined_macros_type> defined_macros; \/\/ global symbol table$/;"	m	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::defined_macros_type	wave/util/cpp_macromap.hpp	/^        defined_macros_type;$/;"	t	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::definition_container_type	wave/util/cpp_macromap.hpp	/^    typedef typename ContextT::token_sequence_type  definition_container_type;$/;"	t	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::end	wave/util/cpp_macromap.hpp	/^    const_name_iterator end() const$/;"	f	class:boost::wave::util::macromap	access:public	signature:() const
boost::wave::util::macromap::end	wave/util/cpp_macromap.hpp	/^    name_iterator end()$/;"	f	class:boost::wave::util::macromap	access:public	signature:()
boost::wave::util::macromap::expand_argument	wave/util/cpp_macromap.hpp	/^    void expand_argument (typename std::vector<ContainerT>::size_type arg,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(typename std::vector<ContainerT>::size_type arg, std::vector<ContainerT> &arguments, std::vector<ContainerT> &expanded_args, bool expand_operator_defined, std::vector<bool> &has_expanded_args)
boost::wave::util::macromap::expand_argument	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::expand_argument ($/;"	f	class:boost::wave::util::macromap	signature:( typename std::vector<ContainerT>::size_type arg, std::vector<ContainerT> &arguments, std::vector<ContainerT> &expanded_args, bool expand_operator_defined, std::vector<bool> &has_expanded_args)
boost::wave::util::macromap::expand_macro	wave/util/cpp_macromap.hpp	/^    bool expand_macro(ContainerT &pending, token_type const &name,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(ContainerT &pending, token_type const &name, typename defined_macros_type::iterator it, IteratorT &first, IteratorT const &last, bool& seen_newline, bool expand_operator_defined, defined_macros_type *scope = 0, ContainerT *queue_symbol = 0)
boost::wave::util::macromap::expand_macro	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::expand_macro(ContainerT &expanded,$/;"	f	class:boost::wave::util::macromap	signature:(ContainerT &expanded, token_type const &curr_token, typename defined_macros_type::iterator it, IteratorT &first, IteratorT const &last, bool& seen_newline, bool expand_operator_defined, defined_macros_type *scope, ContainerT *queue_symbol)
boost::wave::util::macromap::expand_predefined_macro	wave/util/cpp_macromap.hpp	/^    bool expand_predefined_macro(token_type const &curr_token,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(token_type const &curr_token, ContainerT &expanded)
boost::wave::util::macromap::expand_predefined_macro	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::expand_predefined_macro(token_type const &curr_token,$/;"	f	class:boost::wave::util::macromap	signature:(token_type const &curr_token, ContainerT &expanded)
boost::wave::util::macromap::expand_replacement_list	wave/util/cpp_macromap.hpp	/^    void expand_replacement_list($/;"	p	class:boost::wave::util::macromap	access:protected	signature:( macro_definition_type const &macrodefinition, std::vector<ContainerT> &arguments, bool expand_operator_defined, ContainerT &expanded)
boost::wave::util::macromap::expand_replacement_list	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::expand_replacement_list($/;"	f	class:boost::wave::util::macromap	signature:( macro_definition_type const &macrodef, std::vector<ContainerT> &arguments, bool expand_operator_defined, ContainerT &expanded)
boost::wave::util::macromap::expand_tokensequence	wave/util/cpp_macromap.hpp	/^    token_type const &expand_tokensequence(IteratorT &first,$/;"	p	class:boost::wave::util::macromap	access:public	signature:(IteratorT &first, IteratorT const &last, ContainerT &pending, ContainerT &expanded, bool& seen_newline, bool expand_operator_defined)
boost::wave::util::macromap::expand_tokensequence_worker	wave/util/cpp_macromap.hpp	/^    token_type const &expand_tokensequence_worker(ContainerT &pending,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(ContainerT &pending, unput_queue_iterator<IteratorT, token_type, ContainerT> &first, unput_queue_iterator<IteratorT, token_type, ContainerT> const &last, bool& seen_newline, bool expand_operator_defined)
boost::wave::util::macromap::expand_whole_tokensequence	wave/util/cpp_macromap.hpp	/^    void expand_whole_tokensequence(ContainerT &expanded,$/;"	p	class:boost::wave::util::macromap	access:public	signature:(ContainerT &expanded, IteratorT &first, IteratorT const &last, bool expand_operator_defined)
boost::wave::util::macromap::expand_whole_tokensequence	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::expand_whole_tokensequence(ContainerT &expanded,$/;"	f	class:boost::wave::util::macromap	signature:(ContainerT &expanded, IteratorT &first, IteratorT const &last, bool expand_operator_defined)
boost::wave::util::macromap::get_macro	wave/util/cpp_macromap.hpp	/^    bool get_macro(string_type const &name, bool &has_parameters,$/;"	p	class:boost::wave::util::macromap	access:public	signature:(string_type const &name, bool &has_parameters, bool &is_predefined, position_type &pos, parameter_container_type &parameters, definition_container_type &definition, defined_macros_type *scope = 0) const
boost::wave::util::macromap::get_macro	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::get_macro(string_type const &name, bool &has_parameters,$/;"	f	class:boost::wave::util::macromap	signature:(string_type const &name, bool &has_parameters, bool &is_predefined, position_type &pos, parameter_container_type &parameters, definition_container_type &definition, defined_macros_type *scope) const
boost::wave::util::macromap::get_main_pos	wave/util/cpp_macromap.hpp	/^    position_type &get_main_pos() { return main_pos; }$/;"	f	class:boost::wave::util::macromap	access:public	signature:()
boost::wave::util::macromap::get_main_pos	wave/util/cpp_macromap.hpp	/^    position_type const& get_main_pos() const { return main_pos; }$/;"	f	class:boost::wave::util::macromap	access:public	signature:() const
boost::wave::util::macromap::init_predefined_macros	wave/util/cpp_macromap.hpp	/^    void init_predefined_macros(char const *fname = "<Unknown>",$/;"	p	class:boost::wave::util::macromap	access:public	signature:(char const *fname = , defined_macros_type *scope = 0, bool at_global_scope = true)
boost::wave::util::macromap::init_predefined_macros	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::init_predefined_macros(char const *fname,$/;"	f	class:boost::wave::util::macromap	signature:(char const *fname, defined_macros_type *scope, bool at_global_scope)
boost::wave::util::macromap::is_defined	wave/util/cpp_macromap.hpp	/^    bool is_defined(IteratorT const &begin, IteratorT const &end) const;$/;"	p	class:boost::wave::util::macromap	access:public	signature:(IteratorT const &begin, IteratorT const &end) const
boost::wave::util::macromap::is_defined	wave/util/cpp_macromap.hpp	/^    bool is_defined(string_type const &name,$/;"	p	class:boost::wave::util::macromap	access:public	signature:(string_type const &name, typename defined_macros_type::iterator &it, defined_macros_type *scope = 0) const
boost::wave::util::macromap::is_defined	wave/util/cpp_macromap.hpp	/^    bool is_defined(string_type const &str) const;$/;"	p	class:boost::wave::util::macromap	access:public	signature:(string_type const &str) const
boost::wave::util::macromap::is_defined	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::is_defined(IteratorT const &begin,$/;"	f	class:boost::wave::util::macromap	signature:(IteratorT const &begin, IteratorT const &end) const
boost::wave::util::macromap::is_defined	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::is_defined(string_type const &str) const$/;"	f	class:boost::wave::util::macromap	signature:(string_type const &str) const
boost::wave::util::macromap::is_defined	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::is_defined(typename token_type::string_type const &name,$/;"	f	class:boost::wave::util::macromap	signature:(typename token_type::string_type const &name, typename defined_macros_type::iterator &it, defined_macros_type *scope) const
boost::wave::util::macromap::is_valid_concat	wave/util/cpp_macromap.hpp	/^    bool is_valid_concat(string_type new_value,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(string_type new_value, position_type const &pos, ContainerT &rescanned)
boost::wave::util::macromap::is_valid_concat	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::is_valid_concat(string_type new_value,$/;"	f	class:boost::wave::util::macromap	signature:(string_type new_value, position_type const &pos, ContainerT &rescanned)
boost::wave::util::macromap::load	wave/util/cpp_macromap.hpp	/^    void load(Archive &ar, const unsigned int loaded_version)$/;"	f	class:boost::wave::util::macromap	access:private	signature:(Archive &ar, const unsigned int loaded_version)
boost::wave::util::macromap::macro_definition_type	wave/util/cpp_macromap.hpp	/^        macro_definition_type;$/;"	t	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::macro_ref_type	wave/util/cpp_macromap.hpp	/^        macro_ref_type;$/;"	t	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::macro_uid	wave/util/cpp_macromap.hpp	/^    long macro_uid;$/;"	m	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::macromap	wave/util/cpp_macromap.hpp	/^    macromap(ContextT &ctx_)$/;"	f	class:boost::wave::util::macromap	access:public	signature:(ContextT &ctx_)
boost::wave::util::macromap::main_pos	wave/util/cpp_macromap.hpp	/^    position_type main_pos;     \/\/ last token position in the pp_iterator$/;"	m	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::name_iterator	wave/util/cpp_macromap.hpp	/^    typedef typename defined_macros_type::name_iterator name_iterator;$/;"	t	class:boost::wave::util::macromap	access:public
boost::wave::util::macromap::parameter_container_type	wave/util/cpp_macromap.hpp	/^    typedef std::vector<token_type>                 parameter_container_type;$/;"	t	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::position_type	wave/util/cpp_macromap.hpp	/^    typedef typename token_type::position_type      position_type;$/;"	t	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::predef	wave/util/cpp_macromap.hpp	/^    predefined_macros predef;   \/\/ predefined macro support$/;"	m	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::predefine_macro	wave/util/cpp_macromap.hpp	/^    void predefine_macro(defined_macros_type *scope, string_type const &name,$/;"	p	class:boost::wave::util::macromap	access:public	signature:(defined_macros_type *scope, string_type const &name, token_type const &t)
boost::wave::util::macromap::predefine_macro	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::predefine_macro(defined_macros_type *scope,$/;"	f	class:boost::wave::util::macromap	signature:(defined_macros_type *scope, string_type const &name, token_type const &t)
boost::wave::util::macromap::remove_macro	wave/util/cpp_macromap.hpp	/^    bool remove_macro(string_type const &name, position_type const& pos,$/;"	p	class:boost::wave::util::macromap	access:public	signature:(string_type const &name, position_type const& pos, bool even_predefined = false)
boost::wave::util::macromap::remove_macro	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::remove_macro(string_type const &name,$/;"	f	class:boost::wave::util::macromap	signature:(string_type const &name, position_type const& pos, bool even_predefined)
boost::wave::util::macromap::rescan_replacement_list	wave/util/cpp_macromap.hpp	/^    void rescan_replacement_list(token_type const &curr_token,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(token_type const &curr_token, macro_definition_type &macrodef, ContainerT &replacement_list, ContainerT &expanded, bool expand_operator_defined, IteratorT &nfirst, IteratorT const &nlast)
boost::wave::util::macromap::rescan_replacement_list	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::rescan_replacement_list(token_type const &curr_token,$/;"	f	class:boost::wave::util::macromap	signature:(token_type const &curr_token, macro_definition_type &macro_def, ContainerT &replacement_list, ContainerT &expanded, bool expand_operator_defined, IteratorT &nfirst, IteratorT const &nlast)
boost::wave::util::macromap::reset_macromap	wave/util/cpp_macromap.hpp	/^    void reset_macromap();$/;"	p	class:boost::wave::util::macromap	access:public	signature:()
boost::wave::util::macromap::reset_macromap	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::reset_macromap()$/;"	f	class:boost::wave::util::macromap	signature:()
boost::wave::util::macromap::resolve_defined	wave/util/cpp_macromap.hpp	/^    token_type const &resolve_defined(IteratorT &first, IteratorT const &last,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(IteratorT &first, IteratorT const &last, ContainerT &expanded)
boost::wave::util::macromap::resolve_operator_pragma	wave/util/cpp_macromap.hpp	/^    bool resolve_operator_pragma(IteratorT &first,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(IteratorT &first, IteratorT const &last, ContainerT &expanded, bool& seen_newline)
boost::wave::util::macromap::resolve_operator_pragma	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::resolve_operator_pragma(IteratorT &first,$/;"	f	class:boost::wave::util::macromap	signature:(IteratorT &first, IteratorT const &last, ContainerT &pending, bool& seen_newline)
boost::wave::util::macromap::save	wave/util/cpp_macromap.hpp	/^    void save(Archive &ar, const unsigned int version) const$/;"	f	class:boost::wave::util::macromap	access:private	signature:(Archive &ar, const unsigned int version) const
boost::wave::util::macromap::self_type	wave/util/cpp_macromap.hpp	/^    typedef macromap<ContextT>                      self_type;$/;"	t	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::string_type	wave/util/cpp_macromap.hpp	/^    typedef typename token_type::string_type        string_type;$/;"	t	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::token_type	wave/util/cpp_macromap.hpp	/^    typedef typename ContextT::token_type           token_type;$/;"	t	class:boost::wave::util::macromap	access:private
boost::wave::util::macromap::~macromap	wave/util/cpp_macromap.hpp	/^    ~macromap() {}$/;"	f	class:boost::wave::util::macromap	access:public	signature:()
boost::wave::util::mallocator	wave/util/flex_string.hpp	/^template <class T> class mallocator$/;"	c	namespace:boost::wave::util
boost::wave::util::mallocator	wave/util/flex_string.hpp	/^template<> class mallocator<void>$/;"	c	namespace:boost::wave::util
boost::wave::util::mallocator::address	wave/util/flex_string.hpp	/^    const_pointer address(const_reference x) const $/;"	f	class:boost::wave::util::mallocator	access:public	signature:(const_reference x) const
boost::wave::util::mallocator::address	wave/util/flex_string.hpp	/^    pointer address(reference x) const { return &x; }$/;"	f	class:boost::wave::util::mallocator	access:public	signature:(reference x) const
boost::wave::util::mallocator::allocate	wave/util/flex_string.hpp	/^    pointer allocate(size_type n, const_pointer = 0) $/;"	f	class:boost::wave::util::mallocator	access:public	signature:(size_type n, const_pointer = 0)
boost::wave::util::mallocator::const_pointer	wave/util/flex_string.hpp	/^    typedef const value_type* const_pointer;$/;"	t	class:boost::wave::util::mallocator	access:public
boost::wave::util::mallocator::const_pointer	wave/util/flex_string.hpp	/^  typedef const void* const_pointer;$/;"	t	class:boost::wave::util::mallocator	access:private
boost::wave::util::mallocator::const_reference	wave/util/flex_string.hpp	/^    typedef const value_type& const_reference;$/;"	t	class:boost::wave::util::mallocator	access:public
boost::wave::util::mallocator::construct	wave/util/flex_string.hpp	/^    void construct(pointer p, const value_type& x) $/;"	f	class:boost::wave::util::mallocator	access:public	signature:(pointer p, const value_type& x)
boost::wave::util::mallocator::deallocate	wave/util/flex_string.hpp	/^    void deallocate(pointer p, size_type) $/;"	f	class:boost::wave::util::mallocator	access:public	signature:(pointer p, size_type)
boost::wave::util::mallocator::destroy	wave/util/flex_string.hpp	/^    void destroy(pointer p) $/;"	f	class:boost::wave::util::mallocator	access:public	signature:(pointer p)
boost::wave::util::mallocator::difference_type	wave/util/flex_string.hpp	/^    typedef int               difference_type;$/;"	t	class:boost::wave::util::mallocator	access:public
boost::wave::util::mallocator::mallocator	wave/util/flex_string.hpp	/^    mallocator() {}$/;"	f	class:boost::wave::util::mallocator	access:public	signature:()
boost::wave::util::mallocator::mallocator	wave/util/flex_string.hpp	/^    mallocator(const mallocator&) {}$/;"	f	class:boost::wave::util::mallocator	access:public	signature:(const mallocator&)
boost::wave::util::mallocator::max_size	wave/util/flex_string.hpp	/^    size_type max_size() const $/;"	f	class:boost::wave::util::mallocator	access:public	signature:() const
boost::wave::util::mallocator::operator =	wave/util/flex_string.hpp	/^    void operator=(const mallocator&);$/;"	p	class:boost::wave::util::mallocator	access:private	signature:(const mallocator&)
boost::wave::util::mallocator::pointer	wave/util/flex_string.hpp	/^    typedef value_type*       pointer;$/;"	t	class:boost::wave::util::mallocator	access:public
boost::wave::util::mallocator::pointer	wave/util/flex_string.hpp	/^  typedef void*       pointer;$/;"	t	class:boost::wave::util::mallocator	access:private
boost::wave::util::mallocator::rebind	wave/util/flex_string.hpp	/^    struct rebind { typedef mallocator<U> other; };$/;"	s	class:boost::wave::util::mallocator	access:public
boost::wave::util::mallocator::rebind	wave/util/flex_string.hpp	/^  struct rebind { typedef mallocator<U> other; };$/;"	s	class:boost::wave::util::mallocator	access:private
boost::wave::util::mallocator::rebind::other	wave/util/flex_string.hpp	/^    struct rebind { typedef mallocator<U> other; };$/;"	t	struct:boost::wave::util::mallocator::rebind	access:public
boost::wave::util::mallocator::rebind::other	wave/util/flex_string.hpp	/^  struct rebind { typedef mallocator<U> other; };$/;"	t	struct:boost::wave::util::mallocator::rebind	access:public
boost::wave::util::mallocator::reference	wave/util/flex_string.hpp	/^    typedef value_type&       reference;$/;"	t	class:boost::wave::util::mallocator	access:public
boost::wave::util::mallocator::size_type	wave/util/flex_string.hpp	/^    typedef std::size_t       size_type;$/;"	t	class:boost::wave::util::mallocator	access:public
boost::wave::util::mallocator::value_type	wave/util/flex_string.hpp	/^    typedef T                 value_type;$/;"	t	class:boost::wave::util::mallocator	access:public
boost::wave::util::mallocator::value_type	wave/util/flex_string.hpp	/^  typedef void        value_type;$/;"	t	class:boost::wave::util::mallocator	access:private
boost::wave::util::mallocator::~mallocator	wave/util/flex_string.hpp	/^    ~mallocator() {}$/;"	f	class:boost::wave::util::mallocator	access:public	signature:()
boost::wave::util::native_file_string	wave/util/filesystem_compatibility.hpp	/^    inline std::string native_file_string(boost::filesystem::path const& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& p)
boost::wave::util::normalize	wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path normalize(boost::filesystem::path& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path& p)
boost::wave::util::on_exit	wave/util/cpp_macromap_utils.hpp	/^namespace on_exit {$/;"	n	namespace:boost::wave::util
boost::wave::util::on_exit::assign	wave/util/cpp_macromap_utils.hpp	/^    class assign$/;"	c	namespace:boost::wave::util::on_exit
boost::wave::util::on_exit::assign	wave/util/cpp_macromap_utils.hpp	/^    class assign<IteratorT, IteratorT> {$/;"	c	namespace:boost::wave::util::on_exit
boost::wave::util::on_exit::assign::assign	wave/util/cpp_macromap_utils.hpp	/^        assign(IteratorT &it_, IteratorT const &uit_) $/;"	f	class:boost::wave::util::on_exit::assign	access:public	signature:(IteratorT &it_, IteratorT const &uit_)
boost::wave::util::on_exit::assign::assign	wave/util/cpp_macromap_utils.hpp	/^        assign(IteratorT &it_, UnputIteratorT const &uit_) $/;"	f	class:boost::wave::util::on_exit::assign	access:public	signature:(IteratorT &it_, UnputIteratorT const &uit_)
boost::wave::util::on_exit::assign::it	wave/util/cpp_macromap_utils.hpp	/^        IteratorT &it;$/;"	m	class:boost::wave::util::on_exit::assign	access:private
boost::wave::util::on_exit::assign::uit	wave/util/cpp_macromap_utils.hpp	/^        IteratorT const &uit;$/;"	m	class:boost::wave::util::on_exit::assign	access:private
boost::wave::util::on_exit::assign::uit	wave/util/cpp_macromap_utils.hpp	/^        UnputIteratorT const &uit;$/;"	m	class:boost::wave::util::on_exit::assign	access:private
boost::wave::util::on_exit::assign::~assign	wave/util/cpp_macromap_utils.hpp	/^        ~assign() { it = uit.base(); }$/;"	f	class:boost::wave::util::on_exit::assign	access:public	signature:()
boost::wave::util::on_exit::assign::~assign	wave/util/cpp_macromap_utils.hpp	/^        ~assign() { it = uit; }$/;"	f	class:boost::wave::util::on_exit::assign	access:public	signature:()
boost::wave::util::on_exit::pop_front	wave/util/cpp_macromap_utils.hpp	/^    class pop_front {$/;"	c	namespace:boost::wave::util::on_exit
boost::wave::util::on_exit::pop_front::list	wave/util/cpp_macromap_utils.hpp	/^        ContainerT &list;$/;"	m	class:boost::wave::util::on_exit::pop_front	access:private
boost::wave::util::on_exit::pop_front::pop_front	wave/util/cpp_macromap_utils.hpp	/^        pop_front(ContainerT &list_) : list(list_) {}$/;"	f	class:boost::wave::util::on_exit::pop_front	access:public	signature:(ContainerT &list_)
boost::wave::util::on_exit::pop_front::~pop_front	wave/util/cpp_macromap_utils.hpp	/^        ~pop_front() { list.pop_front(); }$/;"	f	class:boost::wave::util::on_exit::pop_front	access:public	signature:()
boost::wave::util::on_exit::reset	wave/util/cpp_macromap_utils.hpp	/^    class reset {$/;"	c	namespace:boost::wave::util::on_exit
boost::wave::util::on_exit::reset::old_value	wave/util/cpp_macromap_utils.hpp	/^        TypeT old_value;$/;"	m	class:boost::wave::util::on_exit::reset	access:private
boost::wave::util::on_exit::reset::reset	wave/util/cpp_macromap_utils.hpp	/^        reset(TypeT &target_value_, TypeT new_value)$/;"	f	class:boost::wave::util::on_exit::reset	access:public	signature:(TypeT &target_value_, TypeT new_value)
boost::wave::util::on_exit::reset::target_value	wave/util/cpp_macromap_utils.hpp	/^        TypeT &target_value;$/;"	m	class:boost::wave::util::on_exit::reset	access:private
boost::wave::util::on_exit::reset::~reset	wave/util/cpp_macromap_utils.hpp	/^        ~reset() { target_value = old_value; }$/;"	f	class:boost::wave::util::on_exit::reset	access:public	signature:()
boost::wave::util::on_exit::splice_pop_front	wave/util/cpp_macromap_utils.hpp	/^    class splice_pop_front {$/;"	c	namespace:boost::wave::util::on_exit
boost::wave::util::on_exit::splice_pop_front::list	wave/util/cpp_macromap_utils.hpp	/^        ContainerT &list;$/;"	m	class:boost::wave::util::on_exit::splice_pop_front	access:private
boost::wave::util::on_exit::splice_pop_front::splice_pop_front	wave/util/cpp_macromap_utils.hpp	/^        splice_pop_front(ContainerT &list_, ContainerT &queue) $/;"	f	class:boost::wave::util::on_exit::splice_pop_front	access:public	signature:(ContainerT &list_, ContainerT &queue)
boost::wave::util::on_exit::splice_pop_front::~splice_pop_front	wave/util/cpp_macromap_utils.hpp	/^        ~splice_pop_front() { list.pop_front(); }$/;"	f	class:boost::wave::util::on_exit::splice_pop_front	access:public	signature:()
boost::wave::util::operator !=	wave/util/flex_string.hpp	/^inline bool operator!=(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const flex_string<E, T, A, S>& rhs)
boost::wave::util::operator !=	wave/util/flex_string.hpp	/^inline bool operator!=(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const typename flex_string<E, T, A, S>::value_type* rhs)
boost::wave::util::operator !=	wave/util/flex_string.hpp	/^inline bool operator!=(const mallocator<T>&, $/;"	f	namespace:boost::wave::util	signature:(const mallocator<T>&, const mallocator<T>&)
boost::wave::util::operator !=	wave/util/flex_string.hpp	/^inline bool operator!=(const typename flex_string<E, T, A, S>::value_type* lhs, $/;"	f	namespace:boost::wave::util	signature:(const typename flex_string<E, T, A, S>::value_type* lhs, const flex_string<E, T, A, S>& rhs)
boost::wave::util::operator +	wave/util/flex_string.hpp	/^flex_string<E, T, A, S> operator+($/;"	f	namespace:boost::wave::util	signature:( typename flex_string<E, T, A, S>::value_type lhs, const flex_string<E, T, A, S>& rhs)
boost::wave::util::operator +	wave/util/flex_string.hpp	/^flex_string<E, T, A, S> operator+(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const flex_string<E, T, A, S>& rhs)
boost::wave::util::operator +	wave/util/flex_string.hpp	/^flex_string<E, T, A, S> operator+(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const typename flex_string<E, T, A, S>::value_type* rhs)
boost::wave::util::operator +	wave/util/flex_string.hpp	/^flex_string<E, T, A, S> operator+(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, typename flex_string<E, T, A, S>::value_type rhs)
boost::wave::util::operator +	wave/util/flex_string.hpp	/^flex_string<E, T, A, S> operator+(const typename flex_string<E, T, A, S>::value_type* lhs, $/;"	f	namespace:boost::wave::util	signature:(const typename flex_string<E, T, A, S>::value_type* lhs, const flex_string<E, T, A, S>& rhs)
boost::wave::util::operator <	wave/util/flex_string.hpp	/^inline bool operator<(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const flex_string<E, T, A, S>& rhs)
boost::wave::util::operator <	wave/util/flex_string.hpp	/^inline bool operator<(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const typename flex_string<E, T, A, S>::value_type* rhs)
boost::wave::util::operator <	wave/util/flex_string.hpp	/^inline bool operator<(const typename flex_string<E, T, A, S>::value_type* lhs, $/;"	f	namespace:boost::wave::util	signature:(const typename flex_string<E, T, A, S>::value_type* lhs, const flex_string<E, T, A, S>& rhs)
boost::wave::util::operator <<	wave/util/file_position.hpp	/^operator<< (std::ostream &o, file_position<StringT> const &pos)$/;"	f	namespace:boost::wave::util	signature:(std::ostream &o, file_position<StringT> const &pos)
boost::wave::util::operator <<	wave/util/flex_string.hpp	/^operator<<($/;"	f	namespace:boost::wave::util	signature:( std::basic_ostream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>& os, const flex_string<E, T, A, S>& str)
boost::wave::util::operator <=	wave/util/flex_string.hpp	/^bool operator<=(const typename flex_string<E, T, A, S>::value_type* lhs, $/;"	f	namespace:boost::wave::util	signature:(const typename flex_string<E, T, A, S>::value_type* lhs, const flex_string<E, T, A, S>& rhs)
boost::wave::util::operator <=	wave/util/flex_string.hpp	/^inline bool operator<=(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const flex_string<E, T, A, S>& rhs)
boost::wave::util::operator <=	wave/util/flex_string.hpp	/^inline bool operator<=(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const typename flex_string<E, T, A, S>::value_type* rhs)
boost::wave::util::operator ==	wave/util/file_position.hpp	/^bool operator== (file_position<StringT> const &lhs, $/;"	f	namespace:boost::wave::util	signature:(file_position<StringT> const &lhs, file_position<StringT> const &rhs)
boost::wave::util::operator ==	wave/util/flex_string.hpp	/^inline bool operator==(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const flex_string<E, T, A, S>& rhs)
boost::wave::util::operator ==	wave/util/flex_string.hpp	/^inline bool operator==(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const typename flex_string<E, T, A, S>::value_type* rhs)
boost::wave::util::operator ==	wave/util/flex_string.hpp	/^inline bool operator==(const mallocator<T>&, $/;"	f	namespace:boost::wave::util	signature:(const mallocator<T>&, const mallocator<T>&)
boost::wave::util::operator ==	wave/util/flex_string.hpp	/^inline bool operator==(const typename flex_string<E, T, A, S>::value_type* lhs, $/;"	f	namespace:boost::wave::util	signature:(const typename flex_string<E, T, A, S>::value_type* lhs, const flex_string<E, T, A, S>& rhs)
boost::wave::util::operator >	wave/util/flex_string.hpp	/^bool operator>(const typename flex_string<E, T, A, S>::value_type* lhs, $/;"	f	namespace:boost::wave::util	signature:(const typename flex_string<E, T, A, S>::value_type* lhs, const flex_string<E, T, A, S>& rhs)
boost::wave::util::operator >	wave/util/flex_string.hpp	/^inline bool operator>(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const flex_string<E, T, A, S>& rhs)
boost::wave::util::operator >	wave/util/flex_string.hpp	/^inline bool operator>(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const typename flex_string<E, T, A, S>::value_type* rhs)
boost::wave::util::operator >=	wave/util/flex_string.hpp	/^bool operator>=(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const flex_string<E, T, A, S>& rhs)
boost::wave::util::operator >=	wave/util/flex_string.hpp	/^bool operator>=(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const typename flex_string<E, T, A, S>::value_type* rhs)
boost::wave::util::operator >=	wave/util/flex_string.hpp	/^inline bool operator>=(const typename flex_string<E, T, A, S>::value_type* lhs, $/;"	f	namespace:boost::wave::util	signature:(const typename flex_string<E, T, A, S>::value_type* lhs, const flex_string<E, T, A, S>& rhs)
boost::wave::util::operator >>	wave/util/flex_string.hpp	/^operator>>($/;"	p	namespace:boost::wave::util	signature:( std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>& is, flex_string<E, T, A, S>& str)
boost::wave::util::pattern_and	wave/util/pattern_parser.hpp	/^    struct pattern_and $/;"	s	namespace:boost::wave::util	inherits:boost::spirit::classic::char_parser
boost::wave::util::pattern_and::pattern	wave/util/pattern_parser.hpp	/^        CharT         pattern;$/;"	m	struct:boost::wave::util::pattern_and	access:public
boost::wave::util::pattern_and::pattern_and	wave/util/pattern_parser.hpp	/^        pattern_and(CharT pattern_, unsigned long pattern_mask_ = 0UL)$/;"	f	struct:boost::wave::util::pattern_and	access:public	signature:(CharT pattern_, unsigned long pattern_mask_ = 0UL)
boost::wave::util::pattern_and::pattern_mask	wave/util/pattern_parser.hpp	/^        unsigned long pattern_mask;$/;"	m	struct:boost::wave::util::pattern_and	access:public
boost::wave::util::pattern_and::test	wave/util/pattern_parser.hpp	/^        bool test(T pattern_) const$/;"	f	struct:boost::wave::util::pattern_and	access:public	signature:(T pattern_) const
boost::wave::util::pattern_p	wave/util/pattern_parser.hpp	/^    pattern_p(CharT pattern, unsigned long pattern_mask = 0UL)$/;"	f	namespace:boost::wave::util	signature:(CharT pattern, unsigned long pattern_mask = 0UL)
boost::wave::util::position_iterator	wave/util/file_position.hpp	/^struct position_iterator $/;"	s	namespace:boost::wave::util	inherits:boost::spirit::classic::position_iterator
boost::wave::util::position_iterator::base_type	wave/util/file_position.hpp	/^    typedef boost::spirit::classic::position_iterator<IteratorT, PositionT> base_type;$/;"	t	struct:boost::wave::util::position_iterator	access:public
boost::wave::util::position_iterator::position_iterator	wave/util/file_position.hpp	/^    position_iterator()$/;"	f	struct:boost::wave::util::position_iterator	access:public	signature:()
boost::wave::util::position_iterator::position_iterator	wave/util/file_position.hpp	/^    position_iterator(IteratorT const &begin, IteratorT const &end,$/;"	f	struct:boost::wave::util::position_iterator	access:public	signature:(IteratorT const &begin, IteratorT const &end, PositionT const &pos)
boost::wave::util::predefined_macros	wave/util/cpp_macromap_predef.hpp	/^    class predefined_macros $/;"	c	namespace:boost::wave::util
boost::wave::util::predefined_macros::compilation_time_	wave/util/cpp_macromap_predef.hpp	/^        boost::wave::util::time_conversion_helper compilation_time_;$/;"	m	class:boost::wave::util::predefined_macros	access:private
boost::wave::util::predefined_macros::datestr_	wave/util/cpp_macromap_predef.hpp	/^        string_type datestr_;     \/\/ __DATE__$/;"	m	class:boost::wave::util::predefined_macros	access:private
boost::wave::util::predefined_macros::dynamic_data	wave/util/cpp_macromap_predef.hpp	/^        dynamic_macros const& dynamic_data(std::size_t i) const$/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:(std::size_t i) const
boost::wave::util::predefined_macros::dynamic_macros	wave/util/cpp_macromap_predef.hpp	/^        struct dynamic_macros {$/;"	s	class:boost::wave::util::predefined_macros	access:public
boost::wave::util::predefined_macros::dynamic_macros::generator	wave/util/cpp_macromap_predef.hpp	/^            string_type (predefined_macros:: *generator)() const;$/;"	m	struct:boost::wave::util::predefined_macros::dynamic_macros	access:public
boost::wave::util::predefined_macros::dynamic_macros::name	wave/util/cpp_macromap_predef.hpp	/^            char const *name;$/;"	m	struct:boost::wave::util::predefined_macros::dynamic_macros	access:public
boost::wave::util::predefined_macros::dynamic_macros::token_id	wave/util/cpp_macromap_predef.hpp	/^            boost::wave::token_id token_id;$/;"	m	struct:boost::wave::util::predefined_macros::dynamic_macros	access:public
boost::wave::util::predefined_macros::get_config	wave/util/cpp_macromap_predef.hpp	/^        string_type get_config() const$/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:() const
boost::wave::util::predefined_macros::get_date	wave/util/cpp_macromap_predef.hpp	/^        string_type get_date() const { return datestr_; }     \/\/ __DATE__ $/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:() const
boost::wave::util::predefined_macros::get_fullversion	wave/util/cpp_macromap_predef.hpp	/^        string_type get_fullversion() const { return version_; }$/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:() const
boost::wave::util::predefined_macros::get_time	wave/util/cpp_macromap_predef.hpp	/^        string_type get_time() const { return timestr_; }     \/\/ __TIME__$/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:() const
boost::wave::util::predefined_macros::get_version	wave/util/cpp_macromap_predef.hpp	/^        string_type get_version() const$/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:() const
boost::wave::util::predefined_macros::get_versionstr	wave/util/cpp_macromap_predef.hpp	/^        string_type get_versionstr() const { return versionstr_; }$/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:() const
boost::wave::util::predefined_macros::predefined_macros	wave/util/cpp_macromap_predef.hpp	/^        predefined_macros() $/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:()
boost::wave::util::predefined_macros::reset	wave/util/cpp_macromap_predef.hpp	/^        void reset()$/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:()
boost::wave::util::predefined_macros::reset_datestr	wave/util/cpp_macromap_predef.hpp	/^        void reset_datestr()$/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:()
boost::wave::util::predefined_macros::reset_timestr	wave/util/cpp_macromap_predef.hpp	/^        void reset_timestr()$/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:()
boost::wave::util::predefined_macros::reset_version	wave/util/cpp_macromap_predef.hpp	/^        void reset_version()$/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:()
boost::wave::util::predefined_macros::reset_versionstr	wave/util/cpp_macromap_predef.hpp	/^        void reset_versionstr()$/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:()
boost::wave::util::predefined_macros::static_data_c99	wave/util/cpp_macromap_predef.hpp	/^        static_macros const& static_data_c99(std::size_t i) const$/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:(std::size_t i) const
boost::wave::util::predefined_macros::static_data_cpp	wave/util/cpp_macromap_predef.hpp	/^        static_macros const& static_data_cpp(std::size_t i) const$/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:(std::size_t i) const
boost::wave::util::predefined_macros::static_data_cpp0x	wave/util/cpp_macromap_predef.hpp	/^        static_macros const& static_data_cpp0x(std::size_t i) const$/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:(std::size_t i) const
boost::wave::util::predefined_macros::static_macros	wave/util/cpp_macromap_predef.hpp	/^        struct static_macros {$/;"	s	class:boost::wave::util::predefined_macros	access:public
boost::wave::util::predefined_macros::static_macros::name	wave/util/cpp_macromap_predef.hpp	/^            char const *name;$/;"	m	struct:boost::wave::util::predefined_macros::static_macros	access:public
boost::wave::util::predefined_macros::static_macros::token_id	wave/util/cpp_macromap_predef.hpp	/^            boost::wave::token_id token_id;$/;"	m	struct:boost::wave::util::predefined_macros::static_macros	access:public
boost::wave::util::predefined_macros::static_macros::value	wave/util/cpp_macromap_predef.hpp	/^            char const *value;$/;"	m	struct:boost::wave::util::predefined_macros::static_macros	access:public
boost::wave::util::predefined_macros::string_type	wave/util/cpp_macromap_predef.hpp	/^        typedef BOOST_WAVE_STRINGTYPE string_type;$/;"	t	class:boost::wave::util::predefined_macros	access:private
boost::wave::util::predefined_macros::timestr_	wave/util/cpp_macromap_predef.hpp	/^        string_type timestr_;     \/\/ __TIME__$/;"	m	class:boost::wave::util::predefined_macros	access:private
boost::wave::util::predefined_macros::version_	wave/util/cpp_macromap_predef.hpp	/^        string_type version_;     \/\/ __SPIRIT_PP_VERSION__\/__WAVE_VERSION__$/;"	m	class:boost::wave::util::predefined_macros	access:private
boost::wave::util::predefined_macros::versionstr_	wave/util/cpp_macromap_predef.hpp	/^        string_type versionstr_;  \/\/ __SPIRIT_PP_VERSION_STR__\/__WAVE_VERSION_STR__$/;"	m	class:boost::wave::util::predefined_macros	access:private
boost::wave::util::report_invalid_concatenation	wave/util/cpp_macromap.hpp	/^inline void report_invalid_concatenation(Context& ctx,$/;"	f	namespace:boost::wave::util	signature:(Context& ctx, typename Context::token_type const& prev, typename Context::token_type const& next, typename Context::position_type const& main_pos)
boost::wave::util::retrieve_macrodefinition	wave/util/cpp_iterator.hpp	/^retrieve_macrodefinition($/;"	f	namespace:boost::wave::util	signature:( ParseNodeT const &node, boost::spirit::classic::parser_id id, ContainerT &macrodefinition, PositionT& act_pos, bool update_position)
boost::wave::util::retrieve_macroname	wave/util/cpp_iterator.hpp	/^retrieve_macroname(ContextT& ctx, ParseNodeT const &node,$/;"	f	namespace:boost::wave::util	signature:(ContextT& ctx, ParseNodeT const &node, boost::spirit::classic::parser_id id, TokenT &macroname, PositionT& act_pos, bool update_position)
boost::wave::util::severity	wave/cpp_exceptions.hpp	/^    enum severity {$/;"	g	namespace:boost::wave::util
boost::wave::util::severity_commandline_error	wave/cpp_exceptions.hpp	/^        severity_commandline_error,$/;"	e	enum:boost::wave::util::severity
boost::wave::util::severity_error	wave/cpp_exceptions.hpp	/^        severity_error,$/;"	e	enum:boost::wave::util::severity
boost::wave::util::severity_fatal	wave/cpp_exceptions.hpp	/^        severity_fatal,$/;"	e	enum:boost::wave::util::severity
boost::wave::util::severity_remark	wave/cpp_exceptions.hpp	/^        severity_remark = 0,$/;"	e	enum:boost::wave::util::severity
boost::wave::util::severity_warning	wave/cpp_exceptions.hpp	/^        severity_warning,$/;"	e	enum:boost::wave::util::severity
boost::wave::util::swap	wave/util/flex_string.hpp	/^void swap(flex_string<E, T, A, S>& lhs, flex_string<E, T, A, S>& rhs)$/;"	f	namespace:boost::wave::util	signature:(flex_string<E, T, A, S>& lhs, flex_string<E, T, A, S>& rhs)
boost::wave::util::symbol_table	wave/util/symbol_table.hpp	/^struct symbol_table $/;"	s	namespace:boost::wave::util	inherits:std::map
boost::wave::util::symbol_table::base_type	wave/util/symbol_table.hpp	/^    typedef std::map<StringT, boost::shared_ptr<MacroDefT> > base_type;$/;"	t	struct:boost::wave::util::symbol_table	access:public
boost::wave::util::symbol_table::const_iterator_type	wave/util/symbol_table.hpp	/^    typedef typename base_type::const_iterator const_iterator_type;$/;"	t	struct:boost::wave::util::symbol_table	access:public
boost::wave::util::symbol_table::const_name_iterator	wave/util/symbol_table.hpp	/^        const_name_iterator;$/;"	t	struct:boost::wave::util::symbol_table	access:public
boost::wave::util::symbol_table::get_first	wave/util/symbol_table.hpp	/^    struct get_first$/;"	s	struct:boost::wave::util::symbol_table	access:private
boost::wave::util::symbol_table::get_first::operator ()	wave/util/symbol_table.hpp	/^        StringT1 const& operator() (std::pair<First, Second> const& p) const$/;"	f	struct:boost::wave::util::symbol_table::get_first	access:public	signature:(std::pair<First, Second> const& p) const
boost::wave::util::symbol_table::get_first::result_type	wave/util/symbol_table.hpp	/^        typedef StringT1 const& result_type;$/;"	t	struct:boost::wave::util::symbol_table::get_first	access:public
boost::wave::util::symbol_table::iterator_type	wave/util/symbol_table.hpp	/^    typedef typename base_type::iterator iterator_type;$/;"	t	struct:boost::wave::util::symbol_table	access:public
boost::wave::util::symbol_table::make_iterator	wave/util/symbol_table.hpp	/^    transform_iterator<unary_functor, Iterator> make_iterator(Iterator it)$/;"	f	struct:boost::wave::util::symbol_table	access:public	signature:(Iterator it)
boost::wave::util::symbol_table::name_iterator	wave/util/symbol_table.hpp	/^        name_iterator;$/;"	t	struct:boost::wave::util::symbol_table	access:public
boost::wave::util::symbol_table::serialize	wave/util/symbol_table.hpp	/^    void serialize(Archive &ar, const unsigned int version)$/;"	f	struct:boost::wave::util::symbol_table	access:private	signature:(Archive &ar, const unsigned int version)
boost::wave::util::symbol_table::symbol_table	wave/util/symbol_table.hpp	/^    symbol_table(long uid_ = 0) $/;"	f	struct:boost::wave::util::symbol_table	access:public	signature:(long uid_ = 0)
boost::wave::util::symbol_table::unary_functor	wave/util/symbol_table.hpp	/^    typedef get_first<StringT> unary_functor;$/;"	t	struct:boost::wave::util::symbol_table	access:private
boost::wave::util::throw_	wave/cpp_throw.hpp	/^    void throw_(Context& ctx, typename Exception::error_code code, $/;"	f	namespace:boost::wave::util	signature:(Context& ctx, typename Exception::error_code code, S1 msg, Pos const& pos)
boost::wave::util::throw_	wave/cpp_throw.hpp	/^    void throw_(Context& ctx, typename Exception::error_code code, $/;"	f	namespace:boost::wave::util	signature:(Context& ctx, typename Exception::error_code code, S1 msg, Pos const& pos, S2 name)
boost::wave::util::throw_	wave/cpp_throw.hpp	/^    void throw_(typename Exception::error_code code, S1 msg, Pos const& pos)$/;"	f	namespace:boost::wave::util	signature:(typename Exception::error_code code, S1 msg, Pos const& pos)
boost::wave::util::throw_	wave/cpp_throw.hpp	/^    void throw_(typename Exception::error_code code, S1 msg, Pos const& pos, $/;"	f	namespace:boost::wave::util	signature:(typename Exception::error_code code, S1 msg, Pos const& pos, S2 name)
boost::wave::util::time_conversion	wave/util/time_conversion_helper.hpp	/^namespace time_conversion {$/;"	n	namespace:boost::wave::util
boost::wave::util::time_conversion::time_conversion_grammar	wave/util/time_conversion_helper.hpp	/^    class time_conversion_grammar :$/;"	c	namespace:boost::wave::util::time_conversion	inherits:boost::spirit::classic::grammar
boost::wave::util::time_conversion::time_conversion_grammar::correct_year	wave/util/time_conversion_helper.hpp	/^        void correct_year() $/;"	f	class:boost::wave::util::time_conversion::time_conversion_grammar	access:public	signature:()
boost::wave::util::time_conversion::time_conversion_grammar::definition	wave/util/time_conversion_helper.hpp	/^        struct definition {$/;"	s	class:boost::wave::util::time_conversion::time_conversion_grammar	access:public
boost::wave::util::time_conversion::time_conversion_grammar::definition::boost::spirit::classic::start	wave/util/time_conversion_helper.hpp	/^            start() const { return time_rule; }$/;"	f	class:boost::wave::util::time_conversion::time_conversion_grammar::definition::boost::spirit::classic	access:public	signature:() const
boost::wave::util::time_conversion::time_conversion_grammar::definition::definition	wave/util/time_conversion_helper.hpp	/^            definition(time_conversion_grammar const &self)$/;"	f	struct:boost::wave::util::time_conversion::time_conversion_grammar::definition	access:public	signature:(time_conversion_grammar const &self)
boost::wave::util::time_conversion::time_conversion_grammar::definition::month	wave/util/time_conversion_helper.hpp	/^            boost::spirit::classic::symbols<> month;$/;"	m	struct:boost::wave::util::time_conversion::time_conversion_grammar::definition	access:public
boost::wave::util::time_conversion::time_conversion_grammar::definition::time_rule	wave/util/time_conversion_helper.hpp	/^            boost::spirit::classic::rule<ScannerT> time_rule;$/;"	m	struct:boost::wave::util::time_conversion::time_conversion_grammar::definition	access:public
boost::wave::util::time_conversion::time_conversion_grammar::fYearIsCorrected	wave/util/time_conversion_helper.hpp	/^        bool fYearIsCorrected;$/;"	m	class:boost::wave::util::time_conversion::time_conversion_grammar	access:public
boost::wave::util::time_conversion::time_conversion_grammar::time_conversion_grammar	wave/util/time_conversion_helper.hpp	/^        time_conversion_grammar() : fYearIsCorrected(false)$/;"	f	class:boost::wave::util::time_conversion::time_conversion_grammar	access:public	signature:()
boost::wave::util::time_conversion::time_conversion_grammar::time_stamp	wave/util/time_conversion_helper.hpp	/^        mutable tm time_stamp;$/;"	m	class:boost::wave::util::time_conversion::time_conversion_grammar	access:public
boost::wave::util::time_conversion::time_conversion_helper	wave/util/time_conversion_helper.hpp	/^    class time_conversion_helper$/;"	c	namespace:boost::wave::util::time_conversion
boost::wave::util::time_conversion::time_conversion_helper::compile_time	wave/util/time_conversion_helper.hpp	/^        time_t compile_time; $/;"	m	class:boost::wave::util::time_conversion::time_conversion_helper	access:private
boost::wave::util::time_conversion::time_conversion_helper::get_time	wave/util/time_conversion_helper.hpp	/^        time_t get_time() const { return compile_time; }$/;"	f	class:boost::wave::util::time_conversion::time_conversion_helper	access:public	signature:() const
boost::wave::util::time_conversion::time_conversion_helper::time_conversion_helper	wave/util/time_conversion_helper.hpp	/^        time_conversion_helper(char const *act_time) : compile_time(0)$/;"	f	class:boost::wave::util::time_conversion::time_conversion_helper	access:public	signature:(char const *act_time)
boost::wave::util::to	wave/util/cpp_include_paths.hpp	/^struct to {};$/;"	s	namespace:boost::wave::util
boost::wave::util::to_string	wave/util/cpp_macromap_utils.hpp	/^to_string(Src const& src)$/;"	f	namespace:boost::wave::util	signature:(Src const& src)
boost::wave::util::unput_queue_iterator	wave/util/unput_queue_iterator.hpp	/^class unput_queue_iterator $/;"	c	namespace:boost::wave::util	inherits:boost::iterator_adaptor
boost::wave::util::unput_queue_iterator::base_type	wave/util/unput_queue_iterator.hpp	/^        base_type;$/;"	t	class:boost::wave::util::unput_queue_iterator	access:private
boost::wave::util::unput_queue_iterator::container_type	wave/util/unput_queue_iterator.hpp	/^    typedef ContainerT  container_type;$/;"	t	class:boost::wave::util::unput_queue_iterator	access:public
boost::wave::util::unput_queue_iterator::dereference	wave/util/unput_queue_iterator.hpp	/^    typename base_type::reference dereference() const$/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:() const
boost::wave::util::unput_queue_iterator::equal	wave/util/unput_queue_iterator.hpp	/^    bool equal($/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:( boost::iterator_adaptor<OtherDerivedT, OtherIteratorT, V, C, R, D> const &x) const
boost::wave::util::unput_queue_iterator::get_base_iterator	wave/util/unput_queue_iterator.hpp	/^    IteratorT &get_base_iterator() $/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:()
boost::wave::util::unput_queue_iterator::get_base_iterator	wave/util/unput_queue_iterator.hpp	/^    IteratorT const &get_base_iterator() const $/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:() const
boost::wave::util::unput_queue_iterator::get_unput_queue	wave/util/unput_queue_iterator.hpp	/^    ContainerT &get_unput_queue() $/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:()
boost::wave::util::unput_queue_iterator::get_unput_queue	wave/util/unput_queue_iterator.hpp	/^    ContainerT const &get_unput_queue() const $/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:() const
boost::wave::util::unput_queue_iterator::increment	wave/util/unput_queue_iterator.hpp	/^    void increment()$/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:()
boost::wave::util::unput_queue_iterator::iterator_type	wave/util/unput_queue_iterator.hpp	/^    typedef IteratorT   iterator_type;$/;"	t	class:boost::wave::util::unput_queue_iterator	access:public
boost::wave::util::unput_queue_iterator::operator =	wave/util/unput_queue_iterator.hpp	/^    unput_queue_iterator &operator= (unput_queue_iterator const &rhs)$/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:(unput_queue_iterator const &rhs)
boost::wave::util::unput_queue_iterator::unput_queue	wave/util/unput_queue_iterator.hpp	/^    ContainerT &unput_queue;$/;"	m	class:boost::wave::util::unput_queue_iterator	access:private
boost::wave::util::unput_queue_iterator::unput_queue_iterator	wave/util/unput_queue_iterator.hpp	/^    unput_queue_iterator(IteratorT const &it, ContainerT &queue)$/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:(IteratorT const &it, ContainerT &queue)
bot	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* bot;     \/* beginning of the current buffer *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
branch_path	wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path branch_path(boost::filesystem::path const& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& p)
buf_	wave/util/flex_string.hpp	/^        mutable char buf_[sizeof(Storage)];$/;"	m	union:boost::wave::util::CowString::__anon6	access:public
buf_	wave/util/flex_string.hpp	/^        mutable value_type buf_[maxSmallString + 1];$/;"	m	union:boost::wave::util::SmallStringOpt::__anon5	access:public
buffer	wave/cpp_exceptions.hpp	/^    char buffer[512];$/;"	m	class:boost::wave::preprocess_exception	access:private
buffer	wave/cpplexer/cpplexer_exceptions.hpp	/^    char buffer[512];$/;"	m	class:boost::wave::cpplexer::lexing_exception	access:private
buffer_	wave/util/flex_string.hpp	/^        E buffer_[1];$/;"	m	struct:boost::wave::util::SimpleStringStorage::Data	access:public
c_str	wave/util/flex_string.hpp	/^    const E* c_str() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
c_str	wave/util/flex_string.hpp	/^    const E* c_str() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
c_str	wave/util/flex_string.hpp	/^    const E* c_str() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
c_str	wave/util/flex_string.hpp	/^    const E* c_str() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
c_str	wave/util/flex_string.hpp	/^    const value_type* c_str() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
c_str	wave/util/flex_string.hpp	/^    const value_type* c_str() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
cache	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    lexer<IteratorT, PositionT, TokenT>::cache =$/;"	m	class:boost::wave::cpplexer::re2clex::lexer
cache	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    static token_cache<string_type> const cache;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
cache	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    token_cache<string_type> const cache;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
cache	wave/cpplexer/token_cache.hpp	/^    std::vector<StringT> cache;$/;"	m	class:boost::wave::cpplexer::token_cache	access:private
call	wave/util/cpp_macromap_utils.hpp	/^    static Src const& call(Src const& str)$/;"	f	struct:boost::wave::util::impl::to_string_helper	access:public	signature:(Src const& str)
call	wave/util/cpp_macromap_utils.hpp	/^    static Target call(Src const& str)$/;"	f	struct:boost::wave::util::impl::to_string_helper	access:public	signature:(Src const& str)
call	wave/util/cpp_macromap_utils.hpp	/^    static Target call(char const* str)$/;"	f	struct:boost::wave::util::impl::to_string_helper	access:public	signature:(char const* str)
call_found_directive_hook	wave/util/cpp_iterator.hpp	/^    bool call_found_directive_hook(ContextT& ctx,$/;"	f	namespace:boost::wave::impl::impl	signature:(ContextT& ctx, typename ContextT::token_type const& found_directive)
call_skipped_token_hook	wave/util/cpp_macromap_utils.hpp	/^void call_skipped_token_hook(ContextT& ctx, $/;"	f	namespace:boost::wave::util::impl	signature:(ContextT& ctx, typename ContextT::token_type const& skipped)
capacity	wave/util/flex_string.hpp	/^    size_type capacity() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
capacity	wave/util/flex_string.hpp	/^    size_type capacity() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
capacity	wave/util/flex_string.hpp	/^    size_type capacity() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
capacity	wave/util/flex_string.hpp	/^    size_type capacity() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
capacity	wave/util/flex_string.hpp	/^    size_type capacity() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
capacity	wave/util/flex_string.hpp	/^    size_type capacity() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
ccomment_count_newlines	wave/whitespace_handling.hpp	/^    int ccomment_count_newlines(TokenT const& token)$/;"	f	namespace:boost::wave::context_policies::util	signature:(TokenT const& token)
ccomment_has_newline	wave/whitespace_handling.hpp	/^    bool ccomment_has_newline(TokenT const& token)$/;"	f	namespace:boost::wave::context_policies::util	signature:(TokenT const& token)
ch_lit	wave/grammars/cpp_chlit_grammar.hpp	/^        rule_t ch_lit;$/;"	m	struct:boost::wave::grammars::chlit_grammar::definition	access:public
character_literal_out_of_range	wave/cpp_exceptions.hpp	/^        character_literal_out_of_range,$/;"	e	enum:boost::wave::preprocess_exception::error_code
check_policy	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef boost::spirit::iterator_policies::buf_id_check check_policy;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
check_policy	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef boost::spirit::iterator_policies::no_check check_policy;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
chlit_closure	wave/grammars/cpp_chlit_grammar.hpp	/^    struct chlit_closure $/;"	s	namespace:boost::wave::grammars::closures	inherits:boost::spirit::classic::closure
chlit_grammar	wave/grammars/cpp_chlit_grammar.hpp	/^    chlit_grammar()$/;"	f	struct:boost::wave::grammars::chlit_grammar	access:public	signature:()
chlit_grammar	wave/grammars/cpp_chlit_grammar.hpp	/^    chlit_grammar(chlit_grammar const&);$/;"	p	struct:boost::wave::grammars::chlit_grammar	access:public	signature:(chlit_grammar const&)
chlit_grammar	wave/grammars/cpp_chlit_grammar.hpp	/^struct chlit_grammar :$/;"	s	namespace:boost::wave::grammars	inherits:boost::spirit::classic::grammar
chlit_grammar_gen	wave/grammars/cpp_literal_grammar_gen.hpp	/^struct BOOST_WAVE_DECL chlit_grammar_gen {$/;"	s	namespace:boost::wave::grammars
classic	wave/util/file_position.hpp	/^namespace spirit { namespace classic {$/;"	n	namespace:boost::spirit
classify_universal_char	wave/cpplexer/validate_universal_char.hpp	/^classify_universal_char (unsigned long ch)$/;"	f	namespace:boost::wave::cpplexer::impl	signature:(unsigned long ch)
clear	wave/util/flex_string.hpp	/^    void clear()$/;"	f	class:boost::wave::util::flex_string	access:public	signature:()
closure_type	wave/grammars/cpp_expression_grammar.hpp	/^        typedef closures::cpp_expr_closure closure_type;$/;"	t	struct:boost::wave::grammars::expression_grammar::definition	access:public
closure_value	wave/grammars/cpp_expression_value.hpp	/^    closure_value(value_error valid_ = error_noerror) $/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(value_error valid_ = error_noerror)
closure_value	wave/grammars/cpp_expression_value.hpp	/^    explicit closure_value(bool b, value_error valid_ = error_noerror) $/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(bool b, value_error valid_ = error_noerror)
closure_value	wave/grammars/cpp_expression_value.hpp	/^    explicit closure_value(int i, value_error valid_ = error_noerror) $/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(int i, value_error valid_ = error_noerror)
closure_value	wave/grammars/cpp_expression_value.hpp	/^    explicit closure_value(int_literal_type i, value_error valid_ = error_noerror) $/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(int_literal_type i, value_error valid_ = error_noerror)
closure_value	wave/grammars/cpp_expression_value.hpp	/^    explicit closure_value(uint_literal_type ui, value_error valid_ = error_noerror) $/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(uint_literal_type ui, value_error valid_ = error_noerror)
closure_value	wave/grammars/cpp_expression_value.hpp	/^    explicit closure_value(unsigned int ui, value_error valid_ = error_noerror) $/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(unsigned int ui, value_error valid_ = error_noerror)
closure_value	wave/grammars/cpp_expression_value.hpp	/^class closure_value {$/;"	c	namespace:boost::wave::grammars::closures
closures	wave/grammars/cpp_chlit_grammar.hpp	/^namespace closures {$/;"	n	namespace:boost::wave::grammars
closures	wave/grammars/cpp_expression_grammar.hpp	/^namespace closures {$/;"	n	namespace:boost::wave::grammars
closures	wave/grammars/cpp_expression_value.hpp	/^namespace closures {$/;"	n	namespace:boost::wave::grammars
closures	wave/grammars/cpp_intlit_grammar.hpp	/^namespace closures {$/;"	n	namespace:boost::wave::grammars
cmp_equality	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t cmp_equality, cmp_relational;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
cmp_equality_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t cmp_equality_nocalc, cmp_relational_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
cmp_relational	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t cmp_equality, cmp_relational;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
cmp_relational_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t cmp_equality_nocalc, cmp_relational_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
code	wave/cpp_exceptions.hpp	/^    error_code code;$/;"	m	class:boost::wave::preprocess_exception	access:private
code	wave/cpplexer/cpplexer_exceptions.hpp	/^    error_code code;$/;"	m	class:boost::wave::cpplexer::lexing_exception	access:private
collect_arguments	wave/util/cpp_macromap.hpp	/^    typename std::vector<ContainerT>::size_type collect_arguments ($/;"	p	class:boost::wave::util::macromap	access:protected	signature:( token_type const curr_token, std::vector<ContainerT> &arguments, IteratorT &next, IteratorT &endparen, IteratorT const &end, SizeT const &parameter_count, bool& seen_newline)
collect_arguments	wave/util/cpp_macromap.hpp	/^    typename std::vector<ContainerT>::size_type collect_arguments ($/;"	p	class:boost::wave::util::macromap	access:protected	signature:( token_type const curr_token, std::vector<ContainerT> &arguments, IteratorT &next, IteratorT const &end, SizeT const &parameter_count, bool& seen_newline)
collect_arguments	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::collect_arguments (token_type const curr_token,$/;"	f	class:boost::wave::util::macromap	signature:(token_type const curr_token, std::vector<ContainerT> &arguments, IteratorT &next, IteratorT const &end, SizeT const &parameter_count, bool& seen_newline)
column	wave/cpp_exceptions.hpp	/^    std::size_t column;$/;"	m	class:boost::wave::cpp_exception	access:protected
column	wave/cpplexer/cpplexer_exceptions.hpp	/^    std::size_t column;$/;"	m	class:boost::wave::cpplexer::cpplexer_exception	access:protected
column	wave/cpplexer/re2clex/scanner.hpp	/^    std::size_t column;         \/* current token start column position *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
column	wave/util/file_position.hpp	/^    std::size_t column;$/;"	m	struct:boost::wave::util::file_position	access:private
column_no	wave/cpp_exceptions.hpp	/^    std::size_t column_no() const throw() { return column; }$/;"	f	class:boost::wave::cpp_exception	access:public	signature:() const
column_no	wave/cpplexer/cpplexer_exceptions.hpp	/^    std::size_t column_no() const throw() { return column; }$/;"	f	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
compare	wave/util/flex_string.hpp	/^    std::ptrdiff_t compare(const flex_string& str) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str) const
compare	wave/util/flex_string.hpp	/^    std::ptrdiff_t compare(const value_type* s) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s) const
compare	wave/util/flex_string.hpp	/^    std::ptrdiff_t compare(size_type pos1, size_type n1,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, size_type n1, const flex_string& str) const
compare	wave/util/flex_string.hpp	/^    std::ptrdiff_t compare(size_type pos1, size_type n1,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, size_type n1, const flex_string& str, size_type pos2, size_type n2) const
compare	wave/util/flex_string.hpp	/^    std::ptrdiff_t compare(size_type pos1, size_type n1,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, size_type n1, const value_type* s) const
compare	wave/util/flex_string.hpp	/^    std::ptrdiff_t compare(size_type pos1, size_type n1,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, size_type n1, const value_type* s, size_type n2) const
compilation_time_	wave/util/cpp_macromap_predef.hpp	/^        boost::wave::util::time_conversion_helper compilation_time_;$/;"	m	class:boost::wave::util::predefined_macros	access:private
compile_time	wave/util/time_conversion_helper.hpp	/^        time_t compile_time; $/;"	m	class:boost::wave::util::time_conversion::time_conversion_helper	access:private
complete_path	wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path complete_path($/;"	f	namespace:boost::wave::util	signature:( boost::filesystem::path const& p)
complete_path	wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path complete_path($/;"	f	namespace:boost::wave::util	signature:( boost::filesystem::path const& p, boost::filesystem::path const& base)
compose	wave/grammars/cpp_chlit_grammar.hpp	/^    phoenix::function<compose_character_literal> const compose;$/;"	m	class:boost::wave::grammars::impl::phoenix
compose_character_literal	wave/grammars/cpp_chlit_grammar.hpp	/^    struct compose_character_literal {$/;"	s	namespace:boost::wave::grammars::impl
concat_tokensequence	wave/util/cpp_macromap.hpp	/^    bool concat_tokensequence(ContainerT &expanded);$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(ContainerT &expanded)
concat_tokensequence	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::concat_tokensequence(ContainerT &expanded)$/;"	f	class:boost::wave::util::macromap	signature:(ContainerT &expanded)
consider_emitting_line_directive	wave/util/cpp_iterator.hpp	/^    bool consider_emitting_line_directive(ContextT const& ctx, token_id id)$/;"	f	namespace:boost::wave::impl::impl	signature:(ContextT const& ctx, token_id id)
const_definition_iterator_t	wave/util/macro_definition.hpp	/^        const_definition_iterator_t;$/;"	t	struct:boost::wave::util::macro_definition	access:public
const_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t const_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
const_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t const_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
const_exp_subrule	wave/grammars/cpp_expression_grammar.hpp	/^        boost::spirit::classic::subrule<0, closure_type::context_t> const_exp_subrule;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
const_iterator	wave/util/flex_string.hpp	/^    typedef const E* const_iterator;$/;"	t	class:boost::wave::util::AllocatorStringStorage	access:public
const_iterator	wave/util/flex_string.hpp	/^    typedef const E* const_iterator;$/;"	t	class:boost::wave::util::SimpleStringStorage	access:public
const_iterator	wave/util/flex_string.hpp	/^    typedef const value_type* const_iterator;$/;"	t	class:boost::wave::util::SmallStringOpt	access:public
const_iterator	wave/util/flex_string.hpp	/^    typedef typename Storage::const_iterator const_iterator;$/;"	t	class:boost::wave::util::CowString	access:public
const_iterator	wave/util/flex_string.hpp	/^    typedef typename Storage::const_iterator const_iterator;$/;"	t	class:boost::wave::util::flex_string	access:public
const_iterator	wave/util/flex_string.hpp	/^    typedef typename base::const_iterator const_iterator;$/;"	t	class:boost::wave::util::VectorStringStorage	access:public
const_iterator_type	wave/util/symbol_table.hpp	/^    typedef typename base_type::const_iterator const_iterator_type;$/;"	t	struct:boost::wave::util::symbol_table	access:public
const_name_iterator	wave/cpp_context.hpp	/^    typedef typename macromap_type::const_name_iterator const_name_iterator;$/;"	t	class:boost::wave::context	access:public
const_name_iterator	wave/util/cpp_macromap.hpp	/^    typedef typename defined_macros_type::const_name_iterator const_name_iterator;$/;"	t	class:boost::wave::util::macromap	access:public
const_name_iterator	wave/util/symbol_table.hpp	/^        const_name_iterator;$/;"	t	struct:boost::wave::util::symbol_table	access:public
const_parameter_iterator_t	wave/util/macro_definition.hpp	/^        const_parameter_iterator_t;$/;"	t	struct:boost::wave::util::macro_definition	access:public
const_pointer	wave/util/flex_string.hpp	/^    typedef const value_type* const_pointer;$/;"	t	class:boost::wave::util::mallocator	access:public
const_pointer	wave/util/flex_string.hpp	/^    typedef typename A::const_pointer const_pointer;$/;"	t	class:boost::wave::util::flex_string	access:public
const_pointer	wave/util/flex_string.hpp	/^  typedef const void* const_pointer;$/;"	t	class:boost::wave::util::mallocator	access:private
const_reference	wave/util/flex_string.hpp	/^    typedef const value_type& const_reference;$/;"	t	class:boost::wave::util::mallocator	access:public
const_reference	wave/util/flex_string.hpp	/^    typedef typename A::const_reference const_reference;$/;"	t	class:boost::wave::util::flex_string	access:public
const_reverse_iterator	wave/util/flex_string.hpp	/^    typedef boost::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:boost::wave::util::flex_string	access:public
constant	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t unary_exp, primary_exp, constant;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
constant_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t unary_exp_nocalc, primary_exp_nocalc, constant_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
construct	wave/util/flex_string.hpp	/^    void construct(pointer p, const value_type& x) $/;"	f	class:boost::wave::util::mallocator	access:public	signature:(pointer p, const value_type& x)
container_type	wave/util/unput_queue_iterator.hpp	/^        typedef ContainerT  container_type;$/;"	t	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public
container_type	wave/util/unput_queue_iterator.hpp	/^    typedef ContainerT  container_type;$/;"	t	class:boost::wave::util::unput_queue_iterator	access:public
context	wave/cpp_context.hpp	/^    context(target_iterator_type const &first_, target_iterator_type const &last_, $/;"	f	class:boost::wave::context	access:public	signature:(target_iterator_type const &first_, target_iterator_type const &last_, char const *fname = , HooksT const &hooks_ = HooksT())
context	wave/cpp_context.hpp	/^class context : private boost::noncopyable$/;"	c	namespace:boost::wave	inherits:boost::noncopyable
context_policies	wave/preprocessing_hooks.hpp	/^namespace context_policies {$/;"	n	namespace:boost::wave
context_policies	wave/whitespace_handling.hpp	/^namespace context_policies {$/;"	n	namespace:boost::wave
convert_chlit	wave/grammars/cpp_expression_grammar.hpp	/^    struct convert_chlit {$/;"	s	namespace:boost::wave::grammars::impl
convert_intlit	wave/grammars/cpp_expression_grammar.hpp	/^    struct convert_intlit {$/;"	s	namespace:boost::wave::grammars::impl
convert_trigraph	wave/cpplexer/convert_trigraphs.hpp	/^convert_trigraph(StringT const &trigraph)$/;"	f	namespace:boost::wave::cpplexer::impl	signature:(StringT const &trigraph)
convert_trigraphs	wave/cpplexer/convert_trigraphs.hpp	/^convert_trigraphs(StringT const &value)$/;"	f	namespace:boost::wave::cpplexer::impl	signature:(StringT const &value)
copy	wave/util/flex_string.hpp	/^    size_type copy(value_type* s, size_type n, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type* s, size_type n, size_type pos = 0) const
copy_n	wave/util/flex_string.hpp	/^    OutIt copy_n(InIt b, $/;"	f	namespace:boost::wave::util::flex_string_details	signature:(InIt b, typename std::iterator_traits<InIt>::difference_type n, OutIt d)
correct_year	wave/util/time_conversion_helper.hpp	/^        void correct_year() $/;"	f	class:boost::wave::util::time_conversion::time_conversion_grammar	access:public	signature:()
could_not_open_output_file	wave/cpp_exceptions.hpp	/^        could_not_open_output_file,$/;"	e	enum:boost::wave::preprocess_exception::error_code
cpp_exception	wave/cpp_exceptions.hpp	/^    cpp_exception(std::size_t line_, std::size_t column_, char const *filename_) throw()$/;"	f	class:boost::wave::cpp_exception	access:public	signature:(std::size_t line_, std::size_t column_, char const *filename_)
cpp_exception	wave/cpp_exceptions.hpp	/^class BOOST_SYMBOL_VISIBLE cpp_exception$/;"	c	namespace:boost::wave	inherits:std::exception
cpp_expr_closure	wave/grammars/cpp_expression_grammar.hpp	/^    struct cpp_expr_closure $/;"	s	namespace:boost::wave::grammars::closures	inherits:boost::spirit::classic::closure
cpp_grammar	wave/grammars/cpp_grammar.hpp	/^    cpp_grammar(bool &found_eof_, TokenT &found_directive_, $/;"	f	struct:boost::wave::grammars::cpp_grammar	access:public	signature:(bool &found_eof_, TokenT &found_directive_, ContainerT &found_eoltokens_)
cpp_grammar	wave/grammars/cpp_grammar.hpp	/^struct cpp_grammar : $/;"	s	namespace:boost::wave::grammars	inherits:boost::spirit::classic::grammar
cpp_grammar_gen	wave/grammars/cpp_grammar_gen.hpp	/^struct BOOST_WAVE_DECL cpp_grammar_gen$/;"	s	namespace:boost::wave::grammars
cpp_grammar_type	wave/util/cpp_iterator.hpp	/^        cpp_grammar_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
cpplexer	wave/cpplexer/convert_trigraphs.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
cpplexer	wave/cpplexer/cpp_lex_interface.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
cpplexer	wave/cpplexer/cpp_lex_interface_generator.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
cpplexer	wave/cpplexer/cpp_lex_iterator.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
cpplexer	wave/cpplexer/cpp_lex_token.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
cpplexer	wave/cpplexer/cpplexer_exceptions.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
cpplexer	wave/cpplexer/detect_include_guards.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
cpplexer	wave/cpplexer/re2clex/aq.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
cpplexer	wave/cpplexer/re2clex/cpp_re.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
cpplexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
cpplexer	wave/cpplexer/re2clex/scanner.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
cpplexer	wave/cpplexer/token_cache.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
cpplexer	wave/cpplexer/validate_universal_char.hpp	/^namespace cpplexer {$/;"	n	namespace:boost::wave
cpplexer_exception	wave/cpplexer/cpplexer_exceptions.hpp	/^    cpplexer_exception(std::size_t line_, std::size_t column_, char const *filename_) throw()$/;"	f	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:(std::size_t line_, std::size_t column_, char const *filename_)
cpplexer_exception	wave/cpplexer/cpplexer_exceptions.hpp	/^class BOOST_SYMBOL_VISIBLE cpplexer_exception$/;"	c	namespace:boost::wave::cpplexer	inherits:std::exception
create_directories	wave/util/filesystem_compatibility.hpp	/^    inline bool create_directories(boost::filesystem::path const& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& p)
create_path	wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path create_path(String const& p)$/;"	f	namespace:boost::wave::util	signature:(String const& p)
ctx	wave/cpp_iteration_context.hpp	/^    ContextT& ctx;              \/\/ corresponding context<> object$/;"	m	struct:boost::wave::base_iteration_context	access:public
ctx	wave/util/cpp_iterator.hpp	/^    ContextT &ctx;              \/\/ context, this iterator is associated with$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
ctx	wave/util/cpp_macromap.hpp	/^    ContextT &ctx;              \/\/ context object associated with the macromap$/;"	m	class:boost::wave::util::macromap	access:private
cur	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* cur;     \/* saves the cursor (maybe is redundant with tok?) *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
curr_column	wave/cpplexer/re2clex/scanner.hpp	/^    std::size_t curr_column;    \/* current column position *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
current_dir	wave/util/cpp_include_paths.hpp	/^    boost::filesystem::path current_dir;$/;"	m	class:boost::wave::util::include_paths	access:private
current_filename	wave/cpp_context.hpp	/^    std::string current_filename;       \/\/ real name of current preprocessed file$/;"	m	class:boost::wave::context	access:private
current_macros	wave/util/cpp_macromap.hpp	/^    defined_macros_type *current_macros;                   \/\/ current symbol table$/;"	m	class:boost::wave::util::macromap	access:private
current_path	wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path current_path()$/;"	f	namespace:boost::wave::util	signature:()
current_rel_dir	wave/util/cpp_include_paths.hpp	/^    boost::filesystem::path current_rel_dir;$/;"	m	class:boost::wave::util::include_paths	access:private
current_relative_filename	wave/cpp_context.hpp	/^    std::string current_relative_filename;        \/\/ real relative name of current preprocessed file$/;"	m	class:boost::wave::context	access:private
current_state	wave/cpplexer/detect_include_guards.hpp	/^    bool current_state;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
current_token	wave/util/cpp_iterator.hpp	/^    result_type const &current_token() const { return act_token; }$/;"	f	class:boost::wave::impl::pp_iterator_functor	access:public	signature:() const
curtok	wave/util/functor_input.hpp	/^            value_type curtok;$/;"	m	struct:boost::wave::util::functor_input::inner::Data	access:public
data	wave/cpplexer/cpp_lex_token.hpp	/^    data_type* data;$/;"	m	class:boost::wave::cpplexer::lex_token	access:private
data	wave/util/flex_string.hpp	/^    const E* data() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
data	wave/util/flex_string.hpp	/^    const E* data() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
data	wave/util/flex_string.hpp	/^    const E* data() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
data	wave/util/flex_string.hpp	/^    const E* data() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
data	wave/util/flex_string.hpp	/^    const value_type* data() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
data	wave/util/flex_string.hpp	/^    const value_type* data() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
data	wave/util/functor_input.hpp	/^        mutable Data *data;$/;"	m	class:boost::wave::util::functor_input::inner	access:private
data_type	wave/cpplexer/cpp_lex_token.hpp	/^    typedef impl::token_data<string_type, position_type> data_type;$/;"	t	class:boost::wave::cpplexer::lex_token	access:private
datestr_	wave/util/cpp_macromap_predef.hpp	/^        string_type datestr_;     \/\/ __DATE__$/;"	m	class:boost::wave::util::predefined_macros	access:private
deallocate	wave/util/flex_string.hpp	/^    void deallocate(pointer p, size_type) $/;"	f	class:boost::wave::util::mallocator	access:public	signature:(pointer p, size_type)
dec_lit	wave/grammars/cpp_intlit_grammar.hpp	/^        boost::spirit::classic::subrule<3> dec_lit;$/;"	m	struct:boost::wave::grammars::intlit_grammar::definition	access:public
default_preprocessing_hooks	wave/preprocessing_hooks.hpp	/^struct default_preprocessing_hooks $/;"	s	namespace:boost::wave::context_policies
defined_grammar	wave/grammars/cpp_defined_grammar.hpp	/^    defined_grammar(ContainerT &result_seq_)$/;"	f	struct:boost::wave::grammars::defined_grammar	access:public	signature:(ContainerT &result_seq_)
defined_grammar	wave/grammars/cpp_defined_grammar.hpp	/^struct defined_grammar :$/;"	s	namespace:boost::wave::grammars	inherits:boost::spirit::classic::grammar
defined_grammar_gen	wave/grammars/cpp_defined_grammar_gen.hpp	/^struct BOOST_WAVE_DECL defined_grammar_gen$/;"	s	namespace:boost::wave::grammars
defined_macro	wave/preprocessing_hooks.hpp	/^    defined_macro(ContextT const& ctx, TokenT const& macro_name, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& macro_name, bool is_functionlike, ParametersT const& parameters, DefinitionT const& definition, bool is_predefined)
defined_macro	wave/preprocessing_hooks.hpp	/^    defined_macro(TokenT const& macro_name, bool is_functionlike, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(TokenT const& macro_name, bool is_functionlike, ParametersT const& parameters, DefinitionT const& definition, bool is_predefined)
defined_macros	wave/util/cpp_macromap.hpp	/^    boost::shared_ptr<defined_macros_type> defined_macros; \/\/ global symbol table$/;"	m	class:boost::wave::util::macromap	access:private
defined_macros_type	wave/util/cpp_macromap.hpp	/^        defined_macros_type;$/;"	t	class:boost::wave::util::macromap	access:private
defined_op	wave/grammars/cpp_defined_grammar.hpp	/^        rule_t defined_op;$/;"	m	struct:boost::wave::grammars::defined_grammar::definition	access:public
definition	wave/grammars/cpp_chlit_grammar.hpp	/^        definition(chlit_grammar const &self)$/;"	f	struct:boost::wave::grammars::chlit_grammar::definition	access:public	signature:(chlit_grammar const &self)
definition	wave/grammars/cpp_chlit_grammar.hpp	/^    struct definition$/;"	s	struct:boost::wave::grammars::chlit_grammar	access:public
definition	wave/grammars/cpp_defined_grammar.hpp	/^        definition(defined_grammar const &self)$/;"	f	struct:boost::wave::grammars::defined_grammar::definition	access:public	signature:(defined_grammar const &self)
definition	wave/grammars/cpp_defined_grammar.hpp	/^    struct definition$/;"	s	struct:boost::wave::grammars::defined_grammar	access:public
definition	wave/grammars/cpp_expression_grammar.hpp	/^        definition(expression_grammar const &self)$/;"	f	struct:boost::wave::grammars::expression_grammar::definition	access:public	signature:(expression_grammar const &self)
definition	wave/grammars/cpp_expression_grammar.hpp	/^    struct definition$/;"	s	struct:boost::wave::grammars::expression_grammar	access:public
definition	wave/grammars/cpp_grammar.hpp	/^        definition(cpp_grammar const &self) $/;"	f	struct:boost::wave::grammars::cpp_grammar::definition	access:public	signature:(cpp_grammar const &self)
definition	wave/grammars/cpp_grammar.hpp	/^    struct definition$/;"	s	struct:boost::wave::grammars::cpp_grammar	access:public
definition	wave/grammars/cpp_intlit_grammar.hpp	/^        definition(intlit_grammar const &self)$/;"	f	struct:boost::wave::grammars::intlit_grammar::definition	access:public	signature:(intlit_grammar const &self)
definition	wave/grammars/cpp_intlit_grammar.hpp	/^    struct definition$/;"	s	struct:boost::wave::grammars::intlit_grammar	access:public
definition	wave/grammars/cpp_predef_macros_grammar.hpp	/^        definition(predefined_macros_grammar const &\/*self*\/) $/;"	f	struct:boost::wave::grammars::predefined_macros_grammar::definition	access:public	signature:(predefined_macros_grammar const & )
definition	wave/grammars/cpp_predef_macros_grammar.hpp	/^    struct definition$/;"	s	struct:boost::wave::grammars::predefined_macros_grammar	access:public
definition	wave/util/time_conversion_helper.hpp	/^            definition(time_conversion_grammar const &self)$/;"	f	struct:boost::wave::util::time_conversion::time_conversion_grammar::definition	access:public	signature:(time_conversion_grammar const &self)
definition	wave/util/time_conversion_helper.hpp	/^        struct definition {$/;"	s	class:boost::wave::util::time_conversion::time_conversion_grammar	access:public
definition_container_type	wave/util/cpp_macromap.hpp	/^    typedef typename ContextT::token_sequence_type  definition_container_type;$/;"	t	class:boost::wave::util::macromap	access:private
definition_container_type	wave/util/macro_definition.hpp	/^    typedef ContainerT          definition_container_type;$/;"	t	struct:boost::wave::util::macro_definition	access:public
definition_equals	wave/util/cpp_macromap_utils.hpp	/^definition_equals(ContainerT const &definition, $/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT const &definition, ContainerT const &new_definition)
dereference	wave/util/unput_queue_iterator.hpp	/^    typename base_type::reference dereference() const$/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:() const
derived	wave/cpp_context.hpp	/^    actual_context_type const& derived() const$/;"	f	class:boost::wave::context	access:public	signature:() const
derived	wave/cpp_context.hpp	/^    actual_context_type& derived() $/;"	f	class:boost::wave::context	access:public	signature:()
description	wave/cpp_exceptions.hpp	/^    virtual char const *description() const throw() = 0;$/;"	p	class:boost::wave::cpp_exception	access:public	signature:() const
description	wave/cpp_exceptions.hpp	/^    virtual char const *description() const throw()$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:() const
description	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual char const *description() const throw() = 0;$/;"	p	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
description	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual char const *description() const throw()$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:() const
destroy	wave/cpplexer/cpp_lex_iterator.hpp	/^    static void destroy(MultiPass& mp)$/;"	f	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public	signature:(MultiPass& mp)
destroy	wave/util/flex_string.hpp	/^    void destroy(pointer p) $/;"	f	class:boost::wave::util::mallocator	access:public	signature:(pointer p)
destroy	wave/util/functor_input.hpp	/^        void destroy()$/;"	f	class:boost::wave::util::functor_input::inner	access:protected	signature:()
detect_guard	wave/cpplexer/detect_include_guards.hpp	/^    Token& detect_guard(Token& t) $/;"	f	class:boost::wave::cpplexer::include_guards	access:public	signature:(Token& t)
detect_pp_numbers	wave/cpplexer/re2clex/scanner.hpp	/^    bool detect_pp_numbers;      \/* lexer should prefer to detect pp-numbers *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
detected	wave/cpplexer/detect_include_guards.hpp	/^    bool detected(std::string& guard_name_) const $/;"	f	class:boost::wave::cpplexer::include_guards	access:public	signature:(std::string& guard_name_) const
detected_guards	wave/cpplexer/detect_include_guards.hpp	/^    bool detected_guards;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
detected_include_guard	wave/preprocessing_hooks.hpp	/^    detected_include_guard(ContextT const& ctx, std::string const& filename,$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, std::string const& filename, std::string const& include_guard)
detected_pragma_once	wave/preprocessing_hooks.hpp	/^    detected_pragma_once(ContextT const& ctx, TokenT const& pragma_token,$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& pragma_token, std::string const& filename)
difference_type	wave/util/flex_string.hpp	/^    typedef int               difference_type;$/;"	t	class:boost::wave::util::mallocator	access:public
difference_type	wave/util/flex_string.hpp	/^    typedef typename A::difference_type difference_type;$/;"	t	class:boost::wave::util::flex_string	access:public
difference_type	wave/util/functor_input.hpp	/^        typedef std::ptrdiff_t difference_type;$/;"	t	class:boost::wave::util::functor_input::inner	access:public
dispatch_directive	wave/util/cpp_iterator.hpp	/^    bool dispatch_directive(tree_parse_info_type const &hit,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(tree_parse_info_type const &hit, result_type const& found_directive, token_sequence_type const& found_eoltokens)
dispatch_directive	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::dispatch_directive($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( tree_parse_info_type const &hit, result_type const& found_directive, token_sequence_type const& found_eoltokens)
division_by_zero	wave/cpp_exceptions.hpp	/^        division_by_zero,$/;"	e	enum:boost::wave::preprocess_exception::error_code
do_	wave/util/unput_queue_iterator.hpp	/^        do_ (IteratorT &dest, IteratorT const &src)$/;"	f	struct:boost::wave::util::impl::assign_iterator	access:public	signature:(IteratorT &dest, IteratorT const &src)
duplicate_parameter_name	wave/cpp_exceptions.hpp	/^        duplicate_parameter_name,$/;"	e	enum:boost::wave::preprocess_exception::error_code
dynamic_data	wave/util/cpp_macromap_predef.hpp	/^        dynamic_macros const& dynamic_data(std::size_t i) const$/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:(std::size_t i) const
dynamic_macros	wave/util/cpp_macromap_predef.hpp	/^        struct dynamic_macros {$/;"	s	class:boost::wave::util::predefined_macros	access:public
eat_whitespace	wave/whitespace_handling.hpp	/^    eat_whitespace();$/;"	p	class:boost::wave::context_policies::eat_whitespace	access:public	signature:()
eat_whitespace	wave/whitespace_handling.hpp	/^class eat_whitespace $/;"	c	namespace:boost::wave::context_policies	inherits:default_preprocessing_hooks
eat_whitespace	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::eat_whitespace()$/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:()
emit_line_directive	wave/preprocessing_hooks.hpp	/^    emit_line_directive(ContextT const& ctx, ContainerT &pending, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT &pending, typename ContextT::token_type const& act_token)
emit_line_directive	wave/util/cpp_iterator.hpp	/^    bool emit_line_directive();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:()
emit_line_directive	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::emit_line_directive()$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:()
emitted_lines	wave/cpp_iteration_context.hpp	/^    std::size_t emitted_lines;            \/\/ count of emitted newlines$/;"	m	struct:boost::wave::base_iteration_context	access:public
empty	wave/util/flex_string.hpp	/^    bool empty() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
emptyString_	wave/util/flex_string.hpp	/^    static const Data emptyString_;$/;"	m	class:boost::wave::util::SimpleStringStorage	access:public
emptyString_	wave/util/flex_string.hpp	/^SimpleStringStorage<E, A>::emptyString_ = $/;"	m	class:boost::wave::util::SimpleStringStorage
empty_macroarguments	wave/cpp_exceptions.hpp	/^        empty_macroarguments,$/;"	e	enum:boost::wave::preprocess_exception::error_code
enable_import_keyword	wave/cpplexer/re2clex/scanner.hpp	/^    bool enable_import_keyword;  \/* recognize import as a keyword *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
enable_ms_extensions	wave/cpplexer/re2clex/scanner.hpp	/^    bool enable_ms_extensions;   \/* enable MS extensions *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
enable_variadics	wave/language_support.hpp	/^enable_variadics(language_support language, bool enable = true)$/;"	f	namespace:boost::wave	signature:(language_support language, bool enable = true)
enclosing_status	wave/util/cpp_ifblock.hpp	/^   bool enclosing_status;   \/\/ Enclosing #if block is true$/;"	m	class:boost::wave::util::if_block	access:private
end	wave/cpp_context.hpp	/^    iterator_type end() const $/;"	f	class:boost::wave::context	access:public	signature:() const
end	wave/util/cpp_macromap.hpp	/^    const_name_iterator end() const$/;"	f	class:boost::wave::util::macromap	access:public	signature:() const
end	wave/util/cpp_macromap.hpp	/^    name_iterator end()$/;"	f	class:boost::wave::util::macromap	access:public	signature:()
end	wave/util/flex_string.hpp	/^    const_iterator end() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
end	wave/util/flex_string.hpp	/^    const_iterator end() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
end	wave/util/flex_string.hpp	/^    const_iterator end() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
end	wave/util/flex_string.hpp	/^    const_iterator end() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
end	wave/util/flex_string.hpp	/^    const_iterator end() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
end	wave/util/flex_string.hpp	/^    const_iterator end() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
end	wave/util/flex_string.hpp	/^    iterator end()$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:()
end	wave/util/flex_string.hpp	/^    iterator end()$/;"	f	class:boost::wave::util::CowString	access:public	signature:()
end	wave/util/flex_string.hpp	/^    iterator end()$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:()
end	wave/util/flex_string.hpp	/^    iterator end()$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:()
end	wave/util/flex_string.hpp	/^    iterator end()$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:()
end	wave/util/flex_string.hpp	/^    iterator end()$/;"	f	class:boost::wave::util::flex_string	access:public	signature:()
ensure_initialized	wave/util/functor_input.hpp	/^        void ensure_initialized() const$/;"	f	class:boost::wave::util::functor_input::inner	access:protected	signature:() const
ensure_is_last_on_line	wave/util/cpp_iterator.hpp	/^    bool ensure_is_last_on_line(IteratorT& it, bool call_hook = true);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(IteratorT& it, bool call_hook = true)
ensure_is_last_on_line	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::ensure_is_last_on_line(IteratorT& it, bool call_hook)$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(IteratorT& it, bool call_hook)
enter_elif_block	wave/cpp_context.hpp	/^    bool enter_elif_block(bool new_status) $/;"	f	class:boost::wave::context	access:protected	signature:(bool new_status)
enter_elif_block	wave/util/cpp_ifblock.hpp	/^    bool enter_elif_block(bool new_status)$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:(bool new_status)
enter_else_block	wave/cpp_context.hpp	/^    bool enter_else_block() { return ifblocks.enter_else_block(); }$/;"	f	class:boost::wave::context	access:protected	signature:()
enter_else_block	wave/util/cpp_ifblock.hpp	/^    bool enter_else_block()$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:()
enter_if_block	wave/cpp_context.hpp	/^    void enter_if_block(bool new_status) $/;"	f	class:boost::wave::context	access:protected	signature:(bool new_status)
enter_if_block	wave/util/cpp_ifblock.hpp	/^    void enter_if_block(bool new_status)$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:(bool new_status)
eof	wave/cpplexer/cpp_lex_iterator.hpp	/^    BOOST_WAVE_EOF_PREFIX result_type const eof;$/;"	m	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public
eof	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* eof;     \/* when we read in the last buffer, will point 1 past the$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
eof	wave/util/cpp_iterator.hpp	/^    pp_iterator_functor<ContextT>::eof;$/;"	m	class:boost::wave::impl::pp_iterator_functor::pp_iterator_functor
eof	wave/util/cpp_iterator.hpp	/^    static result_type const eof;$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:public
eol_offsets	wave/cpplexer/re2clex/scanner.hpp	/^    aq_queue eol_offsets;$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
eol_tokens	wave/grammars/cpp_grammar.hpp	/^        rule_type eol_tokens;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
equal	wave/util/unput_queue_iterator.hpp	/^    bool equal($/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:( boost::iterator_adaptor<OtherDerivedT, OtherIteratorT, V, C, R, D> const &x) const
erase	wave/util/flex_string.hpp	/^    flex_string& erase(size_type pos = 0, size_type n = npos)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos = 0, size_type n = npos)
erase	wave/util/flex_string.hpp	/^    iterator erase(iterator first, iterator last)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(iterator first, iterator last)
erase	wave/util/flex_string.hpp	/^    iterator erase(iterator position)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(iterator position)
error_character_overflow	wave/grammars/cpp_value_error.hpp	/^    error_character_overflow = 0x4$/;"	e	enum:boost::wave::grammars::value_error
error_code	wave/cpp_exceptions.hpp	/^    enum error_code {$/;"	g	class:boost::wave::preprocess_exception	access:public
error_code	wave/cpplexer/cpplexer_exceptions.hpp	/^    enum error_code {$/;"	g	class:boost::wave::cpplexer::lexing_exception	access:public
error_directive	wave/cpp_exceptions.hpp	/^        error_directive,$/;"	e	enum:boost::wave::preprocess_exception::error_code
error_division_by_zero	wave/grammars/cpp_value_error.hpp	/^    error_division_by_zero = 0x1,$/;"	e	enum:boost::wave::grammars::value_error
error_integer_overflow	wave/grammars/cpp_value_error.hpp	/^    error_integer_overflow = 0x2,$/;"	e	enum:boost::wave::grammars::value_error
error_noerror	wave/grammars/cpp_value_error.hpp	/^    error_noerror = 0x0,$/;"	e	enum:boost::wave::grammars::value_error
error_proc	wave/cpplexer/re2clex/scanner.hpp	/^    ReportErrorProc error_proc; \/* must be != 0, this function is called to$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
error_text	wave/cpp_exceptions.hpp	/^    static char const *error_text(int code)$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:(int code)
error_text	wave/cpplexer/cpplexer_exceptions.hpp	/^    static char const *error_text(int code)$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:(int code)
escape_lit	wave/util/macro_helpers.hpp	/^    escape_lit(StringT const &value)$/;"	f	namespace:boost::wave::util::impl	signature:(StringT const &value)
evaluate	wave/grammars/cpp_chlit_grammar.hpp	/^chlit_grammar_gen<IntegralResult, TokenT>::evaluate(TokenT const &token, value_error &status)$/;"	f	class:boost::wave::grammars::chlit_grammar_gen	signature:(TokenT const &token, value_error &status)
evaluate	wave/grammars/cpp_expression_grammar.hpp	/^expression_grammar_gen<TokenT>::evaluate($/;"	f	class:boost::wave::grammars::expression_grammar_gen	signature:( typename token_sequence_type::const_iterator const &first, typename token_sequence_type::const_iterator const &last, typename token_type::position_type const &act_pos, bool if_block_status, value_error &status)
evaluate	wave/grammars/cpp_expression_grammar_gen.hpp	/^    static bool evaluate($/;"	p	struct:boost::wave::grammars::expression_grammar_gen	access:public	signature:( typename token_sequence_type::const_iterator const &first, typename token_sequence_type::const_iterator const &last, typename token_type::position_type const &tok, bool if_block_status, value_error &status)
evaluate	wave/grammars/cpp_intlit_grammar.hpp	/^intlit_grammar_gen<TokenT>::evaluate(TokenT const &token, $/;"	f	class:boost::wave::grammars::intlit_grammar_gen	signature:(TokenT const &token, bool &is_unsigned)
evaluate	wave/grammars/cpp_literal_grammar_gen.hpp	/^    static IntegralResult evaluate(TokenT const &tok, value_error& status);$/;"	p	struct:boost::wave::grammars::chlit_grammar_gen	access:public	signature:(TokenT const &tok, value_error& status)
evaluate	wave/grammars/cpp_literal_grammar_gen.hpp	/^    static uint_literal_type evaluate(TokenT const &tok, bool &is_unsigned);$/;"	p	struct:boost::wave::grammars::intlit_grammar_gen	access:public	signature:(TokenT const &tok, bool &is_unsigned)
evaluated_conditional_expression	wave/preprocessing_hooks.hpp	/^    evaluated_conditional_expression(ContainerT const& expression, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContainerT const& expression, bool expression_value)
evaluated_conditional_expression	wave/preprocessing_hooks.hpp	/^    evaluated_conditional_expression(ContextT const& ctx, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& directive, ContainerT const& expression, bool expression_value)
exclusive_or_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t inclusive_or_exp, exclusive_or_exp, and_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
exclusive_or_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t inclusive_or_exp_nocalc, exclusive_or_exp_nocalc, and_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
exit_if_block	wave/cpp_context.hpp	/^    bool exit_if_block() { return ifblocks.exit_if_block(); }$/;"	f	class:boost::wave::context	access:protected	signature:()
exit_if_block	wave/util/cpp_ifblock.hpp	/^    bool exit_if_block()$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:()
expand_argument	wave/util/cpp_macromap.hpp	/^    void expand_argument (typename std::vector<ContainerT>::size_type arg,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(typename std::vector<ContainerT>::size_type arg, std::vector<ContainerT> &arguments, std::vector<ContainerT> &expanded_args, bool expand_operator_defined, std::vector<bool> &has_expanded_args)
expand_argument	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::expand_argument ($/;"	f	class:boost::wave::util::macromap	signature:( typename std::vector<ContainerT>::size_type arg, std::vector<ContainerT> &arguments, std::vector<ContainerT> &expanded_args, bool expand_operator_defined, std::vector<bool> &has_expanded_args)
expand_macro	wave/util/cpp_macromap.hpp	/^    bool expand_macro(ContainerT &pending, token_type const &name,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(ContainerT &pending, token_type const &name, typename defined_macros_type::iterator it, IteratorT &first, IteratorT const &last, bool& seen_newline, bool expand_operator_defined, defined_macros_type *scope = 0, ContainerT *queue_symbol = 0)
expand_macro	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::expand_macro(ContainerT &expanded,$/;"	f	class:boost::wave::util::macromap	signature:(ContainerT &expanded, token_type const &curr_token, typename defined_macros_type::iterator it, IteratorT &first, IteratorT const &last, bool& seen_newline, bool expand_operator_defined, defined_macros_type *scope, ContainerT *queue_symbol)
expand_predefined_macro	wave/util/cpp_macromap.hpp	/^    bool expand_predefined_macro(token_type const &curr_token,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(token_type const &curr_token, ContainerT &expanded)
expand_predefined_macro	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::expand_predefined_macro(token_type const &curr_token,$/;"	f	class:boost::wave::util::macromap	signature:(token_type const &curr_token, ContainerT &expanded)
expand_replacement_list	wave/util/cpp_macromap.hpp	/^    void expand_replacement_list($/;"	p	class:boost::wave::util::macromap	access:protected	signature:( macro_definition_type const &macrodefinition, std::vector<ContainerT> &arguments, bool expand_operator_defined, ContainerT &expanded)
expand_replacement_list	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::expand_replacement_list($/;"	f	class:boost::wave::util::macromap	signature:( macro_definition_type const &macrodef, std::vector<ContainerT> &arguments, bool expand_operator_defined, ContainerT &expanded)
expand_tokensequence	wave/cpp_context.hpp	/^    token_type expand_tokensequence(IteratorT2 &first_, IteratorT2 const &last_, $/;"	f	class:boost::wave::context	access:protected	signature:(IteratorT2 &first_, IteratorT2 const &last_, token_sequence_type &pending, token_sequence_type &expanded, bool& seen_newline, bool expand_undefined = false)
expand_tokensequence	wave/util/cpp_macromap.hpp	/^    token_type const &expand_tokensequence(IteratorT &first,$/;"	p	class:boost::wave::util::macromap	access:public	signature:(IteratorT &first, IteratorT const &last, ContainerT &pending, ContainerT &expanded, bool& seen_newline, bool expand_operator_defined)
expand_tokensequence	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::expand_tokensequence(IteratorT &first,$/;"	f	class:boost::wave::util::ContextT::macromap	signature:(IteratorT &first, IteratorT const &last, ContainerT &pending, ContainerT &expanded, bool& seen_newline, bool expand_operator_defined)
expand_tokensequence_worker	wave/util/cpp_macromap.hpp	/^    token_type const &expand_tokensequence_worker(ContainerT &pending,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(ContainerT &pending, unput_queue_iterator<IteratorT, token_type, ContainerT> &first, unput_queue_iterator<IteratorT, token_type, ContainerT> const &last, bool& seen_newline, bool expand_operator_defined)
expand_tokensequence_worker	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::expand_tokensequence_worker($/;"	f	class:boost::wave::util::ContextT::macromap	signature:( ContainerT &pending, unput_queue_iterator<IteratorT, token_type, ContainerT> &first, unput_queue_iterator<IteratorT, token_type, ContainerT> const &last, bool& seen_newline, bool expand_operator_defined)
expand_whole_tokensequence	wave/cpp_context.hpp	/^    void expand_whole_tokensequence(IteratorT2 &first_, IteratorT2 const &last_, $/;"	f	class:boost::wave::context	access:protected	signature:(IteratorT2 &first_, IteratorT2 const &last_, token_sequence_type &expanded, bool expand_undefined = true)
expand_whole_tokensequence	wave/util/cpp_macromap.hpp	/^    void expand_whole_tokensequence(ContainerT &expanded,$/;"	p	class:boost::wave::util::macromap	access:public	signature:(ContainerT &expanded, IteratorT &first, IteratorT const &last, bool expand_operator_defined)
expand_whole_tokensequence	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::expand_whole_tokensequence(ContainerT &expanded,$/;"	f	class:boost::wave::util::macromap	signature:(ContainerT &expanded, IteratorT &first, IteratorT const &last, bool expand_operator_defined)
expanded_macro	wave/preprocessing_hooks.hpp	/^    void expanded_macro(ContainerT const& result)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContainerT const& result)
expanded_macro	wave/preprocessing_hooks.hpp	/^    void expanded_macro(ContextT const& ctx, ContainerT const& result)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT const& result)
expanding_function_like_macro	wave/preprocessing_hooks.hpp	/^    void expanding_function_like_macro($/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:( TokenT const& macrodef, std::vector<TokenT> const& formal_args, ContainerT const& definition, TokenT const& macrocall, std::vector<ContainerT> const& arguments)
expanding_object_like_macro	wave/preprocessing_hooks.hpp	/^    expanding_object_like_macro(ContextT const& ctx, TokenT const& macro, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& macro, ContainerT const& definition, TokenT const& macrocall)
expanding_object_like_macro	wave/preprocessing_hooks.hpp	/^    void expanding_object_like_macro(TokenT const& macro, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(TokenT const& macro, ContainerT const& definition, TokenT const& macrocall)
expression_grammar	wave/grammars/cpp_expression_grammar.hpp	/^    expression_grammar()$/;"	f	struct:boost::wave::grammars::expression_grammar	access:public	signature:()
expression_grammar	wave/grammars/cpp_expression_grammar.hpp	/^    expression_grammar(expression_grammar const&);$/;"	p	struct:boost::wave::grammars::expression_grammar	access:public	signature:(expression_grammar const&)
expression_grammar	wave/grammars/cpp_expression_grammar.hpp	/^struct expression_grammar :$/;"	s	namespace:boost::wave::grammars	inherits:boost::spirit::classic::grammar
expression_grammar_gen	wave/grammars/cpp_expression_grammar_gen.hpp	/^struct BOOST_WAVE_DECL expression_grammar_gen {$/;"	s	namespace:boost::wave::grammars
extract_identifier	wave/util/cpp_iterator.hpp	/^    bool extract_identifier(IteratorT &it);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(IteratorT &it)
extract_identifier	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::extract_identifier(IteratorT &it)$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(IteratorT &it)
fYearIsCorrected	wave/util/time_conversion_helper.hpp	/^        bool fYearIsCorrected;$/;"	m	class:boost::wave::util::time_conversion::time_conversion_grammar	access:public
file	wave/util/file_position.hpp	/^    string_type file;$/;"	m	struct:boost::wave::util::file_position	access:private
file_name	wave/cpp_exceptions.hpp	/^    char const *file_name() const throw() { return filename; }$/;"	f	class:boost::wave::cpp_exception	access:public	signature:() const
file_name	wave/cpplexer/cpplexer_exceptions.hpp	/^    char const *file_name() const throw() { return filename; }$/;"	f	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
file_name	wave/cpplexer/re2clex/scanner.hpp	/^    char const *file_name;      \/* name of the lex'ed file *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
file_position	wave/util/file_position.hpp	/^    explicit file_position(string_type const& file_, std::size_t line_ = 1, $/;"	f	struct:boost::wave::util::file_position	access:public	signature:(string_type const& file_, std::size_t line_ = 1, std::size_t column_ = 1)
file_position	wave/util/file_position.hpp	/^    file_position()$/;"	f	struct:boost::wave::util::file_position	access:public	signature:()
file_position	wave/util/file_position.hpp	/^struct file_position {$/;"	s	namespace:boost::wave::util
file_position_type	wave/util/file_position.hpp	/^typedef file_position<BOOST_WAVE_STRINGTYPE> file_position_type;$/;"	t	namespace:boost::wave::util
file_type	wave/cpp_iteration_context.hpp	/^    enum file_type$/;"	g	struct:boost::wave::base_iteration_context	access:public
filename	wave/cpp_context.hpp	/^    std::string filename;               \/\/ associated main filename$/;"	m	class:boost::wave::context	access:private
filename	wave/cpp_exceptions.hpp	/^    char filename[512];$/;"	m	class:boost::wave::cpp_exception	access:protected
filename	wave/cpp_iteration_context.hpp	/^    BOOST_WAVE_STRINGTYPE filename;       \/\/ actual processed file$/;"	m	struct:boost::wave::base_iteration_context	access:public
filename	wave/cpplexer/cpplexer_exceptions.hpp	/^    char filename[512];$/;"	m	class:boost::wave::cpplexer::cpplexer_exception	access:protected
filename	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    string_type filename;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
find	wave/util/flex_string.hpp	/^    size_type find (const value_type* s, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos = 0) const
find	wave/util/flex_string.hpp	/^    size_type find (const value_type* s, size_type pos, size_type n) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos, size_type n) const
find	wave/util/flex_string.hpp	/^    size_type find (value_type c, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c, size_type pos = 0) const
find	wave/util/flex_string.hpp	/^    size_type find(const flex_string& str, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos = 0) const
find_concat_operator	wave/util/cpp_macromap_utils.hpp	/^    find_concat_operator(bool &found_) : found_concat(found_) {}$/;"	f	class:boost::wave::util::impl::find_concat_operator	access:public	signature:(bool &found_)
find_concat_operator	wave/util/cpp_macromap_utils.hpp	/^class find_concat_operator {$/;"	c	namespace:boost::wave::util::impl
find_first_not_of	wave/util/flex_string.hpp	/^    size_type find_first_not_of(const flex_string& str,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos = 0) const
find_first_not_of	wave/util/flex_string.hpp	/^    size_type find_first_not_of(const value_type* s, $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos = 0) const
find_first_not_of	wave/util/flex_string.hpp	/^    size_type find_first_not_of(const value_type* s, size_type pos,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos, size_type n) const
find_first_not_of	wave/util/flex_string.hpp	/^    size_type find_first_not_of(value_type c, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c, size_type pos = 0) const
find_first_of	wave/util/flex_string.hpp	/^    size_type find_first_of(const flex_string& str, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos = 0) const
find_first_of	wave/util/flex_string.hpp	/^    size_type find_first_of(const value_type* s, $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos, size_type n) const
find_first_of	wave/util/flex_string.hpp	/^    size_type find_first_of(const value_type* s, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos = 0) const
find_first_of	wave/util/flex_string.hpp	/^    size_type find_first_of(value_type c, size_type pos = 0) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c, size_type pos = 0) const
find_include_file	wave/cpp_context.hpp	/^    bool find_include_file (std::string &s, std::string &d, bool is_system, $/;"	f	class:boost::wave::context	access:public	signature:(std::string &s, std::string &d, bool is_system, char const *current_file) const
find_include_file	wave/util/cpp_include_paths.hpp	/^    bool find_include_file (std::string &s, std::string &dir, $/;"	p	class:boost::wave::util::include_paths	access:protected	signature:(std::string &s, std::string &dir, include_list_type const &pathes, char const *) const
find_include_file	wave/util/cpp_include_paths.hpp	/^    bool find_include_file (std::string &s, std::string &dir, bool is_system, $/;"	p	class:boost::wave::util::include_paths	access:public	signature:(std::string &s, std::string &dir, bool is_system, char const *current_file) const
find_include_file	wave/util/cpp_include_paths.hpp	/^bool include_paths::find_include_file (std::string &s, std::string &dir, $/;"	f	class:boost::wave::util::include_paths	signature:(std::string &s, std::string &dir, include_list_type const &pathes, char const *current_file) const
find_include_file	wave/util/cpp_include_paths.hpp	/^include_paths::find_include_file (std::string &s, std::string &dir, $/;"	f	class:boost::wave::util::include_paths	signature:(std::string &s, std::string &dir, bool is_system, char const *current_file) const
find_last_not_of	wave/util/flex_string.hpp	/^    size_type find_last_not_of (value_type c, size_type pos = npos) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c, size_type pos = npos) const
find_last_not_of	wave/util/flex_string.hpp	/^    size_type find_last_not_of(const flex_string& str,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos = npos) const
find_last_not_of	wave/util/flex_string.hpp	/^    size_type find_last_not_of(const value_type* s, $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos = npos) const
find_last_not_of	wave/util/flex_string.hpp	/^    size_type find_last_not_of(const value_type* s, size_type pos,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos, size_type n) const
find_last_of	wave/util/flex_string.hpp	/^    size_type find_last_of (const flex_string& str,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos = npos) const
find_last_of	wave/util/flex_string.hpp	/^    size_type find_last_of (const value_type* s, $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos = npos) const
find_last_of	wave/util/flex_string.hpp	/^    size_type find_last_of (const value_type* s, size_type pos, $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos, size_type n) const
find_last_of	wave/util/flex_string.hpp	/^    size_type find_last_of (value_type c, size_type pos = npos) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c, size_type pos = npos) const
first	wave/cpp_context.hpp	/^    target_iterator_type first;         \/\/ underlying input stream$/;"	m	class:boost::wave::context	access:private
first	wave/cpp_iteration_context.hpp	/^    IteratorT first;            \/\/ actual input stream position$/;"	m	struct:boost::wave::base_iteration_context	access:public
first	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* first;   \/* start of input buffer *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
flex_string	wave/util/flex_string.hpp	/^    explicit flex_string(const A& a = A())$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const A& a = A())
flex_string	wave/util/flex_string.hpp	/^    flex_string(InputIterator begin, InputIterator end, const A& a = A())$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(InputIterator begin, InputIterator end, const A& a = A())
flex_string	wave/util/flex_string.hpp	/^    flex_string(const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str)
flex_string	wave/util/flex_string.hpp	/^    flex_string(const flex_string& str, size_type pos, $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos, size_type n = npos, const A& a = A())
flex_string	wave/util/flex_string.hpp	/^    flex_string(const value_type* s, const A& a = A())$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, const A& a = A())
flex_string	wave/util/flex_string.hpp	/^    flex_string(const value_type* s, size_type n, const A& a = A())$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type n, const A& a = A())
flex_string	wave/util/flex_string.hpp	/^    flex_string(size_type n, value_type c, const A& a = A())$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type n, value_type c, const A& a = A())
flex_string	wave/util/flex_string.hpp	/^class flex_string : private Storage$/;"	c	namespace:boost::wave::util	inherits:Storage
flex_string_details	wave/util/flex_string.hpp	/^namespace flex_string_details$/;"	n	namespace:boost::wave::util
flush_underlying_parser	wave/grammars/cpp_grammar.hpp	/^    struct flush_underlying_parser$/;"	s	namespace:boost::wave::grammars::impl	inherits:boost::spirit::classic::parser
flush_underlying_parser_p	wave/grammars/cpp_grammar.hpp	/^        flush_underlying_parser_p = flush_underlying_parser();$/;"	m	namespace:boost::wave::grammars::impl
force_include	wave/util/cpp_iterator.hpp	/^    bool force_include(char const *path_, bool is_last)$/;"	f	class:boost::wave::pp_iterator	access:public	signature:(char const *path_, bool is_last)
found_concat	wave/util/cpp_macromap_utils.hpp	/^    bool &found_concat;$/;"	m	class:boost::wave::util::impl::find_concat_operator	access:private
found_directive	wave/grammars/cpp_grammar.hpp	/^        TokenT &found_directive;$/;"	m	struct:boost::wave::grammars::impl::store_found_directive	access:public
found_directive	wave/grammars/cpp_grammar.hpp	/^    TokenT &found_directive;$/;"	m	struct:boost::wave::grammars::cpp_grammar	access:public
found_directive	wave/preprocessing_hooks.hpp	/^    found_directive(ContextT const& ctx, TokenT const& directive)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& directive)
found_directive	wave/preprocessing_hooks.hpp	/^    found_directive(TokenT const& directive)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(TokenT const& directive)
found_eof	wave/grammars/cpp_grammar.hpp	/^        bool &found_eof;$/;"	m	struct:boost::wave::grammars::impl::store_found_eof	access:public
found_eof	wave/grammars/cpp_grammar.hpp	/^    bool &found_eof;$/;"	m	struct:boost::wave::grammars::cpp_grammar	access:public
found_eoltokens	wave/grammars/cpp_grammar.hpp	/^        ContainerT &found_eoltokens;$/;"	m	struct:boost::wave::grammars::impl::store_found_eoltokens	access:public
found_eoltokens	wave/grammars/cpp_grammar.hpp	/^    ContainerT &found_eoltokens;$/;"	m	struct:boost::wave::grammars::cpp_grammar	access:public
found_error_directive	wave/preprocessing_hooks.hpp	/^    found_error_directive(ContextT const& ctx, ContainerT const& message)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT const& message)
found_include_directive	wave/preprocessing_hooks.hpp	/^    found_include_directive(ContextT const& ctx, std::string const& filename, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, std::string const& filename, bool include_next)
found_include_directive	wave/preprocessing_hooks.hpp	/^    found_include_directive(std::string const& filename, bool include_next) $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(std::string const& filename, bool include_next)
found_line_directive	wave/preprocessing_hooks.hpp	/^    found_line_directive(ContextT const& ctx, ContainerT const& arguments,$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT const& arguments, unsigned int line, std::string const& filename)
found_unknown_directive	wave/preprocessing_hooks.hpp	/^    found_unknown_directive(ContextT const& ctx, ContainerT const& line, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT const& line, ContainerT& pending)
found_warning_directive	wave/preprocessing_hooks.hpp	/^    found_warning_directive(ContextT const& ctx, ContainerT const& message)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT const& message)
from	wave/util/cpp_include_paths.hpp	/^struct from {};$/;"	s	namespace:boost::wave::util
ftor	wave/util/functor_input.hpp	/^            FunctorT ftor;$/;"	m	struct:boost::wave::util::functor_input::inner::Data	access:public
functor_data_type	wave/cpplexer/cpp_lex_iterator.hpp	/^        functor_data_type;$/;"	t	class:boost::wave::cpplexer::lex_iterator	access:private
functor_data_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    functor_data_type;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
functor_input	wave/util/functor_input.hpp	/^struct functor_input {$/;"	s	namespace:boost::wave::util
functor_input_type	wave/util/cpp_iterator.hpp	/^    typedef boost::wave::util::functor_input functor_input_type;$/;"	t	class:boost::wave::pp_iterator	access:private
gen_unput_queue_iterator	wave/util/unput_queue_iterator.hpp	/^    struct gen_unput_queue_iterator $/;"	s	namespace:boost::wave::util::impl
gen_unput_queue_iterator	wave/util/unput_queue_iterator.hpp	/^    struct gen_unput_queue_iterator<$/;"	s	namespace:boost::wave::util::impl
general	wave/whitespace_handling.hpp	/^    state_t general, newline, newline_2nd, whitespace, bol_whitespace;$/;"	m	class:boost::wave::context_policies::eat_whitespace	access:private
general	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::general(TokenT &token, bool &skipped_newline) $/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:(TokenT &token, bool &skipped_newline)
generate	wave/util/unput_queue_iterator.hpp	/^        generate(ContainerT &queue, iterator_type &it)$/;"	f	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public	signature:(ContainerT &queue, iterator_type &it)
generate	wave/util/unput_queue_iterator.hpp	/^        generate(ContainerT &queue, iterator_type const &it)$/;"	f	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public	signature:(ContainerT &queue, iterator_type const &it)
generate	wave/util/unput_queue_iterator.hpp	/^        generate(iterator_type &it)$/;"	f	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public	signature:(iterator_type &it)
generate	wave/util/unput_queue_iterator.hpp	/^        generate(iterator_type const &it)$/;"	f	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public	signature:(iterator_type const &it)
generated_token	wave/preprocessing_hooks.hpp	/^    generated_token(ContextT const& ctx, TokenT const& t)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& t)
generator	wave/util/cpp_macromap_predef.hpp	/^            string_type (predefined_macros:: *generator)() const;$/;"	m	struct:boost::wave::util::predefined_macros::dynamic_macros	access:public
generic_lexing_error	wave/cpplexer/cpplexer_exceptions.hpp	/^        generic_lexing_error = 5,$/;"	e	enum:boost::wave::cpplexer::lexing_exception::error_code
generic_lexing_warning	wave/cpplexer/cpplexer_exceptions.hpp	/^        generic_lexing_warning = 6$/;"	e	enum:boost::wave::cpplexer::lexing_exception::error_code
get	wave/cpplexer/cpp_lex_interface.hpp	/^    virtual TokenT& get(TokenT&) = 0;$/;"	p	struct:boost::wave::cpplexer::lex_input_interface	access:public	signature:(TokenT&)
get	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    token_type& get(token_type& result) { return re2c_lexer.get(result); }$/;"	f	class:boost::wave::cpplexer::re2clex::lex_functor	access:public	signature:(token_type& result)
get	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    token_type& get(token_type&);$/;"	p	class:boost::wave::cpplexer::re2clex::lexer	access:public	signature:(token_type&)
get	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^lexer<IteratorT, PositionT, TokenT>::get(TokenT& result)$/;"	f	class:boost::wave::cpplexer::re2clex::lexer	signature:(TokenT& result)
get_allocator	wave/util/flex_string.hpp	/^    A get_allocator() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
get_allocator	wave/util/flex_string.hpp	/^    A get_allocator() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
get_allocator	wave/util/flex_string.hpp	/^    A get_allocator() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
get_allocator	wave/util/flex_string.hpp	/^    allocator_type get_allocator() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
get_allocator	wave/util/flex_string.hpp	/^    allocator_type get_allocator() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
get_allocator	wave/util/flex_string.hpp	/^    allocator_type get_allocator() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
get_base_iterator	wave/util/unput_queue_iterator.hpp	/^    IteratorT &get_base_iterator() $/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:()
get_base_iterator	wave/util/unput_queue_iterator.hpp	/^    IteratorT const &get_base_iterator() const $/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:() const
get_column	wave/util/cpp_include_paths.hpp	/^    static unsigned int get_column() { return 0; }$/;"	f	struct:boost::wave::util::load_filepos	access:public	signature:()
get_column	wave/util/file_position.hpp	/^    std::size_t get_column() const { return column; }$/;"	f	struct:boost::wave::util::file_position	access:public	signature:() const
get_config	wave/util/cpp_macromap_predef.hpp	/^        string_type get_config() const$/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:() const
get_current_directory	wave/cpp_context.hpp	/^    boost::filesystem::path get_current_directory() const$/;"	f	class:boost::wave::context	access:public	signature:() const
get_current_directory	wave/util/cpp_include_paths.hpp	/^    boost::filesystem::path get_current_directory() const $/;"	f	class:boost::wave::util::include_paths	access:public	signature:() const
get_current_filename	wave/cpp_context.hpp	/^    std::string const &get_current_filename() const $/;"	f	class:boost::wave::context::std	access:public	signature:() const
get_current_relative_filename	wave/cpp_context.hpp	/^    std::string const &get_current_relative_filename() const $/;"	f	class:boost::wave::context::std	access:public	signature:() const
get_date	wave/util/cpp_macromap_predef.hpp	/^        string_type get_date() const { return datestr_; }     \/\/ __DATE__ $/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:() const
get_enclosing_if_block_status	wave/cpp_context.hpp	/^    bool get_enclosing_if_block_status() const$/;"	f	class:boost::wave::context	access:protected	signature:() const
get_enclosing_status	wave/util/cpp_ifblock.hpp	/^    bool get_enclosing_status() const { return enclosing_status; }$/;"	f	class:boost::wave::util::if_block	access:public	signature:() const
get_enclosing_status	wave/util/cpp_ifblock.hpp	/^    bool get_enclosing_status() const$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:() const
get_errorcode	wave/cpp_exceptions.hpp	/^    virtual int get_errorcode() const throw() = 0;$/;"	p	class:boost::wave::cpp_exception	access:public	signature:() const
get_errorcode	wave/cpp_exceptions.hpp	/^    virtual int get_errorcode() const throw()$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:() const
get_errorcode	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual int get_errorcode() const throw() = 0;$/;"	p	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
get_errorcode	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual int get_errorcode() const throw()$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:() const
get_file	wave/util/cpp_include_paths.hpp	/^    static std::string get_file() { return "<loading-state>"; }$/;"	f	struct:boost::wave::util::load_filepos	access:public	signature:()
get_file	wave/util/file_position.hpp	/^    string_type const &get_file() const { return file; }$/;"	f	struct:boost::wave::util::file_position	access:public	signature:() const
get_first	wave/util/symbol_table.hpp	/^    struct get_first$/;"	s	struct:boost::wave::util::symbol_table	access:private
get_full_name	wave/util/cpp_macromap_utils.hpp	/^get_full_name(IteratorT const &begin, IteratorT const &end)$/;"	f	namespace:boost::wave::util::impl	signature:(IteratorT const &begin, IteratorT const &end)
get_fullversion	wave/util/cpp_macromap_predef.hpp	/^        string_type get_fullversion() const { return version_; }$/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:() const
get_functor	wave/util/functor_input.hpp	/^        FunctorT& get_functor() const$/;"	f	class:boost::wave::util::functor_input::inner	access:public	signature:() const
get_hooks	wave/cpp_context.hpp	/^    hook_policy_type &get_hooks() { return hooks; }$/;"	f	class:boost::wave::context	access:public	signature:()
get_hooks	wave/cpp_context.hpp	/^    hook_policy_type const &get_hooks() const { return hooks; }$/;"	f	class:boost::wave::context	access:public	signature:() const
get_if_block_depth	wave/cpp_context.hpp	/^    typename boost::wave::util::if_block_stack::size_type get_if_block_depth() const $/;"	f	class:boost::wave::context	access:protected	signature:() const
get_if_block_depth	wave/util/cpp_ifblock.hpp	/^    size_type get_if_block_depth() const { return this->size(); }$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:() const
get_if_block_some_part_status	wave/cpp_context.hpp	/^    bool get_if_block_some_part_status() const $/;"	f	class:boost::wave::context	access:protected	signature:() const
get_if_block_status	wave/cpp_context.hpp	/^    bool get_if_block_status() const { return ifblocks.get_status(); }$/;"	f	class:boost::wave::context	access:protected	signature:() const
get_in_else	wave/util/cpp_ifblock.hpp	/^    bool get_in_else() const { return is_in_else; }$/;"	f	class:boost::wave::util::if_block	access:public	signature:() const
get_input	wave/util/functor_input.hpp	/^        reference get_input() const$/;"	f	class:boost::wave::util::functor_input::inner	access:public	signature:() const
get_iteration_depth	wave/cpp_context.hpp	/^    typename iteration_context_stack_type::size_type get_iteration_depth() const $/;"	f	class:boost::wave::context	access:public	signature:() const
get_language	wave/cpp_context.hpp	/^    boost::wave::language_support get_language() const { return language; }$/;"	f	class:boost::wave::context	access:public	signature:() const
get_line	wave/util/cpp_include_paths.hpp	/^    static unsigned int get_line() { return 0; }$/;"	f	struct:boost::wave::util::load_filepos	access:public	signature:()
get_line	wave/util/file_position.hpp	/^    std::size_t get_line() const { return line; }$/;"	f	struct:boost::wave::util::file_position	access:public	signature:() const
get_macro	wave/util/cpp_macromap.hpp	/^    bool get_macro(string_type const &name, bool &has_parameters,$/;"	p	class:boost::wave::util::macromap	access:public	signature:(string_type const &name, bool &has_parameters, bool &is_predefined, position_type &pos, parameter_container_type &parameters, definition_container_type &definition, defined_macros_type *scope = 0) const
get_macro	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::get_macro(string_type const &name, bool &has_parameters,$/;"	f	class:boost::wave::util::macromap	signature:(string_type const &name, bool &has_parameters, bool &is_predefined, position_type &pos, parameter_container_type &parameters, definition_container_type &definition, defined_macros_type *scope) const
get_macro_definition	wave/cpp_context.hpp	/^    bool get_macro_definition(StringT const &name, $/;"	f	class:boost::wave::context	access:public	signature:(StringT const &name, bool &has_params, bool &is_predefined, position_type &pos, std::vector<token_type> &parameters, token_sequence_type &definition) const
get_main_pos	wave/cpp_context.hpp	/^    position_type &get_main_pos() { return macros.get_main_pos(); }$/;"	f	class:boost::wave::context	access:public	signature:()
get_main_pos	wave/cpp_context.hpp	/^    position_type const& get_main_pos() const { return macros.get_main_pos(); }$/;"	f	class:boost::wave::context	access:public	signature:() const
get_main_pos	wave/util/cpp_macromap.hpp	/^    position_type &get_main_pos() { return main_pos; }$/;"	f	class:boost::wave::util::macromap	access:public	signature:()
get_main_pos	wave/util/cpp_macromap.hpp	/^    position_type const& get_main_pos() const { return main_pos; }$/;"	f	class:boost::wave::util::macromap	access:public	signature:() const
get_max_include_nesting_depth	wave/cpp_context.hpp	/^    iter_size_type get_max_include_nesting_depth() const$/;"	f	class:boost::wave::context	access:public	signature:() const
get_max_include_nesting_depth	wave/util/iteration_context.hpp	/^    size_type get_max_include_nesting_depth() const$/;"	f	class:boost::wave::util::iteration_context_stack	access:public	signature:() const
get_next	wave/cpplexer/cpp_lex_iterator.hpp	/^    static result_type& get_next(MultiPass& mp, result_type& result)$/;"	f	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public	signature:(MultiPass& mp, result_type& result)
get_next_token	wave/util/cpp_iterator.hpp	/^    result_type const &get_next_token();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:()
get_next_token	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::get_next_token()$/;"	f	class:boost::wave::impl::pp_iterator_functor::pp_iterator_functor	signature:()
get_position	wave/cpplexer/cpp_lex_token.hpp	/^    position_type const &get_position() const { return data->get_position(); }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:() const
get_position	wave/cpplexer/cpp_lex_token.hpp	/^    position_type const &get_position() const { return pos; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:() const
get_refcnt	wave/cpplexer/cpp_lex_token.hpp	/^    std::size_t get_refcnt() const { return refcnt; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:() const
get_related_name	wave/cpp_exceptions.hpp	/^    char const* get_related_name() const throw()$/;"	f	class:boost::wave::macro_handling_exception	access:public	signature:() const
get_related_name	wave/cpp_exceptions.hpp	/^    virtual char const* get_related_name() const throw() = 0;$/;"	p	class:boost::wave::cpp_exception	access:public	signature:() const
get_related_name	wave/cpp_exceptions.hpp	/^    virtual char const* get_related_name() const throw()$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:() const
get_severity	wave/cpp_exceptions.hpp	/^    get_severity(int level)$/;"	f	namespace:boost::wave::util	signature:(int level)
get_severity	wave/cpp_exceptions.hpp	/^    virtual int get_severity() const throw() = 0;$/;"	p	class:boost::wave::cpp_exception	access:public	signature:() const
get_severity	wave/cpp_exceptions.hpp	/^    virtual int get_severity() const throw()$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:() const
get_severity	wave/cpplexer/cpplexer_exceptions.hpp	/^    get_severity(severity level)$/;"	f	namespace:boost::wave::cpplexer::util	signature:(severity level)
get_severity	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual int get_severity() const throw() = 0;$/;"	p	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
get_severity	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual int get_severity() const throw()$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:() const
get_some_part_status	wave/util/cpp_ifblock.hpp	/^    bool get_some_part_status() const { return some_part_status; }$/;"	f	class:boost::wave::util::if_block	access:public	signature:() const
get_some_part_status	wave/util/cpp_ifblock.hpp	/^    bool get_some_part_status() const$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:() const
get_status	wave/util/cpp_ifblock.hpp	/^    bool get_status() const { return status; }$/;"	f	class:boost::wave::util::if_block	access:public	signature:() const
get_status	wave/util/cpp_ifblock.hpp	/^    bool get_status() const$/;"	f	class:boost::wave::util::if_block_stack	access:public	signature:() const
get_support_options	wave/language_support.hpp	/^get_support_options(language_support language)$/;"	f	namespace:boost::wave	signature:(language_support language)
get_time	wave/util/cpp_macromap_predef.hpp	/^        string_type get_time() const { return timestr_; }     \/\/ __TIME__$/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:() const
get_time	wave/util/time_conversion_helper.hpp	/^        time_t get_time() const { return compile_time; }$/;"	f	class:boost::wave::util::time_conversion::time_conversion_helper	access:public	signature:() const
get_token_id	wave/cpplexer/cpp_lex_token.hpp	/^    static int get_token_id(lex_token const &t) $/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(lex_token const &t)
get_token_name	wave/token_ids.hpp	/^BOOST_WAVE_STRINGTYPE get_token_name(token_id tokid);$/;"	p	namespace:boost::wave	signature:(token_id tokid)
get_token_value	wave/cpplexer/cpp_lex_token.hpp	/^    static string_type get_token_value(lex_token const &t) $/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(lex_token const &t)
get_token_value	wave/cpplexer/token_cache.hpp	/^    StringT const &get_token_value(token_id id) const$/;"	f	class:boost::wave::cpplexer::token_cache	access:public	signature:(token_id id) const
get_token_value	wave/token_ids.hpp	/^char const *get_token_value(token_id tokid);$/;"	p	namespace:boost::wave	signature:(token_id tokid)
get_token_value	wave/util/transform_iterator.hpp	/^    struct get_token_value {$/;"	s	namespace:boost::wave::impl
get_type	wave/grammars/cpp_expression_value.hpp	/^    value_type get_type() const { return type; }$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:() const
get_unput_queue	wave/util/unput_queue_iterator.hpp	/^    ContainerT &get_unput_queue() $/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:()
get_unput_queue	wave/util/unput_queue_iterator.hpp	/^    ContainerT const &get_unput_queue() const $/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:() const
get_unsigned	wave/util/flex_string.hpp	/^    template <> struct get_unsigned<char>$/;"	s	namespace:boost::wave::util::flex_string_details
get_unsigned	wave/util/flex_string.hpp	/^    template <> struct get_unsigned<int>$/;"	s	namespace:boost::wave::util::flex_string_details
get_unsigned	wave/util/flex_string.hpp	/^    template <> struct get_unsigned<long int>$/;"	s	namespace:boost::wave::util::flex_string_details
get_unsigned	wave/util/flex_string.hpp	/^    template <> struct get_unsigned<short int>$/;"	s	namespace:boost::wave::util::flex_string_details
get_unsigned	wave/util/flex_string.hpp	/^    template <> struct get_unsigned<signed char>$/;"	s	namespace:boost::wave::util::flex_string_details
get_unsigned	wave/util/flex_string.hpp	/^    template <typename T> struct get_unsigned$/;"	s	namespace:boost::wave::util::flex_string_details
get_value	wave/cpplexer/cpp_lex_token.hpp	/^    string_type const &get_value() const { return data->get_value(); }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:() const
get_value	wave/cpplexer/cpp_lex_token.hpp	/^    string_type const &get_value() const { return value; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:() const
get_version	wave/cpp_context.hpp	/^    static std::string get_version()  $/;"	f	class:boost::wave::context	access:public	signature:()
get_version	wave/util/cpp_macromap_predef.hpp	/^        string_type get_version() const$/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:() const
get_version_string	wave/cpp_context.hpp	/^    static std::string get_version_string()  $/;"	f	class:boost::wave::context	access:public	signature:()
get_versionstr	wave/util/cpp_macromap_predef.hpp	/^        string_type get_versionstr() const { return versionstr_; }$/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:() const
grammar_type	wave/grammars/cpp_grammar.hpp	/^    typedef cpp_grammar<TokenT, ContainerT> grammar_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar	access:public
grammars	wave/grammars/cpp_chlit_grammar.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
grammars	wave/grammars/cpp_defined_grammar.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
grammars	wave/grammars/cpp_defined_grammar_gen.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
grammars	wave/grammars/cpp_expression_grammar.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
grammars	wave/grammars/cpp_expression_grammar_gen.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
grammars	wave/grammars/cpp_expression_value.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
grammars	wave/grammars/cpp_grammar.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
grammars	wave/grammars/cpp_grammar_gen.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
grammars	wave/grammars/cpp_intlit_grammar.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
grammars	wave/grammars/cpp_literal_grammar_gen.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
grammars	wave/grammars/cpp_predef_macros_gen.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
grammars	wave/grammars/cpp_predef_macros_grammar.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
grammars	wave/grammars/cpp_value_error.hpp	/^namespace grammars {$/;"	n	namespace:boost::wave
guard_name	wave/cpplexer/detect_include_guards.hpp	/^    typename Token::string_type guard_name;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
guards	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    include_guards<token_type> guards;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
handle_alt_leftbrace	wave/util/insert_whitespace_detection.hpp	/^    handle_alt_leftbrace(boost::wave::token_id prev, $/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id )
handle_alt_leftbracket	wave/util/insert_whitespace_detection.hpp	/^    handle_alt_leftbracket(boost::wave::token_id prev, $/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id )
handle_dot	wave/util/insert_whitespace_detection.hpp	/^    handle_dot(boost::wave::token_id prev, boost::wave::token_id before)$/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id before)
handle_fixedpointlit	wave/util/insert_whitespace_detection.hpp	/^    handle_fixedpointlit(boost::wave::token_id prev, $/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id )
handle_floatlit	wave/util/insert_whitespace_detection.hpp	/^    handle_floatlit(boost::wave::token_id prev, $/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id )
handle_identifier	wave/util/insert_whitespace_detection.hpp	/^    handle_identifier(boost::wave::token_id prev, $/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id before, StringT const &value)
handle_intlit	wave/util/insert_whitespace_detection.hpp	/^    handle_intlit(boost::wave::token_id prev, boost::wave::token_id \/*before*\/)$/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id )
handle_newline	wave/util/insert_whitespace_detection.hpp	/^    handle_newline(boost::wave::token_id prev, $/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id before)
handle_parens	wave/util/insert_whitespace_detection.hpp	/^    handle_parens(boost::wave::token_id prev)$/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev)
handle_pp_directive	wave/util/cpp_iterator.hpp	/^    bool handle_pp_directive(IteratorT &it);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(IteratorT &it)
handle_pp_directive	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::handle_pp_directive(IteratorT &it)$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(IteratorT &it)
handle_questionmark	wave/grammars/cpp_expression_value.hpp	/^    handle_questionmark(closure_value const &cond, closure_value const &val2)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &cond, closure_value const &val2)
handle_questionmark	wave/util/insert_whitespace_detection.hpp	/^    handle_questionmark(boost::wave::token_id prev, $/;"	f	namespace:boost::wave::util::impl	signature:(boost::wave::token_id prev, boost::wave::token_id )
has_been_initialized	wave/cpp_context.hpp	/^    bool has_been_initialized;          \/\/ set cwd once$/;"	m	class:boost::wave::context	access:private
has_ellipsis	wave/util/macro_definition.hpp	/^    bool has_ellipsis;$/;"	m	struct:boost::wave::util::macro_definition	access:public
has_include_guards	wave/cpplexer/cpp_lex_interface.hpp	/^    virtual bool has_include_guards(std::string& guard_name) const = 0;$/;"	p	struct:boost::wave::cpplexer::lex_input_interface	access:public	signature:(std::string& guard_name) const
has_include_guards	wave/cpplexer/cpp_lex_iterator.hpp	/^    bool has_include_guards(std::string& guard_name) const$/;"	f	class:boost::wave::cpplexer::lex_iterator	access:public	signature:(std::string& guard_name) const
has_include_guards	wave/cpplexer/cpp_lex_iterator.hpp	/^    static bool has_include_guards(MultiPass& mp, std::string& guard_name) $/;"	f	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public	signature:(MultiPass& mp, std::string& guard_name)
has_include_guards	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    bool has_include_guards(std::string& guard_name) const$/;"	f	class:boost::wave::cpplexer::re2clex::lex_functor	access:public	signature:(std::string& guard_name) const
has_include_guards	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    bool has_include_guards(std::string& guard_name) const$/;"	f	class:boost::wave::cpplexer::re2clex::lexer	access:public	signature:(std::string& guard_name) const
has_pragma_once	wave/cpp_context.hpp	/^    bool has_pragma_once(std::string const &filename_)$/;"	f	class:boost::wave::context	access:public	signature:(std::string const &filename_)
has_pragma_once	wave/util/cpp_include_paths.hpp	/^    bool has_pragma_once(std::string const &filename)$/;"	f	class:boost::wave::util::include_paths	access:public	signature:(std::string const &filename)
head	wave/cpplexer/re2clex/aq.hpp	/^    std::size_t head;$/;"	m	struct:boost::wave::cpplexer::re2clex::tag_aq_queuetype	access:public
hex_lit	wave/grammars/cpp_intlit_grammar.hpp	/^        boost::spirit::classic::subrule<2> hex_lit;$/;"	m	struct:boost::wave::grammars::intlit_grammar::definition	access:public
hook_policy_type	wave/cpp_context.hpp	/^    typedef HooksT                                  hook_policy_type;$/;"	t	class:boost::wave::context	access:public
hooks	wave/cpp_context.hpp	/^    hook_policy_type hooks;                       \/\/ hook policy instance$/;"	m	class:boost::wave::context	access:private
i	wave/grammars/cpp_expression_value.hpp	/^        int_literal_type i;$/;"	m	union:boost::wave::grammars::closures::closure_value::__anon7	access:public
id	wave/cpplexer/cpp_lex_token.hpp	/^    token_id id;                \/\/ the token id$/;"	m	class:boost::wave::cpplexer::impl::token_data	access:private
identifier	wave/grammars/cpp_defined_grammar.hpp	/^        rule_t identifier;$/;"	m	struct:boost::wave::grammars::defined_grammar::definition	access:public
if_block	wave/util/cpp_ifblock.hpp	/^    if_block() :$/;"	f	class:boost::wave::util::if_block	access:public	signature:()
if_block	wave/util/cpp_ifblock.hpp	/^    if_block(bool status_, bool enclosing_status_) : $/;"	f	class:boost::wave::util::if_block	access:public	signature:(bool status_, bool enclosing_status_)
if_block	wave/util/cpp_ifblock.hpp	/^class if_block$/;"	c	namespace:boost::wave::util
if_block_depth	wave/cpp_iteration_context.hpp	/^    std::size_t if_block_depth; \/\/ depth of #if block recursion$/;"	m	struct:boost::wave::base_iteration_context	access:public
if_block_stack	wave/util/cpp_ifblock.hpp	/^class if_block_stack $/;"	c	namespace:boost::wave::util	inherits:std::stack
if_depth	wave/cpplexer/detect_include_guards.hpp	/^    int if_depth;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
ifblocks	wave/cpp_context.hpp	/^    boost::wave::util::if_block_stack ifblocks;   \/\/ conditional compilation contexts$/;"	m	class:boost::wave::context	access:private
ill_formed_character_literal	wave/cpp_exceptions.hpp	/^        ill_formed_character_literal,$/;"	e	enum:boost::wave::preprocess_exception::error_code
ill_formed_directive	wave/cpp_exceptions.hpp	/^        ill_formed_directive,$/;"	e	enum:boost::wave::preprocess_exception::error_code
ill_formed_expression	wave/cpp_exceptions.hpp	/^        ill_formed_expression,$/;"	e	enum:boost::wave::preprocess_exception::error_code
ill_formed_integer_literal	wave/cpp_exceptions.hpp	/^        ill_formed_integer_literal,$/;"	e	enum:boost::wave::preprocess_exception::error_code
ill_formed_operator	wave/cpp_exceptions.hpp	/^        ill_formed_operator,$/;"	e	enum:boost::wave::preprocess_exception::error_code
ill_formed_pragma_message	wave/cpp_exceptions.hpp	/^        ill_formed_pragma_message,$/;"	e	enum:boost::wave::preprocess_exception::error_code
ill_formed_pragma_option	wave/cpp_exceptions.hpp	/^        ill_formed_pragma_option,$/;"	e	enum:boost::wave::preprocess_exception::error_code
illegal_operator_redefinition	wave/cpp_exceptions.hpp	/^        illegal_operator_redefinition,$/;"	e	enum:boost::wave::preprocess_exception::error_code
illegal_redefinition	wave/cpp_exceptions.hpp	/^        illegal_redefinition,$/;"	e	enum:boost::wave::preprocess_exception::error_code
illformed	wave/grammars/cpp_grammar.hpp	/^        rule_type illformed;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
impl	wave/cpplexer/convert_trigraphs.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::cpplexer
impl	wave/cpplexer/cpp_lex_iterator.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::cpplexer
impl	wave/cpplexer/cpp_lex_token.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::cpplexer
impl	wave/cpplexer/validate_universal_char.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::cpplexer
impl	wave/grammars/cpp_chlit_grammar.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::grammars
impl	wave/grammars/cpp_expression_grammar.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::grammars
impl	wave/grammars/cpp_grammar.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::grammars
impl	wave/util/cpp_iterator.hpp	/^namespace impl {$/;"	n	namespace:boost::wave
impl	wave/util/cpp_iterator.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::impl
impl	wave/util/cpp_macromap_utils.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::util
impl	wave/util/insert_whitespace_detection.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::util
impl	wave/util/macro_helpers.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::util
impl	wave/util/transform_iterator.hpp	/^namespace impl {$/;"	n	namespace:boost::wave
impl	wave/util/unput_queue_iterator.hpp	/^namespace impl {$/;"	n	namespace:boost::wave::util
implementation_level	wave/util/flex_string.hpp	/^struct implementation_level<boost::wave::util::flex_string<E, T, A, S> >$/;"	s	namespace:boost::serialization
improperly_terminated_macro	wave/cpp_exceptions.hpp	/^        improperly_terminated_macro,$/;"	e	enum:boost::wave::preprocess_exception::error_code
in_range	wave/cpplexer/validate_universal_char.hpp	/^in_range(unsigned long ch, unsigned long l, unsigned long u)$/;"	f	namespace:boost::wave::cpplexer::impl	signature:(unsigned long ch, unsigned long l, unsigned long u)
include_guards	wave/cpplexer/detect_include_guards.hpp	/^    include_guards()$/;"	f	class:boost::wave::cpplexer::include_guards	access:public	signature:()
include_guards	wave/cpplexer/detect_include_guards.hpp	/^class include_guards$/;"	c	namespace:boost::wave::cpplexer
include_list_type	wave/util/cpp_include_paths.hpp	/^        include_list_type;$/;"	t	class:boost::wave::util::include_paths	access:private
include_nesting_too_deep	wave/cpp_exceptions.hpp	/^        include_nesting_too_deep,$/;"	e	enum:boost::wave::preprocess_exception::error_code
include_paths	wave/util/cpp_include_paths.hpp	/^    include_paths()$/;"	f	class:boost::wave::util::include_paths	access:public	signature:()
include_paths	wave/util/cpp_include_paths.hpp	/^class include_paths$/;"	c	namespace:boost::wave::util
include_value_type	wave/util/cpp_include_paths.hpp	/^    typedef include_list_type::value_type include_value_type;$/;"	t	class:boost::wave::util::include_paths	access:private
includes	wave/cpp_context.hpp	/^    boost::wave::util::include_paths includes;    \/\/ lists of include directories to search$/;"	m	class:boost::wave::context	access:private
inclusive_or_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t inclusive_or_exp, exclusive_or_exp, and_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
inclusive_or_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t inclusive_or_exp_nocalc, exclusive_or_exp_nocalc, and_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
incompatible_config	wave/cpp_exceptions.hpp	/^        incompatible_config,$/;"	e	enum:boost::wave::preprocess_exception::error_code
increment	wave/util/unput_queue_iterator.hpp	/^    void increment()$/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:()
init	wave/cpplexer/cpp_lex_token.hpp	/^    void init(token_data const& rhs)$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(token_data const& rhs)
init	wave/cpplexer/cpp_lex_token.hpp	/^    void init(token_id id_, string_type const &value_, position_type const &pos_)$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(token_id id_, string_type const &value_, position_type const &pos_)
init_context	wave/cpp_context.hpp	/^    void init_context()$/;"	f	class:boost::wave::context	access:protected	signature:()
init_iterators	wave/cpp_iteration_context.hpp	/^            static void init_iterators(IterContextT &iter_ctx,$/;"	f	class:boost::wave::iteration_context_policies::load_file_to_string::inner	access:public	signature:(IterContextT &iter_ctx, PositionT const &act_pos, language_support language)
init_predefined_macros	wave/util/cpp_macromap.hpp	/^    void init_predefined_macros(char const *fname = "<Unknown>",$/;"	p	class:boost::wave::util::macromap	access:public	signature:(char const *fname = , defined_macros_type *scope = 0, bool at_global_scope = true)
init_predefined_macros	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::init_predefined_macros(char const *fname,$/;"	f	class:boost::wave::util::macromap	signature:(char const *fname, defined_macros_type *scope, bool at_global_scope)
init_rule_id_to_name_map	wave/grammars/cpp_grammar.hpp	/^        void init_rule_id_to_name_map(cpp_grammar const &self)$/;"	f	struct:boost::wave::grammars::cpp_grammar::map_ruleid_to_name	access:public	signature:(cpp_grammar const &self)
initial_path	wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path initial_path()$/;"	f	namespace:boost::wave::util	signature:()
inner	wave/cpp_iteration_context.hpp	/^        class inner$/;"	c	struct:boost::wave::iteration_context_policies::load_file_to_string	access:public
inner	wave/util/functor_input.hpp	/^        inner()$/;"	f	class:boost::wave::util::functor_input::inner	access:protected	signature:()
inner	wave/util/functor_input.hpp	/^        inner(FunctorT const &x)$/;"	f	class:boost::wave::util::functor_input::inner	access:protected	signature:(FunctorT const &x)
inner	wave/util/functor_input.hpp	/^        inner(inner const &x)$/;"	f	class:boost::wave::util::functor_input::inner	access:protected	signature:(inner const &x)
inner	wave/util/functor_input.hpp	/^    class inner {$/;"	c	struct:boost::wave::util::functor_input	access:public
input_at_eof	wave/util/functor_input.hpp	/^        bool input_at_eof() const$/;"	f	class:boost::wave::util::functor_input::inner	access:public	signature:() const
input_policy	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef boost::spirit::iterator_policies::split_functor_input input_policy;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
input_policy_type	wave/cpp_context.hpp	/^    typedef InputPolicyT                            input_policy_type;$/;"	t	class:boost::wave::context	access:public
input_policy_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef impl::lex_iterator_functor_shim<TokenT> input_policy_type;$/;"	t	class:boost::wave::cpplexer::lex_iterator	access:private
input_policy_type	wave/util/cpp_iterator.hpp	/^    typedef boost::wave::impl::pp_iterator_functor<ContextT> input_policy_type;$/;"	t	class:boost::wave::pp_iterator	access:public
insert	wave/util/flex_string.hpp	/^    flex_string& insert(size_type pos, const value_type* s)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos, const value_type* s)
insert	wave/util/flex_string.hpp	/^    flex_string& insert(size_type pos, const value_type* s, size_type n)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos, const value_type* s, size_type n)
insert	wave/util/flex_string.hpp	/^    flex_string& insert(size_type pos, size_type n, value_type c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos, size_type n, value_type c)
insert	wave/util/flex_string.hpp	/^    flex_string& insert(size_type pos1, const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, const flex_string& str)
insert	wave/util/flex_string.hpp	/^    flex_string& insert(size_type pos1, const flex_string& str,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, const flex_string& str, size_type pos2, size_type n)
insert	wave/util/flex_string.hpp	/^    iterator insert(iterator p, value_type c = value_type()) $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(iterator p, value_type c = value_type())
insert	wave/util/flex_string.hpp	/^    void insert(iterator p, ItOrLength first_or_n, ItOrChar last_or_c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(iterator p, ItOrLength first_or_n, ItOrChar last_or_c)
insert_whitespace	wave/util/insert_whitespace_detection.hpp	/^    bool insert_whitespace;            \/\/ enable this component$/;"	m	class:boost::wave::util::insert_whitespace_detection	access:private
insert_whitespace_detection	wave/util/insert_whitespace_detection.hpp	/^    insert_whitespace_detection(bool insert_whitespace_ = true) $/;"	f	class:boost::wave::util::insert_whitespace_detection	access:public	signature:(bool insert_whitespace_ = true)
insert_whitespace_detection	wave/util/insert_whitespace_detection.hpp	/^class insert_whitespace_detection $/;"	c	namespace:boost::wave::util
instring	wave/cpp_iteration_context.hpp	/^            std::string instring;$/;"	m	class:boost::wave::iteration_context_policies::load_file_to_string::inner	access:private
int_lit	wave/grammars/cpp_intlit_grammar.hpp	/^        rule_t int_lit;$/;"	m	struct:boost::wave::grammars::intlit_grammar::definition	access:public
int_literal_type	wave/wave_config.hpp	/^    typedef boost::long_long_type int_literal_type;$/;"	t	namespace:boost::wave
integer_overflow	wave/cpp_exceptions.hpp	/^        integer_overflow,$/;"	e	enum:boost::wave::preprocess_exception::error_code
interpret_pragma	wave/preprocessing_hooks.hpp	/^    interpret_pragma(ContextT const& ctx, ContainerT &pending, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT &pending, typename ContextT::token_type const& option, ContainerT const& values, typename ContextT::token_type const& act_token)
interpret_pragma	wave/util/cpp_iterator.hpp	/^    bool interpret_pragma(token_sequence_type const &pragma_body,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(token_sequence_type const &pragma_body, token_sequence_type &result)
interpret_pragma	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::interpret_pragma($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( token_sequence_type const &pragma_body, token_sequence_type &result)
interpret_pragma	wave/util/interpret_pragma.hpp	/^interpret_pragma(ContextT &ctx, typename ContextT::token_type const &act_token,$/;"	f	namespace:boost::wave::util	signature:(ContextT &ctx, typename ContextT::token_type const &act_token, IteratorT it, IteratorT const &end, ContainerT &pending)
intlit_closure	wave/grammars/cpp_intlit_grammar.hpp	/^    struct intlit_closure $/;"	s	namespace:boost::wave::grammars::closures	inherits:boost::spirit::classic::closure
intlit_grammar	wave/grammars/cpp_intlit_grammar.hpp	/^    intlit_grammar(bool &is_unsigned_) : is_unsigned(is_unsigned_)$/;"	f	struct:boost::wave::grammars::intlit_grammar	access:public	signature:(bool &is_unsigned_)
intlit_grammar	wave/grammars/cpp_intlit_grammar.hpp	/^struct intlit_grammar :$/;"	s	namespace:boost::wave::grammars	inherits:boost::spirit::classic::grammar
intlit_grammar_gen	wave/grammars/cpp_literal_grammar_gen.hpp	/^struct BOOST_WAVE_DECL intlit_grammar_gen {$/;"	s	namespace:boost::wave::grammars
intrusive_ptr_add_ref	wave/util/macro_definition.hpp	/^intrusive_ptr_add_ref(macro_definition<TokenT, ContainerT>* p)$/;"	f	namespace:boost::wave::util	signature:(macro_definition<TokenT, ContainerT>* p)
intrusive_ptr_release	wave/util/macro_definition.hpp	/^intrusive_ptr_release(macro_definition<TokenT, ContainerT>* p)$/;"	f	namespace:boost::wave::util	signature:(macro_definition<TokenT, ContainerT>* p)
invalid_concat	wave/cpp_exceptions.hpp	/^        invalid_concat,$/;"	e	enum:boost::wave::preprocess_exception::error_code
invalid_long_long_literal	wave/cpplexer/cpplexer_exceptions.hpp	/^        invalid_long_long_literal = 4,$/;"	e	enum:boost::wave::cpplexer::lexing_exception::error_code
invalid_macroname	wave/cpp_exceptions.hpp	/^        invalid_macroname,$/;"	e	enum:boost::wave::preprocess_exception::error_code
is_available_for_replacement	wave/util/macro_definition.hpp	/^    bool is_available_for_replacement;$/;"	m	struct:boost::wave::util::macro_definition	access:public
is_bool	wave/grammars/cpp_expression_value.hpp	/^        is_bool = 3$/;"	e	enum:boost::wave::grammars::closures::closure_value::value_type
is_defined	wave/util/cpp_macromap.hpp	/^    bool is_defined(IteratorT const &begin, IteratorT const &end) const;$/;"	p	class:boost::wave::util::macromap	access:public	signature:(IteratorT const &begin, IteratorT const &end) const
is_defined	wave/util/cpp_macromap.hpp	/^    bool is_defined(string_type const &name,$/;"	p	class:boost::wave::util::macromap	access:public	signature:(string_type const &name, typename defined_macros_type::iterator &it, defined_macros_type *scope = 0) const
is_defined	wave/util/cpp_macromap.hpp	/^    bool is_defined(string_type const &str) const;$/;"	p	class:boost::wave::util::macromap	access:public	signature:(string_type const &str) const
is_defined	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::is_defined(IteratorT const &begin,$/;"	f	class:boost::wave::util::macromap	signature:(IteratorT const &begin, IteratorT const &end) const
is_defined	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::is_defined(string_type const &str) const$/;"	f	class:boost::wave::util::macromap	signature:(string_type const &str) const
is_defined	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::is_defined(typename token_type::string_type const &name,$/;"	f	class:boost::wave::util::macromap	signature:(typename token_type::string_type const &name, typename defined_macros_type::iterator &it, defined_macros_type *scope) const
is_defined_macro	wave/cpp_context.hpp	/^    bool is_defined_macro(IteratorT2 const &begin, IteratorT2 const &end) const$/;"	f	class:boost::wave::context	access:protected	signature:(IteratorT2 const &begin, IteratorT2 const &end) const
is_defined_macro	wave/cpp_context.hpp	/^    bool is_defined_macro(StringT const &str) const$/;"	f	class:boost::wave::context	access:public	signature:(StringT const &str) const
is_eoi	wave/cpplexer/cpp_lex_token.hpp	/^    bool is_eoi() const { return 0 == data || token_id(*data) == T_EOI; }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:() const
is_functionlike	wave/util/macro_definition.hpp	/^    bool is_functionlike;$/;"	m	struct:boost::wave::util::macro_definition	access:public
is_in_else	wave/util/cpp_ifblock.hpp	/^   bool is_in_else;         \/\/ Inside the #else part$/;"	m	class:boost::wave::util::if_block	access:private
is_inside_elsepart	wave/util/cpp_ifblock.hpp	/^    bool is_inside_elsepart() const$/;"	f	class:boost::wave::util::if_block_stack	access:protected	signature:() const
is_inside_ifpart	wave/util/cpp_ifblock.hpp	/^    bool is_inside_ifpart() const$/;"	f	class:boost::wave::util::if_block_stack	access:protected	signature:() const
is_int	wave/grammars/cpp_expression_value.hpp	/^        is_int = 1,$/;"	e	enum:boost::wave::grammars::closures::closure_value::value_type
is_pp_token	wave/token_ids.hpp	/^inline bool is_pp_token(TokenT const& tok)$/;"	f	namespace:boost::wave	signature:(TokenT const& tok)
is_pp_token	wave/token_ids.hpp	/^inline bool is_pp_token(boost::wave::token_id id)$/;"	f	namespace:boost::wave	signature:(boost::wave::token_id id)
is_predefined	wave/util/macro_definition.hpp	/^    bool is_predefined;$/;"	m	struct:boost::wave::util::macro_definition	access:public
is_recoverable	wave/cpp_exceptions.hpp	/^    virtual bool is_recoverable() const throw() = 0;$/;"	p	class:boost::wave::cpp_exception	access:public	signature:() const
is_recoverable	wave/cpp_exceptions.hpp	/^    virtual bool is_recoverable() const throw()$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:() const
is_recoverable	wave/cpp_exceptions.hpp	/^is_recoverable(cpp_exception const& e)$/;"	f	namespace:boost::wave	signature:(cpp_exception const& e)
is_recoverable	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual bool is_recoverable() const throw() = 0;$/;"	p	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
is_recoverable	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual bool is_recoverable() const throw()$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:() const
is_recoverable	wave/cpplexer/cpplexer_exceptions.hpp	/^is_recoverable(lexing_exception const& e)$/;"	f	namespace:boost::wave::cpplexer	signature:(lexing_exception const& e)
is_skippable	wave/cpplexer/detect_include_guards.hpp	/^    bool is_skippable(token_id id) const$/;"	f	class:boost::wave::cpplexer::include_guards	access:private	signature:(token_id id) const
is_special_macroname	wave/util/cpp_macromap_utils.hpp	/^is_special_macroname (StringT const &name)$/;"	f	namespace:boost::wave::util::impl	signature:(StringT const &name)
is_trigraph	wave/cpplexer/convert_trigraphs.hpp	/^is_trigraph(StringT const& trigraph)$/;"	f	namespace:boost::wave::cpplexer::impl	signature:(StringT const& trigraph)
is_uint	wave/grammars/cpp_expression_value.hpp	/^        is_uint = 2,$/;"	e	enum:boost::wave::grammars::closures::closure_value::value_type
is_unsigned	wave/grammars/cpp_intlit_grammar.hpp	/^    bool &is_unsigned;$/;"	m	struct:boost::wave::grammars::intlit_grammar	access:public
is_valid	wave/cpplexer/cpp_lex_token.hpp	/^    bool is_valid() const { return 0 != data && token_id(*data) != T_UNKNOWN; }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:() const
is_valid	wave/grammars/cpp_expression_value.hpp	/^    value_error is_valid() const { return valid; }$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:() const
is_valid_concat	wave/util/cpp_macromap.hpp	/^    bool is_valid_concat(string_type new_value,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(string_type new_value, position_type const &pos, ContainerT &rescanned)
is_valid_concat	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::is_valid_concat(string_type new_value,$/;"	f	class:boost::wave::util::macromap	signature:(string_type new_value, position_type const &pos, ContainerT &rescanned)
is_whitespace_only	wave/util/cpp_macromap_utils.hpp	/^is_whitespace_only (ContainerT const &argument)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT const &argument)
it	wave/util/cpp_macromap_utils.hpp	/^        IteratorT &it;$/;"	m	class:boost::wave::util::on_exit::assign	access:private
iter_ctx	wave/util/cpp_iterator.hpp	/^    boost::shared_ptr<base_iteration_context_type> iter_ctx;$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
iter_ctx	wave/util/iteration_context.hpp	/^    base_type iter_ctx;$/;"	m	class:boost::wave::util::iteration_context_stack	access:private
iter_ctxs	wave/cpp_context.hpp	/^    iteration_context_stack_type iter_ctxs;       \/\/ iteration contexts$/;"	m	class:boost::wave::context	access:private
iter_size_type	wave/cpp_context.hpp	/^    typedef typename iteration_context_stack_type::size_type iter_size_type;$/;"	t	class:boost::wave::context	access:private
iteration_context	wave/cpp_iteration_context.hpp	/^    iteration_context(ContextT& ctx, BOOST_WAVE_STRINGTYPE const &fname,$/;"	f	struct:boost::wave::iteration_context	access:public	signature:(ContextT& ctx, BOOST_WAVE_STRINGTYPE const &fname, position_type const &act_pos, boost::wave::language_support language_, typename base_type::file_type type = base_type::main_file)
iteration_context	wave/cpp_iteration_context.hpp	/^struct iteration_context$/;"	s	namespace:boost::wave	inherits:base_iteration_context,InputPolicyT::,inner
iteration_context_policies	wave/cpp_iteration_context.hpp	/^namespace iteration_context_policies {$/;"	n	namespace:boost::wave
iteration_context_stack	wave/util/iteration_context.hpp	/^    iteration_context_stack()$/;"	f	class:boost::wave::util::iteration_context_stack	access:public	signature:()
iteration_context_stack	wave/util/iteration_context.hpp	/^class iteration_context_stack$/;"	c	namespace:boost::wave::util
iteration_context_stack_type	wave/cpp_context.hpp	/^            iteration_context_stack_type;$/;"	t	class:boost::wave::context	access:private
iteration_context_type	wave/util/cpp_iterator.hpp	/^    typedef iteration_context<ContextT, lexer_type> iteration_context_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
iteration_policy_t	wave/grammars/cpp_grammar.hpp	/^        typedef typename ScannerT::iteration_policy_t iteration_policy_t;$/;"	t	struct:boost::wave::grammars::cpp_grammar::definition	access:public
iteration_ptr_type	wave/cpp_context.hpp	/^        iteration_ptr_type;$/;"	t	class:boost::wave::context	access:private
iterator	wave/util/flex_string.hpp	/^    typedef E* iterator;$/;"	t	class:boost::wave::util::AllocatorStringStorage	access:public
iterator	wave/util/flex_string.hpp	/^    typedef E* iterator;$/;"	t	class:boost::wave::util::SimpleStringStorage	access:public
iterator	wave/util/flex_string.hpp	/^    typedef typename Storage::iterator iterator;$/;"	t	class:boost::wave::util::CowString	access:public
iterator	wave/util/flex_string.hpp	/^    typedef typename Storage::iterator iterator;$/;"	t	class:boost::wave::util::flex_string	access:public
iterator	wave/util/flex_string.hpp	/^    typedef typename base::iterator iterator;$/;"	t	class:boost::wave::util::VectorStringStorage	access:public
iterator	wave/util/flex_string.hpp	/^    typedef value_type* iterator;$/;"	t	class:boost::wave::util::SmallStringOpt	access:public
iterator1_type	wave/grammars/cpp_defined_grammar_gen.hpp	/^        iterator1_type;$/;"	t	struct:boost::wave::grammars::defined_grammar_gen	access:public
iterator2_type	wave/grammars/cpp_defined_grammar_gen.hpp	/^        iterator2_type;$/;"	t	struct:boost::wave::grammars::defined_grammar_gen	access:public
iterator_type	wave/cpp_context.hpp	/^    typedef pp_iterator<context>                    iterator_type;$/;"	t	class:boost::wave::context	access:public
iterator_type	wave/cpp_iteration_context.hpp	/^    typedef IteratorT iterator_type;$/;"	t	struct:boost::wave::iteration_context	access:public
iterator_type	wave/grammars/cpp_grammar_gen.hpp	/^    typedef LexIteratorT                          iterator_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar_gen	access:public
iterator_type	wave/grammars/cpp_predef_macros_gen.hpp	/^    typedef LexIteratorT iterator_type;$/;"	t	struct:boost::wave::grammars::predefined_macros_grammar_gen	access:public
iterator_type	wave/util/symbol_table.hpp	/^    typedef typename base_type::iterator iterator_type;$/;"	t	struct:boost::wave::util::symbol_table	access:public
iterator_type	wave/util/unput_queue_iterator.hpp	/^            iterator_type;$/;"	t	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public
iterator_type	wave/util/unput_queue_iterator.hpp	/^        typedef IteratorT iterator_type;$/;"	t	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public
iterator_type	wave/util/unput_queue_iterator.hpp	/^        typedef unput_queue_iterator<IteratorT, TokenT, ContainerT> iterator_type;$/;"	t	struct:boost::wave::util::impl::next_token	access:public
iterator_type	wave/util/unput_queue_iterator.hpp	/^    typedef IteratorT   iterator_type;$/;"	t	class:boost::wave::util::unput_queue_iterator	access:public
language	wave/cpp_context.hpp	/^    boost::wave::language_support language;       \/\/ supported language\/extensions$/;"	m	class:boost::wave::context	access:private
language	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    boost::wave::language_support language;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
language_support	wave/language_support.hpp	/^enum language_support {$/;"	g	namespace:boost::wave
last	wave/cpp_context.hpp	/^    target_iterator_type last;$/;"	m	class:boost::wave::context	access:private
last	wave/cpp_iteration_context.hpp	/^    IteratorT last;             \/\/ end of input stream$/;"	m	struct:boost::wave::base_iteration_context	access:public
last	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* last;    \/* end (one past last char) of input buffer *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
last	wave/util/unput_queue_iterator.hpp	/^        gen_unput_queue_iterator<IteratorT, TokenT, ContainerT>::last = $/;"	m	class:boost::wave::util::impl::gen_unput_queue_iterator
last	wave/util/unput_queue_iterator.hpp	/^        static container_type last;$/;"	m	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public
last_error_number	wave/cpp_exceptions.hpp	/^        last_error_number = pragma_message_directive$/;"	e	enum:boost::wave::preprocess_exception::error_code
last_line_not_terminated	wave/cpp_exceptions.hpp	/^        last_line_not_terminated,$/;"	e	enum:boost::wave::preprocess_exception::error_code
last_severity_code	wave/cpp_exceptions.hpp	/^        last_severity_code = severity_commandline_error$/;"	e	enum:boost::wave::util::severity
leaf	wave/util/filesystem_compatibility.hpp	/^    inline std::string leaf(boost::filesystem::path const& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& p)
length	wave/util/flex_string.hpp	/^    size_type length() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
level	wave/cpplexer/cpplexer_exceptions.hpp	/^    util::severity level;$/;"	m	class:boost::wave::cpplexer::lexing_exception	access:private
lex_functor	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    lex_functor(IteratorT const &first, IteratorT const &last,$/;"	f	class:boost::wave::cpplexer::re2clex::lex_functor	access:public	signature:(IteratorT const &first, IteratorT const &last, PositionT const &pos, boost::wave::language_support language)
lex_functor	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^class lex_functor$/;"	c	namespace:boost::wave::cpplexer::re2clex	inherits:lex_input_interface_generator
lex_input_interface	wave/cpplexer/cpp_lex_interface.hpp	/^    lex_input_interface() {}$/;"	f	struct:boost::wave::cpplexer::lex_input_interface	access:public	signature:()
lex_input_interface	wave/cpplexer/cpp_lex_interface.hpp	/^struct lex_input_interface $/;"	s	namespace:boost::wave::cpplexer
lex_input_interface_generator	wave/cpplexer/cpp_lex_interface_generator.hpp	/^    lex_input_interface_generator() {}$/;"	f	struct:boost::wave::cpplexer::lex_input_interface_generator	access:public	signature:()
lex_input_interface_generator	wave/cpplexer/cpp_lex_interface_generator.hpp	/^struct lex_input_interface_generator$/;"	s	namespace:boost::wave::cpplexer	inherits:lex_input_interface
lex_iterator	wave/cpplexer/cpp_lex_iterator.hpp	/^    lex_iterator()$/;"	f	class:boost::wave::cpplexer::lex_iterator	access:public	signature:()
lex_iterator	wave/cpplexer/cpp_lex_iterator.hpp	/^    lex_iterator(IteratorT const &first, IteratorT const &last, $/;"	f	class:boost::wave::cpplexer::lex_iterator	access:public	signature:(IteratorT const &first, IteratorT const &last, typename TokenT::position_type const &pos, boost::wave::language_support language)
lex_iterator	wave/cpplexer/cpp_lex_iterator.hpp	/^class lex_iterator $/;"	c	namespace:boost::wave::cpplexer	inherits:make_multi_pass::type
lex_iterator_functor_shim	wave/cpplexer/cpp_lex_iterator.hpp	/^    lex_iterator_functor_shim() $/;"	f	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public	signature:()
lex_iterator_functor_shim	wave/cpplexer/cpp_lex_iterator.hpp	/^class lex_iterator_functor_shim $/;"	c	namespace:boost::wave::cpplexer::impl
lex_token	wave/cpplexer/cpp_lex_token.hpp	/^    explicit lex_token(int)$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(int)
lex_token	wave/cpplexer/cpp_lex_token.hpp	/^    lex_token()$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:()
lex_token	wave/cpplexer/cpp_lex_token.hpp	/^    lex_token(lex_token const& rhs)$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(lex_token const& rhs)
lex_token	wave/cpplexer/cpp_lex_token.hpp	/^    lex_token(token_id id_, string_type const &value_, PositionT const &pos_)$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(token_id id_, string_type const &value_, PositionT const &pos_)
lex_token	wave/cpplexer/cpp_lex_token.hpp	/^class lex_token $/;"	c	namespace:boost::wave::cpplexer
lexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    lexer(IteratorT const &first, IteratorT const &last,$/;"	p	class:boost::wave::cpplexer::re2clex::lexer	access:public	signature:(IteratorT const &first, IteratorT const &last, PositionT const &pos, boost::wave::language_support language_)
lexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^class lexer$/;"	c	namespace:boost::wave::cpplexer::re2clex
lexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^lexer<IteratorT, PositionT, TokenT>::lexer(IteratorT const &first,$/;"	f	class:boost::wave::cpplexer::re2clex::lexer	signature:(IteratorT const &first, IteratorT const &last, PositionT const &pos, boost::wave::language_support language_)
lexer_type	wave/cpp_context.hpp	/^    typedef LexIteratorT                            lexer_type;$/;"	t	class:boost::wave::context	access:public
lexer_type	wave/util/cpp_iterator.hpp	/^    typedef typename ContextT::lexer_type               lexer_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
lexing_exception	wave/cpplexer/cpplexer_exceptions.hpp	/^    lexing_exception(char const *what_, error_code code, std::size_t line_,$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:(char const *what_, error_code code, std::size_t line_, std::size_t column_, char const *filename_)
lexing_exception	wave/cpplexer/cpplexer_exceptions.hpp	/^class BOOST_SYMBOL_VISIBLE lexing_exception :$/;"	c	namespace:boost::wave::cpplexer	inherits:cpplexer_exception
lim	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* lim;     \/* used for YYLIMIT - points to the end of the buffer *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
line	wave/cpp_exceptions.hpp	/^    std::size_t line;$/;"	m	class:boost::wave::cpp_exception	access:protected
line	wave/cpp_iteration_context.hpp	/^    std::size_t line;                     \/\/ line counter of underlying stream$/;"	m	struct:boost::wave::base_iteration_context	access:public
line	wave/cpplexer/cpplexer_exceptions.hpp	/^    std::size_t line;$/;"	m	class:boost::wave::cpplexer::cpplexer_exception	access:protected
line	wave/cpplexer/re2clex/scanner.hpp	/^    std::size_t line;           \/* current line being lex'ed *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
line	wave/util/file_position.hpp	/^    std::size_t line;$/;"	m	struct:boost::wave::util::file_position	access:private
line_no	wave/cpp_exceptions.hpp	/^    std::size_t line_no() const throw() { return line; }$/;"	f	class:boost::wave::cpp_exception	access:public	signature:() const
line_no	wave/cpplexer/cpplexer_exceptions.hpp	/^    std::size_t line_no() const throw() { return line; }$/;"	f	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
list	wave/util/cpp_macromap_utils.hpp	/^        ContainerT &list;$/;"	m	class:boost::wave::util::on_exit::pop_front	access:private
list	wave/util/cpp_macromap_utils.hpp	/^        ContainerT &list;$/;"	m	class:boost::wave::util::on_exit::splice_pop_front	access:private
load	wave/cpp_context.hpp	/^    void load(Archive & ar, const unsigned int loaded_version)$/;"	f	class:boost::wave::context	access:private	signature:(Archive & ar, const unsigned int loaded_version)
load	wave/util/cpp_include_paths.hpp	/^    void load(Archive & ar, const unsigned int loaded_version)$/;"	f	class:boost::wave::util::include_paths	access:private	signature:(Archive & ar, const unsigned int loaded_version)
load	wave/util/cpp_include_paths.hpp	/^inline void load (Archive & ar, boost::filesystem::path &p,$/;"	f	namespace:boost::serialization	signature:(Archive & ar, boost::filesystem::path &p, const unsigned int )
load	wave/util/cpp_include_paths.hpp	/^inline void load (Archive & ar,$/;"	f	namespace:boost::serialization	signature:(Archive & ar, typename boost::wave::util::bidirectional_map<std::string, std::string>::type &t, const unsigned int )
load	wave/util/cpp_macromap.hpp	/^    void load(Archive &ar, const unsigned int loaded_version)$/;"	f	class:boost::wave::util::macromap	access:private	signature:(Archive &ar, const unsigned int loaded_version)
load_file_to_string	wave/cpp_iteration_context.hpp	/^    struct load_file_to_string$/;"	s	namespace:boost::wave::iteration_context_policies
load_filepos	wave/util/cpp_include_paths.hpp	/^struct load_filepos$/;"	s	namespace:boost::wave::util
locate_include_file	wave/preprocessing_hooks.hpp	/^    locate_include_file(ContextT& ctx, std::string &file_path, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT& ctx, std::string &file_path, bool is_system, char const *current_name, std::string &dir_path, std::string &native_name)
logical_and_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t logical_or_exp, logical_and_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
logical_and_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t logical_or_exp_nocalc, logical_and_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
logical_or_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t logical_or_exp, logical_and_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
logical_or_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t logical_or_exp_nocalc, logical_and_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
long_lit	wave/grammars/cpp_chlit_grammar.hpp	/^        member2 long_lit;$/;"	m	struct:boost::wave::grammars::closures::chlit_closure	access:public
m_CharsPerTab	wave/util/file_position.hpp	/^        unsigned int m_CharsPerTab;$/;"	m	class:boost::spirit::classic::position_policy	access:private
macro_definition	wave/grammars/cpp_grammar.hpp	/^        rule_type plain_define, macro_definition, macro_parameters;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
macro_definition	wave/grammars/cpp_predef_macros_grammar.hpp	/^        rule_type plain_define, macro_definition, macro_parameters;$/;"	m	struct:boost::wave::grammars::predefined_macros_grammar::definition	access:public
macro_definition	wave/util/macro_definition.hpp	/^    macro_definition() $/;"	f	struct:boost::wave::util::macro_definition	access:public	signature:()
macro_definition	wave/util/macro_definition.hpp	/^    macro_definition(TokenT const &token_, bool has_parameters, $/;"	f	struct:boost::wave::util::macro_definition	access:public	signature:(TokenT const &token_, bool has_parameters, bool is_predefined_, long uid_)
macro_definition	wave/util/macro_definition.hpp	/^struct macro_definition {$/;"	s	namespace:boost::wave::util
macro_definition_type	wave/util/cpp_macromap.hpp	/^        macro_definition_type;$/;"	t	class:boost::wave::util::macromap	access:private
macro_handling_exception	wave/cpp_exceptions.hpp	/^    macro_handling_exception(char const *what_, error_code code, std::size_t line_,$/;"	f	class:boost::wave::macro_handling_exception	access:public	signature:(char const *what_, error_code code, std::size_t line_, std::size_t column_, char const *filename_, char const *macroname)
macro_handling_exception	wave/cpp_exceptions.hpp	/^class BOOST_SYMBOL_VISIBLE macro_handling_exception :$/;"	c	namespace:boost::wave	inherits:preprocess_exception
macro_include_file	wave/grammars/cpp_grammar.hpp	/^        rule_type pp_statement, macro_include_file;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
macro_insertion_error	wave/cpp_exceptions.hpp	/^        macro_insertion_error,$/;"	e	enum:boost::wave::preprocess_exception::error_code
macro_names_begin	wave/cpp_context.hpp	/^    const_name_iterator macro_names_begin() const { return macros.begin(); }$/;"	f	class:boost::wave::context	access:public	signature:() const
macro_names_begin	wave/cpp_context.hpp	/^    name_iterator macro_names_begin() { return macros.begin(); }$/;"	f	class:boost::wave::context	access:public	signature:()
macro_names_end	wave/cpp_context.hpp	/^    const_name_iterator macro_names_end() const { return macros.end(); }$/;"	f	class:boost::wave::context	access:public	signature:() const
macro_names_end	wave/cpp_context.hpp	/^    name_iterator macro_names_end() { return macros.end(); }$/;"	f	class:boost::wave::context	access:public	signature:()
macro_parameters	wave/grammars/cpp_grammar.hpp	/^        rule_type plain_define, macro_definition, macro_parameters;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
macro_parameters	wave/grammars/cpp_predef_macros_grammar.hpp	/^        rule_type plain_define, macro_definition, macro_parameters;$/;"	m	struct:boost::wave::grammars::predefined_macros_grammar::definition	access:public
macro_redefinition	wave/cpp_exceptions.hpp	/^        macro_redefinition,$/;"	e	enum:boost::wave::preprocess_exception::error_code
macro_ref_type	wave/util/cpp_macromap.hpp	/^        macro_ref_type;$/;"	t	class:boost::wave::util::macromap	access:private
macro_uid	wave/util/cpp_macromap.hpp	/^    long macro_uid;$/;"	m	class:boost::wave::util::macromap	access:private
macrodefinition	wave/util/macro_definition.hpp	/^    definition_container_type macrodefinition; \/\/ macro definition token sequence$/;"	m	struct:boost::wave::util::macro_definition	access:public
macromap	wave/util/cpp_macromap.hpp	/^    macromap(ContextT &ctx_)$/;"	f	class:boost::wave::util::macromap	access:public	signature:(ContextT &ctx_)
macromap	wave/util/cpp_macromap.hpp	/^class macromap {$/;"	c	namespace:boost::wave::util
macromap_type	wave/cpp_context.hpp	/^    typedef boost::wave::util::macromap<context> macromap_type;$/;"	t	class:boost::wave::context	access:public
macroname	wave/util/macro_definition.hpp	/^    TokenT macroname;                       \/\/ macro name$/;"	m	struct:boost::wave::util::macro_definition	access:public
macroparameters	wave/util/macro_definition.hpp	/^    parameter_container_type macroparameters;  \/\/ formal parameters$/;"	m	struct:boost::wave::util::macro_definition	access:public
macros	wave/cpp_context.hpp	/^    macromap_type macros;                         \/\/ map of defined macros$/;"	m	class:boost::wave::context	access:private
magic	wave/util/flex_string.hpp	/^    enum { magic = maxSmallString + 1 };$/;"	e	enum:boost::wave::util::SmallStringOpt::__anon4
main_file	wave/cpp_iteration_context.hpp	/^        main_file,      \/\/ ... the main preprocessed file$/;"	e	enum:boost::wave::base_iteration_context::file_type
main_pos	wave/util/cpp_macromap.hpp	/^    position_type main_pos;     \/\/ last token position in the pp_iterator$/;"	m	class:boost::wave::util::macromap	access:private
make_iterator	wave/util/symbol_table.hpp	/^    transform_iterator<unary_functor, Iterator> make_iterator(Iterator it)$/;"	f	struct:boost::wave::util::symbol_table	access:public	signature:(Iterator it)
make_multi_pass	wave/cpplexer/cpp_lex_iterator.hpp	/^struct make_multi_pass$/;"	s	namespace:boost::wave::cpplexer
make_ref_transform_iterator	wave/util/transform_iterator.hpp	/^    make_ref_transform_iterator($/;"	f	namespace:boost::wave::impl	signature:( IteratorT base, AdaptableUnaryFunctionT const &f)
make_unique	wave/cpplexer/cpp_lex_token.hpp	/^    void make_unique()$/;"	f	class:boost::wave::cpplexer::lex_token	access:private	signature:()
mallocator	wave/util/flex_string.hpp	/^    mallocator() {}$/;"	f	class:boost::wave::util::mallocator	access:public	signature:()
mallocator	wave/util/flex_string.hpp	/^    mallocator(const mallocator&) {}$/;"	f	class:boost::wave::util::mallocator	access:public	signature:(const mallocator&)
mallocator	wave/util/flex_string.hpp	/^template <class T> class mallocator$/;"	c	namespace:boost::wave::util
mallocator	wave/util/flex_string.hpp	/^template<> class mallocator<void>$/;"	c	namespace:boost::wave::util
map_rule_id_to_name	wave/grammars/cpp_grammar.hpp	/^    mutable map_ruleid_to_name map_rule_id_to_name;$/;"	m	struct:boost::wave::grammars::cpp_grammar	access:public
map_ruleid_to_name	wave/grammars/cpp_grammar.hpp	/^    struct map_ruleid_to_name :$/;"	s	struct:boost::wave::grammars::cpp_grammar	inherits:std::map	access:public
match_policy_t	wave/grammars/cpp_grammar.hpp	/^        typedef boost::spirit::classic::match_policy match_policy_t;$/;"	t	struct:boost::wave::grammars::cpp_grammar::definition	access:public
maxSmallString	wave/util/flex_string.hpp	/^    enum { maxSmallString = $/;"	e	enum:boost::wave::util::SmallStringOpt::__anon3
max_include_nesting_depth	wave/util/iteration_context.hpp	/^    size_type max_include_nesting_depth;$/;"	m	class:boost::wave::util::iteration_context_stack	access:private
max_size	wave/cpplexer/re2clex/aq.hpp	/^    std::size_t max_size;$/;"	m	struct:boost::wave::cpplexer::re2clex::tag_aq_queuetype	access:public
max_size	wave/util/flex_string.hpp	/^    size_type max_size() const $/;"	f	class:boost::wave::util::mallocator	access:public	signature:() const
max_size	wave/util/flex_string.hpp	/^    size_type max_size() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
max_size	wave/util/flex_string.hpp	/^    size_type max_size() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
max_size	wave/util/flex_string.hpp	/^    size_type max_size() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
max_size	wave/util/flex_string.hpp	/^    size_type max_size() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
max_size	wave/util/flex_string.hpp	/^    size_type max_size() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
max_size	wave/util/flex_string.hpp	/^    size_type max_size() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
may_skip_whitespace	wave/preprocessing_hooks.hpp	/^    may_skip_whitespace(ContextT const& ctx, TokenT& token, bool& skipped_newline)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT& token, bool& skipped_newline)
may_skip_whitespace	wave/whitespace_handling.hpp	/^    bool may_skip_whitespace(ContextT const& ctx, TokenT &token, $/;"	p	class:boost::wave::context_policies::eat_whitespace	access:public	signature:(ContextT const& ctx, TokenT &token, bool &skipped_newline)
may_skip_whitespace	wave/whitespace_handling.hpp	/^    bool may_skip_whitespace(ContextT const& ctx, TokenT &token, $/;"	p	class:boost::wave::context_policies::eat_whitespace	access:public	signature:(ContextT const& ctx, TokenT &token, bool preserve_comments_, bool preserve_bol_whitespace_, bool &skipped_newline)
may_skip_whitespace	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::may_skip_whitespace(ContextT const& ctx, TokenT &token, $/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:(ContextT const& ctx, TokenT &token, bool &skipped_newline)
may_skip_whitespace	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::may_skip_whitespace(ContextT const& ctx, TokenT &token, $/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:(ContextT const& ctx, TokenT &token, bool preserve_comments_, bool preserve_bol_whitespace_, bool &skipped_newline)
misplaced_operator	wave/cpp_exceptions.hpp	/^        misplaced_operator,$/;"	e	enum:boost::wave::preprocess_exception::error_code
missing_matching_endif	wave/cpp_exceptions.hpp	/^        missing_matching_endif,$/;"	e	enum:boost::wave::preprocess_exception::error_code
missing_matching_if	wave/cpp_exceptions.hpp	/^        missing_matching_if,$/;"	e	enum:boost::wave::preprocess_exception::error_code
month	wave/util/time_conversion_helper.hpp	/^            boost::spirit::classic::symbols<> month;$/;"	m	struct:boost::wave::util::time_conversion::time_conversion_grammar::definition	access:public
multiply_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t add_exp, multiply_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
multiply_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t add_exp_nocalc, multiply_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
must_emit_line_directive	wave/util/cpp_iterator.hpp	/^    bool must_emit_line_directive;  \/\/ must emit a line directive$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
must_insert	wave/util/insert_whitespace_detection.hpp	/^    bool must_insert(boost::wave::token_id current, StringT const &value)$/;"	f	class:boost::wave::util::insert_whitespace_detection	access:public	signature:(boost::wave::token_id current, StringT const &value)
name	wave/cpp_exceptions.hpp	/^    char name[512];$/;"	m	class:boost::wave::macro_handling_exception	access:private
name	wave/util/cpp_macromap_predef.hpp	/^            char const *name;$/;"	m	struct:boost::wave::util::predefined_macros::dynamic_macros	access:public
name	wave/util/cpp_macromap_predef.hpp	/^            char const *name;$/;"	m	struct:boost::wave::util::predefined_macros::static_macros	access:public
name_iterator	wave/cpp_context.hpp	/^    typedef typename macromap_type::name_iterator name_iterator;$/;"	t	class:boost::wave::context	access:public
name_iterator	wave/util/cpp_macromap.hpp	/^    typedef typename defined_macros_type::name_iterator name_iterator;$/;"	t	class:boost::wave::util::macromap	access:public
name_iterator	wave/util/symbol_table.hpp	/^        name_iterator;$/;"	t	struct:boost::wave::util::symbol_table	access:public
native_file_string	wave/util/filesystem_compatibility.hpp	/^    inline std::string native_file_string(boost::filesystem::path const& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path const& p)
need_c99	wave/language_support.hpp	/^need_c99(language_support language)$/;"	f	namespace:boost::wave	signature:(language_support language)
need_cpp	wave/language_support.hpp	/^need_cpp(language_support language)$/;"	f	namespace:boost::wave	signature:(language_support language)
need_cpp0x	wave/language_support.hpp	/^need_cpp0x(language_support language)$/;"	f	namespace:boost::wave	signature:(language_support language)
need_variadics	wave/language_support.hpp	/^need_variadics(language_support language)$/;"	f	namespace:boost::wave	signature:(language_support language)
new_lexer	wave/cpplexer/cpp_lex_interface_generator.hpp	/^    new_lexer(IteratorT const &first, IteratorT const &last, $/;"	f	struct:boost::wave::cpplexer::lex_input_interface_generator	access:public	signature:(IteratorT const &first, IteratorT const &last, position_type const &pos, boost::wave::language_support language)
new_lexer	wave/cpplexer/cpp_lex_interface_generator.hpp	/^    new_lexer(IteratorT const &first, IteratorT const &last, $/;"	p	struct:boost::wave::cpplexer::new_lexer_gen	access:public	signature:(IteratorT const &first, IteratorT const &last, PositionT const &pos, boost::wave::language_support language)
new_lexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^new_lexer_gen<IteratorT, PositionT, TokenT>::new_lexer(IteratorT const &first,$/;"	f	class:boost::wave::cpplexer::new_lexer_gen	signature:(IteratorT const &first, IteratorT const &last, PositionT const &pos, boost::wave::language_support language)
new_lexer_gen	wave/cpplexer/cpp_lex_interface_generator.hpp	/^struct BOOST_WAVE_NEW_LEXER_DECL new_lexer_gen$/;"	s	namespace:boost::wave::cpplexer
newline	wave/whitespace_handling.hpp	/^    state_t general, newline, newline_2nd, whitespace, bol_whitespace;$/;"	m	class:boost::wave::context_policies::eat_whitespace	access:private
newline	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::newline(TokenT &token, bool &skipped_newline) $/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:(TokenT &token, bool &skipped_newline)
newline_2nd	wave/whitespace_handling.hpp	/^    state_t general, newline, newline_2nd, whitespace, bol_whitespace;$/;"	m	class:boost::wave::context_policies::eat_whitespace	access:private
newline_2nd	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::newline_2nd(TokenT &token, bool &skipped_newline) $/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:(TokenT &token, bool &skipped_newline)
next_char	wave/util/file_position.hpp	/^        void next_char(boost::wave::util::file_position_type &pos)$/;"	f	class:boost::spirit::classic::position_policy	access:public	signature:(boost::wave::util::file_position_type &pos)
next_line	wave/util/file_position.hpp	/^        void next_line(boost::wave::util::file_position_type &pos)$/;"	f	class:boost::spirit::classic::position_policy	access:public	signature:(boost::wave::util::file_position_type &pos)
next_token	wave/util/unput_queue_iterator.hpp	/^    struct next_token $/;"	s	namespace:boost::wave::util::impl
next_token	wave/util/unput_queue_iterator.hpp	/^    struct next_token<$/;"	s	namespace:boost::wave::util::impl
next_token_is_pp_directive	wave/util/cpp_iterator.hpp	/^    bool next_token_is_pp_directive(ContextT &ctx, IteratorT &it, IteratorT const &end)$/;"	f	namespace:boost::wave::impl::impl	signature:(ContextT &ctx, IteratorT &it, IteratorT const &end)
no_error	wave/cpp_exceptions.hpp	/^        no_error = 0,$/;"	e	enum:boost::wave::preprocess_exception::error_code
no_tree_rule_type	wave/grammars/cpp_grammar.hpp	/^            no_tree_rule_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar::definition	access:public
node_factory_type	wave/grammars/cpp_grammar_gen.hpp	/^        > node_factory_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar_gen	access:public
node_factory_type	wave/util/cpp_iterator.hpp	/^    typedef typename cpp_grammar_type::node_factory_type node_factory_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
non_tree_scanner_t	wave/grammars/cpp_grammar.hpp	/^            non_tree_scanner_t;$/;"	t	struct:boost::wave::grammars::cpp_grammar::definition	access:public
normalize	wave/util/filesystem_compatibility.hpp	/^    inline boost::filesystem::path normalize(boost::filesystem::path& p)$/;"	f	namespace:boost::wave::util	signature:(boost::filesystem::path& p)
npos	wave/util/flex_string.hpp	/^    static const size_type npos;    \/\/ = size_type(-1)$/;"	m	class:boost::wave::util::flex_string	access:public
npos	wave/util/flex_string.hpp	/^flex_string<E1, T, A, S>::npos = (typename flex_string<E1, T, A, S>::size_type)(-1);$/;"	m	class:boost::wave::util::flex_string
oct_lit	wave/grammars/cpp_intlit_grammar.hpp	/^        boost::spirit::classic::subrule<1> oct_lit;$/;"	m	struct:boost::wave::grammars::intlit_grammar::definition	access:public
old_value	wave/util/cpp_macromap_utils.hpp	/^        TypeT old_value;$/;"	m	class:boost::wave::util::on_exit::reset	access:private
on_define	wave/util/cpp_iterator.hpp	/^    void on_define(parse_node_type const &node);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(parse_node_type const &node)
on_define	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_define (parse_node_type const &node)$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(parse_node_type const &node)
on_elif	wave/util/cpp_iterator.hpp	/^    void on_elif(result_type const& found_directive,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(result_type const& found_directive, typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
on_elif	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_elif($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( result_type const& found_directive, typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
on_else	wave/util/cpp_iterator.hpp	/^    void on_else();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:()
on_else	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_else()$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:()
on_endif	wave/util/cpp_iterator.hpp	/^    void on_endif();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:()
on_endif	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_endif()$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:()
on_error	wave/util/cpp_iterator.hpp	/^    void on_error(typename parse_tree_type::const_iterator const &begin,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
on_error	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_error($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
on_exit	wave/util/cpp_macromap_utils.hpp	/^namespace on_exit {$/;"	n	namespace:boost::wave::util
on_if	wave/util/cpp_iterator.hpp	/^    void on_if(result_type const& found_directive,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(result_type const& found_directive, typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
on_if	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_if($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( result_type const& found_directive, typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
on_ifdef	wave/util/cpp_iterator.hpp	/^    void on_ifdef(result_type const& found_directive, lexer_type const &it);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(result_type const& found_directive, lexer_type const &it)
on_ifdef	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_ifdef($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( result_type const& found_directive, lexer_type const &it)
on_ifndef	wave/util/cpp_iterator.hpp	/^    void on_ifndef(result_type const& found_directive, lexer_type const& it);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(result_type const& found_directive, lexer_type const& it)
on_ifndef	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_ifndef($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( result_type const& found_directive, lexer_type const &it)
on_illformed	wave/util/cpp_iterator.hpp	/^    void on_illformed(typename result_type::string_type s);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(typename result_type::string_type s)
on_illformed	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_illformed($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( typename result_type::string_type s)
on_include	wave/util/cpp_iterator.hpp	/^    void on_include(string_type const &s, bool is_system, bool include_next);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(string_type const &s, bool is_system, bool include_next)
on_include	wave/util/cpp_iterator.hpp	/^    void on_include(typename parse_tree_type::const_iterator const &begin,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end, bool include_next)
on_include	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_include (string_type const &s,$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(string_type const &s, bool is_system, bool include_next)
on_include	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_include($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end, bool include_next)
on_include_helper	wave/util/cpp_iterator.hpp	/^    bool on_include_helper(char const *t, char const *s, bool is_system,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(char const *t, char const *s, bool is_system, bool include_next)
on_include_helper	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_include_helper (char const *f, char const *s,$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(char const *f, char const *s, bool is_system, bool include_next)
on_line	wave/util/cpp_iterator.hpp	/^    void on_line(typename parse_tree_type::const_iterator const &begin,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
on_line	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_line($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
on_pragma	wave/util/cpp_iterator.hpp	/^    bool on_pragma(typename parse_tree_type::const_iterator const &begin,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
on_pragma	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_pragma($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
on_undefine	wave/util/cpp_iterator.hpp	/^    void on_undefine(lexer_type const &it);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(lexer_type const &it)
on_undefine	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_undefine (lexer_type const &it)$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(lexer_type const &it)
on_warning	wave/util/cpp_iterator.hpp	/^    void on_warning(typename parse_tree_type::const_iterator const &begin,$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
on_warning	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::on_warning($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( typename parse_tree_type::const_iterator const &begin, typename parse_tree_type::const_iterator const &end)
opened_include_file	wave/preprocessing_hooks.hpp	/^    opened_include_file(ContextT const& ctx, std::string const& relname, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, std::string const& relname, std::string const& absname, bool is_system_include)
opened_include_file	wave/preprocessing_hooks.hpp	/^    opened_include_file(std::string const& relname, std::string const& absname, $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(std::string const& relname, std::string const& absname, std::size_t include_depth, bool is_system_include)
operator !	wave/grammars/cpp_expression_value.hpp	/^    operator! (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &rhs)
operator !=	wave/grammars/cpp_expression_value.hpp	/^    operator!= (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
operator !=	wave/util/flex_string.hpp	/^inline bool operator!=(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const flex_string<E, T, A, S>& rhs)
operator !=	wave/util/flex_string.hpp	/^inline bool operator!=(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const typename flex_string<E, T, A, S>::value_type* rhs)
operator !=	wave/util/flex_string.hpp	/^inline bool operator!=(const mallocator<T>&, $/;"	f	namespace:boost::wave::util	signature:(const mallocator<T>&, const mallocator<T>&)
operator !=	wave/util/flex_string.hpp	/^inline bool operator!=(const typename flex_string<E, T, A, S>::value_type* lhs, $/;"	f	namespace:boost::wave::util	signature:(const typename flex_string<E, T, A, S>::value_type* lhs, const flex_string<E, T, A, S>& rhs)
operator %=	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator%= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
operator &	wave/grammars/cpp_expression_value.hpp	/^    operator& (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
operator &&	wave/grammars/cpp_expression_value.hpp	/^    operator&& (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
operator ()	wave/grammars/cpp_chlit_grammar.hpp	/^        operator()(boost::uint32_t& value, bool long_lit, bool& overflow,$/;"	f	struct:boost::wave::grammars::impl::compose_character_literal	access:public	signature:(boost::uint32_t& value, bool long_lit, bool& overflow, boost::uint32_t character) const
operator ()	wave/grammars/cpp_expression_grammar.hpp	/^        operator()(ArgT &val) const$/;"	f	struct:boost::wave::grammars::impl::operator_as_bool	access:public	signature:(ArgT &val) const
operator ()	wave/grammars/cpp_expression_grammar.hpp	/^        operator()(ArgT &val) const$/;"	f	struct:boost::wave::grammars::impl::operator_to_bool	access:public	signature:(ArgT &val) const
operator ()	wave/grammars/cpp_expression_grammar.hpp	/^        operator()(CondT const &cond, Arg1T &val1, Arg2T const &val2) const$/;"	f	struct:boost::wave::grammars::impl::operator_questionmark	access:public	signature:(CondT const &cond, Arg1T &val1, Arg2T const &val2) const
operator ()	wave/grammars/cpp_expression_grammar.hpp	/^        operator()(TokenT const &token) const$/;"	f	struct:boost::wave::grammars::impl::convert_chlit	access:public	signature:(TokenT const &token) const
operator ()	wave/grammars/cpp_expression_grammar.hpp	/^        operator()(TokenT const &token) const$/;"	f	struct:boost::wave::grammars::impl::convert_intlit	access:public	signature:(TokenT const &token) const
operator ()	wave/grammars/cpp_grammar.hpp	/^        void operator()(IteratorT const &first, IteratorT const& last) const$/;"	f	struct:boost::wave::grammars::impl::store_found_eoltokens	access:public	signature:(IteratorT const &first, IteratorT const& last) const
operator ()	wave/grammars/cpp_grammar.hpp	/^        void operator()(TokenT const &\/*token*\/) const$/;"	f	struct:boost::wave::grammars::impl::store_found_eof	access:public	signature:(TokenT const & ) const
operator ()	wave/grammars/cpp_grammar.hpp	/^        void operator()(TokenT const &token) const$/;"	f	struct:boost::wave::grammars::impl::store_found_directive	access:public	signature:(TokenT const &token) const
operator ()	wave/util/cpp_iterator.hpp	/^    result_type const &operator()();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:public	signature:()
operator ()	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::operator()()$/;"	f	class:boost::wave::impl::pp_iterator_functor::pp_iterator_functor	signature:()
operator ()	wave/util/cpp_macromap_utils.hpp	/^    bool operator()(TokenT const &tok)$/;"	f	class:boost::wave::util::impl::find_concat_operator	access:public	signature:(TokenT const &tok)
operator ()	wave/util/symbol_table.hpp	/^        StringT1 const& operator() (std::pair<First, Second> const& p) const$/;"	f	struct:boost::wave::util::symbol_table::get_first	access:public	signature:(std::pair<First, Second> const& p) const
operator *=	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator*= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
operator +	wave/util/flex_string.hpp	/^flex_string<E, T, A, S> operator+($/;"	f	namespace:boost::wave::util	signature:( typename flex_string<E, T, A, S>::value_type lhs, const flex_string<E, T, A, S>& rhs)
operator +	wave/util/flex_string.hpp	/^flex_string<E, T, A, S> operator+(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const flex_string<E, T, A, S>& rhs)
operator +	wave/util/flex_string.hpp	/^flex_string<E, T, A, S> operator+(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const typename flex_string<E, T, A, S>::value_type* rhs)
operator +	wave/util/flex_string.hpp	/^flex_string<E, T, A, S> operator+(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, typename flex_string<E, T, A, S>::value_type rhs)
operator +	wave/util/flex_string.hpp	/^flex_string<E, T, A, S> operator+(const typename flex_string<E, T, A, S>::value_type* lhs, $/;"	f	namespace:boost::wave::util	signature:(const typename flex_string<E, T, A, S>::value_type* lhs, const flex_string<E, T, A, S>& rhs)
operator +=	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator+= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
operator +=	wave/util/flex_string.hpp	/^    flex_string& operator+=(const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str)
operator +=	wave/util/flex_string.hpp	/^    flex_string& operator+=(const value_type* s)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s)
operator +=	wave/util/flex_string.hpp	/^    flex_string& operator+=(value_type c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c)
operator -	wave/grammars/cpp_expression_value.hpp	/^    operator- (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &rhs)
operator -=	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator-= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
operator /=	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator\/= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
operator <	wave/grammars/cpp_expression_value.hpp	/^    operator< (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
operator <	wave/util/flex_string.hpp	/^inline bool operator<(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const flex_string<E, T, A, S>& rhs)
operator <	wave/util/flex_string.hpp	/^inline bool operator<(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const typename flex_string<E, T, A, S>::value_type* rhs)
operator <	wave/util/flex_string.hpp	/^inline bool operator<(const typename flex_string<E, T, A, S>::value_type* lhs, $/;"	f	namespace:boost::wave::util	signature:(const typename flex_string<E, T, A, S>::value_type* lhs, const flex_string<E, T, A, S>& rhs)
operator <<	wave/cpplexer/cpp_lex_token.hpp	/^operator<< (std::ostream &stream, lex_token<PositionT> const &object)$/;"	f	namespace:boost::wave::cpplexer	signature:(std::ostream &stream, lex_token<PositionT> const &object)
operator <<	wave/grammars/cpp_expression_value.hpp	/^    operator<< (std::ostream &o, closure_value const &val)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(std::ostream &o, closure_value const &val)
operator <<	wave/util/file_position.hpp	/^operator<< (std::ostream &o, file_position<StringT> const &pos)$/;"	f	namespace:boost::wave::util	signature:(std::ostream &o, file_position<StringT> const &pos)
operator <<	wave/util/flex_string.hpp	/^operator<<($/;"	f	namespace:boost::wave::util	signature:( std::basic_ostream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>& os, const flex_string<E, T, A, S>& str)
operator <<=	wave/grammars/cpp_expression_value.hpp	/^    operator<<= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
operator <=	wave/grammars/cpp_expression_value.hpp	/^    operator<= (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
operator <=	wave/util/flex_string.hpp	/^bool operator<=(const typename flex_string<E, T, A, S>::value_type* lhs, $/;"	f	namespace:boost::wave::util	signature:(const typename flex_string<E, T, A, S>::value_type* lhs, const flex_string<E, T, A, S>& rhs)
operator <=	wave/util/flex_string.hpp	/^inline bool operator<=(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const flex_string<E, T, A, S>& rhs)
operator <=	wave/util/flex_string.hpp	/^inline bool operator<=(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const typename flex_string<E, T, A, S>::value_type* rhs)
operator =	wave/cpplexer/cpp_lex_iterator.hpp	/^    lex_iterator_functor_shim& operator= (lex_iterator_functor_shim const& rhs)$/;"	f	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public	signature:(lex_iterator_functor_shim const& rhs)
operator =	wave/cpplexer/cpp_lex_token.hpp	/^    lex_token& operator=(lex_token const& rhs)$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(lex_token const& rhs)
operator =	wave/grammars/cpp_chlit_grammar.hpp	/^    chlit_grammar& operator=(chlit_grammar const&);$/;"	p	struct:boost::wave::grammars::chlit_grammar	access:public	signature:(chlit_grammar const&)
operator =	wave/grammars/cpp_expression_grammar.hpp	/^    expression_grammar& operator= (expression_grammar const&);$/;"	p	struct:boost::wave::grammars::expression_grammar	access:public	signature:(expression_grammar const&)
operator =	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator= (bool rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(bool rhs)
operator =	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
operator =	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator= (int rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(int rhs)
operator =	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator= (int_literal_type rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(int_literal_type rhs)
operator =	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator= (uint_literal_type rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(uint_literal_type rhs)
operator =	wave/grammars/cpp_expression_value.hpp	/^    closure_value &operator= (unsigned int rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(unsigned int rhs)
operator =	wave/util/flex_string.hpp	/^        Invariant& operator=(const Invariant&);$/;"	p	struct:boost::wave::util::flex_string::Invariant	access:private	signature:(const Invariant&)
operator =	wave/util/flex_string.hpp	/^    AllocatorStringStorage& operator=(const AllocatorStringStorage& rhs)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(const AllocatorStringStorage& rhs)
operator =	wave/util/flex_string.hpp	/^    CowString& operator=(const CowString& rhs)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(const CowString& rhs)
operator =	wave/util/flex_string.hpp	/^    SimpleStringStorage& operator=(const SimpleStringStorage& rhs)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(const SimpleStringStorage& rhs)
operator =	wave/util/flex_string.hpp	/^    SmallStringOpt& operator=(const SmallStringOpt& rhs)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(const SmallStringOpt& rhs)
operator =	wave/util/flex_string.hpp	/^    VectorStringStorage& operator=(const VectorStringStorage& rhs)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(const VectorStringStorage& rhs)
operator =	wave/util/flex_string.hpp	/^    flex_string& operator=(const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str)
operator =	wave/util/flex_string.hpp	/^    flex_string& operator=(const value_type* s)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s)
operator =	wave/util/flex_string.hpp	/^    flex_string& operator=(value_type c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c)
operator =	wave/util/flex_string.hpp	/^    void operator=(const mallocator&);$/;"	p	class:boost::wave::util::mallocator	access:private	signature:(const mallocator&)
operator =	wave/util/unput_queue_iterator.hpp	/^    unput_queue_iterator &operator= (unput_queue_iterator const &rhs)$/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:(unput_queue_iterator const &rhs)
operator ==	wave/cpplexer/cpp_lex_token.hpp	/^    friend bool operator== (lex_token const& lhs, lex_token const& rhs)$/;"	f	class:boost::wave::cpplexer::lex_token	access:friend	signature:(lex_token const& lhs, lex_token const& rhs)
operator ==	wave/cpplexer/cpp_lex_token.hpp	/^    friend bool operator== (token_data const& lhs, token_data const& rhs)$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:friend	signature:(token_data const& lhs, token_data const& rhs)
operator ==	wave/grammars/cpp_expression_value.hpp	/^    operator== (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
operator ==	wave/util/file_position.hpp	/^bool operator== (file_position<StringT> const &lhs, $/;"	f	namespace:boost::wave::util	signature:(file_position<StringT> const &lhs, file_position<StringT> const &rhs)
operator ==	wave/util/flex_string.hpp	/^inline bool operator==(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const flex_string<E, T, A, S>& rhs)
operator ==	wave/util/flex_string.hpp	/^inline bool operator==(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const typename flex_string<E, T, A, S>::value_type* rhs)
operator ==	wave/util/flex_string.hpp	/^inline bool operator==(const mallocator<T>&, $/;"	f	namespace:boost::wave::util	signature:(const mallocator<T>&, const mallocator<T>&)
operator ==	wave/util/flex_string.hpp	/^inline bool operator==(const typename flex_string<E, T, A, S>::value_type* lhs, $/;"	f	namespace:boost::wave::util	signature:(const typename flex_string<E, T, A, S>::value_type* lhs, const flex_string<E, T, A, S>& rhs)
operator >	wave/grammars/cpp_expression_value.hpp	/^    operator> (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
operator >	wave/util/flex_string.hpp	/^bool operator>(const typename flex_string<E, T, A, S>::value_type* lhs, $/;"	f	namespace:boost::wave::util	signature:(const typename flex_string<E, T, A, S>::value_type* lhs, const flex_string<E, T, A, S>& rhs)
operator >	wave/util/flex_string.hpp	/^inline bool operator>(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const flex_string<E, T, A, S>& rhs)
operator >	wave/util/flex_string.hpp	/^inline bool operator>(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const typename flex_string<E, T, A, S>::value_type* rhs)
operator >=	wave/grammars/cpp_expression_value.hpp	/^    operator>= (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
operator >=	wave/util/flex_string.hpp	/^bool operator>=(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const flex_string<E, T, A, S>& rhs)
operator >=	wave/util/flex_string.hpp	/^bool operator>=(const flex_string<E, T, A, S>& lhs, $/;"	f	namespace:boost::wave::util	signature:(const flex_string<E, T, A, S>& lhs, const typename flex_string<E, T, A, S>::value_type* rhs)
operator >=	wave/util/flex_string.hpp	/^inline bool operator>=(const typename flex_string<E, T, A, S>::value_type* lhs, $/;"	f	namespace:boost::wave::util	signature:(const typename flex_string<E, T, A, S>::value_type* lhs, const flex_string<E, T, A, S>& rhs)
operator >>	wave/util/flex_string.hpp	/^operator>>($/;"	p	namespace:boost::wave::util	signature:( std::basic_istream<typename flex_string<E, T, A, S>::value_type, typename flex_string<E, T, A, S>::traits_type>& is, flex_string<E, T, A, S>& str)
operator >>=	wave/grammars/cpp_expression_value.hpp	/^    operator>>= (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:public	signature:(closure_value const &rhs)
operator []	wave/util/flex_string.hpp	/^    const_reference operator[](size_type pos) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos) const
operator []	wave/util/flex_string.hpp	/^    reference operator[](size_type pos)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos)
operator ^	wave/grammars/cpp_expression_value.hpp	/^    operator^ (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
operator delete	wave/cpplexer/cpp_lex_token.hpp	/^    static void operator delete(void *p, std::size_t size);$/;"	p	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(void *p, std::size_t size)
operator delete	wave/cpplexer/cpp_lex_token.hpp	/^token_data<StringTypeT, PositionT>::operator delete(void *p, std::size_t size)$/;"	f	class:boost::wave::cpplexer::impl::token_data	signature:(void *p, std::size_t size)
operator new	wave/cpplexer/cpp_lex_token.hpp	/^    static void *operator new(std::size_t size);$/;"	p	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(std::size_t size)
operator new	wave/cpplexer/cpp_lex_token.hpp	/^token_data<StringTypeT, PositionT>::operator new(std::size_t size)$/;"	f	class:boost::wave::cpplexer::impl::token_data	signature:(std::size_t size)
operator token_id	wave/cpplexer/cpp_lex_token.hpp	/^    operator token_id() const { return 0 != data ? token_id(*data) : T_EOI; }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:() const
operator token_id	wave/cpplexer/cpp_lex_token.hpp	/^    operator token_id() const { return id; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:() const
operator |	wave/grammars/cpp_expression_value.hpp	/^    operator| (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
operator ||	wave/grammars/cpp_expression_value.hpp	/^    operator|| (closure_value const &lhs, closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &lhs, closure_value const &rhs)
operator ~	wave/grammars/cpp_expression_value.hpp	/^    operator~ (closure_value const &rhs)$/;"	f	class:boost::wave::grammars::closures::closure_value	access:friend	signature:(closure_value const &rhs)
operator_as_bool	wave/grammars/cpp_expression_grammar.hpp	/^    struct operator_as_bool {$/;"	s	namespace:boost::wave::grammars::impl
operator_questionmark	wave/grammars/cpp_expression_grammar.hpp	/^    struct operator_questionmark {$/;"	s	namespace:boost::wave::grammars::impl
operator_to_bool	wave/grammars/cpp_expression_grammar.hpp	/^    struct operator_to_bool {$/;"	s	namespace:boost::wave::grammars::impl
other	wave/util/flex_string.hpp	/^    struct rebind { typedef mallocator<U> other; };$/;"	t	struct:boost::wave::util::mallocator::rebind	access:public
other	wave/util/flex_string.hpp	/^  struct rebind { typedef mallocator<U> other; };$/;"	t	struct:boost::wave::util::mallocator::rebind	access:public
overflow	wave/grammars/cpp_chlit_grammar.hpp	/^    mutable bool overflow;$/;"	m	struct:boost::wave::grammars::chlit_grammar	access:public
ownership_policy	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef boost::spirit::iterator_policies::ref_counted ownership_policy;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
pData_	wave/util/flex_string.hpp	/^    Data* pData_;$/;"	m	class:boost::wave::util::AllocatorStringStorage	access:private
pData_	wave/util/flex_string.hpp	/^    Data* pData_;$/;"	m	class:boost::wave::util::SimpleStringStorage	access:private
pEndOfMem_	wave/util/flex_string.hpp	/^        E* pEndOfMem_;$/;"	m	struct:boost::wave::util::SimpleStringStorage::Data	access:public
pEnd_	wave/util/flex_string.hpp	/^        E* pEnd_;$/;"	m	struct:boost::wave::util::SimpleStringStorage::Data	access:public
parameter_container_type	wave/util/cpp_macromap.hpp	/^    typedef std::vector<token_type>                 parameter_container_type;$/;"	t	class:boost::wave::util::macromap	access:private
parameter_container_type	wave/util/macro_definition.hpp	/^    typedef std::vector<TokenT> parameter_container_type;$/;"	t	struct:boost::wave::util::macro_definition	access:public
parameters_equal	wave/util/cpp_macromap_utils.hpp	/^parameters_equal(ContainerT const &parameters, ContainerT const &new_parameters)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT const &parameters, ContainerT const &new_parameters)
parse	wave/grammars/cpp_grammar.hpp	/^        parse(ScannerT const& scan) const$/;"	f	struct:boost::wave::grammars::impl::flush_underlying_parser	access:public	signature:(ScannerT const& scan) const
parse_cpp_grammar	wave/grammars/cpp_grammar.hpp	/^cpp_grammar_gen<LexIteratorT, TokenContainerT>::parse_cpp_grammar ($/;"	f	class:boost::wave::grammars::cpp_grammar_gen	signature:( LexIteratorT const &first, LexIteratorT const &last, position_type const &act_pos, bool &found_eof, token_type &found_directive, token_container_type &found_eoltokens)
parse_cpp_grammar	wave/grammars/cpp_grammar_gen.hpp	/^    parse_cpp_grammar (iterator_type const &first, iterator_type const &last,$/;"	p	struct:boost::wave::grammars::cpp_grammar_gen	access:public	signature:(iterator_type const &first, iterator_type const &last, position_type const &act_pos, bool &found_eof, token_type &found_directive, token_container_type &found_eoltokens)
parse_node_type	wave/util/cpp_iterator.hpp	/^    typedef typename parse_tree_match_type::node_t       parse_node_type;       \/\/ tree_node<node_val_data<> >$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
parse_node_value_type	wave/util/cpp_iterator.hpp	/^    typedef typename parse_tree_match_type::parse_node_t parse_node_value_type; \/\/ node_val_data<>$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
parse_operator_defined	wave/grammars/cpp_defined_grammar.hpp	/^defined_grammar_gen<LexIteratorT>::parse_operator_defined ($/;"	f	class:boost::wave::grammars::defined_grammar_gen	signature:( iterator1_type const &first, iterator1_type const &last, token_sequence_type &found_qualified_name)
parse_operator_defined	wave/grammars/cpp_defined_grammar.hpp	/^defined_grammar_gen<LexIteratorT>::parse_operator_defined ($/;"	f	class:boost::wave::grammars::defined_grammar_gen	signature:( iterator2_type const &first, iterator2_type const &last, token_sequence_type &found_qualified_name)
parse_operator_defined	wave/grammars/cpp_defined_grammar_gen.hpp	/^    parse_operator_defined (iterator1_type const &first, $/;"	p	struct:boost::wave::grammars::defined_grammar_gen	access:public	signature:(iterator1_type const &first, iterator1_type const &last, token_sequence_type &found_qualified_name)
parse_operator_defined	wave/grammars/cpp_defined_grammar_gen.hpp	/^    parse_operator_defined (iterator2_type const &first, $/;"	p	struct:boost::wave::grammars::defined_grammar_gen	access:public	signature:(iterator2_type const &first, iterator2_type const &last, token_sequence_type &found_qualified_name)
parse_predefined_macro	wave/grammars/cpp_predef_macros_gen.hpp	/^    parse_predefined_macro (iterator_type const &first, iterator_type const &last);$/;"	p	struct:boost::wave::grammars::predefined_macros_grammar_gen	access:public	signature:(iterator_type const &first, iterator_type const &last)
parse_predefined_macro	wave/grammars/cpp_predef_macros_grammar.hpp	/^predefined_macros_grammar_gen<LexIteratorT>::parse_predefined_macro ($/;"	f	class:boost::wave::grammars::predefined_macros_grammar_gen	signature:( LexIteratorT const &first, LexIteratorT const &last)
parse_tree_match_type	wave/util/cpp_iterator.hpp	/^        parse_tree_match_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
parse_tree_type	wave/util/cpp_iterator.hpp	/^    typedef typename parse_tree_match_type::container_t  parse_tree_type;       \/\/ parse_node_type::children_t$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
parsetree_parse	wave/grammars/cpp_grammar.hpp	/^parsetree_parse(IteratorT const& first_, IteratorT const& last,$/;"	f	namespace:boost::wave::grammars	signature:(IteratorT const& first_, IteratorT const& last, boost::spirit::classic::parser<ParserT> const& p)
pattern	wave/util/pattern_parser.hpp	/^        CharT         pattern;$/;"	m	struct:boost::wave::util::pattern_and	access:public
pattern_and	wave/util/pattern_parser.hpp	/^        pattern_and(CharT pattern_, unsigned long pattern_mask_ = 0UL)$/;"	f	struct:boost::wave::util::pattern_and	access:public	signature:(CharT pattern_, unsigned long pattern_mask_ = 0UL)
pattern_and	wave/util/pattern_parser.hpp	/^    struct pattern_and $/;"	s	namespace:boost::wave::util	inherits:boost::spirit::classic::char_parser
pattern_mask	wave/util/pattern_parser.hpp	/^        unsigned long pattern_mask;$/;"	m	struct:boost::wave::util::pattern_and	access:public
pattern_p	wave/util/pattern_parser.hpp	/^    pattern_p(CharT pattern, unsigned long pattern_mask = 0UL)$/;"	f	namespace:boost::wave::util	signature:(CharT pattern, unsigned long pattern_mask = 0UL)
peek	wave/util/unput_queue_iterator.hpp	/^        peek(IteratorT it, IteratorT end, bool skip_whitespace = true)$/;"	f	struct:boost::wave::util::impl::next_token	access:public	signature:(IteratorT it, IteratorT end, bool skip_whitespace = true)
peek	wave/util/unput_queue_iterator.hpp	/^        peek(iterator_type it, iterator_type end, bool skip_whitespace = true)$/;"	f	struct:boost::wave::util::impl::next_token	access:public	signature:(iterator_type it, iterator_type end, bool skip_whitespace = true)
pending_queue	wave/util/cpp_iterator.hpp	/^    token_sequence_type pending_queue;   \/\/ tokens already preprocessed$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
plain_define	wave/grammars/cpp_grammar.hpp	/^        rule_type plain_define, macro_definition, macro_parameters;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
plain_define	wave/grammars/cpp_predef_macros_grammar.hpp	/^        rule_type plain_define, macro_definition, macro_parameters;$/;"	m	struct:boost::wave::grammars::predefined_macros_grammar::definition	access:public
pod_copy	wave/util/flex_string.hpp	/^    inline Pod* pod_copy(const Pod* b, const Pod* e, Pod* d)$/;"	f	namespace:boost::wave::util::flex_string_details	signature:(const Pod* b, const Pod* e, Pod* d)
pod_fill	wave/util/flex_string.hpp	/^    inline void pod_fill(Pod* b, Pod* e, T c)$/;"	f	namespace:boost::wave::util::flex_string_details	signature:(Pod* b, Pod* e, T c)
pod_move	wave/util/flex_string.hpp	/^    inline void pod_move(const Pod* b, const Pod* e, Pod* d)$/;"	f	namespace:boost::wave::util::flex_string_details	signature:(const Pod* b, const Pod* e, Pod* d)
pointer	wave/util/flex_string.hpp	/^    typedef typename A::pointer pointer;$/;"	t	class:boost::wave::util::flex_string	access:public
pointer	wave/util/flex_string.hpp	/^    typedef value_type*       pointer;$/;"	t	class:boost::wave::util::mallocator	access:public
pointer	wave/util/flex_string.hpp	/^  typedef void*       pointer;$/;"	t	class:boost::wave::util::mallocator	access:private
pointer	wave/util/functor_input.hpp	/^        typedef result_type *pointer;$/;"	t	class:boost::wave::util::functor_input::inner	access:public
policies_t	wave/grammars/cpp_grammar.hpp	/^            policies_t;$/;"	t	struct:boost::wave::grammars::cpp_grammar::definition	access:public
policy_type	wave/cpplexer/cpp_lex_iterator.hpp	/^        policy_type;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
pop	wave/util/iteration_context.hpp	/^    void pop() { iter_ctx.pop(); }$/;"	f	class:boost::wave::util::iteration_context_stack	access:public	signature:()
pop_front	wave/util/cpp_macromap_utils.hpp	/^        pop_front(ContainerT &list_) : list(list_) {}$/;"	f	class:boost::wave::util::on_exit::pop_front	access:public	signature:(ContainerT &list_)
pop_front	wave/util/cpp_macromap_utils.hpp	/^    class pop_front {$/;"	c	namespace:boost::wave::util::on_exit
pop_iteration_context	wave/cpp_context.hpp	/^    iteration_ptr_type pop_iteration_context()$/;"	f	class:boost::wave::context	access:protected	signature:()
pos	wave/cpplexer/cpp_lex_token.hpp	/^    position_type pos;          \/\/ the original file position$/;"	m	class:boost::wave::cpplexer::impl::token_data	access:private
position_iterator	wave/util/file_position.hpp	/^    position_iterator()$/;"	f	struct:boost::wave::util::position_iterator	access:public	signature:()
position_iterator	wave/util/file_position.hpp	/^    position_iterator(IteratorT const &begin, IteratorT const &end,$/;"	f	struct:boost::wave::util::position_iterator	access:public	signature:(IteratorT const &begin, IteratorT const &end, PositionT const &pos)
position_iterator	wave/util/file_position.hpp	/^struct position_iterator $/;"	s	namespace:boost::wave::util	inherits:boost::spirit::classic::position_iterator
position_policy	wave/util/file_position.hpp	/^        position_policy()$/;"	f	class:boost::spirit::classic::position_policy	access:public	signature:()
position_policy	wave/util/file_position.hpp	/^    class position_policy<boost::wave::util::file_position_type> {$/;"	c	namespace:boost::spirit::classic
position_type	wave/cpp_context.hpp	/^    typedef typename token_type::position_type      position_type;$/;"	t	class:boost::wave::context	access:public
position_type	wave/cpp_iteration_context.hpp	/^    typedef typename IteratorT::token_type::position_type position_type;$/;"	t	struct:boost::wave::iteration_context	access:public
position_type	wave/cpplexer/cpp_lex_interface.hpp	/^    typedef typename TokenT::position_type position_type;$/;"	t	struct:boost::wave::cpplexer::lex_input_interface	access:public
position_type	wave/cpplexer/cpp_lex_interface_generator.hpp	/^    typedef typename lex_input_interface<TokenT>::position_type position_type;$/;"	t	struct:boost::wave::cpplexer::lex_input_interface_generator	access:public
position_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef typename TokenT::position_type  position_type;$/;"	t	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:private
position_type	wave/cpplexer/cpp_lex_token.hpp	/^    typedef PositionT               position_type;$/;"	t	class:boost::wave::cpplexer::lex_token	access:public
position_type	wave/cpplexer/cpp_lex_token.hpp	/^    typedef PositionT   position_type;$/;"	t	class:boost::wave::cpplexer::impl::token_data	access:public
position_type	wave/grammars/cpp_grammar.hpp	/^    typedef typename TokenT::position_type  position_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar	access:public
position_type	wave/grammars/cpp_grammar_gen.hpp	/^    typedef typename token_type::position_type    position_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar_gen	access:public
position_type	wave/util/cpp_iterator.hpp	/^    typedef typename result_type::position_type         position_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
position_type	wave/util/cpp_macromap.hpp	/^    typedef typename token_type::position_type      position_type;$/;"	t	class:boost::wave::util::macromap	access:private
pp_directive	wave/util/cpp_iterator.hpp	/^    bool pp_directive();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:()
pp_directive	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::pp_directive()$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:()
pp_expression	wave/grammars/cpp_expression_grammar.hpp	/^        simple_rule_t pp_expression;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
pp_is_last_on_line	wave/util/cpp_iterator.hpp	/^    bool pp_is_last_on_line(ContextT &ctx, IteratorT &it, IteratorT const &end,$/;"	f	namespace:boost::wave::impl::impl	signature:(ContextT &ctx, IteratorT &it, IteratorT const &end, bool call_hook = true)
pp_iterator	wave/util/cpp_iterator.hpp	/^    pp_iterator()$/;"	f	class:boost::wave::pp_iterator	access:public	signature:()
pp_iterator	wave/util/cpp_iterator.hpp	/^    pp_iterator(ContextT &ctx, IteratorT const &first, IteratorT const &last,$/;"	f	class:boost::wave::pp_iterator	access:public	signature:(ContextT &ctx, IteratorT const &first, IteratorT const &last, typename ContextT::position_type const &pos)
pp_iterator	wave/util/cpp_iterator.hpp	/^class pp_iterator$/;"	c	namespace:boost::wave	inherits:boost::spirit::classic::multi_pass
pp_iterator_functor	wave/util/cpp_iterator.hpp	/^    pp_iterator_functor(ContextT &ctx_, IteratorT const &first_,$/;"	f	class:boost::wave::impl::pp_iterator_functor	access:public	signature:(ContextT &ctx_, IteratorT const &first_, IteratorT const &last_, typename ContextT::position_type const &pos_)
pp_iterator_functor	wave/util/cpp_iterator.hpp	/^class pp_iterator_functor {$/;"	c	namespace:boost::wave::impl
pp_statement	wave/grammars/cpp_grammar.hpp	/^        rule_type pp_statement, macro_include_file;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
pp_token	wave/util/cpp_iterator.hpp	/^    result_type const &pp_token();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:()
pp_token	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::pp_token()$/;"	f	class:boost::wave::impl::pp_iterator_functor::pp_iterator_functor	signature:()
ppelif	wave/grammars/cpp_grammar.hpp	/^        rule_type ppifdef, ppifndef, ppif, ppelif;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
ppendregion	wave/grammars/cpp_grammar.hpp	/^        rule_type ppendregion;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
pperror	wave/grammars/cpp_grammar.hpp	/^        rule_type pperror;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
ppif	wave/grammars/cpp_grammar.hpp	/^        rule_type ppifdef, ppifndef, ppif, ppelif;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
ppifdef	wave/grammars/cpp_grammar.hpp	/^        rule_type ppifdef, ppifndef, ppif, ppelif;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
ppifndef	wave/grammars/cpp_grammar.hpp	/^        rule_type ppifdef, ppifndef, ppif, ppelif;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
ppline	wave/grammars/cpp_grammar.hpp	/^        rule_type ppline; $/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
pppragma	wave/grammars/cpp_grammar.hpp	/^        rule_type pppragma;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
ppqualifiedname	wave/grammars/cpp_grammar.hpp	/^        rule_type ppqualifiedname;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
ppregion	wave/grammars/cpp_grammar.hpp	/^        rule_type ppregion;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
ppsp	wave/grammars/cpp_grammar.hpp	/^        no_tree_rule_type ppsp;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
ppwarning	wave/grammars/cpp_grammar.hpp	/^        rule_type ppwarning;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
pragma_message_directive	wave/cpp_exceptions.hpp	/^        pragma_message_directive,$/;"	e	enum:boost::wave::preprocess_exception::error_code
pragma_once_files	wave/util/cpp_include_paths.hpp	/^    pragma_once_set_type pragma_once_files;$/;"	m	class:boost::wave::util::include_paths	access:private
pragma_once_set_type	wave/util/cpp_include_paths.hpp	/^        pragma_once_set_type;$/;"	t	class:boost::wave::util::include_paths	access:private
predef	wave/util/cpp_macromap.hpp	/^    predefined_macros predef;   \/\/ predefined macro support$/;"	m	class:boost::wave::util::macromap	access:private
predefine_macro	wave/util/cpp_macromap.hpp	/^    void predefine_macro(defined_macros_type *scope, string_type const &name,$/;"	p	class:boost::wave::util::macromap	access:public	signature:(defined_macros_type *scope, string_type const &name, token_type const &t)
predefine_macro	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::predefine_macro(defined_macros_type *scope,$/;"	f	class:boost::wave::util::macromap	signature:(defined_macros_type *scope, string_type const &name, token_type const &t)
predefined_macros	wave/util/cpp_macromap_predef.hpp	/^        predefined_macros() $/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:()
predefined_macros	wave/util/cpp_macromap_predef.hpp	/^    class predefined_macros $/;"	c	namespace:boost::wave::util
predefined_macros_grammar	wave/grammars/cpp_predef_macros_grammar.hpp	/^    predefined_macros_grammar() $/;"	f	struct:boost::wave::grammars::predefined_macros_grammar	access:public	signature:()
predefined_macros_grammar	wave/grammars/cpp_predef_macros_grammar.hpp	/^struct predefined_macros_grammar : $/;"	s	namespace:boost::wave::grammars	inherits:boost::spirit::classic::grammar
predefined_macros_grammar_gen	wave/grammars/cpp_predef_macros_gen.hpp	/^struct BOOST_WAVE_DECL predefined_macros_grammar_gen$/;"	s	namespace:boost::wave::grammars
preprocess_exception	wave/cpp_exceptions.hpp	/^    preprocess_exception(char const *what_, error_code code, std::size_t line_,$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:(char const *what_, error_code code, std::size_t line_, std::size_t column_, char const *filename_)
preprocess_exception	wave/cpp_exceptions.hpp	/^class BOOST_SYMBOL_VISIBLE preprocess_exception :$/;"	c	namespace:boost::wave	inherits:cpp_exception
preserve_bol_whitespace	wave/whitespace_handling.hpp	/^    bool preserve_bol_whitespace;$/;"	m	class:boost::wave::context_policies::eat_whitespace	access:private
preserve_comments	wave/whitespace_handling.hpp	/^    bool preserve_comments;$/;"	m	class:boost::wave::context_policies::eat_whitespace	access:private
prev	wave/util/insert_whitespace_detection.hpp	/^    boost::wave::token_id prev;        \/\/ the previous analyzed token$/;"	m	class:boost::wave::util::insert_whitespace_detection	access:private
primary_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t unary_exp, primary_exp, constant;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
primary_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t unary_exp_nocalc, primary_exp_nocalc, constant_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
print	wave/cpplexer/cpp_lex_token.hpp	/^    void print (std::ostream &stream) const$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(std::ostream &stream) const
print	wave/cpplexer/cpp_lex_token.hpp	/^    void print (std::ostream &stream) const$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(std::ostream &stream) const
ptr	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* ptr;     \/* used for YYMARKER - saves backtracking info *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
push	wave/util/iteration_context.hpp	/^    void push(Context& ctx, PositionT const &pos,$/;"	f	class:boost::wave::util::iteration_context_stack	access:public	signature:(Context& ctx, PositionT const &pos, typename base_type::value_type const &val)
push_back	wave/util/flex_string.hpp	/^    void push_back(value_type c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c)
push_iteration_context	wave/cpp_context.hpp	/^    void push_iteration_context(position_type const &act_pos, iteration_ptr_type iter_ctx)$/;"	f	class:boost::wave::context	access:protected	signature:(position_type const &act_pos, iteration_ptr_type iter_ctx)
questionmark	wave/grammars/cpp_expression_grammar.hpp	/^    phoenix::function<operator_questionmark> const questionmark;$/;"	m	class:boost::wave::grammars::impl::phoenix
queue	wave/cpplexer/re2clex/aq.hpp	/^    aq_stdelement* queue;$/;"	m	struct:boost::wave::cpplexer::re2clex::tag_aq_queuetype	access:public
rawstring_count_newlines	wave/whitespace_handling.hpp	/^    int rawstring_count_newlines(TokenT const& token)$/;"	f	namespace:boost::wave::context_policies::util	signature:(TokenT const& token)
rbegin	wave/util/flex_string.hpp	/^    const_reverse_iterator rbegin() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
rbegin	wave/util/flex_string.hpp	/^    reverse_iterator rbegin()$/;"	f	class:boost::wave::util::flex_string	access:public	signature:()
re2c_lexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    lexer<IteratorT, PositionT, TokenT> re2c_lexer;$/;"	m	class:boost::wave::cpplexer::re2clex::lex_functor	access:private
re2clex	wave/cpplexer/re2clex/aq.hpp	/^namespace re2clex {$/;"	n	namespace:boost::wave::cpplexer
re2clex	wave/cpplexer/re2clex/cpp_re.hpp	/^namespace re2clex {$/;"	n	namespace:boost::wave::cpplexer
re2clex	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^namespace re2clex {$/;"	n	namespace:boost::wave::cpplexer
re2clex	wave/cpplexer/re2clex/scanner.hpp	/^namespace re2clex {$/;"	n	namespace:boost::wave::cpplexer
real_filename	wave/cpp_iteration_context.hpp	/^    BOOST_WAVE_STRINGTYPE real_filename;  \/\/ real name of the current file$/;"	m	struct:boost::wave::base_iteration_context	access:public
real_relative_filename	wave/cpp_iteration_context.hpp	/^    BOOST_WAVE_STRINGTYPE real_relative_filename;  \/\/ real relative name of the current file$/;"	m	struct:boost::wave::base_iteration_context	access:public
rebind	wave/util/flex_string.hpp	/^    struct rebind { typedef mallocator<U> other; };$/;"	s	class:boost::wave::util::mallocator	access:public
rebind	wave/util/flex_string.hpp	/^  struct rebind { typedef mallocator<U> other; };$/;"	s	class:boost::wave::util::mallocator	access:private
ref_transform_iterator_generator	wave/util/transform_iterator.hpp	/^    class ref_transform_iterator_generator$/;"	c	namespace:boost::wave::impl
refcnt	wave/cpplexer/cpp_lex_token.hpp	/^    boost::detail::atomic_count refcnt;$/;"	m	class:boost::wave::cpplexer::impl::token_data	access:private
reference	wave/util/flex_string.hpp	/^    typedef typename A::reference reference;$/;"	t	class:boost::wave::util::flex_string	access:public
reference	wave/util/flex_string.hpp	/^    typedef typename Storage::reference reference;$/;"	t	class:boost::wave::util::CowString	access:public
reference	wave/util/flex_string.hpp	/^    typedef value_type&       reference;$/;"	t	class:boost::wave::util::mallocator	access:public
reference	wave/util/functor_input.hpp	/^        typedef result_type &reference;$/;"	t	class:boost::wave::util::functor_input::inner	access:public
release	wave/cpplexer/cpp_lex_token.hpp	/^    std::size_t release() { return --refcnt; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:()
remove_leading_whitespace	wave/util/cpp_iterator.hpp	/^    remove_leading_whitespace(ContextT &ctx, ContainerT& c, bool call_hook = true)$/;"	f	namespace:boost::wave::impl::impl	signature:(ContextT &ctx, ContainerT& c, bool call_hook = true)
remove_macro	wave/util/cpp_macromap.hpp	/^    bool remove_macro(string_type const &name, position_type const& pos,$/;"	p	class:boost::wave::util::macromap	access:public	signature:(string_type const &name, position_type const& pos, bool even_predefined = false)
remove_macro	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::remove_macro(string_type const &name,$/;"	f	class:boost::wave::util::macromap	signature:(string_type const &name, position_type const& pos, bool even_predefined)
remove_macro_definition	wave/cpp_context.hpp	/^    bool remove_macro_definition(StringT const& undefname, bool even_predefined = false)$/;"	f	class:boost::wave::context	access:public	signature:(StringT const& undefname, bool even_predefined = false)
remove_placeholders	wave/util/cpp_macromap_utils.hpp	/^remove_placeholders (ContainerT &replacement_list)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT &replacement_list)
remove_pragma_once_header	wave/util/cpp_include_paths.hpp	/^    bool remove_pragma_once_header(std::string const& guard_name)$/;"	f	class:boost::wave::util::include_paths	access:public	signature:(std::string const& guard_name)
rend	wave/util/flex_string.hpp	/^    const_reverse_iterator rend() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
rend	wave/util/flex_string.hpp	/^    reverse_iterator rend()$/;"	f	class:boost::wave::util::flex_string	access:public	signature:()
replace	wave/util/flex_string.hpp	/^    flex_string& replace(iterator i1, iterator i2, const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(iterator i1, iterator i2, const flex_string& str)
replace	wave/util/flex_string.hpp	/^    flex_string& replace(iterator i1, iterator i2, const value_type* s)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(iterator i1, iterator i2, const value_type* s)
replace	wave/util/flex_string.hpp	/^    flex_string& replace(iterator i1, iterator i2,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(iterator i1, iterator i2, T1 first_or_n_or_s, T2 last_or_c_or_n)
replace	wave/util/flex_string.hpp	/^    flex_string& replace(size_type pos, size_type n1, $/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos, size_type n1, StrOrLength s_or_n2, NumOrChar n_or_c)
replace	wave/util/flex_string.hpp	/^    flex_string& replace(size_type pos, size_type n1, const value_type* s)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos, size_type n1, const value_type* s)
replace	wave/util/flex_string.hpp	/^    flex_string& replace(size_type pos1, size_type n1, const flex_string& str)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, size_type n1, const flex_string& str)
replace	wave/util/flex_string.hpp	/^    flex_string& replace(size_type pos1, size_type n1, const flex_string& str,$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos1, size_type n1, const flex_string& str, size_type pos2, size_type n2)
replace_ellipsis	wave/util/macro_helpers.hpp	/^    void replace_ellipsis (std::vector<ContainerT> const &arguments,$/;"	f	namespace:boost::wave::util::impl	signature:(std::vector<ContainerT> const &arguments, typename ContainerT::size_type index, ContainerT &expanded, PositionT const &pos)
replace_parameters	wave/util/macro_definition.hpp	/^    void replace_parameters()$/;"	f	struct:boost::wave::util::macro_definition	access:public	signature:()
replace_undefined_identifiers	wave/util/cpp_iterator.hpp	/^    void replace_undefined_identifiers(token_sequence_type &expanded);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(token_sequence_type &expanded)
replace_undefined_identifiers	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::replace_undefined_identifiers($/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:( token_sequence_type &expanded)
replaced_parameters	wave/util/macro_definition.hpp	/^    bool replaced_parameters;$/;"	m	struct:boost::wave::util::macro_definition	access:public
report_error	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    static int report_error(Scanner const* s, int code, char const *, ...);$/;"	p	class:boost::wave::cpplexer::re2clex::lexer	access:public	signature:(Scanner const* s, int code, char const *, ...)
report_error	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^lexer<IteratorT, PositionT, TokenT>::report_error(Scanner const *s, int errcode,$/;"	f	class:boost::wave::cpplexer::re2clex::lexer	signature:(Scanner const *s, int errcode, char const *msg, ...)
report_invalid_concatenation	wave/util/cpp_macromap.hpp	/^inline void report_invalid_concatenation(Context& ctx,$/;"	f	namespace:boost::wave::util	signature:(Context& ctx, typename Context::token_type const& prev, typename Context::token_type const& next, typename Context::position_type const& main_pos)
rescan_replacement_list	wave/util/cpp_macromap.hpp	/^    void rescan_replacement_list(token_type const &curr_token,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(token_type const &curr_token, macro_definition_type &macrodef, ContainerT &replacement_list, ContainerT &expanded, bool expand_operator_defined, IteratorT &nfirst, IteratorT const &nlast)
rescan_replacement_list	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::rescan_replacement_list(token_type const &curr_token,$/;"	f	class:boost::wave::util::macromap	signature:(token_type const &curr_token, macro_definition_type &macro_def, ContainerT &replacement_list, ContainerT &expanded, bool expand_operator_defined, IteratorT &nfirst, IteratorT const &nlast)
rescanned_macro	wave/preprocessing_hooks.hpp	/^    void rescanned_macro(ContainerT const& result)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContainerT const& result)
rescanned_macro	wave/preprocessing_hooks.hpp	/^    void rescanned_macro(ContextT const& ctx, ContainerT const& result)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ContainerT const& result)
reserve	wave/util/flex_string.hpp	/^    void reserve(size_type res_arg = 0)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type res_arg = 0)
reserve	wave/util/flex_string.hpp	/^    void reserve(size_type res_arg)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(size_type res_arg)
reserve	wave/util/flex_string.hpp	/^    void reserve(size_type res_arg)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(size_type res_arg)
reserve	wave/util/flex_string.hpp	/^    void reserve(size_type res_arg)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(size_type res_arg)
reserve	wave/util/flex_string.hpp	/^    void reserve(size_type res_arg)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(size_type res_arg)
reserve	wave/util/flex_string.hpp	/^    void reserve(size_type res_arg)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(size_type res_arg)
reset	wave/util/cpp_macromap_predef.hpp	/^        void reset()$/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:()
reset	wave/util/cpp_macromap_utils.hpp	/^        reset(TypeT &target_value_, TypeT new_value)$/;"	f	class:boost::wave::util::on_exit::reset	access:public	signature:(TypeT &target_value_, TypeT new_value)
reset	wave/util/cpp_macromap_utils.hpp	/^    class reset {$/;"	c	namespace:boost::wave::util::on_exit
reset_datestr	wave/util/cpp_macromap_predef.hpp	/^        void reset_datestr()$/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:()
reset_macro_definitions	wave/cpp_context.hpp	/^    void reset_macro_definitions() $/;"	f	class:boost::wave::context	access:public	signature:()
reset_macromap	wave/util/cpp_macromap.hpp	/^    void reset_macromap();$/;"	p	class:boost::wave::util::macromap	access:public	signature:()
reset_macromap	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::reset_macromap()$/;"	f	class:boost::wave::util::macromap	signature:()
reset_timestr	wave/util/cpp_macromap_predef.hpp	/^        void reset_timestr()$/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:()
reset_version	wave/util/cpp_macromap_predef.hpp	/^        void reset_version()$/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:()
reset_versionstr	wave/util/cpp_macromap_predef.hpp	/^        void reset_versionstr()$/;"	f	class:boost::wave::util::predefined_macros	access:protected	signature:()
resize	wave/util/flex_string.hpp	/^    void resize(size_type n)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type n)
resize	wave/util/flex_string.hpp	/^    void resize(size_type n, E c)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(size_type n, E c)
resize	wave/util/flex_string.hpp	/^    void resize(size_type n, E c)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(size_type n, E c)
resize	wave/util/flex_string.hpp	/^    void resize(size_type n, E c)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(size_type n, E c)
resize	wave/util/flex_string.hpp	/^    void resize(size_type n, value_type c)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(size_type n, value_type c)
resize	wave/util/flex_string.hpp	/^    void resize(size_type n, value_type c)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type n, value_type c)
resize	wave/util/flex_string.hpp	/^    void resize(size_type newSize, E fill)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(size_type newSize, E fill)
resolve_defined	wave/util/cpp_macromap.hpp	/^    token_type const &resolve_defined(IteratorT &first, IteratorT const &last,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(IteratorT &first, IteratorT const &last, ContainerT &expanded)
resolve_defined	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::resolve_defined(IteratorT &first,$/;"	f	class:boost::wave::util::ContextT::macromap	signature:(IteratorT &first, IteratorT const &last, ContainerT &pending)
resolve_operator_pragma	wave/util/cpp_macromap.hpp	/^    bool resolve_operator_pragma(IteratorT &first,$/;"	p	class:boost::wave::util::macromap	access:protected	signature:(IteratorT &first, IteratorT const &last, ContainerT &expanded, bool& seen_newline)
resolve_operator_pragma	wave/util/cpp_macromap.hpp	/^macromap<ContextT>::resolve_operator_pragma(IteratorT &first,$/;"	f	class:boost::wave::util::macromap	signature:(IteratorT &first, IteratorT const &last, ContainerT &pending, bool& seen_newline)
result	wave/grammars/cpp_chlit_grammar.hpp	/^        struct result $/;"	s	struct:boost::wave::grammars::impl::compose_character_literal	access:public
result	wave/grammars/cpp_expression_grammar.hpp	/^        struct result { $/;"	s	struct:boost::wave::grammars::impl::convert_chlit	access:public
result	wave/grammars/cpp_expression_grammar.hpp	/^        struct result { $/;"	s	struct:boost::wave::grammars::impl::convert_intlit	access:public
result	wave/grammars/cpp_expression_grammar.hpp	/^        struct result { $/;"	s	struct:boost::wave::grammars::impl::operator_as_bool	access:public
result	wave/grammars/cpp_expression_grammar.hpp	/^        struct result { $/;"	s	struct:boost::wave::grammars::impl::operator_questionmark	access:public
result	wave/grammars/cpp_expression_grammar.hpp	/^        struct result { $/;"	s	struct:boost::wave::grammars::impl::operator_to_bool	access:public
result	wave/util/flex_string.hpp	/^        typedef T result;$/;"	t	struct:boost::wave::util::flex_string_details::get_unsigned	access:public
result	wave/util/flex_string.hpp	/^        typedef unsigned char result;$/;"	t	struct:boost::wave::util::flex_string_details::get_unsigned	access:public
result	wave/util/flex_string.hpp	/^        typedef unsigned int result;$/;"	t	struct:boost::wave::util::flex_string_details::get_unsigned	access:public
result	wave/util/flex_string.hpp	/^        typedef unsigned long int result;$/;"	t	struct:boost::wave::util::flex_string_details::get_unsigned	access:public
result	wave/util/flex_string.hpp	/^        typedef unsigned short int result;$/;"	t	struct:boost::wave::util::flex_string_details::get_unsigned	access:public
result_seq	wave/grammars/cpp_defined_grammar.hpp	/^    ContainerT &result_seq;$/;"	m	struct:boost::wave::grammars::defined_grammar	access:public
result_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef TokenT result_type;$/;"	t	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public
result_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef typename FunctorData::result_type result_type;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
result_type	wave/util/cpp_iterator.hpp	/^    typedef typename ContextT::token_type               result_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:public
result_type	wave/util/functor_input.hpp	/^        typedef typename FunctorT::result_type result_type;$/;"	t	class:boost::wave::util::functor_input::inner	access:private
result_type	wave/util/symbol_table.hpp	/^        typedef StringT1 const& result_type;$/;"	t	struct:boost::wave::util::symbol_table::get_first	access:public
result_type	wave/util/transform_iterator.hpp	/^        typedef TokenT const &result_type;$/;"	t	struct:boost::wave::impl::get_token_value	access:public
retrieve_line_info	wave/util/cpp_iterator.hpp	/^    bool retrieve_line_info (IteratorT first, IteratorT const &last,$/;"	f	namespace:boost::wave::impl::impl	signature:(IteratorT first, IteratorT const &last, unsigned int &line, StringT &file, boost::wave::preprocess_exception::error_code& error)
retrieve_macrodefinition	wave/util/cpp_iterator.hpp	/^retrieve_macrodefinition($/;"	f	namespace:boost::wave::util	signature:( ParseNodeT const &node, boost::spirit::classic::parser_id id, ContainerT &macrodefinition, PositionT& act_pos, bool update_position)
retrieve_macroname	wave/util/cpp_iterator.hpp	/^retrieve_macroname(ContextT& ctx, ParseNodeT const &node,$/;"	f	namespace:boost::wave::util	signature:(ContextT& ctx, ParseNodeT const &node, boost::spirit::classic::parser_id id, TokenT &macroname, PositionT& act_pos, bool update_position)
return_type	wave/util/transform_iterator.hpp	/^        typedef typename AdaptableUnaryFunctionT::result_type   return_type;$/;"	t	class:boost::wave::impl::ref_transform_iterator_generator	access:private
return_type	wave/util/unput_queue_iterator.hpp	/^            return_type;$/;"	t	struct:boost::wave::util::impl::gen_unput_queue_iterator	access:public
returned_from_include	wave/util/cpp_iterator.hpp	/^    bool returned_from_include();$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:()
returned_from_include	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::returned_from_include()$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:()
returning_from_include_file	wave/preprocessing_hooks.hpp	/^    returning_from_include_file() $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:()
returning_from_include_file	wave/preprocessing_hooks.hpp	/^    returning_from_include_file(ContextT const& ctx) $/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx)
reverse_iterator	wave/util/flex_string.hpp	/^    typedef boost::reverse_iterator<iterator> reverse_iterator;$/;"	t	class:boost::wave::util::flex_string	access:public
rfind	wave/util/flex_string.hpp	/^    size_type rfind(const flex_string& str, size_type pos = npos) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const flex_string& str, size_type pos = npos) const
rfind	wave/util/flex_string.hpp	/^    size_type rfind(const value_type* s, size_type pos = npos) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos = npos) const
rfind	wave/util/flex_string.hpp	/^    size_type rfind(const value_type* s, size_type pos, size_type n) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(const value_type* s, size_type pos, size_type n) const
rfind	wave/util/flex_string.hpp	/^    size_type rfind(value_type c, size_type pos = npos) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(value_type c, size_type pos = npos) const
rule_t	wave/grammars/cpp_chlit_grammar.hpp	/^            rule_t;$/;"	t	struct:boost::wave::grammars::chlit_grammar::definition	access:public
rule_t	wave/grammars/cpp_defined_grammar.hpp	/^        typedef boost::spirit::classic::rule<ScannerT> rule_t;$/;"	t	struct:boost::wave::grammars::defined_grammar::definition	access:public
rule_t	wave/grammars/cpp_expression_grammar.hpp	/^        typedef boost::spirit::classic::rule<ScannerT, closure_type::context_t> rule_t;$/;"	t	struct:boost::wave::grammars::expression_grammar::definition	access:public
rule_t	wave/grammars/cpp_intlit_grammar.hpp	/^        typedef boost::spirit::classic::rule<ScannerT> rule_t;$/;"	t	struct:boost::wave::grammars::intlit_grammar::definition	access:public
rule_type	wave/grammars/cpp_grammar.hpp	/^            rule_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar::definition	access:public
rule_type	wave/grammars/cpp_predef_macros_grammar.hpp	/^            rule_type;$/;"	t	struct:boost::wave::grammars::predefined_macros_grammar::definition	access:public
s_	wave/util/flex_string.hpp	/^        const flex_string& s_;$/;"	m	struct:boost::wave::util::flex_string::Invariant	access:private
same_input	wave/util/functor_input.hpp	/^        bool same_input(inner const &x) const$/;"	f	class:boost::wave::util::functor_input::inner	access:protected	signature:(inner const &x) const
save	wave/cpp_context.hpp	/^    void save(Archive & ar, const unsigned int version) const$/;"	f	class:boost::wave::context	access:private	signature:(Archive & ar, const unsigned int version) const
save	wave/util/cpp_include_paths.hpp	/^    void save(Archive & ar, const unsigned int version) const$/;"	f	class:boost::wave::util::include_paths	access:private	signature:(Archive & ar, const unsigned int version) const
save	wave/util/cpp_include_paths.hpp	/^inline void save (Archive & ar, boost::filesystem::path const& p, $/;"	f	namespace:boost::serialization	signature:(Archive & ar, boost::filesystem::path const& p, const unsigned int )
save	wave/util/cpp_include_paths.hpp	/^inline void save (Archive & ar,$/;"	f	namespace:boost::serialization	signature:(Archive & ar, const typename boost::wave::util::bidirectional_map< std::string, std::string >::type &t, const unsigned int )
save	wave/util/cpp_macromap.hpp	/^    void save(Archive &ar, const unsigned int version) const$/;"	f	class:boost::wave::util::macromap	access:private	signature:(Archive &ar, const unsigned int version) const
scan	wave/cpplexer/re2clex/cpp_re.hpp	/^BOOST_WAVE_DECL boost::wave::token_id scan(Scanner *s);$/;"	p	namespace:boost::wave::cpplexer::re2clex	signature:(Scanner *s)
scanner	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    Scanner scanner;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
seen_newline	wave/util/cpp_iterator.hpp	/^    bool seen_newline;              \/\/ needed for recognizing begin of line$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
self_type	wave/cpp_iteration_context.hpp	/^    typedef iteration_context<ContextT, IteratorT, InputPolicyT> self_type;$/;"	t	struct:boost::wave::iteration_context	access:public
self_type	wave/util/cpp_iterator.hpp	/^    typedef pp_iterator<ContextT> self_type;$/;"	t	class:boost::wave::pp_iterator	access:private
self_type	wave/util/cpp_macromap.hpp	/^    typedef macromap<ContextT>                      self_type;$/;"	t	class:boost::wave::util::macromap	access:private
serialization	wave/cpp_context.hpp	/^namespace boost { namespace serialization {$/;"	n	namespace:boost
serialization	wave/util/cpp_include_paths.hpp	/^namespace boost { namespace serialization {$/;"	n	namespace:boost
serialization	wave/util/cpp_macromap.hpp	/^namespace boost { namespace serialization {$/;"	n	namespace:boost
serialization	wave/util/flex_string.hpp	/^namespace boost { namespace serialization {$/;"	n	namespace:boost
serialize	wave/cpplexer/cpp_lex_token.hpp	/^    void serialize(Archive &ar, const unsigned int version)$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(Archive &ar, const unsigned int version)
serialize	wave/cpplexer/cpp_lex_token.hpp	/^    void serialize(Archive &ar, const unsigned int version)$/;"	f	class:boost::wave::cpplexer::lex_token	access:private	signature:(Archive &ar, const unsigned int version)
serialize	wave/util/cpp_include_paths.hpp	/^inline void serialize (Archive & ar, $/;"	f	namespace:boost::serialization	signature:(Archive & ar, typename boost::wave::util::bidirectional_map< std::string, std::string >::type &t, const unsigned int file_version)
serialize	wave/util/cpp_include_paths.hpp	/^inline void serialize (Archive & ar, boost::filesystem::path &p,$/;"	f	namespace:boost::serialization	signature:(Archive & ar, boost::filesystem::path &p, const unsigned int file_version)
serialize	wave/util/file_position.hpp	/^    void serialize(Archive &ar, const unsigned int version)$/;"	f	struct:boost::wave::util::file_position	access:private	signature:(Archive &ar, const unsigned int version)
serialize	wave/util/macro_definition.hpp	/^    void serialize(Archive &ar, const unsigned int version)$/;"	f	struct:boost::wave::util::macro_definition	access:private	signature:(Archive &ar, const unsigned int version)
serialize	wave/util/symbol_table.hpp	/^    void serialize(Archive &ar, const unsigned int version)$/;"	f	struct:boost::wave::util::symbol_table	access:private	signature:(Archive &ar, const unsigned int version)
set_column	wave/util/file_position.hpp	/^    void set_column(std::size_t column_) { column = column_; }$/;"	f	struct:boost::wave::util::file_position	access:public	signature:(std::size_t column_)
set_current_directory	wave/cpp_context.hpp	/^    void set_current_directory(char const *path_) $/;"	f	class:boost::wave::context	access:protected	signature:(char const *path_)
set_current_directory	wave/util/cpp_include_paths.hpp	/^    void set_current_directory(char const *path_);$/;"	p	class:boost::wave::util::include_paths	access:public	signature:(char const *path_)
set_current_directory	wave/util/cpp_include_paths.hpp	/^void include_paths::set_current_directory(char const *path_)$/;"	f	class:boost::wave::util::include_paths	signature:(char const *path_)
set_current_filename	wave/cpp_context.hpp	/^    void set_current_filename(char const *real_name)$/;"	f	class:boost::wave::context	access:public	signature:(char const *real_name)
set_current_relative_filename	wave/cpp_context.hpp	/^    void set_current_relative_filename(char const *real_name)$/;"	f	class:boost::wave::context	access:public	signature:(char const *real_name)
set_file	wave/util/file_position.hpp	/^    void set_file(string_type const &file_) $/;"	f	struct:boost::wave::util::file_position	access:public	signature:(string_type const &file_)
set_in_else	wave/util/cpp_ifblock.hpp	/^    void set_in_else() { is_in_else = true; }$/;"	f	class:boost::wave::util::if_block	access:public	signature:()
set_language	wave/cpp_context.hpp	/^    void set_language(boost::wave::language_support language_,$/;"	f	class:boost::wave::context	access:public	signature:(boost::wave::language_support language_, bool reset_macros = true)
set_line	wave/util/file_position.hpp	/^    void set_line(std::size_t line_) { line = line_; }$/;"	f	struct:boost::wave::util::file_position	access:public	signature:(std::size_t line_)
set_max_include_nesting_depth	wave/cpp_context.hpp	/^    void set_max_include_nesting_depth(iter_size_type new_depth)$/;"	f	class:boost::wave::context	access:public	signature:(iter_size_type new_depth)
set_max_include_nesting_depth	wave/util/iteration_context.hpp	/^    void set_max_include_nesting_depth(size_type new_depth)$/;"	f	class:boost::wave::util::iteration_context_stack	access:public	signature:(size_type new_depth)
set_position	wave/cpplexer/cpp_lex_interface.hpp	/^    virtual void set_position(position_type const &pos) = 0;$/;"	p	struct:boost::wave::cpplexer::lex_input_interface	access:public	signature:(position_type const &pos)
set_position	wave/cpplexer/cpp_lex_iterator.hpp	/^    static void set_position(MultiPass& mp, position_type const &pos)$/;"	f	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public	signature:(MultiPass& mp, position_type const &pos)
set_position	wave/cpplexer/cpp_lex_iterator.hpp	/^    void set_position(typename TokenT::position_type const &pos)$/;"	f	class:boost::wave::cpplexer::lex_iterator	access:public	signature:(typename TokenT::position_type const &pos)
set_position	wave/cpplexer/cpp_lex_token.hpp	/^    void set_position (position_type const &pos_) { make_unique(); data->set_position(pos_); }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(position_type const &pos_)
set_position	wave/cpplexer/cpp_lex_token.hpp	/^    void set_position (position_type const &pos_) { pos = pos_; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(position_type const &pos_)
set_position	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    void set_position(PositionT const &pos) { re2c_lexer.set_position(pos); }$/;"	f	class:boost::wave::cpplexer::re2clex::lex_functor	access:public	signature:(PositionT const &pos)
set_position	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    void set_position(PositionT const &pos)$/;"	f	class:boost::wave::cpplexer::re2clex::lexer	access:public	signature:(PositionT const &pos)
set_status	wave/util/cpp_ifblock.hpp	/^    void set_status(bool status_) $/;"	f	class:boost::wave::util::if_block	access:public	signature:(bool status_)
set_support_options	wave/language_support.hpp	/^set_support_options(language_support language, language_support option)$/;"	f	namespace:boost::wave	signature:(language_support language, language_support option)
set_sys_include_delimiter	wave/util/cpp_include_paths.hpp	/^    void set_sys_include_delimiter() { was_sys_include_path = true; }$/;"	f	class:boost::wave::util::include_paths	access:public	signature:()
set_sysinclude_delimiter	wave/cpp_context.hpp	/^    void set_sysinclude_delimiter() { includes.set_sys_include_delimiter(); }$/;"	f	class:boost::wave::context	access:public	signature:()
set_tab_chars	wave/util/file_position.hpp	/^        void set_tab_chars(unsigned int chars)$/;"	f	class:boost::spirit::classic::position_policy	access:public	signature:(unsigned int chars)
set_token_id	wave/cpplexer/cpp_lex_token.hpp	/^    void set_token_id (token_id id_) { id = id_; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(token_id id_)
set_token_id	wave/cpplexer/cpp_lex_token.hpp	/^    void set_token_id (token_id id_) { make_unique(); data->set_token_id(id_); }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(token_id id_)
set_value	wave/cpplexer/cpp_lex_token.hpp	/^    void set_value (string_type const &value_) { make_unique(); data->set_value(value_); }$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:(string_type const &value_)
set_value	wave/cpplexer/cpp_lex_token.hpp	/^    void set_value (string_type const &value_) { value = value_; }$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(string_type const &value_)
severity	wave/cpp_exceptions.hpp	/^    enum severity {$/;"	g	namespace:boost::wave::util
severity	wave/cpplexer/cpplexer_exceptions.hpp	/^    enum severity {$/;"	g	namespace:boost::wave::cpplexer::util
severity_commandline_error	wave/cpp_exceptions.hpp	/^        severity_commandline_error,$/;"	e	enum:boost::wave::util::severity
severity_error	wave/cpp_exceptions.hpp	/^        severity_error,$/;"	e	enum:boost::wave::util::severity
severity_error	wave/cpplexer/cpplexer_exceptions.hpp	/^        severity_error,$/;"	e	enum:boost::wave::cpplexer::util::severity
severity_fatal	wave/cpp_exceptions.hpp	/^        severity_fatal,$/;"	e	enum:boost::wave::util::severity
severity_fatal	wave/cpplexer/cpplexer_exceptions.hpp	/^        severity_fatal$/;"	e	enum:boost::wave::cpplexer::util::severity
severity_level	wave/cpp_exceptions.hpp	/^    static util::severity severity_level(int code)$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:(int code)
severity_level	wave/cpplexer/cpplexer_exceptions.hpp	/^    static util::severity severity_level(int code)$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:(int code)
severity_remark	wave/cpp_exceptions.hpp	/^        severity_remark = 0,$/;"	e	enum:boost::wave::util::severity
severity_remark	wave/cpplexer/cpplexer_exceptions.hpp	/^        severity_remark = 0,$/;"	e	enum:boost::wave::cpplexer::util::severity
severity_text	wave/cpp_exceptions.hpp	/^    static char const *severity_text(int code)$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:(int code)
severity_text	wave/cpplexer/cpplexer_exceptions.hpp	/^    static char const *severity_text(int code)$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:(int code)
severity_warning	wave/cpp_exceptions.hpp	/^        severity_warning,$/;"	e	enum:boost::wave::util::severity
severity_warning	wave/cpplexer/cpplexer_exceptions.hpp	/^        severity_warning,$/;"	e	enum:boost::wave::cpplexer::util::severity
shared	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef lex_input_interface<TokenT>* shared;$/;"	t	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public
shared_functor_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef typename input_policy_type::shared shared_functor_type;$/;"	t	class:boost::wave::cpplexer::lex_iterator	access:private
shift_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t shift_exp;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
shift_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t shift_exp_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
shift_tokens	wave/util/insert_whitespace_detection.hpp	/^    void shift_tokens (boost::wave::token_id next_id)$/;"	f	class:boost::wave::util::insert_whitespace_detection	access:public	signature:(boost::wave::token_id next_id)
simple_rule_t	wave/grammars/cpp_expression_grammar.hpp	/^        typedef boost::spirit::classic::rule<ScannerT> simple_rule_t;$/;"	t	struct:boost::wave::grammars::expression_grammar::definition	access:public
single_line_only	wave/cpplexer/re2clex/scanner.hpp	/^    bool single_line_only;       \/* don't report missing eol's in C++ comments *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
size	wave/cpplexer/re2clex/aq.hpp	/^    std::size_t size;$/;"	m	struct:boost::wave::cpplexer::re2clex::tag_aq_queuetype	access:public
size	wave/util/flex_string.hpp	/^    size_type size() const$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:() const
size	wave/util/flex_string.hpp	/^    size_type size() const$/;"	f	class:boost::wave::util::CowString	access:public	signature:() const
size	wave/util/flex_string.hpp	/^    size_type size() const$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:() const
size	wave/util/flex_string.hpp	/^    size_type size() const$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:() const
size	wave/util/flex_string.hpp	/^    size_type size() const$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:() const
size	wave/util/flex_string.hpp	/^    size_type size() const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:() const
size	wave/util/iteration_context.hpp	/^    typename base_type::size_type size() const { return iter_ctx.size(); }$/;"	f	class:boost::wave::util::iteration_context_stack	access:public	signature:() const
size_type	wave/util/cpp_ifblock.hpp	/^    typedef std::stack<if_block>::size_type size_type;$/;"	t	class:boost::wave::util::if_block_stack	access:public
size_type	wave/util/flex_string.hpp	/^    typedef std::size_t       size_type;$/;"	t	class:boost::wave::util::mallocator	access:public
size_type	wave/util/flex_string.hpp	/^    typedef typename A::size_type size_type;$/;"	t	class:boost::wave::util::AllocatorStringStorage	access:private
size_type	wave/util/flex_string.hpp	/^    typedef typename A::size_type size_type;$/;"	t	class:boost::wave::util::SimpleStringStorage	access:public
size_type	wave/util/flex_string.hpp	/^    typedef typename A::size_type size_type;$/;"	t	class:boost::wave::util::VectorStringStorage	access:public
size_type	wave/util/flex_string.hpp	/^    typedef typename A::size_type size_type;$/;"	t	class:boost::wave::util::flex_string	access:public
size_type	wave/util/flex_string.hpp	/^    typedef typename allocator_type::size_type size_type;$/;"	t	class:boost::wave::util::CowString	access:public
size_type	wave/util/flex_string.hpp	/^    typedef typename allocator_type::size_type size_type;$/;"	t	class:boost::wave::util::SmallStringOpt	access:public
size_type	wave/util/iteration_context.hpp	/^    typedef typename base_type::size_type size_type;$/;"	t	class:boost::wave::util::iteration_context_stack	access:public
skip_cppcomment	wave/whitespace_handling.hpp	/^    bool skip_cppcomment(boost::wave::token_id id)$/;"	f	class:boost::wave::context_policies::eat_whitespace	access:protected	signature:(boost::wave::token_id id)
skip_to_eol	wave/util/cpp_iterator.hpp	/^    bool skip_to_eol(ContextT &ctx, IteratorT &it, IteratorT const &end,$/;"	f	namespace:boost::wave::impl::impl	signature:(ContextT &ctx, IteratorT &it, IteratorT const &end, bool call_hook = true)
skip_to_eol_with_check	wave/util/cpp_iterator.hpp	/^    bool skip_to_eol_with_check(IteratorT &it, bool call_hook = true);$/;"	p	class:boost::wave::impl::pp_iterator_functor	access:protected	signature:(IteratorT &it, bool call_hook = true)
skip_to_eol_with_check	wave/util/cpp_iterator.hpp	/^pp_iterator_functor<ContextT>::skip_to_eol_with_check(IteratorT &it, bool call_hook)$/;"	f	class:boost::wave::impl::pp_iterator_functor	signature:(IteratorT &it, bool call_hook)
skip_to_token	wave/util/cpp_macromap_utils.hpp	/^skip_to_token(ContextT& ctx, IteratorT &it, IteratorT const &end, $/;"	f	namespace:boost::wave::util::impl	signature:(ContextT& ctx, IteratorT &it, IteratorT const &end, token_id id, bool& seen_newline)
skip_whitespace	wave/util/macro_helpers.hpp	/^    skip_whitespace(IteratorT &first, IteratorT const &last)$/;"	f	namespace:boost::wave::util::impl	signature:(IteratorT &first, IteratorT const &last)
skip_whitespace	wave/util/macro_helpers.hpp	/^    skip_whitespace(IteratorT &first, IteratorT const &last, ContainerT &queue)$/;"	f	namespace:boost::wave::util::impl	signature:(IteratorT &first, IteratorT const &last, ContainerT &queue)
skipped_newline	wave/util/cpp_iterator.hpp	/^    bool skipped_newline;           \/\/ a newline has been skipped since last one$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
skipped_token	wave/preprocessing_hooks.hpp	/^    skipped_token(ContextT const& ctx, TokenT const& token)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& token)
skipped_token	wave/preprocessing_hooks.hpp	/^    skipped_token(TokenT const& token)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(TokenT const& token)
some_part_status	wave/util/cpp_ifblock.hpp	/^   bool some_part_status;   \/\/ One of the preceding or current #if\/#elif was true$/;"	m	class:boost::wave::util::if_block	access:private
spirit	wave/util/file_position.hpp	/^namespace spirit { namespace classic {$/;"	n	namespace:boost
spirit_append_actor	wave/grammars/cpp_chlit_grammar.hpp	37;"	d
spirit_append_actor	wave/grammars/cpp_defined_grammar.hpp	27;"	d
spirit_append_actor	wave/grammars/cpp_expression_grammar.hpp	39;"	d
spirit_append_actor	wave/grammars/cpp_intlit_grammar.hpp	29;"	d
spirit_append_actor	wave/util/interpret_pragma.hpp	33;"	d
spirit_append_actor	wave/util/time_conversion_helper.hpp	24;"	d
spirit_assign_actor	wave/grammars/cpp_chlit_grammar.hpp	38;"	d
spirit_assign_actor	wave/grammars/cpp_defined_grammar.hpp	28;"	d
spirit_assign_actor	wave/grammars/cpp_expression_grammar.hpp	40;"	d
spirit_assign_actor	wave/grammars/cpp_intlit_grammar.hpp	30;"	d
spirit_assign_actor	wave/util/interpret_pragma.hpp	34;"	d
spirit_assign_actor	wave/util/time_conversion_helper.hpp	25;"	d
splice_pop_front	wave/util/cpp_macromap_utils.hpp	/^        splice_pop_front(ContainerT &list_, ContainerT &queue) $/;"	f	class:boost::wave::util::on_exit::splice_pop_front	access:public	signature:(ContainerT &list_, ContainerT &queue)
splice_pop_front	wave/util/cpp_macromap_utils.hpp	/^    class splice_pop_front {$/;"	c	namespace:boost::wave::util::on_exit
start	wave/grammars/cpp_chlit_grammar.hpp	/^        rule_t const& start() const$/;"	f	struct:boost::wave::grammars::chlit_grammar::definition	access:public	signature:() const
start	wave/grammars/cpp_defined_grammar.hpp	/^        rule_t const& start() const$/;"	f	struct:boost::wave::grammars::defined_grammar::definition	access:public	signature:() const
start	wave/grammars/cpp_expression_grammar.hpp	/^        simple_rule_t const& start() const$/;"	f	struct:boost::wave::grammars::expression_grammar::definition	access:public	signature:() const
start	wave/grammars/cpp_grammar.hpp	/^        rule_type const& start() const$/;"	f	struct:boost::wave::grammars::cpp_grammar::definition	access:public	signature:() const
start	wave/grammars/cpp_intlit_grammar.hpp	/^        rule_t const& start() const$/;"	f	struct:boost::wave::grammars::intlit_grammar::definition	access:public	signature:() const
start	wave/grammars/cpp_predef_macros_grammar.hpp	/^        rule_type const& start() const$/;"	f	struct:boost::wave::grammars::predefined_macros_grammar::definition	access:public	signature:() const
start	wave/util/time_conversion_helper.hpp	/^            start() const { return time_rule; }$/;"	f	class:boost::wave::util::time_conversion::time_conversion_grammar::definition::boost::spirit::classic	access:public	signature:() const
state	wave/cpplexer/detect_include_guards.hpp	/^    state_type include_guards::* state;$/;"	m	class:boost::wave::cpplexer::include_guards::include_guards	access:private
state	wave/whitespace_handling.hpp	/^    state_t eat_whitespace::* state;$/;"	m	class:boost::wave::context_policies::eat_whitespace::eat_whitespace	access:private
state_0	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_0, state_1, state_2, state_3, state_4, state_5;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
state_0	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_0(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
state_1	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_0, state_1, state_2, state_3, state_4, state_5;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
state_1	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_1(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
state_1a	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_1a, state_1b, state_1c, state_1d, state_1e;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
state_1a	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_1a(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
state_1b	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_1a, state_1b, state_1c, state_1d, state_1e;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
state_1b	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_1b(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
state_1c	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_1a, state_1b, state_1c, state_1d, state_1e;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
state_1c	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_1c(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
state_1d	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_1a, state_1b, state_1c, state_1d, state_1e;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
state_1d	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_1d(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
state_1e	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_1a, state_1b, state_1c, state_1d, state_1e;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
state_1e	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_1e(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
state_2	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_0, state_1, state_2, state_3, state_4, state_5;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
state_2	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_2(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
state_3	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_0, state_1, state_2, state_3, state_4, state_5;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
state_3	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_3(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
state_4	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_0, state_1, state_2, state_3, state_4, state_5;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
state_4	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_4(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
state_5	wave/cpplexer/detect_include_guards.hpp	/^    state_type state_0, state_1, state_2, state_3, state_4, state_5;$/;"	m	class:boost::wave::cpplexer::include_guards	access:private
state_5	wave/cpplexer/detect_include_guards.hpp	/^include_guards<Token>::state_5(Token& t)$/;"	f	class:boost::wave::cpplexer::include_guards	signature:(Token& t)
state_t	wave/whitespace_handling.hpp	/^    typedef bool state_t(TokenT &token, bool &skipped_newline);$/;"	t	class:boost::wave::context_policies::eat_whitespace	access:private
state_type	wave/cpplexer/detect_include_guards.hpp	/^    typedef Token& state_type(Token& t);$/;"	t	class:boost::wave::cpplexer::include_guards	access:private
static_data_c99	wave/util/cpp_macromap_predef.hpp	/^        static_macros const& static_data_c99(std::size_t i) const$/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:(std::size_t i) const
static_data_cpp	wave/util/cpp_macromap_predef.hpp	/^        static_macros const& static_data_cpp(std::size_t i) const$/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:(std::size_t i) const
static_data_cpp0x	wave/util/cpp_macromap_predef.hpp	/^        static_macros const& static_data_cpp0x(std::size_t i) const$/;"	f	class:boost::wave::util::predefined_macros	access:public	signature:(std::size_t i) const
static_macros	wave/util/cpp_macromap_predef.hpp	/^        struct static_macros {$/;"	s	class:boost::wave::util::predefined_macros	access:public
status	wave/util/cpp_ifblock.hpp	/^   bool status;             \/\/ Current block is true$/;"	m	class:boost::wave::util::if_block	access:private
storage_policy	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef boost::spirit::iterator_policies::split_std_deque storage_policy;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
store_found_directive	wave/grammars/cpp_grammar.hpp	/^        store_found_directive(TokenT &found_directive_) $/;"	f	struct:boost::wave::grammars::impl::store_found_directive	access:public	signature:(TokenT &found_directive_)
store_found_directive	wave/grammars/cpp_grammar.hpp	/^    struct store_found_directive {$/;"	s	namespace:boost::wave::grammars::impl
store_found_directive_type	wave/grammars/cpp_grammar.hpp	/^    typedef impl::store_found_directive<TokenT>     store_found_directive_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar	access:public
store_found_eof	wave/grammars/cpp_grammar.hpp	/^        store_found_eof(bool &found_eof_) : found_eof(found_eof_) {}$/;"	f	struct:boost::wave::grammars::impl::store_found_eof	access:public	signature:(bool &found_eof_)
store_found_eof	wave/grammars/cpp_grammar.hpp	/^    struct store_found_eof {$/;"	s	namespace:boost::wave::grammars::impl
store_found_eof_type	wave/grammars/cpp_grammar.hpp	/^    typedef impl::store_found_eof           store_found_eof_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar	access:public
store_found_eoltokens	wave/grammars/cpp_grammar.hpp	/^        store_found_eoltokens(ContainerT &found_eoltokens_) $/;"	f	struct:boost::wave::grammars::impl::store_found_eoltokens	access:public	signature:(ContainerT &found_eoltokens_)
store_found_eoltokens	wave/grammars/cpp_grammar.hpp	/^    struct store_found_eoltokens {$/;"	s	namespace:boost::wave::grammars::impl
store_found_eoltokens_type	wave/grammars/cpp_grammar.hpp	/^    typedef impl::store_found_eoltokens<ContainerT> store_found_eoltokens_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar	access:public
string_type	wave/cpp_context.hpp	/^    typedef typename token_type::string_type        string_type;$/;"	t	class:boost::wave::context	access:public
string_type	wave/cpplexer/cpp_lex_token.hpp	/^    typedef BOOST_WAVE_STRINGTYPE   string_type;$/;"	t	class:boost::wave::cpplexer::lex_token	access:public
string_type	wave/cpplexer/cpp_lex_token.hpp	/^    typedef StringTypeT string_type;$/;"	t	class:boost::wave::cpplexer::impl::token_data	access:public
string_type	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    typedef typename token_type::string_type  string_type;$/;"	t	class:boost::wave::cpplexer::re2clex::lexer	access:public
string_type	wave/util/cpp_iterator.hpp	/^    typedef typename result_type::string_type           string_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
string_type	wave/util/cpp_macromap.hpp	/^    typedef typename token_type::string_type        string_type;$/;"	t	class:boost::wave::util::macromap	access:private
string_type	wave/util/cpp_macromap_predef.hpp	/^        typedef BOOST_WAVE_STRINGTYPE string_type;$/;"	t	class:boost::wave::util::predefined_macros	access:private
string_type	wave/util/file_position.hpp	/^    typedef StringT string_type;$/;"	t	struct:boost::wave::util::file_position	access:public
sub_int_lit	wave/grammars/cpp_intlit_grammar.hpp	/^        boost::spirit::classic::subrule<0> sub_int_lit;$/;"	m	struct:boost::wave::grammars::intlit_grammar::definition	access:public
substr	wave/util/flex_string.hpp	/^    flex_string substr(size_type pos = 0, size_type n = npos) const$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(size_type pos = 0, size_type n = npos) const
support_c99	wave/language_support.hpp	/^    support_c99 = support_option_variadics | support_option_long_long | 0x08,$/;"	e	enum:boost::wave::language_support
support_cpp	wave/language_support.hpp	/^    support_cpp = support_normal,$/;"	e	enum:boost::wave::language_support
support_cpp0x	wave/language_support.hpp	/^    support_cpp0x = support_option_variadics | support_option_long_long | 0x10,$/;"	e	enum:boost::wave::language_support
support_cpp11	wave/language_support.hpp	/^    support_cpp11 = support_cpp0x,$/;"	e	enum:boost::wave::language_support
support_normal	wave/language_support.hpp	/^    support_normal = 0x01,$/;"	e	enum:boost::wave::language_support
support_option_convert_trigraphs	wave/language_support.hpp	/^    support_option_convert_trigraphs = 0x0400,$/;"	e	enum:boost::wave::language_support
support_option_emit_contnewlines	wave/language_support.hpp	/^    support_option_emit_contnewlines = 0x0040,$/;"	e	enum:boost::wave::language_support
support_option_emit_line_directives	wave/language_support.hpp	/^    support_option_emit_line_directives = 0x2000,$/;"	e	enum:boost::wave::language_support
support_option_emit_pragma_directives	wave/language_support.hpp	/^    support_option_emit_pragma_directives = 0x8000$/;"	e	enum:boost::wave::language_support
support_option_include_guard_detection	wave/language_support.hpp	/^    support_option_include_guard_detection = 0x4000,$/;"	e	enum:boost::wave::language_support
support_option_insert_whitespace	wave/language_support.hpp	/^    support_option_insert_whitespace = 0x0080,$/;"	e	enum:boost::wave::language_support
support_option_long_long	wave/language_support.hpp	/^    support_option_long_long = 0x02,$/;"	e	enum:boost::wave::language_support
support_option_mask	wave/language_support.hpp	/^    support_option_mask = 0xFFC0,$/;"	e	enum:boost::wave::language_support
support_option_no_character_validation	wave/language_support.hpp	/^    support_option_no_character_validation = 0x0200,$/;"	e	enum:boost::wave::language_support
support_option_prefer_pp_numbers	wave/language_support.hpp	/^    support_option_prefer_pp_numbers = 0x1000,$/;"	e	enum:boost::wave::language_support
support_option_preserve_comments	wave/language_support.hpp	/^    support_option_preserve_comments = 0x0100,$/;"	e	enum:boost::wave::language_support
support_option_single_line	wave/language_support.hpp	/^    support_option_single_line = 0x0800,$/;"	e	enum:boost::wave::language_support
support_option_variadics	wave/language_support.hpp	/^    support_option_variadics = 0x04,$/;"	e	enum:boost::wave::language_support
swap	wave/util/flex_string.hpp	/^    void swap(AllocatorStringStorage& rhs)$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:(AllocatorStringStorage& rhs)
swap	wave/util/flex_string.hpp	/^    void swap(CowString& rhs)$/;"	f	class:boost::wave::util::CowString	access:public	signature:(CowString& rhs)
swap	wave/util/flex_string.hpp	/^    void swap(SimpleStringStorage& rhs)$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:(SimpleStringStorage& rhs)
swap	wave/util/flex_string.hpp	/^    void swap(SmallStringOpt& rhs)$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:(SmallStringOpt& rhs)
swap	wave/util/flex_string.hpp	/^    void swap(VectorStringStorage& rhs)$/;"	f	class:boost::wave::util::VectorStringStorage	access:public	signature:(VectorStringStorage& rhs)
swap	wave/util/flex_string.hpp	/^    void swap(flex_string& rhs)$/;"	f	class:boost::wave::util::flex_string	access:public	signature:(flex_string& rhs)
swap	wave/util/flex_string.hpp	/^void swap(flex_string<E, T, A, S>& lhs, flex_string<E, T, A, S>& rhs)$/;"	f	namespace:boost::wave::util	signature:(flex_string<E, T, A, S>& lhs, flex_string<E, T, A, S>& rhs)
swap	wave/util/functor_input.hpp	/^        void swap(inner &x)$/;"	f	class:boost::wave::util::functor_input::inner	access:protected	signature:(inner &x)
symbol_table	wave/util/symbol_table.hpp	/^    symbol_table(long uid_ = 0) $/;"	f	struct:boost::wave::util::symbol_table	access:public	signature:(long uid_ = 0)
symbol_table	wave/util/symbol_table.hpp	/^struct symbol_table $/;"	s	namespace:boost::wave::util	inherits:std::map
system_header	wave/cpp_iteration_context.hpp	/^        system_header,  \/\/ ... a header file included used #include  <>$/;"	e	enum:boost::wave::base_iteration_context::file_type
system_include_paths	wave/util/cpp_include_paths.hpp	/^    include_list_type system_include_paths;$/;"	m	class:boost::wave::util::include_paths	access:private
tabulation	wave/util/file_position.hpp	/^        void tabulation(boost::wave::util::file_position_type &pos)   $/;"	f	class:boost::spirit::classic::position_policy	access:public	signature:(boost::wave::util::file_position_type &pos)
tag	wave/cpp_context.hpp	/^    typedef mpl::integral_c_tag tag;$/;"	t	struct:boost::serialization::tracking_level	access:public
tag	wave/cpp_context.hpp	/^    typedef mpl::integral_c_tag tag;$/;"	t	struct:boost::serialization::version	access:public
tag	wave/util/cpp_macromap.hpp	/^    typedef mpl::integral_c_tag tag;$/;"	t	struct:boost::serialization::version	access:public
tag	wave/util/flex_string.hpp	/^    typedef mpl::integral_c_tag tag;$/;"	t	struct:boost::serialization::implementation_level	access:public
tag_aq_queuetype	wave/cpplexer/re2clex/aq.hpp	/^typedef struct tag_aq_queuetype$/;"	s	namespace:boost::wave::cpplexer::re2clex
tail	wave/cpplexer/re2clex/aq.hpp	/^    std::size_t tail;$/;"	m	struct:boost::wave::cpplexer::re2clex::tag_aq_queuetype	access:public
target_iterator_type	wave/cpp_context.hpp	/^    typedef IteratorT                               target_iterator_type;$/;"	t	class:boost::wave::context	access:public
target_type	wave/cpp_context.hpp	/^        target_type;$/;"	t	struct:boost::serialization::version	access:public
target_type	wave/util/cpp_macromap.hpp	/^    typedef boost::wave::util::macromap<ContextT> target_type;$/;"	t	struct:boost::serialization::version	access:public
target_value	wave/util/cpp_macromap_utils.hpp	/^        TypeT &target_value;$/;"	m	class:boost::wave::util::on_exit::reset	access:private
temp1	wave/util/flex_string.hpp	/^  enum { temp1 = threshold * sizeof(value_type) > sizeof(Storage) $/;"	e	enum:boost::wave::util::SmallStringOpt::__anon1
temp2	wave/util/flex_string.hpp	/^    enum { temp2 = temp1 > sizeof(Align) ? temp1 : sizeof(Align) };$/;"	e	enum:boost::wave::util::SmallStringOpt::__anon2
test	wave/util/pattern_parser.hpp	/^        bool test(T pattern_) const$/;"	f	struct:boost::wave::util::pattern_and	access:public	signature:(T pattern_) const
test_configuration	wave/wave_config_constant.hpp	/^    BOOST_WAVE_DECL bool test_configuration(unsigned int config, $/;"	p	namespace:boost::wave	signature:(unsigned int config, char const* pragma_keyword, char const* string_type)
this_	wave/cpp_context.hpp	/^    context *this_() { return this; }           \/\/ avoid warning in constructor$/;"	f	class:boost::wave::context	access:private	signature:()
this_t	wave/grammars/cpp_grammar.hpp	/^        typedef flush_underlying_parser this_t;$/;"	t	struct:boost::wave::grammars::impl::flush_underlying_parser	access:public
this_type	wave/cpp_context.hpp	/^struct this_type {};$/;"	s	namespace:boost::wave
throw_	wave/cpp_throw.hpp	/^    void throw_(Context& ctx, typename Exception::error_code code, $/;"	f	namespace:boost::wave::util	signature:(Context& ctx, typename Exception::error_code code, S1 msg, Pos const& pos)
throw_	wave/cpp_throw.hpp	/^    void throw_(Context& ctx, typename Exception::error_code code, $/;"	f	namespace:boost::wave::util	signature:(Context& ctx, typename Exception::error_code code, S1 msg, Pos const& pos, S2 name)
throw_	wave/cpp_throw.hpp	/^    void throw_(typename Exception::error_code code, S1 msg, Pos const& pos)$/;"	f	namespace:boost::wave::util	signature:(typename Exception::error_code code, S1 msg, Pos const& pos)
throw_	wave/cpp_throw.hpp	/^    void throw_(typename Exception::error_code code, S1 msg, Pos const& pos, $/;"	f	namespace:boost::wave::util	signature:(typename Exception::error_code code, S1 msg, Pos const& pos, S2 name)
throw_exception	wave/preprocessing_hooks.hpp	/^    throw_exception(ContextT const& ctx, ExceptionT const& e)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, ExceptionT const& e)
time_conversion	wave/util/time_conversion_helper.hpp	/^namespace time_conversion {$/;"	n	namespace:boost::wave::util
time_conversion_grammar	wave/util/time_conversion_helper.hpp	/^        time_conversion_grammar() : fYearIsCorrected(false)$/;"	f	class:boost::wave::util::time_conversion::time_conversion_grammar	access:public	signature:()
time_conversion_grammar	wave/util/time_conversion_helper.hpp	/^    class time_conversion_grammar :$/;"	c	namespace:boost::wave::util::time_conversion	inherits:boost::spirit::classic::grammar
time_conversion_helper	wave/util/time_conversion_helper.hpp	/^        time_conversion_helper(char const *act_time) : compile_time(0)$/;"	f	class:boost::wave::util::time_conversion::time_conversion_helper	access:public	signature:(char const *act_time)
time_conversion_helper	wave/util/time_conversion_helper.hpp	/^    class time_conversion_helper$/;"	c	namespace:boost::wave::util::time_conversion
time_rule	wave/util/time_conversion_helper.hpp	/^            boost::spirit::classic::rule<ScannerT> time_rule;$/;"	m	struct:boost::wave::util::time_conversion::time_conversion_grammar::definition	access:public
time_stamp	wave/util/time_conversion_helper.hpp	/^        mutable tm time_stamp;$/;"	m	class:boost::wave::util::time_conversion::time_conversion_grammar	access:public
timestr_	wave/util/cpp_macromap_predef.hpp	/^        string_type timestr_;     \/\/ __TIME__$/;"	m	class:boost::wave::util::predefined_macros	access:private
to	wave/util/cpp_include_paths.hpp	/^struct to {};$/;"	s	namespace:boost::wave::util
to_bool	wave/grammars/cpp_expression_grammar.hpp	/^    phoenix::function<operator_to_bool> const to_bool;$/;"	m	class:boost::wave::grammars::impl::phoenix
to_string	wave/util/cpp_macromap_utils.hpp	/^to_string(Src const& src)$/;"	f	namespace:boost::wave::util	signature:(Src const& src)
to_string_helper	wave/util/cpp_macromap_utils.hpp	/^struct to_string_helper$/;"	s	namespace:boost::wave::util::impl
to_string_helper	wave/util/cpp_macromap_utils.hpp	/^struct to_string_helper<Src, Src>$/;"	s	namespace:boost::wave::util::impl
to_string_helper	wave/util/cpp_macromap_utils.hpp	/^struct to_string_helper<Target, char const*>$/;"	s	namespace:boost::wave::util::impl
tok	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* tok;     \/* points to the beginning of the current token *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
tok_names	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    static char const *tok_names[];$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
token_cache	wave/cpplexer/token_cache.hpp	/^    token_cache()$/;"	f	class:boost::wave::cpplexer::token_cache	access:public	signature:()
token_cache	wave/cpplexer/token_cache.hpp	/^class token_cache $/;"	c	namespace:boost::wave::cpplexer
token_category	wave/token_ids.hpp	/^enum token_category {$/;"	g	namespace:boost::wave
token_container_type	wave/grammars/cpp_grammar_gen.hpp	/^    typedef TokenContainerT                       token_container_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar_gen	access:public
token_data	wave/cpplexer/cpp_lex_token.hpp	/^    explicit token_data(int)$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(int)
token_data	wave/cpplexer/cpp_lex_token.hpp	/^    token_data()$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:()
token_data	wave/cpplexer/cpp_lex_token.hpp	/^    token_data(token_data const& rhs)$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(token_data const& rhs)
token_data	wave/cpplexer/cpp_lex_token.hpp	/^    token_data(token_id id_, string_type const &value_, position_type const &pos_)$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:(token_id id_, string_type const &value_, position_type const &pos_)
token_data	wave/cpplexer/cpp_lex_token.hpp	/^class token_data$/;"	c	namespace:boost::wave::cpplexer::impl
token_data_tag	wave/cpplexer/cpp_lex_token.hpp	/^struct token_data_tag {};$/;"	s	namespace:boost::wave::cpplexer::impl
token_equals	wave/util/cpp_macromap_utils.hpp	/^token_equals(TokenT const &left, TokenT const &right)$/;"	f	namespace:boost::wave::util::impl	signature:(TokenT const &left, TokenT const &right)
token_id	wave/token_ids.hpp	/^enum token_id {$/;"	g	namespace:boost::wave
token_id	wave/util/cpp_macromap_predef.hpp	/^            boost::wave::token_id token_id;$/;"	m	struct:boost::wave::util::predefined_macros::dynamic_macros	access:public
token_id	wave/util/cpp_macromap_predef.hpp	/^            boost::wave::token_id token_id;$/;"	m	struct:boost::wave::util::predefined_macros::static_macros	access:public
token_is_valid	wave/cpplexer/cpp_lex_token.hpp	/^token_is_valid(lex_token<Position> const& t)$/;"	f	namespace:boost::wave::cpplexer	signature:(lex_token<Position> const& t)
token_sequence_type	wave/cpp_context.hpp	/^        token_sequence_type;$/;"	t	class:boost::wave::context	access:public
token_sequence_type	wave/grammars/cpp_defined_grammar_gen.hpp	/^        token_sequence_type;$/;"	t	struct:boost::wave::grammars::defined_grammar_gen	access:public
token_sequence_type	wave/grammars/cpp_expression_grammar_gen.hpp	/^        token_sequence_type;$/;"	t	struct:boost::wave::grammars::expression_grammar_gen	access:public
token_sequence_type	wave/util/cpp_iterator.hpp	/^    typedef typename ContextT::token_sequence_type      token_sequence_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
token_type	wave/cpp_context.hpp	/^    typedef typename LexIteratorT::token_type       token_type;$/;"	t	class:boost::wave::context	access:public
token_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef TokenT token_type;$/;"	t	class:boost::wave::cpplexer::lex_iterator	access:public
token_type	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    typedef TokenT token_type;$/;"	t	class:boost::wave::cpplexer::re2clex::lex_functor	access:public
token_type	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    typedef TokenT token_type;$/;"	t	class:boost::wave::cpplexer::re2clex::lexer	access:public
token_type	wave/grammars/cpp_defined_grammar_gen.hpp	/^    typedef typename LexIteratorT::token_type token_type;$/;"	t	struct:boost::wave::grammars::defined_grammar_gen	access:public
token_type	wave/grammars/cpp_expression_grammar_gen.hpp	/^    typedef TokenT token_type;$/;"	t	struct:boost::wave::grammars::expression_grammar_gen	access:public
token_type	wave/grammars/cpp_grammar_gen.hpp	/^    typedef typename LexIteratorT::token_type     token_type;$/;"	t	struct:boost::wave::grammars::cpp_grammar_gen	access:public
token_type	wave/util/cpp_macromap.hpp	/^    typedef typename ContextT::token_type           token_type;$/;"	t	class:boost::wave::util::macromap	access:private
too_few_macroarguments	wave/cpp_exceptions.hpp	/^        too_few_macroarguments,$/;"	e	enum:boost::wave::preprocess_exception::error_code
too_many_macroarguments	wave/cpp_exceptions.hpp	/^        too_many_macroarguments,$/;"	e	enum:boost::wave::preprocess_exception::error_code
top	wave/cpplexer/re2clex/scanner.hpp	/^    uchar* top;     \/* top of the current buffer *\/$/;"	m	struct:boost::wave::cpplexer::re2clex::Scanner	access:public
top	wave/util/iteration_context.hpp	/^    typename base_type::value_type &top() { return iter_ctx.top(); }$/;"	f	class:boost::wave::util::iteration_context_stack	access:public	signature:()
tracking_level	wave/cpp_context.hpp	/^struct tracking_level<boost::wave::context<Iterator, LexIterator, InputPolicy, Hooks> >$/;"	s	namespace:boost::serialization
traits_type	wave/util/flex_string.hpp	/^    typedef T traits_type;$/;"	t	class:boost::wave::util::flex_string	access:public
transform	wave/util/transform_iterator.hpp	/^        transform (argument_type node) $/;"	f	struct:boost::wave::impl::get_token_value	access:public	signature:(argument_type node)
tree_parse_info_type	wave/util/cpp_iterator.hpp	/^        tree_parse_info_type;$/;"	t	class:boost::wave::impl::pp_iterator_functor	access:private
trim_replacement_list	wave/util/cpp_macromap_utils.hpp	/^trim_replacement_list (ContainerT &replacement_list)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT &replacement_list)
trim_sequence	wave/util/cpp_macromap_utils.hpp	/^trim_sequence (ContainerT &argument)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT &argument)
trim_sequence_left	wave/util/cpp_macromap_utils.hpp	/^trim_sequence_left (ContainerT &argument)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT &argument)
trim_sequence_right	wave/util/cpp_macromap_utils.hpp	/^trim_sequence_right (ContainerT &argument)$/;"	f	namespace:boost::wave::util::impl	signature:(ContainerT &argument)
trim_whitespace	wave/util/cpp_iterator.hpp	/^    trim_whitespace(StringT const &s)$/;"	f	namespace:boost::wave::impl::impl	signature:(StringT const &s)
type	wave/cpp_context.hpp	/^    typedef mpl::int_<target_type::version> type;$/;"	t	struct:boost::serialization::version	access:public
type	wave/cpp_context.hpp	/^    typedef mpl::int_<track_never> type;$/;"	t	struct:boost::serialization::tracking_level	access:public
type	wave/cpp_iteration_context.hpp	/^    file_type type;             \/\/ the type of the handled file$/;"	m	struct:boost::wave::base_iteration_context	access:public
type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef boost::spirit::multi_pass<functor_data_type, policy_type> type;$/;"	t	struct:boost::wave::cpplexer::make_multi_pass	access:public
type	wave/grammars/cpp_chlit_grammar.hpp	/^            typedef void type; $/;"	t	struct:boost::wave::grammars::impl::compose_character_literal::result	access:public
type	wave/grammars/cpp_expression_grammar.hpp	/^            typedef bool type; $/;"	t	struct:boost::wave::grammars::impl::operator_as_bool::result	access:public
type	wave/grammars/cpp_expression_grammar.hpp	/^            typedef boost::wave::grammars::closures::closure_value type; $/;"	t	struct:boost::wave::grammars::impl::convert_chlit::result	access:public
type	wave/grammars/cpp_expression_grammar.hpp	/^            typedef boost::wave::grammars::closures::closure_value type; $/;"	t	struct:boost::wave::grammars::impl::convert_intlit::result	access:public
type	wave/grammars/cpp_expression_grammar.hpp	/^            typedef boost::wave::grammars::closures::closure_value type; $/;"	t	struct:boost::wave::grammars::impl::operator_questionmark::result	access:public
type	wave/grammars/cpp_expression_grammar.hpp	/^            typedef boost::wave::grammars::closures::closure_value type; $/;"	t	struct:boost::wave::grammars::impl::operator_to_bool::result	access:public
type	wave/grammars/cpp_expression_value.hpp	/^    value_type type;$/;"	m	class:boost::wave::grammars::closures::closure_value	access:private
type	wave/util/cpp_include_paths.hpp	/^    > type;$/;"	t	struct:boost::wave::util::bidirectional_map	access:public
type	wave/util/cpp_include_paths.hpp	/^  > type;$/;"	t	struct:boost::wave::util::bidirectional_map	access:public
type	wave/util/cpp_macromap.hpp	/^    typedef mpl::int_<target_type::version> type;$/;"	t	struct:boost::serialization::version	access:public
type	wave/util/cpp_macromap_utils.hpp	/^    typedef Src const& type;$/;"	t	struct:boost::wave::util::impl::to_string_helper	access:public
type	wave/util/cpp_macromap_utils.hpp	/^    typedef Target type;$/;"	t	struct:boost::wave::util::impl::to_string_helper	access:public
type	wave/util/flex_string.hpp	/^    typedef mpl::int_<boost::serialization::primitive_type> type;$/;"	t	struct:boost::serialization::implementation_level	access:public
type	wave/util/transform_iterator.hpp	/^            type;$/;"	t	class:boost::wave::impl::ref_transform_iterator_generator	access:public
uchar	wave/cpplexer/re2clex/scanner.hpp	/^typedef unsigned char uchar;$/;"	t	namespace:boost::wave::cpplexer::re2clex
ui	wave/grammars/cpp_expression_value.hpp	/^        uint_literal_type ui;$/;"	m	union:boost::wave::grammars::closures::closure_value::__anon7	access:public
uid	wave/util/macro_definition.hpp	/^    long uid;                               \/\/ unique id of this macro$/;"	m	struct:boost::wave::util::macro_definition	access:public
uint_literal_type	wave/wave_config.hpp	/^    typedef boost::ulong_long_type uint_literal_type;$/;"	t	namespace:boost::wave
uit	wave/util/cpp_macromap_utils.hpp	/^        IteratorT const &uit;$/;"	m	class:boost::wave::util::on_exit::assign	access:private
uit	wave/util/cpp_macromap_utils.hpp	/^        UnputIteratorT const &uit;$/;"	m	class:boost::wave::util::on_exit::assign	access:private
unary_exp	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t unary_exp, primary_exp, constant;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
unary_exp_nocalc	wave/grammars/cpp_expression_grammar.hpp	/^        rule_t unary_exp_nocalc, primary_exp_nocalc, constant_nocalc;$/;"	m	struct:boost::wave::grammars::expression_grammar::definition	access:public
unary_functor	wave/util/symbol_table.hpp	/^    typedef get_first<StringT> unary_functor;$/;"	t	struct:boost::wave::util::symbol_table	access:private
unbalanced_if_endif	wave/cpp_exceptions.hpp	/^        unbalanced_if_endif,$/;"	e	enum:boost::wave::preprocess_exception::error_code
undefine	wave/grammars/cpp_grammar.hpp	/^        rule_type undefine;$/;"	m	struct:boost::wave::grammars::cpp_grammar::definition	access:public
undefined_macro	wave/preprocessing_hooks.hpp	/^    undefined_macro(ContextT const& ctx, TokenT const& macro_name)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(ContextT const& ctx, TokenT const& macro_name)
undefined_macro	wave/preprocessing_hooks.hpp	/^    undefined_macro(TokenT const& macro_name)$/;"	f	struct:boost::wave::context_policies::default_preprocessing_hooks	access:public	signature:(TokenT const& macro_name)
undefined_macroname	wave/cpp_exceptions.hpp	/^        undefined_macroname,$/;"	e	enum:boost::wave::preprocess_exception::error_code
unescape_lit	wave/util/macro_helpers.hpp	/^    unescape_lit(StringT const &value)$/;"	f	namespace:boost::wave::util::impl	signature:(StringT const &value)
unexpected_error	wave/cpp_exceptions.hpp	/^        unexpected_error,$/;"	e	enum:boost::wave::preprocess_exception::error_code
unexpected_error	wave/cpplexer/cpplexer_exceptions.hpp	/^        unexpected_error = 0,$/;"	e	enum:boost::wave::cpplexer::lexing_exception::error_code
unexpected_qualified_name	wave/cpp_exceptions.hpp	/^        unexpected_qualified_name,$/;"	e	enum:boost::wave::preprocess_exception::error_code
unique	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef lex_iterator_functor_shim unique;$/;"	t	class:boost::wave::cpplexer::impl::lex_iterator_functor_shim	access:public
unique_functor_type	wave/cpplexer/cpp_lex_iterator.hpp	/^    typedef typename input_policy_type::unique unique_functor_type;$/;"	t	class:boost::wave::cpplexer::lex_iterator	access:private
universal_char_base_charset	wave/cpplexer/cpplexer_exceptions.hpp	/^        universal_char_base_charset = 2,$/;"	e	enum:boost::wave::cpplexer::lexing_exception::error_code
universal_char_invalid	wave/cpplexer/cpplexer_exceptions.hpp	/^        universal_char_invalid = 1,$/;"	e	enum:boost::wave::cpplexer::lexing_exception::error_code
universal_char_not_allowed	wave/cpplexer/cpplexer_exceptions.hpp	/^        universal_char_not_allowed = 3,$/;"	e	enum:boost::wave::cpplexer::lexing_exception::error_code
universal_char_type	wave/cpplexer/validate_universal_char.hpp	/^enum universal_char_type {$/;"	g	namespace:boost::wave::cpplexer::impl
universal_char_type_base_charset	wave/cpplexer/validate_universal_char.hpp	/^    universal_char_type_base_charset = 2,$/;"	e	enum:boost::wave::cpplexer::impl::universal_char_type
universal_char_type_invalid	wave/cpplexer/validate_universal_char.hpp	/^    universal_char_type_invalid = 1,$/;"	e	enum:boost::wave::cpplexer::impl::universal_char_type
universal_char_type_not_allowed_for_identifiers	wave/cpplexer/validate_universal_char.hpp	/^    universal_char_type_not_allowed_for_identifiers = 3$/;"	e	enum:boost::wave::cpplexer::impl::universal_char_type
universal_char_type_valid	wave/cpplexer/validate_universal_char.hpp	/^    universal_char_type_valid = 0,$/;"	e	enum:boost::wave::cpplexer::impl::universal_char_type
unput_queue	wave/util/cpp_iterator.hpp	/^    token_sequence_type unput_queue;     \/\/ tokens to be preprocessed again$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
unput_queue	wave/util/unput_queue_iterator.hpp	/^    ContainerT &unput_queue;$/;"	m	class:boost::wave::util::unput_queue_iterator	access:private
unput_queue_iterator	wave/util/unput_queue_iterator.hpp	/^    unput_queue_iterator(IteratorT const &it, ContainerT &queue)$/;"	f	class:boost::wave::util::unput_queue_iterator	access:public	signature:(IteratorT const &it, ContainerT &queue)
unput_queue_iterator	wave/util/unput_queue_iterator.hpp	/^class unput_queue_iterator $/;"	c	namespace:boost::wave::util	inherits:boost::iterator_adaptor
use_count	wave/util/macro_definition.hpp	/^    boost::detail::atomic_count use_count;$/;"	m	struct:boost::wave::util::macro_definition	access:public
user_header	wave/cpp_iteration_context.hpp	/^        user_header     \/\/ ... a header file included using #include ""$/;"	e	enum:boost::wave::base_iteration_context::file_type
user_include_paths	wave/util/cpp_include_paths.hpp	/^    include_list_type user_include_paths;$/;"	m	class:boost::wave::util::include_paths	access:private
util	wave/cpp_exceptions.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/cpp_throw.hpp	/^namespace boost { namespace wave { namespace util$/;"	n	namespace:boost::wave
util	wave/cpplexer/cpplexer_exceptions.hpp	/^namespace util {$/;"	n	namespace:boost::wave::cpplexer
util	wave/util/cpp_ifblock.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/util/cpp_include_paths.hpp	/^namespace boost { namespace wave { namespace util {$/;"	n	namespace:boost::wave
util	wave/util/cpp_iterator.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/util/cpp_macromap.hpp	/^namespace boost { namespace wave { namespace util {$/;"	n	namespace:boost::wave
util	wave/util/cpp_macromap_predef.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/util/cpp_macromap_utils.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/util/file_position.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/util/filesystem_compatibility.hpp	/^namespace boost { namespace wave { namespace util$/;"	n	namespace:boost::wave
util	wave/util/flex_string.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/util/functor_input.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/util/insert_whitespace_detection.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/util/interpret_pragma.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/util/iteration_context.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/util/macro_definition.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/util/macro_helpers.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/util/pattern_parser.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/util/symbol_table.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/util/time_conversion_helper.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/util/unput_queue_iterator.hpp	/^namespace util {$/;"	n	namespace:boost::wave
util	wave/whitespace_handling.hpp	/^namespace util {$/;"	n	namespace:boost::wave::context_policies
val	wave/grammars/cpp_expression_grammar.hpp	/^        member1 val;$/;"	m	struct:boost::wave::grammars::closures::cpp_expr_closure	access:public
val	wave/grammars/cpp_intlit_grammar.hpp	/^        member1 val;$/;"	m	struct:boost::wave::grammars::closures::intlit_closure	access:public
valid	wave/grammars/cpp_expression_value.hpp	/^    value_error valid;$/;"	m	class:boost::wave::grammars::closures::closure_value	access:private
validate_identifier_name	wave/cpplexer/validate_universal_char.hpp	/^validate_identifier_name (StringT const &name, std::size_t line, $/;"	f	namespace:boost::wave::cpplexer::impl	signature:(StringT const &name, std::size_t line, std::size_t column, StringT const &file_name)
validate_literal	wave/cpplexer/validate_universal_char.hpp	/^validate_literal (StringT const &name, std::size_t line, std::size_t column,$/;"	f	namespace:boost::wave::cpplexer::impl	signature:(StringT const &name, std::size_t line, std::size_t column, StringT const &file_name)
value	wave/cpplexer/cpp_lex_token.hpp	/^    string_type value;          \/\/ the text, which was parsed into this token$/;"	m	class:boost::wave::cpplexer::impl::token_data	access:private
value	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    string_type value;$/;"	m	class:boost::wave::cpplexer::re2clex::lexer	access:private
value	wave/grammars/cpp_chlit_grammar.hpp	/^        member1 value;$/;"	m	struct:boost::wave::grammars::closures::chlit_closure	access:public
value	wave/grammars/cpp_expression_value.hpp	/^    } value;$/;"	m	class:boost::wave::grammars::closures::closure_value	typeref:union:boost::wave::grammars::closures::closure_value::__anon7	access:private
value	wave/util/cpp_macromap_predef.hpp	/^            char const *value;$/;"	m	struct:boost::wave::util::predefined_macros::static_macros	access:public
value_error	wave/grammars/cpp_value_error.hpp	/^enum value_error {$/;"	g	namespace:boost::wave::grammars
value_type	wave/grammars/cpp_expression_value.hpp	/^    enum value_type {$/;"	g	class:boost::wave::grammars::closures::closure_value	access:public
value_type	wave/util/cpp_include_paths.hpp	/^    typedef std::pair<FromType, ToType> value_type;$/;"	t	struct:boost::wave::util::bidirectional_map	access:public
value_type	wave/util/flex_string.hpp	/^    typedef E value_type;$/;"	t	class:boost::wave::util::AllocatorStringStorage	access:public
value_type	wave/util/flex_string.hpp	/^    typedef E value_type;$/;"	t	class:boost::wave::util::CowString	access:public
value_type	wave/util/flex_string.hpp	/^    typedef E value_type;$/;"	t	class:boost::wave::util::SimpleStringStorage	access:public
value_type	wave/util/flex_string.hpp	/^    typedef E value_type;$/;"	t	class:boost::wave::util::VectorStringStorage	access:public
value_type	wave/util/flex_string.hpp	/^    typedef T                 value_type;$/;"	t	class:boost::wave::util::mallocator	access:public
value_type	wave/util/flex_string.hpp	/^    typedef typename Storage::value_type value_type;$/;"	t	class:boost::wave::util::SmallStringOpt	access:public
value_type	wave/util/flex_string.hpp	/^    typedef typename traits_type::char_type value_type;$/;"	t	class:boost::wave::util::flex_string	access:public
value_type	wave/util/flex_string.hpp	/^  typedef void        value_type;$/;"	t	class:boost::wave::util::mallocator	access:private
value_type	wave/util/functor_input.hpp	/^        typedef result_type value_type;$/;"	t	class:boost::wave::util::functor_input::inner	access:public
version	wave/cpp_context.hpp	/^struct version<boost::wave::context<Iterator, LexIterator, InputPolicy, Hooks> >$/;"	s	namespace:boost::serialization
version	wave/util/cpp_macromap.hpp	/^struct version<boost::wave::util::macromap<ContextT> >$/;"	s	namespace:boost::serialization
version_	wave/util/cpp_macromap_predef.hpp	/^        string_type version_;     \/\/ __SPIRIT_PP_VERSION__\/__WAVE_VERSION__$/;"	m	class:boost::wave::util::predefined_macros	access:private
versionstr_	wave/util/cpp_macromap_predef.hpp	/^        string_type versionstr_;  \/\/ __SPIRIT_PP_VERSION_STR__\/__WAVE_VERSION_STR__$/;"	m	class:boost::wave::util::predefined_macros	access:private
warning_directive	wave/cpp_exceptions.hpp	/^        warning_directive,$/;"	e	enum:boost::wave::preprocess_exception::error_code
was_initialized	wave/util/functor_input.hpp	/^            bool was_initialized;$/;"	m	struct:boost::wave::util::functor_input::inner::Data	access:public
was_sys_include_path	wave/util/cpp_include_paths.hpp	/^    bool was_sys_include_path;          \/\/ saw a set_sys_include_delimiter()$/;"	m	class:boost::wave::util::include_paths	access:private
wave	wave/cpp_context.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/cpp_exceptions.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/cpp_iteration_context.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/cpp_throw.hpp	/^namespace boost { namespace wave { namespace util$/;"	n	namespace:boost
wave	wave/cpplexer/convert_trigraphs.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/cpplexer/cpp_lex_interface.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/cpplexer/cpp_lex_interface_generator.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/cpplexer/cpp_lex_iterator.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/cpplexer/cpp_lex_token.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/cpplexer/cpplexer_exceptions.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/cpplexer/detect_include_guards.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/cpplexer/re2clex/aq.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/cpplexer/re2clex/cpp_re.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/cpplexer/re2clex/scanner.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/cpplexer/token_cache.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/cpplexer/validate_universal_char.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/grammars/cpp_chlit_grammar.hpp	/^namespace wave { $/;"	n	namespace:boost
wave	wave/grammars/cpp_defined_grammar.hpp	/^namespace wave { $/;"	n	namespace:boost
wave	wave/grammars/cpp_defined_grammar_gen.hpp	/^namespace wave { $/;"	n	namespace:boost
wave	wave/grammars/cpp_expression_grammar.hpp	/^namespace wave { $/;"	n	namespace:boost
wave	wave/grammars/cpp_expression_grammar_gen.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/grammars/cpp_expression_value.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/grammars/cpp_grammar.hpp	/^namespace wave { $/;"	n	namespace:boost
wave	wave/grammars/cpp_grammar_gen.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/grammars/cpp_intlit_grammar.hpp	/^namespace wave { $/;"	n	namespace:boost
wave	wave/grammars/cpp_literal_grammar_gen.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/grammars/cpp_predef_macros_gen.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/grammars/cpp_predef_macros_grammar.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/grammars/cpp_value_error.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/language_support.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/preprocessing_hooks.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/token_ids.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/cpp_ifblock.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/cpp_include_paths.hpp	/^namespace boost { namespace wave { namespace util {$/;"	n	namespace:boost
wave	wave/util/cpp_iterator.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/cpp_macromap.hpp	/^namespace boost { namespace wave { namespace util {$/;"	n	namespace:boost
wave	wave/util/cpp_macromap_predef.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/cpp_macromap_utils.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/file_position.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/filesystem_compatibility.hpp	/^namespace boost { namespace wave { namespace util$/;"	n	namespace:boost
wave	wave/util/flex_string.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/functor_input.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/insert_whitespace_detection.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/interpret_pragma.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/iteration_context.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/macro_definition.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/macro_helpers.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/pattern_parser.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/symbol_table.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/time_conversion_helper.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/util/transform_iterator.hpp	/^namespace wave { $/;"	n	namespace:boost
wave	wave/util/unput_queue_iterator.hpp	/^namespace wave {$/;"	n	namespace:boost
wave	wave/wave_config.hpp	/^namespace boost { namespace wave $/;"	n	namespace:boost
wave	wave/wave_config_constant.hpp	/^namespace boost { namespace wave {$/;"	n	namespace:boost
wave	wave/whitespace_handling.hpp	/^namespace wave {$/;"	n	namespace:boost
what	wave/cpp_exceptions.hpp	/^    virtual char const *what() const throw() = 0;           \/\/ to be overloaded$/;"	p	class:boost::wave::cpp_exception	access:public	signature:() const
what	wave/cpp_exceptions.hpp	/^    virtual char const *what() const throw()$/;"	f	class:boost::wave::macro_handling_exception	access:public	signature:() const
what	wave/cpp_exceptions.hpp	/^    virtual char const *what() const throw()$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:() const
what	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual char const *what() const throw() = 0;   \/\/ to be overloaded$/;"	p	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:() const
what	wave/cpplexer/cpplexer_exceptions.hpp	/^    virtual char const *what() const throw()$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:() const
whitespace	wave/util/cpp_iterator.hpp	/^    boost::wave::util::insert_whitespace_detection whitespace;$/;"	m	class:boost::wave::impl::pp_iterator_functor	access:private
whitespace	wave/whitespace_handling.hpp	/^    state_t general, newline, newline_2nd, whitespace, bol_whitespace;$/;"	m	class:boost::wave::context_policies::eat_whitespace	access:private
whitespace	wave/whitespace_handling.hpp	/^eat_whitespace<TokenT>::whitespace(TokenT &token, bool &skipped_newline) $/;"	f	class:boost::wave::context_policies::eat_whitespace	signature:(TokenT &token, bool &skipped_newline)
would_form_universal_char	wave/util/insert_whitespace_detection.hpp	/^    would_form_universal_char (StringT const &value)$/;"	f	namespace:boost::wave::util::impl	signature:(StringT const &value)
~AllocatorStringStorage	wave/util/flex_string.hpp	/^    ~AllocatorStringStorage()$/;"	f	class:boost::wave::util::AllocatorStringStorage	access:public	signature:()
~CowString	wave/util/flex_string.hpp	/^    ~CowString()$/;"	f	class:boost::wave::util::CowString	access:public	signature:()
~Invariant	wave/util/flex_string.hpp	/^        ~Invariant()$/;"	f	struct:boost::wave::util::flex_string::Invariant	access:public	signature:()
~SimpleStringStorage	wave/util/flex_string.hpp	/^    ~SimpleStringStorage()$/;"	f	class:boost::wave::util::SimpleStringStorage	access:public	signature:()
~SmallStringOpt	wave/util/flex_string.hpp	/^    ~SmallStringOpt()$/;"	f	class:boost::wave::util::SmallStringOpt	access:public	signature:()
~assign	wave/util/cpp_macromap_utils.hpp	/^        ~assign() { it = uit.base(); }$/;"	f	class:boost::wave::util::on_exit::assign	access:public	signature:()
~assign	wave/util/cpp_macromap_utils.hpp	/^        ~assign() { it = uit; }$/;"	f	class:boost::wave::util::on_exit::assign	access:public	signature:()
~cpp_exception	wave/cpp_exceptions.hpp	/^    ~cpp_exception() throw() {}$/;"	f	class:boost::wave::cpp_exception	access:public	signature:()
~cpplexer_exception	wave/cpplexer/cpplexer_exceptions.hpp	/^    ~cpplexer_exception() throw() {}$/;"	f	class:boost::wave::cpplexer::cpplexer_exception	access:public	signature:()
~flex_string	wave/util/flex_string.hpp	/^    ~flex_string()$/;"	f	class:boost::wave::util::flex_string	access:public	signature:()
~lex_functor	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    virtual ~lex_functor() {}$/;"	f	class:boost::wave::cpplexer::re2clex::lex_functor	access:public	signature:()
~lex_input_interface	wave/cpplexer/cpp_lex_interface.hpp	/^    virtual ~lex_input_interface() {}$/;"	f	struct:boost::wave::cpplexer::lex_input_interface	access:public	signature:()
~lex_input_interface_generator	wave/cpplexer/cpp_lex_interface_generator.hpp	/^    ~lex_input_interface_generator() {}$/;"	f	struct:boost::wave::cpplexer::lex_input_interface_generator	access:public	signature:()
~lex_token	wave/cpplexer/cpp_lex_token.hpp	/^    ~lex_token()$/;"	f	class:boost::wave::cpplexer::lex_token	access:public	signature:()
~lexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^    ~lexer();$/;"	p	class:boost::wave::cpplexer::re2clex::lexer	access:public	signature:()
~lexer	wave/cpplexer/re2clex/cpp_re2c_lexer.hpp	/^lexer<IteratorT, PositionT, TokenT>::~lexer()$/;"	f	class:boost::wave::cpplexer::re2clex::lexer	signature:()
~lexing_exception	wave/cpplexer/cpplexer_exceptions.hpp	/^    ~lexing_exception() throw() {}$/;"	f	class:boost::wave::cpplexer::lexing_exception	access:public	signature:()
~macro_handling_exception	wave/cpp_exceptions.hpp	/^    ~macro_handling_exception() throw() {}$/;"	f	class:boost::wave::macro_handling_exception	access:public	signature:()
~macromap	wave/util/cpp_macromap.hpp	/^    ~macromap() {}$/;"	f	class:boost::wave::util::macromap	access:public	signature:()
~mallocator	wave/util/flex_string.hpp	/^    ~mallocator() {}$/;"	f	class:boost::wave::util::mallocator	access:public	signature:()
~pop_front	wave/util/cpp_macromap_utils.hpp	/^        ~pop_front() { list.pop_front(); }$/;"	f	class:boost::wave::util::on_exit::pop_front	access:public	signature:()
~preprocess_exception	wave/cpp_exceptions.hpp	/^    ~preprocess_exception() throw() {}$/;"	f	class:boost::wave::preprocess_exception	access:public	signature:()
~reset	wave/util/cpp_macromap_utils.hpp	/^        ~reset() { target_value = old_value; }$/;"	f	class:boost::wave::util::on_exit::reset	access:public	signature:()
~splice_pop_front	wave/util/cpp_macromap_utils.hpp	/^        ~splice_pop_front() { list.pop_front(); }$/;"	f	class:boost::wave::util::on_exit::splice_pop_front	access:public	signature:()
~token_data	wave/cpplexer/cpp_lex_token.hpp	/^    ~token_data()$/;"	f	class:boost::wave::cpplexer::impl::token_data	access:public	signature:()
