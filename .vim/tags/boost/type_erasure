!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BOOST_MPL_ASSERT	type_erasure/detail/normalize.hpp	/^    BOOST_MPL_ASSERT((::boost::is_same<T, U>));$/;"	p	struct:boost::type_erasure::detail::select_pair	access:public	signature:(::boost::is_same<T, U>)
BOOST_MPL_ASSERT	type_erasure/detail/normalize.hpp	/^    BOOST_MPL_ASSERT((boost::is_same<typename ::boost::mpl::at<type, typename P::second>::type, result>));$/;"	p	struct:boost::type_erasure::detail::add_deduced	access:public	signature:(boost::is_same<typename ::boost::mpl::at<type, typename P::second>::type, result>)
BOOST_MPL_ASSERT	type_erasure/detail/normalize.hpp	/^    BOOST_MPL_ASSERT((boost::is_same<typename ::boost::mpl::at<type, typename P::second>::type, result>));$/;"	p	struct:boost::type_erasure::detail::convert_deduced	access:public	signature:(boost::is_same<typename ::boost::mpl::at<type, typename P::second>::type, result>)
BOOST_MPL_ASSERT	type_erasure/detail/rebind_placeholders.hpp	/^    BOOST_MPL_ASSERT((boost::mpl::or_<$/;"	p	struct:boost::type_erasure::detail::rebind_placeholders_in_argument	access:public	signature:(boost::mpl::or_< ::boost::mpl::not_< ::boost::type_erasure::is_placeholder<T> >, ::boost::mpl::has_key<Bindings, T> >)
BOOST_NO_FUNCTION_REFERENCE_QUALIFIERS	type_erasure/param.hpp	81;"	d
BOOST_PP_ENUM_BINARY_PARAMS	type_erasure/detail/construct.hpp	/^    any(BOOST_PP_ENUM_BINARY_PARAMS(N, U, &&u))$/;"	f	signature:(N, U, &&u)
BOOST_PP_ENUM_BINARY_PARAMS	type_erasure/detail/construct.hpp	/^    any(BOOST_PP_ENUM_BINARY_PARAMS(N, U, &u))$/;"	f	signature:(N, U, &u)
BOOST_PP_ENUM_BINARY_PARAMS	type_erasure/detail/construct.hpp	/^    any(BOOST_PP_ENUM_BINARY_PARAMS(N, const U, &u))$/;"	f	signature:(N, const U, &u)
BOOST_PP_ENUM_TRAILING_BINARY_PARAMS	type_erasure/detail/construct.hpp	/^        BOOST_PP_ENUM_TRAILING_BINARY_PARAMS(N, U, &u))$/;"	f	signature:(N, U, &u)
BOOST_PP_ENUM_TRAILING_BINARY_PARAMS	type_erasure/detail/construct.hpp	/^    any(binding<Concept>& binding_arg BOOST_PP_ENUM_TRAILING_BINARY_PARAMS(N, U, &&u))$/;"	f	signature:(N, U, &&u)
BOOST_PP_ENUM_TRAILING_BINARY_PARAMS	type_erasure/detail/construct.hpp	/^    any(binding<Concept>& binding_arg BOOST_PP_ENUM_TRAILING_BINARY_PARAMS(N, U, &u))$/;"	f	signature:(N, U, &u)
BOOST_PP_ENUM_TRAILING_BINARY_PARAMS	type_erasure/detail/construct.hpp	/^    any(binding<Concept>&& binding_arg BOOST_PP_ENUM_TRAILING_BINARY_PARAMS(N, U, &&u))$/;"	f	signature:(N, U, &&u)
BOOST_PP_ENUM_TRAILING_BINARY_PARAMS	type_erasure/detail/construct.hpp	/^    any(const binding<Concept>& binding_arg BOOST_PP_ENUM_TRAILING_BINARY_PARAMS(N, U, &&u))$/;"	f	signature:(N, U, &&u)
BOOST_PP_ENUM_TRAILING_BINARY_PARAMS	type_erasure/detail/construct.hpp	/^    any(const binding<Concept>& binding_arg BOOST_PP_ENUM_TRAILING_BINARY_PARAMS(N, U, &u))$/;"	f	signature:(N, U, &u)
BOOST_PP_ENUM_TRAILING_BINARY_PARAMS	type_erasure/detail/construct.hpp	/^    any(const binding<Concept>& binding_arg BOOST_PP_ENUM_TRAILING_BINARY_PARAMS(N, const U, &u))$/;"	f	signature:(N, const U, &u)
BOOST_PP_FILENAME_1	type_erasure/detail/adapt_to_vtable.hpp	243;"	d
BOOST_PP_FILENAME_1	type_erasure/detail/check_call.hpp	138;"	d
BOOST_PP_FILENAME_1	type_erasure/detail/construct.hpp	16;"	d
BOOST_PP_FILENAME_1	type_erasure/detail/extract_concept.hpp	87;"	d
BOOST_PP_FILENAME_1	type_erasure/detail/get_placeholders.hpp	100;"	d
BOOST_PP_FILENAME_1	type_erasure/detail/instantiate.hpp	55;"	d
BOOST_PP_FILENAME_1	type_erasure/detail/normalize_deduced.hpp	29;"	d
BOOST_PP_FILENAME_1	type_erasure/detail/null.hpp	37;"	d
BOOST_PP_FILENAME_1	type_erasure/detail/rebind_placeholders.hpp	138;"	d
BOOST_PP_FILENAME_1	type_erasure/require_match.hpp	132;"	d
BOOST_PP_ITERATION_LIMITS	type_erasure/detail/adapt_to_vtable.hpp	244;"	d
BOOST_PP_ITERATION_LIMITS	type_erasure/detail/check_call.hpp	139;"	d
BOOST_PP_ITERATION_LIMITS	type_erasure/detail/construct.hpp	17;"	d
BOOST_PP_ITERATION_LIMITS	type_erasure/detail/extract_concept.hpp	88;"	d
BOOST_PP_ITERATION_LIMITS	type_erasure/detail/get_placeholders.hpp	101;"	d
BOOST_PP_ITERATION_LIMITS	type_erasure/detail/instantiate.hpp	56;"	d
BOOST_PP_ITERATION_LIMITS	type_erasure/detail/normalize_deduced.hpp	30;"	d
BOOST_PP_ITERATION_LIMITS	type_erasure/detail/null.hpp	38;"	d
BOOST_PP_ITERATION_LIMITS	type_erasure/detail/rebind_placeholders.hpp	139;"	d
BOOST_PP_ITERATION_LIMITS	type_erasure/require_match.hpp	133;"	d
BOOST_TYPE_ERASURE_ANY_CAST_HPP_INCLUDED	type_erasure/any_cast.hpp	12;"	d
BOOST_TYPE_ERASURE_ANY_HPP_INCLUDED	type_erasure/any.hpp	12;"	d
BOOST_TYPE_ERASURE_ASSIGNMENT_OPERATOR	type_erasure/operators.hpp	200;"	d
BOOST_TYPE_ERASURE_ASSIGNMENT_OPERATOR	type_erasure/operators.hpp	254;"	d
BOOST_TYPE_ERASURE_BINARY_OPERATOR	type_erasure/operators.hpp	151;"	d
BOOST_TYPE_ERASURE_BINARY_OPERATOR	type_erasure/operators.hpp	197;"	d
BOOST_TYPE_ERASURE_BINDING_HPP_INCLUDED	type_erasure/binding.hpp	12;"	d
BOOST_TYPE_ERASURE_BINDING_OF_HPP_INCLUDED	type_erasure/binding_of.hpp	12;"	d
BOOST_TYPE_ERASURE_BROKEN_RVALUE_IS_CONVERTIBLE	type_erasure/detail/check_call.hpp	117;"	d
BOOST_TYPE_ERASURE_BUILTIN_HPP_INCLUDED	type_erasure/builtin.hpp	12;"	d
BOOST_TYPE_ERASURE_CALLABLE_HPP_INCLUDED	type_erasure/callable.hpp	14;"	d
BOOST_TYPE_ERASURE_CALL_HPP_INCLUDED	type_erasure/call.hpp	14;"	d
BOOST_TYPE_ERASURE_CHECK_MATCH_HPP_INCLUDED	type_erasure/check_match.hpp	14;"	d
BOOST_TYPE_ERASURE_CLOSE_NAMESPACE	type_erasure/detail/macro.hpp	36;"	d
BOOST_TYPE_ERASURE_CONCEPT_INTERFACE_HPP_INCLUDED	type_erasure/concept_interface.hpp	12;"	d
BOOST_TYPE_ERASURE_CONCEPT_OF_HPP_INCLUDED	type_erasure/concept_of.hpp	12;"	d
BOOST_TYPE_ERASURE_CONFIG_HPP_INCLUDED	type_erasure/config.hpp	12;"	d
BOOST_TYPE_ERASURE_CONSTRUCTIBLE_HPP_INCLUDED	type_erasure/constructible.hpp	14;"	d
BOOST_TYPE_ERASURE_DEDUCED_HPP_INCLUDED	type_erasure/deduced.hpp	12;"	d
BOOST_TYPE_ERASURE_DERIVED_HPP_INCLUDED	type_erasure/derived.hpp	12;"	d
BOOST_TYPE_ERASURE_DETAIL_ACCESS_HPP_INCLUDED	type_erasure/detail/access.hpp	12;"	d
BOOST_TYPE_ERASURE_DETAIL_ADAPT_TO_VTABLE_HPP_INCLUDED	type_erasure/detail/adapt_to_vtable.hpp	14;"	d
BOOST_TYPE_ERASURE_DETAIL_ANY_BASE_HPP_INCLUDED	type_erasure/detail/any_base.hpp	12;"	d
BOOST_TYPE_ERASURE_DETAIL_CHECK_CALL_HPP_INCLUDED	type_erasure/detail/check_call.hpp	14;"	d
BOOST_TYPE_ERASURE_DETAIL_CHECK_MAP_HPP_INCLUDED	type_erasure/detail/check_map.hpp	12;"	d
BOOST_TYPE_ERASURE_DETAIL_CONSTRUCT_HPP_INCLUDED	type_erasure/detail/construct.hpp	14;"	d
BOOST_TYPE_ERASURE_DETAIL_CONST_HPP_INCLUDED	type_erasure/detail/const.hpp	12;"	d
BOOST_TYPE_ERASURE_DETAIL_EXTRACT_CONCEPT_HPP_INCLUDED	type_erasure/detail/extract_concept.hpp	14;"	d
BOOST_TYPE_ERASURE_DETAIL_GET_PLACEHOLDERS_HPP_INCLUDED	type_erasure/detail/get_placeholders.hpp	14;"	d
BOOST_TYPE_ERASURE_DETAIL_GET_SIGNATURE_HPP_INCLUDED	type_erasure/detail/get_signature.hpp	12;"	d
BOOST_TYPE_ERASURE_DETAIL_INSTANTIATE_HPP_INCLUDED	type_erasure/detail/instantiate.hpp	14;"	d
BOOST_TYPE_ERASURE_DETAIL_IS_PLACEHOLDER_HPP_INCLUDED	type_erasure/is_placeholder.hpp	12;"	d
BOOST_TYPE_ERASURE_DETAIL_NORMALIZE_DEDUCED_HPP_INCLUDED	type_erasure/detail/normalize_deduced.hpp	14;"	d
BOOST_TYPE_ERASURE_DETAIL_NORMALIZE_HPP_INCLUDED	type_erasure/detail/normalize.hpp	12;"	d
BOOST_TYPE_ERASURE_DETAIL_NULL_HPP_INCLUDED	type_erasure/detail/null.hpp	14;"	d
BOOST_TYPE_ERASURE_DETAIL_REBIND_PLACEHOLDERS_HPP_INCLUDED	type_erasure/detail/rebind_placeholders.hpp	14;"	d
BOOST_TYPE_ERASURE_DETAIL_STORAGE_HPP_INCLUDED	type_erasure/detail/storage.hpp	12;"	d
BOOST_TYPE_ERASURE_DETAIL_VTABLE_HPP_INCLUDED	type_erasure/detail/vtable.hpp	14;"	d
BOOST_TYPE_ERASURE_EXCEPTION_HPP_INCLUDED	type_erasure/exception.hpp	12;"	d
BOOST_TYPE_ERASURE_FORWARD	type_erasure/detail/construct.hpp	111;"	d
BOOST_TYPE_ERASURE_FORWARD	type_erasure/detail/construct.hpp	29;"	d
BOOST_TYPE_ERASURE_FORWARD_I	type_erasure/detail/construct.hpp	112;"	d
BOOST_TYPE_ERASURE_FORWARD_I	type_erasure/detail/construct.hpp	28;"	d
BOOST_TYPE_ERASURE_FORWARD_REBIND1	type_erasure/member.hpp	54;"	d
BOOST_TYPE_ERASURE_FREE	type_erasure/free.hpp	302;"	d
BOOST_TYPE_ERASURE_FREE_FORWARD	type_erasure/free.hpp	86;"	d
BOOST_TYPE_ERASURE_FREE_FORWARD_I	type_erasure/free.hpp	84;"	d
BOOST_TYPE_ERASURE_FREE_FORWARD_PARAM_I	type_erasure/free.hpp	88;"	d
BOOST_TYPE_ERASURE_FREE_HPP_INCLUDED	type_erasure/free.hpp	12;"	d
BOOST_TYPE_ERASURE_FREE_I	type_erasure/free.hpp	275;"	d
BOOST_TYPE_ERASURE_FREE_II	type_erasure/free.hpp	102;"	d
BOOST_TYPE_ERASURE_FREE_PARAM_TYPE	type_erasure/free.hpp	75;"	d
BOOST_TYPE_ERASURE_FREE_QUALIFIED_ID	type_erasure/free.hpp	67;"	d
BOOST_TYPE_ERASURE_FREE_UNQUALIFIED_PARAM_TYPE	type_erasure/free.hpp	71;"	d
BOOST_TYPE_ERASURE_INSTANTIATE	type_erasure/detail/instantiate.hpp	43;"	d
BOOST_TYPE_ERASURE_INSTANTIATE1	type_erasure/detail/instantiate.hpp	48;"	d
BOOST_TYPE_ERASURE_IS_EMPTY_HPP_INCLUDED	type_erasure/is_empty.hpp	12;"	d
BOOST_TYPE_ERASURE_IS_SUBCONCEPT_HPP_INCLUDED	type_erasure/is_subconcept.hpp	12;"	d
BOOST_TYPE_ERASURE_ITERATOR_HPP_INCLUDED	type_erasure/iterator.hpp	12;"	d
BOOST_TYPE_ERASURE_MACRO_HPP_INCLUDED	type_erasure/detail/macro.hpp	12;"	d
BOOST_TYPE_ERASURE_MAX_ARITY	type_erasure/config.hpp	20;"	d
BOOST_TYPE_ERASURE_MAX_FUNCTIONS	type_erasure/config.hpp	16;"	d
BOOST_TYPE_ERASURE_MAX_TUPLE_SIZE	type_erasure/config.hpp	24;"	d
BOOST_TYPE_ERASURE_MEMBER	type_erasure/member.hpp	104;"	d
BOOST_TYPE_ERASURE_MEMBER	type_erasure/member.hpp	126;"	d
BOOST_TYPE_ERASURE_MEMBER_ARG	type_erasure/member.hpp	33;"	d
BOOST_TYPE_ERASURE_MEMBER_ENUM_ARGS	type_erasure/member.hpp	123;"	d
BOOST_TYPE_ERASURE_MEMBER_ENUM_ARGS	type_erasure/member.hpp	72;"	d
BOOST_TYPE_ERASURE_MEMBER_ENUM_PARAMS	type_erasure/member.hpp	118;"	d
BOOST_TYPE_ERASURE_MEMBER_ENUM_PARAMS	type_erasure/member.hpp	45;"	d
BOOST_TYPE_ERASURE_MEMBER_ENUM_TRAILING_BINARY_PARAMS	type_erasure/member.hpp	122;"	d
BOOST_TYPE_ERASURE_MEMBER_ENUM_TRAILING_BINARY_PARAMS	type_erasure/member.hpp	70;"	d
BOOST_TYPE_ERASURE_MEMBER_ENUM_TRAILING_PARAMS	type_erasure/member.hpp	120;"	d
BOOST_TYPE_ERASURE_MEMBER_ENUM_TRAILING_PARAMS	type_erasure/member.hpp	68;"	d
BOOST_TYPE_ERASURE_MEMBER_FORWARD	type_erasure/member.hpp	50;"	d
BOOST_TYPE_ERASURE_MEMBER_FORWARD_PARAMS	type_erasure/member.hpp	119;"	d
BOOST_TYPE_ERASURE_MEMBER_FORWARD_PARAMS	type_erasure/member.hpp	52;"	d
BOOST_TYPE_ERASURE_MEMBER_FORWARD_PARAMS	type_erasure/member.hpp	61;"	d
BOOST_TYPE_ERASURE_MEMBER_FORWARD_REBIND	type_erasure/member.hpp	121;"	d
BOOST_TYPE_ERASURE_MEMBER_FORWARD_REBIND	type_erasure/member.hpp	56;"	d
BOOST_TYPE_ERASURE_MEMBER_FORWARD_REBIND	type_erasure/member.hpp	63;"	d
BOOST_TYPE_ERASURE_MEMBER_HPP_INCLUDED	type_erasure/member.hpp	12;"	d
BOOST_TYPE_ERASURE_MEMBER_I	type_erasure/member.hpp	238;"	d
BOOST_TYPE_ERASURE_MEMBER_II	type_erasure/member.hpp	136;"	d
BOOST_TYPE_ERASURE_MEMBER_QUALIFIED_ID	type_erasure/member.hpp	114;"	d
BOOST_TYPE_ERASURE_MEMBER_QUALIFIED_ID	type_erasure/member.hpp	39;"	d
BOOST_TYPE_ERASURE_MEMBER_TPL_ARG_LIST	type_erasure/member.hpp	117;"	d
BOOST_TYPE_ERASURE_MEMBER_TPL_ARG_LIST	type_erasure/member.hpp	43;"	d
BOOST_TYPE_ERASURE_OPEN_NAMEPACE_I	type_erasure/detail/macro.hpp	28;"	d
BOOST_TYPE_ERASURE_OPEN_NAMESPACE	type_erasure/detail/macro.hpp	32;"	d
BOOST_TYPE_ERASURE_OPEN_NAMESPACE_F	type_erasure/detail/macro.hpp	24;"	d
BOOST_TYPE_ERASURE_OPERATORS_HPP_INCLUDED	type_erasure/operators.hpp	12;"	d
BOOST_TYPE_ERASURE_PARAM_HPP_INCLUDED	type_erasure/param.hpp	12;"	d
BOOST_TYPE_ERASURE_PLACEHOLDERS_HPP_INCLUDED	type_erasure/placeholder.hpp	12;"	d
BOOST_TYPE_ERASURE_PLACEHOLDER_OF_HPP_INCLUDED	type_erasure/placeholder_of.hpp	12;"	d
BOOST_TYPE_ERASURE_QUALIFIED_NAME	type_erasure/detail/macro.hpp	44;"	d
BOOST_TYPE_ERASURE_QUALIFIED_NAME_F	type_erasure/detail/macro.hpp	40;"	d
BOOST_TYPE_ERASURE_REBIND_ANY_HPP_INCLUDED	type_erasure/rebind_any.hpp	12;"	d
BOOST_TYPE_ERASURE_RELAXED_HPP_INCLUDED	type_erasure/relaxed.hpp	12;"	d
BOOST_TYPE_ERASURE_REQUIRE_MATCH_HPP_INCLUDED	type_erasure/require_match.hpp	14;"	d
BOOST_TYPE_ERASURE_SAME_TYPE_HPP_INCLUDED	type_erasure/same_type.hpp	12;"	d
BOOST_TYPE_ERASURE_STATIC_BINDING_HPP_INCLUDED	type_erasure/static_binding.hpp	12;"	d
BOOST_TYPE_ERASURE_TUPLE_HPP_INCLUDED	type_erasure/tuple.hpp	14;"	d
BOOST_TYPE_ERASURE_TYPEID_OF_HPP_INCLUDED	type_erasure/typeid_of.hpp	12;"	d
BOOST_TYPE_ERASURE_UNARY_INPLACE_OPERATOR	type_erasure/operators.hpp	35;"	d
BOOST_TYPE_ERASURE_UNARY_INPLACE_OPERATOR	type_erasure/operators.hpp	99;"	d
BOOST_TYPE_ERASURE_UNARY_OPERATOR	type_erasure/operators.hpp	102;"	d
BOOST_TYPE_ERASURE_UNARY_OPERATOR	type_erasure/operators.hpp	129;"	d
N	type_erasure/detail/construct.hpp	209;"	d
N	type_erasure/detail/construct.hpp	24;"	d
_a	type_erasure/placeholder.hpp	/^struct _a : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
_b	type_erasure/placeholder.hpp	/^struct _b : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( Other& other, const assignable<T, U>*, ::boost::mpl::false_)
_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( Other& other, const assignable<T, U>*, ::boost::mpl::true_)
_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( Other& other, const void*, ::boost::mpl::true_)
_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( const Other& other, const assignable<T, U>*, ::boost::mpl::false_)
_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( const Other& other, const assignable<T, U>*, ::boost::mpl::true_)
_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( const Other& other, const assignable<T, U>*, const constructible<Sig>*, ::boost::mpl::true_)
_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( const Other& other, const assignable<T, U>*, const void*, ::boost::mpl::false_)
_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( const Other& other, const assignable<T, U>*, const void*, ::boost::mpl::true_)
_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( const Other& other, const void*, ::boost::mpl::true_)
_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( const Other& other, const void*, const constructible<Sig>*, ::boost::mpl::true_)
_boost_type_erasure_concept_type	type_erasure/any.hpp	/^    typedef Concept _boost_type_erasure_concept_type;$/;"	t	class:boost::type_erasure::any	access:public
_boost_type_erasure_deduce_assign	type_erasure/builtin.hpp	/^    assignable<T, U>* _boost_type_erasure_deduce_assign($/;"	f	struct:boost::type_erasure::concept_interface	access:public	signature:( typename ::boost::type_erasure::rebind_any<Base, const U&>::type)
_boost_type_erasure_deduce_assign	type_erasure/detail/any_base.hpp	/^    void* _boost_type_erasure_deduce_assign(...) { return 0; }$/;"	f	struct:boost::type_erasure::any_base	access:public	signature:(....)
_boost_type_erasure_deduce_constructor	type_erasure/constructible.hpp	/^    _boost_type_erasure_deduce_constructor($/;"	f	struct:boost::type_erasure::concept_interface	access:public	signature:( typename ::boost::type_erasure::as_param<Base, T>::type...)
_boost_type_erasure_deduce_constructor	type_erasure/detail/any_base.hpp	/^    void* _boost_type_erasure_deduce_constructor(...) { return 0; }$/;"	f	struct:boost::type_erasure::any_base	access:public	signature:(....)
_boost_type_erasure_derived_type	type_erasure/detail/any_base.hpp	/^    typedef Derived _boost_type_erasure_derived_type;$/;"	t	struct:boost::type_erasure::any_base	access:public
_boost_type_erasure_derived_type	type_erasure/param.hpp	/^    typedef param _boost_type_erasure_derived_type;$/;"	t	class:boost::type_erasure::param	access:public
_boost_type_erasure_extract_table	type_erasure/any.hpp	/^    const table_type& _boost_type_erasure_extract_table($/;"	f	class:boost::type_erasure::any	access:public	signature:( ::boost::type_erasure::constructible<R(A...)>*, U&&... u)
_boost_type_erasure_is_any	type_erasure/detail/any_base.hpp	/^    typedef void _boost_type_erasure_is_any;$/;"	t	struct:boost::type_erasure::any_base	access:public
_boost_type_erasure_is_any	type_erasure/param.hpp	/^    typedef void _boost_type_erasure_is_any;$/;"	t	class:boost::type_erasure::param	access:public
_boost_type_erasure_resolve_assign	type_erasure/any.hpp	/^    void _boost_type_erasure_resolve_assign(Other& other)$/;"	f	class:boost::type_erasure::any	access:private	signature:(Other& other)
_boost_type_erasure_resolve_assign	type_erasure/any.hpp	/^    void _boost_type_erasure_resolve_assign(const Other& other)$/;"	f	class:boost::type_erasure::any	access:private	signature:(const Other& other)
_boost_type_erasure_resolve_assign	type_erasure/any.hpp	/^    void _boost_type_erasure_resolve_assign(const any<Concept2, Tag2>& other)$/;"	f	class:boost::type_erasure::any	access:private	signature:(const any<Concept2, Tag2>& other)
_boost_type_erasure_swap	type_erasure/any.hpp	/^    void _boost_type_erasure_swap(any& other)$/;"	f	class:boost::type_erasure::any	access:private	signature:(any& other)
_c	type_erasure/placeholder.hpp	/^struct _c : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
_d	type_erasure/placeholder.hpp	/^struct _d : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
_e	type_erasure/placeholder.hpp	/^struct _e : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
_f	type_erasure/placeholder.hpp	/^struct _f : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
_g	type_erasure/placeholder.hpp	/^struct _g : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
_impl	type_erasure/param.hpp	/^    any<Concept, T> _impl;$/;"	m	class:boost::type_erasure::param	access:private
_impl	type_erasure/param.hpp	/^    any<Concept, const T&> _impl;$/;"	m	class:boost::type_erasure::param	access:protected
_self	type_erasure/placeholder.hpp	/^struct _self : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
access	type_erasure/detail/access.hpp	/^struct access$/;"	s	namespace:boost::type_erasure::detail
actual_concept	type_erasure/binding.hpp	/^    >::type actual_concept;$/;"	t	class:boost::type_erasure::binding	access:private
adapt_to_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct adapt_to_vtable$/;"	s	namespace:boost::type_erasure::detail
add_const	type_erasure/detail/check_call.hpp	/^    >::type add_const;$/;"	t	struct:boost::type_erasure::detail::qualified_placeholder	access:public
add_deduced	type_erasure/detail/normalize.hpp	/^struct add_deduced$/;"	s	namespace:boost::type_erasure::detail
add_deductions	type_erasure/detail/normalize.hpp	/^struct add_deductions$/;"	s	namespace:boost::type_erasure::detail
add_typeinfo	type_erasure/detail/normalize.hpp	/^struct add_typeinfo$/;"	s	namespace:boost::type_erasure::detail
any	type_erasure/any.hpp	/^    any()$/;"	f	class:boost::type_erasure::any	access:public	signature:()
any	type_erasure/any.hpp	/^    any(::boost::type_erasure::detail::storage&& data_arg, const table_type& table_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(::boost::type_erasure::detail::storage&& data_arg, const table_type& table_arg)
any	type_erasure/any.hpp	/^    any(U& arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(U& arg , typename ::boost::disable_if< ::boost::mpl::or_< ::boost::is_const<U>, ::boost::type_erasure::detail::is_any<U> > >::type* = 0 )
any	type_erasure/any.hpp	/^    any(U& arg, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U& arg, const static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(U& data_arg, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U& data_arg, const static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(U& data_arg, static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U& data_arg, static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(U&& arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(U&& arg , typename ::boost::disable_if< ::boost::mpl::or_< ::boost::is_reference<U>, ::boost::is_const<U>, ::boost::type_erasure::detail::is_any<U> > >::type* = 0 )
any	type_erasure/any.hpp	/^    any(U&& arg, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U&& arg, const static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(U&& data_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U&& data_arg)
any	type_erasure/any.hpp	/^    any(U&& data_arg, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U&& data_arg, const static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(U&& data_arg, static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U&& data_arg, static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(U&& data_arg, static_binding<Map>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U&& data_arg, static_binding<Map>&& binding_arg)
any	type_erasure/any.hpp	/^    any(U* data_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U* data_arg)
any	type_erasure/any.hpp	/^    any(U* data_arg, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U* data_arg, const static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(U* data_arg, static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U* data_arg, static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(U* data_arg, static_binding<Map>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U* data_arg, static_binding<Map>&& binding_arg)
any	type_erasure/any.hpp	/^    any(U0&& u0, U1&& u1, U&&... u)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U0&& u0, U1&& u1, U&&... u)
any	type_erasure/any.hpp	/^    any(any& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any& other)
any	type_erasure/any.hpp	/^    any(any&& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any&& other)
any	type_erasure/any.hpp	/^    any(any<Concept, T&>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, T&>& other)
any	type_erasure/any.hpp	/^    any(any<Concept, T&>&& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, T&>&& other)
any	type_erasure/any.hpp	/^    any(any<Concept, T>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, T>& other)
any	type_erasure/any.hpp	/^    any(any<Concept, T>&& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, T>&& other)
any	type_erasure/any.hpp	/^    any(any<Concept, const T&>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, const T&>& other)
any	type_erasure/any.hpp	/^    any(any<Concept, const T&>&& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, const T&>&& other)
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2&&>&& other$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2&&>&& other , typename ::boost::disable_if< ::boost::mpl::or_< ::boost::is_reference<Tag2>, ::boost::is_same<Concept, Concept2>, ::boost::is_const<Tag2> > >::type* = 0 )
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other , typename ::boost::disable_if< ::boost::mpl::or_< ::boost::is_same<Concept, Concept2>, ::boost::is_const<typename ::boost::remove_reference<Tag2>::type> > >::type* = 0 )
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other)
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, binding<Concept>& binding_arg)
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, binding<Concept>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, binding<Concept>&& binding_arg)
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, const binding<Concept>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, const binding<Concept>& binding_arg , typename ::boost::disable_if< ::boost::is_const<typename ::boost::remove_reference<Tag2>::type> >::type* = 0 )
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, const binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, const binding<Concept>& binding_arg)
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, const static_binding<Map>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, const static_binding<Map>& binding_arg , typename ::boost::disable_if< ::boost::is_const<typename ::boost::remove_reference<Tag2>::type> >::type* = 0 )
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, const static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, static_binding<Map>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, static_binding<Map>&& binding_arg)
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other , typename ::boost::disable_if< ::boost::mpl::or_< ::boost::is_same<Concept, Concept2>, ::boost::is_const<typename ::boost::remove_reference<Tag2>::type> > >::type* = 0 )
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other)
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, binding<Concept>& binding_arg)
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, binding<Concept>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, binding<Concept>&& binding_arg)
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, const binding<Concept>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, const binding<Concept>& binding_arg , typename ::boost::disable_if< ::boost::is_const<typename ::boost::remove_reference<Tag2>::type> >::type* = 0 )
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, const binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, const binding<Concept>& binding_arg)
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, const static_binding<Map>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, const static_binding<Map>& binding_arg , typename ::boost::disable_if< ::boost::is_const<typename ::boost::remove_reference<Tag2>::type> >::type* = 0 )
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, const static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, static_binding<Map>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, static_binding<Map>&& binding_arg)
any	type_erasure/any.hpp	/^    any(binding<Concept>& binding_arg, U0&& u0, U&&... u)$/;"	f	class:boost::type_erasure::any	access:public	signature:(binding<Concept>& binding_arg, U0&& u0, U&&... u)
any	type_erasure/any.hpp	/^    any(binding<Concept>&& binding_arg, U0&& u0, U&&... u)$/;"	f	class:boost::type_erasure::any	access:public	signature:(binding<Concept>&& binding_arg, U0&& u0, U&&... u)
any	type_erasure/any.hpp	/^    any(const ::boost::type_erasure::detail::storage& data_arg, const table_type& table_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const ::boost::type_erasure::detail::storage& data_arg, const table_type& table_arg)
any	type_erasure/any.hpp	/^    any(const ::boost::type_erasure::detail::storage& data_arg,$/;"	f	class:boost::type_erasure::any	access:public	signature:(const ::boost::type_erasure::detail::storage& data_arg, const table_type& table_arg)
any	type_erasure/any.hpp	/^    any(const U& arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const U& arg)
any	type_erasure/any.hpp	/^    any(const U& arg, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const U& arg, const static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(const U& data_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const U& data_arg)
any	type_erasure/any.hpp	/^    any(const U& data_arg, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const U& data_arg, const static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(const U& data_arg, static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const U& data_arg, static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(const any& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any& other)
any	type_erasure/any.hpp	/^    any(const any<Concept, T&&>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept, T&&>& other)
any	type_erasure/any.hpp	/^    any(const any<Concept, T&>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept, T&>& other)
any	type_erasure/any.hpp	/^    any(const any<Concept, T>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept, T>& other)
any	type_erasure/any.hpp	/^    any(const any<Concept, const T&>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept, const T&>& other)
any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2&&>& other, const binding<Concept>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2&&>& other, const binding<Concept>& binding_arg , typename ::boost::disable_if< ::boost::is_const<Tag2> >::type* = 0 )
any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2&&>& other, const static_binding<Map>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2&&>& other, const static_binding<Map>& binding_arg , typename ::boost::disable_if< ::boost::is_const<Tag2> >::type* = 0 )
any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2&>& other$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2&>& other , typename ::boost::disable_if< ::boost::mpl::or_< ::boost::is_same<Concept, Concept2>, ::boost::is_const<Tag2> > >::type* = 0 )
any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2&>& other, const binding<Concept>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2&>& other, const binding<Concept>& binding_arg , typename ::boost::disable_if< ::boost::is_const<Tag2> >::type* = 0 )
any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2&>& other, const static_binding<Map>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2&>& other, const static_binding<Map>& binding_arg , typename ::boost::disable_if< ::boost::is_const<Tag2> >::type* = 0 )
any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other , typename ::boost::disable_if< ::boost::is_same<Concept, Concept2> >::type* = 0 )
any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other)
any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other, binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other, binding<Concept>& binding_arg)
any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other, binding<Concept>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other, binding<Concept>&& binding_arg)
any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other, const binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other, const binding<Concept>& binding_arg)
any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other, const static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other, static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other, static_binding<Map>& binding_arg)
any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other, static_binding<Map>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other, static_binding<Map>&& binding_arg)
any	type_erasure/any.hpp	/^    any(const binding<Concept>& binding_arg, U0&& u0, U&&... u)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const binding<Concept>& binding_arg, U0&& u0, U&&... u)
any	type_erasure/any.hpp	/^    explicit any(U&&... arg);$/;"	p	class:boost::type_erasure::any	access:public	signature:(U&&.... arg)
any	type_erasure/any.hpp	/^    explicit any(any<Concept, Tag2>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, Tag2>& other)
any	type_erasure/any.hpp	/^    explicit any(any<Concept, Tag2>&& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, Tag2>&& other)
any	type_erasure/any.hpp	/^    explicit any(binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(binding<Concept>& binding_arg)
any	type_erasure/any.hpp	/^    explicit any(binding<Concept>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(binding<Concept>&& binding_arg)
any	type_erasure/any.hpp	/^    explicit any(const any<Concept, Tag2>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept, Tag2>& other)
any	type_erasure/any.hpp	/^    explicit any(const binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const binding<Concept>& binding_arg)
any	type_erasure/any.hpp	/^    explicit any(const binding<Concept>& binding_arg, U&&... arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const binding<Concept>& binding_arg, U&&... arg)
any	type_erasure/any.hpp	/^class any :$/;"	c	namespace:boost::type_erasure	inherits:::boost::type_erasure::detail::compute_bases::type
any	type_erasure/any.hpp	/^class any<Concept, T&&> :$/;"	c	namespace:boost::type_erasure	inherits:::boost::type_erasure::detail::compute_bases::type
any	type_erasure/any.hpp	/^class any<Concept, T&> :$/;"	c	namespace:boost::type_erasure	inherits:::boost::type_erasure::detail::compute_bases::type
any	type_erasure/any.hpp	/^class any<Concept, const T&> :$/;"	c	namespace:boost::type_erasure	inherits:::boost::type_erasure::detail::compute_bases::type
any_base	type_erasure/detail/any_base.hpp	/^struct any_base$/;"	s	namespace:boost::type_erasure
any_cast	type_erasure/any_cast.hpp	/^T any_cast(any<Concept, Tag>& arg)$/;"	f	namespace:boost::type_erasure	signature:(any<Concept, Tag>& arg)
any_cast	type_erasure/any_cast.hpp	/^T any_cast(any<Concept, Tag>* arg)$/;"	f	namespace:boost::type_erasure	signature:(any<Concept, Tag>* arg)
any_cast	type_erasure/any_cast.hpp	/^T any_cast(const any<Concept, Tag>& arg)$/;"	f	namespace:boost::type_erasure	signature:(const any<Concept, Tag>& arg)
any_cast	type_erasure/any_cast.hpp	/^T any_cast(const any<Concept, Tag>* arg)$/;"	f	namespace:boost::type_erasure	signature:(const any<Concept, Tag>* arg)
append_typeinfo	type_erasure/detail/normalize.hpp	/^struct append_typeinfo$/;"	s	namespace:boost::type_erasure::detail
apply	type_erasure/builtin.hpp	/^    static const std::type_info& apply()$/;"	f	struct:boost::type_erasure::typeid_	access:public	signature:()
apply	type_erasure/builtin.hpp	/^    static void apply(T& dst, const U& src) { dst = src; }$/;"	f	struct:boost::type_erasure::assignable	access:public	signature:(T& dst, const U& src)
apply	type_erasure/builtin.hpp	/^    static void apply(detail::storage& arg)$/;"	f	struct:boost::type_erasure::destructible	access:public	signature:(detail::storage& arg)
apply	type_erasure/callable.hpp	/^    static R apply(F& f, T... arg);$/;"	p	struct:boost::type_erasure::callable	access:public	signature:(F& f, T... arg)
apply	type_erasure/constructible.hpp	/^    apply(T... arg)$/;"	f	struct:boost::type_erasure::constructible	access:public	signature:(T.... arg)
apply	type_erasure/detail/normalize.hpp	/^    struct apply : boost::mpl::true_$/;"	s	struct:boost::mpl::has_key_impl	inherits:boost::mpl::true_	access:public
apply	type_erasure/detail/normalize.hpp	/^    struct apply$/;"	s	struct:boost::mpl::at_impl	access:public
apply	type_erasure/detail/normalize.hpp	/^    struct apply$/;"	s	struct:boost::type_erasure::detail::append_typeinfo	access:public
apply	type_erasure/detail/vtable.hpp	/^    static bool apply(const S& s1, const S& s2)$/;"	f	struct:boost::type_erasure::detail::compare_vtable	access:public	signature:(const S& s1, const S& s2)
apply	type_erasure/operators.hpp	/^    static R apply(T& arg, const N& index) { return arg[index]; }$/;"	f	struct:boost::type_erasure::subscriptable	access:public	signature:(T& arg, const N& index)
apply	type_erasure/operators.hpp	/^    static R apply(const T& arg) { return *arg; }$/;"	f	struct:boost::type_erasure::dereferenceable	access:public	signature:(const T& arg)
apply	type_erasure/operators.hpp	/^    static bool apply(const T& lhs, const U& rhs) { return lhs < rhs; }$/;"	f	struct:boost::type_erasure::less_than_comparable	access:public	signature:(const T& lhs, const U& rhs)
apply	type_erasure/operators.hpp	/^    static bool apply(const T& lhs, const U& rhs) { return lhs == rhs; }$/;"	f	struct:boost::type_erasure::equality_comparable	access:public	signature:(const T& lhs, const U& rhs)
apply	type_erasure/operators.hpp	/^    static void apply(Is& out, T& arg) { out >> arg; }$/;"	f	struct:boost::type_erasure::istreamable	access:public	signature:(Is& out, T& arg)
apply	type_erasure/operators.hpp	/^    static void apply(Os& out, const T& arg) { out << arg; }$/;"	f	struct:boost::type_erasure::ostreamable	access:public	signature:(Os& out, const T& arg)
as_param	type_erasure/param.hpp	/^struct as_param {$/;"	s	namespace:boost::type_erasure
assignable	type_erasure/builtin.hpp	/^struct assignable$/;"	s	namespace:boost::type_erasure
at_impl	type_erasure/detail/normalize.hpp	/^struct at_impl< ::boost::type_erasure::detail::substitution_map_tag>$/;"	s	namespace:boost::mpl
bad_any_cast	type_erasure/exception.hpp	/^class bad_any_cast : public std::bad_cast {};$/;"	c	namespace:boost::type_erasure	inherits:std::bad_cast
bad_function_call	type_erasure/exception.hpp	/^    bad_function_call() : ::std::invalid_argument("bad_function_call") {}$/;"	f	class:boost::type_erasure::bad_function_call	access:public	signature:()
bad_function_call	type_erasure/exception.hpp	/^class bad_function_call : public ::std::invalid_argument$/;"	c	namespace:boost::type_erasure	inherits:::std::invalid_argument
basic	type_erasure/detail/normalize.hpp	/^    >::type basic;$/;"	t	struct:boost::type_erasure::detail::normalize_concept	access:public
basic_components	type_erasure/detail/check_map.hpp	/^    typedef typename normalize_concept<Concept>::basic basic_components;$/;"	t	struct:boost::type_erasure::detail::check_map	access:public
bidirectional_iterator	type_erasure/iterator.hpp	/^struct bidirectional_iterator :$/;"	s	namespace:boost::type_erasure	inherits:iterator
binding	type_erasure/binding.hpp	/^    binding() { BOOST_MPL_ASSERT((::boost::type_erasure::is_relaxed<Concept>)); }$/;"	f	class:boost::type_erasure::binding	access:public	signature:()
binding	type_erasure/binding.hpp	/^    binding(const binding<Concept2>& other, const Map&$/;"	f	class:boost::type_erasure::binding	access:public	signature:(const binding<Concept2>& other, const Map& , typename ::boost::enable_if< ::boost::mpl::and_< ::boost::type_erasure::detail::check_map<Concept, Map>, ::boost::type_erasure::is_subconcept<Concept, Concept2, Map> > >::type* = 0 )
binding	type_erasure/binding.hpp	/^    binding(const binding<Concept2>& other, const static_binding<Map>&$/;"	f	class:boost::type_erasure::binding	access:public	signature:(const binding<Concept2>& other, const static_binding<Map>& , typename ::boost::enable_if< ::boost::mpl::and_< ::boost::type_erasure::detail::check_map<Concept, Map>, ::boost::type_erasure::is_subconcept<Concept, Concept2, Map> > >::type* = 0 )
binding	type_erasure/binding.hpp	/^    binding(const static_binding<Map>&)$/;"	f	class:boost::type_erasure::binding	access:public	signature:(const static_binding<Map>&)
binding	type_erasure/binding.hpp	/^    explicit binding(const Map&)$/;"	f	class:boost::type_erasure::binding	access:public	signature:(const Map&)
binding	type_erasure/binding.hpp	/^class binding$/;"	c	namespace:boost::type_erasure
binding_of	type_erasure/binding_of.hpp	/^const binding<Concept>& binding_of(const any<Concept, T>& arg)$/;"	f	namespace:boost::type_erasure	signature:(const any<Concept, T>& arg)
bindings	type_erasure/is_subconcept.hpp	/^    >::type bindings;$/;"	t	struct:boost::type_erasure::detail::is_subconcept_impl	access:public
boost	type_erasure/any.hpp	/^namespace boost {$/;"	n
boost	type_erasure/any_cast.hpp	/^namespace boost {$/;"	n
boost	type_erasure/binding.hpp	/^namespace boost {$/;"	n
boost	type_erasure/binding_of.hpp	/^namespace boost {$/;"	n
boost	type_erasure/builtin.hpp	/^namespace boost {$/;"	n
boost	type_erasure/call.hpp	/^namespace boost {$/;"	n
boost	type_erasure/callable.hpp	/^namespace boost {$/;"	n
boost	type_erasure/check_match.hpp	/^namespace boost {$/;"	n
boost	type_erasure/concept_interface.hpp	/^namespace boost {$/;"	n
boost	type_erasure/concept_of.hpp	/^namespace boost {$/;"	n
boost	type_erasure/constructible.hpp	/^namespace boost {$/;"	n
boost	type_erasure/deduced.hpp	/^namespace boost {$/;"	n
boost	type_erasure/derived.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/access.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/adapt_to_vtable.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/any_base.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/check_call.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/check_map.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/const.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/extract_concept.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/get_placeholders.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/get_signature.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/instantiate.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/normalize.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/normalize_deduced.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/null.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/rebind_placeholders.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/storage.hpp	/^namespace boost {$/;"	n
boost	type_erasure/detail/vtable.hpp	/^namespace boost {$/;"	n
boost	type_erasure/exception.hpp	/^namespace boost {$/;"	n
boost	type_erasure/free.hpp	/^namespace boost {$/;"	n
boost	type_erasure/is_empty.hpp	/^namespace boost {$/;"	n
boost	type_erasure/is_placeholder.hpp	/^namespace boost {$/;"	n
boost	type_erasure/is_subconcept.hpp	/^namespace boost {$/;"	n
boost	type_erasure/iterator.hpp	/^namespace boost {$/;"	n
boost	type_erasure/operators.hpp	/^namespace boost {$/;"	n
boost	type_erasure/param.hpp	/^namespace boost {$/;"	n
boost	type_erasure/placeholder.hpp	/^namespace boost {$/;"	n
boost	type_erasure/placeholder_of.hpp	/^namespace boost {$/;"	n
boost	type_erasure/rebind_any.hpp	/^namespace boost {$/;"	n
boost	type_erasure/relaxed.hpp	/^namespace boost {$/;"	n
boost	type_erasure/require_match.hpp	/^namespace boost {$/;"	n
boost	type_erasure/same_type.hpp	/^namespace boost {$/;"	n
boost	type_erasure/static_binding.hpp	/^namespace boost {$/;"	n
boost	type_erasure/tuple.hpp	/^namespace boost {$/;"	n
boost	type_erasure/typeid_of.hpp	/^namespace boost {$/;"	n
boost::mpl	type_erasure/detail/normalize.hpp	/^namespace mpl {$/;"	n	namespace:boost
boost::mpl::at_impl	type_erasure/detail/normalize.hpp	/^struct at_impl< ::boost::type_erasure::detail::substitution_map_tag>$/;"	s	namespace:boost::mpl
boost::mpl::at_impl::apply	type_erasure/detail/normalize.hpp	/^    struct apply$/;"	s	struct:boost::mpl::at_impl	access:public
boost::mpl::at_impl::apply::type	type_erasure/detail/normalize.hpp	/^        >::type type;$/;"	t	struct:boost::mpl::at_impl::apply	access:public
boost::mpl::has_key_impl	type_erasure/detail/normalize.hpp	/^struct has_key_impl< ::boost::type_erasure::detail::substitution_map_tag>$/;"	s	namespace:boost::mpl
boost::mpl::has_key_impl::apply	type_erasure/detail/normalize.hpp	/^    struct apply : boost::mpl::true_$/;"	s	struct:boost::mpl::has_key_impl	inherits:boost::mpl::true_	access:public
boost::type_erasure	type_erasure/any.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/any_cast.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/binding.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/binding_of.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/builtin.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/call.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/callable.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/check_match.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/concept_interface.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/concept_of.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/constructible.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/deduced.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/derived.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/access.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/adapt_to_vtable.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/any_base.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/check_call.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/check_map.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/const.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/extract_concept.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/get_placeholders.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/get_signature.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/instantiate.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/normalize.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/normalize_deduced.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/null.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/rebind_placeholders.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/storage.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/detail/vtable.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/exception.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/free.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/is_empty.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/is_placeholder.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/is_subconcept.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/iterator.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/operators.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/param.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/placeholder.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/placeholder_of.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/rebind_any.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/relaxed.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/require_match.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/same_type.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/static_binding.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/tuple.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure	type_erasure/typeid_of.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
boost::type_erasure::_a	type_erasure/placeholder.hpp	/^struct _a : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
boost::type_erasure::_b	type_erasure/placeholder.hpp	/^struct _b : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
boost::type_erasure::_c	type_erasure/placeholder.hpp	/^struct _c : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
boost::type_erasure::_d	type_erasure/placeholder.hpp	/^struct _d : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
boost::type_erasure::_e	type_erasure/placeholder.hpp	/^struct _e : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
boost::type_erasure::_f	type_erasure/placeholder.hpp	/^struct _f : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
boost::type_erasure::_g	type_erasure/placeholder.hpp	/^struct _g : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
boost::type_erasure::_self	type_erasure/placeholder.hpp	/^struct _self : placeholder {};$/;"	s	namespace:boost::type_erasure	inherits:placeholder
boost::type_erasure::any	type_erasure/any.hpp	/^class any :$/;"	c	namespace:boost::type_erasure	inherits:::boost::type_erasure::detail::compute_bases::type
boost::type_erasure::any	type_erasure/any.hpp	/^class any<Concept, T&&> :$/;"	c	namespace:boost::type_erasure	inherits:::boost::type_erasure::detail::compute_bases::type
boost::type_erasure::any	type_erasure/any.hpp	/^class any<Concept, T&> :$/;"	c	namespace:boost::type_erasure	inherits:::boost::type_erasure::detail::compute_bases::type
boost::type_erasure::any	type_erasure/any.hpp	/^class any<Concept, const T&> :$/;"	c	namespace:boost::type_erasure	inherits:::boost::type_erasure::detail::compute_bases::type
boost::type_erasure::any::_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( Other& other, const assignable<T, U>*, ::boost::mpl::false_)
boost::type_erasure::any::_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( Other& other, const assignable<T, U>*, ::boost::mpl::true_)
boost::type_erasure::any::_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( Other& other, const void*, ::boost::mpl::true_)
boost::type_erasure::any::_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( const Other& other, const assignable<T, U>*, ::boost::mpl::false_)
boost::type_erasure::any::_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( const Other& other, const assignable<T, U>*, ::boost::mpl::true_)
boost::type_erasure::any::_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( const Other& other, const assignable<T, U>*, const constructible<Sig>*, ::boost::mpl::true_)
boost::type_erasure::any::_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( const Other& other, const assignable<T, U>*, const void*, ::boost::mpl::false_)
boost::type_erasure::any::_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( const Other& other, const assignable<T, U>*, const void*, ::boost::mpl::true_)
boost::type_erasure::any::_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( const Other& other, const void*, ::boost::mpl::true_)
boost::type_erasure::any::_boost_type_erasure_assign_impl	type_erasure/any.hpp	/^    void _boost_type_erasure_assign_impl($/;"	f	class:boost::type_erasure::any	access:private	signature:( const Other& other, const void*, const constructible<Sig>*, ::boost::mpl::true_)
boost::type_erasure::any::_boost_type_erasure_concept_type	type_erasure/any.hpp	/^    typedef Concept _boost_type_erasure_concept_type;$/;"	t	class:boost::type_erasure::any	access:public
boost::type_erasure::any::_boost_type_erasure_extract_table	type_erasure/any.hpp	/^    const table_type& _boost_type_erasure_extract_table($/;"	f	class:boost::type_erasure::any	access:public	signature:( ::boost::type_erasure::constructible<R(A...)>*, U&&... u)
boost::type_erasure::any::_boost_type_erasure_resolve_assign	type_erasure/any.hpp	/^    void _boost_type_erasure_resolve_assign(Other& other)$/;"	f	class:boost::type_erasure::any	access:private	signature:(Other& other)
boost::type_erasure::any::_boost_type_erasure_resolve_assign	type_erasure/any.hpp	/^    void _boost_type_erasure_resolve_assign(const Other& other)$/;"	f	class:boost::type_erasure::any	access:private	signature:(const Other& other)
boost::type_erasure::any::_boost_type_erasure_resolve_assign	type_erasure/any.hpp	/^    void _boost_type_erasure_resolve_assign(const any<Concept2, Tag2>& other)$/;"	f	class:boost::type_erasure::any	access:private	signature:(const any<Concept2, Tag2>& other)
boost::type_erasure::any::_boost_type_erasure_swap	type_erasure/any.hpp	/^    void _boost_type_erasure_swap(any& other)$/;"	f	class:boost::type_erasure::any	access:private	signature:(any& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any()$/;"	f	class:boost::type_erasure::any	access:public	signature:()
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(::boost::type_erasure::detail::storage&& data_arg, const table_type& table_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(::boost::type_erasure::detail::storage&& data_arg, const table_type& table_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(U& arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(U& arg , typename ::boost::disable_if< ::boost::mpl::or_< ::boost::is_const<U>, ::boost::type_erasure::detail::is_any<U> > >::type* = 0 )
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(U& arg, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U& arg, const static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(U& data_arg, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U& data_arg, const static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(U& data_arg, static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U& data_arg, static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(U&& arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(U&& arg , typename ::boost::disable_if< ::boost::mpl::or_< ::boost::is_reference<U>, ::boost::is_const<U>, ::boost::type_erasure::detail::is_any<U> > >::type* = 0 )
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(U&& arg, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U&& arg, const static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(U&& data_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U&& data_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(U&& data_arg, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U&& data_arg, const static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(U&& data_arg, static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U&& data_arg, static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(U&& data_arg, static_binding<Map>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U&& data_arg, static_binding<Map>&& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(U* data_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U* data_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(U* data_arg, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U* data_arg, const static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(U* data_arg, static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U* data_arg, static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(U* data_arg, static_binding<Map>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U* data_arg, static_binding<Map>&& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(U0&& u0, U1&& u1, U&&... u)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U0&& u0, U1&& u1, U&&... u)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any&& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any&& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept, T&>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, T&>& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept, T&>&& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, T&>&& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept, T>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, T>& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept, T>&& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, T>&& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept, const T&>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, const T&>& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept, const T&>&& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, const T&>&& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2&&>&& other$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2&&>&& other , typename ::boost::disable_if< ::boost::mpl::or_< ::boost::is_reference<Tag2>, ::boost::is_same<Concept, Concept2>, ::boost::is_const<Tag2> > >::type* = 0 )
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other , typename ::boost::disable_if< ::boost::mpl::or_< ::boost::is_same<Concept, Concept2>, ::boost::is_const<typename ::boost::remove_reference<Tag2>::type> > >::type* = 0 )
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, binding<Concept>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, binding<Concept>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, binding<Concept>&& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, const binding<Concept>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, const binding<Concept>& binding_arg , typename ::boost::disable_if< ::boost::is_const<typename ::boost::remove_reference<Tag2>::type> >::type* = 0 )
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, const binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, const binding<Concept>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, const static_binding<Map>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, const static_binding<Map>& binding_arg , typename ::boost::disable_if< ::boost::is_const<typename ::boost::remove_reference<Tag2>::type> >::type* = 0 )
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, const static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>& other, static_binding<Map>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>& other, static_binding<Map>&& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other , typename ::boost::disable_if< ::boost::mpl::or_< ::boost::is_same<Concept, Concept2>, ::boost::is_const<typename ::boost::remove_reference<Tag2>::type> > >::type* = 0 )
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, binding<Concept>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, binding<Concept>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, binding<Concept>&& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, const binding<Concept>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, const binding<Concept>& binding_arg , typename ::boost::disable_if< ::boost::is_const<typename ::boost::remove_reference<Tag2>::type> >::type* = 0 )
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, const binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, const binding<Concept>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, const static_binding<Map>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, const static_binding<Map>& binding_arg , typename ::boost::disable_if< ::boost::is_const<typename ::boost::remove_reference<Tag2>::type> >::type* = 0 )
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, const static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(any<Concept2, Tag2>&& other, static_binding<Map>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept2, Tag2>&& other, static_binding<Map>&& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(binding<Concept>& binding_arg, U0&& u0, U&&... u)$/;"	f	class:boost::type_erasure::any	access:public	signature:(binding<Concept>& binding_arg, U0&& u0, U&&... u)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(binding<Concept>&& binding_arg, U0&& u0, U&&... u)$/;"	f	class:boost::type_erasure::any	access:public	signature:(binding<Concept>&& binding_arg, U0&& u0, U&&... u)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const ::boost::type_erasure::detail::storage& data_arg, const table_type& table_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const ::boost::type_erasure::detail::storage& data_arg, const table_type& table_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const ::boost::type_erasure::detail::storage& data_arg,$/;"	f	class:boost::type_erasure::any	access:public	signature:(const ::boost::type_erasure::detail::storage& data_arg, const table_type& table_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const U& arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const U& arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const U& arg, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const U& arg, const static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const U& data_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const U& data_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const U& data_arg, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const U& data_arg, const static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const U& data_arg, static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const U& data_arg, static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept, T&&>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept, T&&>& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept, T&>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept, T&>& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept, T>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept, T>& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept, const T&>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept, const T&>& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2&&>& other, const binding<Concept>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2&&>& other, const binding<Concept>& binding_arg , typename ::boost::disable_if< ::boost::is_const<Tag2> >::type* = 0 )
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2&&>& other, const static_binding<Map>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2&&>& other, const static_binding<Map>& binding_arg , typename ::boost::disable_if< ::boost::is_const<Tag2> >::type* = 0 )
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2&>& other$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2&>& other , typename ::boost::disable_if< ::boost::mpl::or_< ::boost::is_same<Concept, Concept2>, ::boost::is_const<Tag2> > >::type* = 0 )
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2&>& other, const binding<Concept>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2&>& other, const binding<Concept>& binding_arg , typename ::boost::disable_if< ::boost::is_const<Tag2> >::type* = 0 )
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2&>& other, const static_binding<Map>& binding_arg$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2&>& other, const static_binding<Map>& binding_arg , typename ::boost::disable_if< ::boost::is_const<Tag2> >::type* = 0 )
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other , typename ::boost::disable_if< ::boost::is_same<Concept, Concept2> >::type* = 0 )
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other, binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other, binding<Concept>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other, binding<Concept>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other, binding<Concept>&& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other, const binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other, const binding<Concept>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other, const static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other, const static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other, static_binding<Map>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other, static_binding<Map>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const any<Concept2, Tag2>& other, static_binding<Map>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept2, Tag2>& other, static_binding<Map>&& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    any(const binding<Concept>& binding_arg, U0&& u0, U&&... u)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const binding<Concept>& binding_arg, U0&& u0, U&&... u)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    explicit any(U&&... arg);$/;"	p	class:boost::type_erasure::any	access:public	signature:(U&&.... arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    explicit any(any<Concept, Tag2>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, Tag2>& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    explicit any(any<Concept, Tag2>&& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(any<Concept, Tag2>&& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    explicit any(binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(binding<Concept>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    explicit any(binding<Concept>&& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(binding<Concept>&& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    explicit any(const any<Concept, Tag2>& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any<Concept, Tag2>& other)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    explicit any(const binding<Concept>& binding_arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const binding<Concept>& binding_arg)
boost::type_erasure::any::any	type_erasure/any.hpp	/^    explicit any(const binding<Concept>& binding_arg, U&&... arg)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const binding<Concept>& binding_arg, U&&... arg)
boost::type_erasure::any::data	type_erasure/any.hpp	/^    ::boost::type_erasure::detail::storage data;$/;"	m	class:boost::type_erasure::any	access:private
boost::type_erasure::any::operator =	type_erasure/any.hpp	/^    any& operator=(U& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U& other)
boost::type_erasure::any::operator =	type_erasure/any.hpp	/^    any& operator=(const U& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const U& other)
boost::type_erasure::any::operator =	type_erasure/any.hpp	/^    any& operator=(const any& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any& other)
boost::type_erasure::any::operator param<Concept, T&&>	type_erasure/any.hpp	/^    operator param<Concept, T&&>() && { return param<Concept, T&&>(data, table); }$/;"	f	class:boost::type_erasure::any	access:public	signature:()
boost::type_erasure::any::operator param<Concept, T&&>	type_erasure/any.hpp	/^    operator param<Concept, T&&>() const { return param<Concept, T&&>(data, table); }$/;"	f	class:boost::type_erasure::any	access:public	signature:() const
boost::type_erasure::any::operator param<Concept, T&>	type_erasure/any.hpp	/^    operator param<Concept, T&>() & { return param<Concept, T&>(data, table); }$/;"	f	class:boost::type_erasure::any	access:public	signature:()
boost::type_erasure::any::operator param<Concept, T&>	type_erasure/any.hpp	/^    operator param<Concept, T&>() const { return param<Concept, T&>(data, table); }$/;"	f	class:boost::type_erasure::any	access:public	signature:() const
boost::type_erasure::any::operator param<Concept, const T&>	type_erasure/any.hpp	/^    operator param<Concept, const T&>() const { return param<Concept, const T&>(data, table); }$/;"	f	class:boost::type_erasure::any	access:public	signature:() const
boost::type_erasure::any::table	type_erasure/any.hpp	/^    table_type table;$/;"	m	class:boost::type_erasure::any	access:private
boost::type_erasure::any::table_type	type_erasure/any.hpp	/^    typedef ::boost::type_erasure::binding<Concept> table_type;$/;"	t	class:boost::type_erasure::any	access:private
boost::type_erasure::any::~any	type_erasure/any.hpp	/^    ~any()$/;"	f	class:boost::type_erasure::any	access:public	signature:()
boost::type_erasure::any_base	type_erasure/detail/any_base.hpp	/^struct any_base$/;"	s	namespace:boost::type_erasure
boost::type_erasure::any_base::_boost_type_erasure_deduce_assign	type_erasure/detail/any_base.hpp	/^    void* _boost_type_erasure_deduce_assign(...) { return 0; }$/;"	f	struct:boost::type_erasure::any_base	access:public	signature:(....)
boost::type_erasure::any_base::_boost_type_erasure_deduce_constructor	type_erasure/detail/any_base.hpp	/^    void* _boost_type_erasure_deduce_constructor(...) { return 0; }$/;"	f	struct:boost::type_erasure::any_base	access:public	signature:(....)
boost::type_erasure::any_base::_boost_type_erasure_derived_type	type_erasure/detail/any_base.hpp	/^    typedef Derived _boost_type_erasure_derived_type;$/;"	t	struct:boost::type_erasure::any_base	access:public
boost::type_erasure::any_base::_boost_type_erasure_is_any	type_erasure/detail/any_base.hpp	/^    typedef void _boost_type_erasure_is_any;$/;"	t	struct:boost::type_erasure::any_base	access:public
boost::type_erasure::any_cast	type_erasure/any_cast.hpp	/^T any_cast(any<Concept, Tag>& arg)$/;"	f	namespace:boost::type_erasure	signature:(any<Concept, Tag>& arg)
boost::type_erasure::any_cast	type_erasure/any_cast.hpp	/^T any_cast(any<Concept, Tag>* arg)$/;"	f	namespace:boost::type_erasure	signature:(any<Concept, Tag>* arg)
boost::type_erasure::any_cast	type_erasure/any_cast.hpp	/^T any_cast(const any<Concept, Tag>& arg)$/;"	f	namespace:boost::type_erasure	signature:(const any<Concept, Tag>& arg)
boost::type_erasure::any_cast	type_erasure/any_cast.hpp	/^T any_cast(const any<Concept, Tag>* arg)$/;"	f	namespace:boost::type_erasure	signature:(const any<Concept, Tag>* arg)
boost::type_erasure::as_param	type_erasure/param.hpp	/^struct as_param {$/;"	s	namespace:boost::type_erasure
boost::type_erasure::as_param::type	type_erasure/param.hpp	/^    typedef detail::unspecified type;$/;"	t	struct:boost::type_erasure::as_param	access:public
boost::type_erasure::assignable	type_erasure/builtin.hpp	/^struct assignable$/;"	s	namespace:boost::type_erasure
boost::type_erasure::assignable::apply	type_erasure/builtin.hpp	/^    static void apply(T& dst, const U& src) { dst = src; }$/;"	f	struct:boost::type_erasure::assignable	access:public	signature:(T& dst, const U& src)
boost::type_erasure::bad_any_cast	type_erasure/exception.hpp	/^class bad_any_cast : public std::bad_cast {};$/;"	c	namespace:boost::type_erasure	inherits:std::bad_cast
boost::type_erasure::bad_function_call	type_erasure/exception.hpp	/^class bad_function_call : public ::std::invalid_argument$/;"	c	namespace:boost::type_erasure	inherits:::std::invalid_argument
boost::type_erasure::bad_function_call::bad_function_call	type_erasure/exception.hpp	/^    bad_function_call() : ::std::invalid_argument("bad_function_call") {}$/;"	f	class:boost::type_erasure::bad_function_call	access:public	signature:()
boost::type_erasure::bidirectional_iterator	type_erasure/iterator.hpp	/^struct bidirectional_iterator :$/;"	s	namespace:boost::type_erasure	inherits:iterator
boost::type_erasure::binding	type_erasure/binding.hpp	/^class binding$/;"	c	namespace:boost::type_erasure
boost::type_erasure::binding::actual_concept	type_erasure/binding.hpp	/^    >::type actual_concept;$/;"	t	class:boost::type_erasure::binding	access:private
boost::type_erasure::binding::binding	type_erasure/binding.hpp	/^    binding() { BOOST_MPL_ASSERT((::boost::type_erasure::is_relaxed<Concept>)); }$/;"	f	class:boost::type_erasure::binding	access:public	signature:()
boost::type_erasure::binding::binding	type_erasure/binding.hpp	/^    binding(const binding<Concept2>& other, const Map&$/;"	f	class:boost::type_erasure::binding	access:public	signature:(const binding<Concept2>& other, const Map& , typename ::boost::enable_if< ::boost::mpl::and_< ::boost::type_erasure::detail::check_map<Concept, Map>, ::boost::type_erasure::is_subconcept<Concept, Concept2, Map> > >::type* = 0 )
boost::type_erasure::binding::binding	type_erasure/binding.hpp	/^    binding(const binding<Concept2>& other, const static_binding<Map>&$/;"	f	class:boost::type_erasure::binding	access:public	signature:(const binding<Concept2>& other, const static_binding<Map>& , typename ::boost::enable_if< ::boost::mpl::and_< ::boost::type_erasure::detail::check_map<Concept, Map>, ::boost::type_erasure::is_subconcept<Concept, Concept2, Map> > >::type* = 0 )
boost::type_erasure::binding::binding	type_erasure/binding.hpp	/^    binding(const static_binding<Map>&)$/;"	f	class:boost::type_erasure::binding	access:public	signature:(const static_binding<Map>&)
boost::type_erasure::binding::binding	type_erasure/binding.hpp	/^    explicit binding(const Map&)$/;"	f	class:boost::type_erasure::binding	access:public	signature:(const Map&)
boost::type_erasure::binding::find	type_erasure/binding.hpp	/^    typename T::type find() const { return impl.table->lookup((T*)0); }$/;"	f	class:boost::type_erasure::binding	access:public	signature:() const
boost::type_erasure::binding::impl	type_erasure/binding.hpp	/^    } impl;$/;"	m	class:boost::type_erasure::binding	typeref:struct:boost::type_erasure::binding::impl_type	access:private
boost::type_erasure::binding::impl_type	type_erasure/binding.hpp	/^    struct impl_type$/;"	s	class:boost::type_erasure::binding	access:private
boost::type_erasure::binding::impl_type::impl_type	type_erasure/binding.hpp	/^        impl_type() {$/;"	f	struct:boost::type_erasure::binding::impl_type	access:public	signature:()
boost::type_erasure::binding::impl_type::impl_type	type_erasure/binding.hpp	/^        impl_type(const binding<Concept2>& other, const static_binding<Map>&, boost::mpl::false_)$/;"	f	struct:boost::type_erasure::binding::impl_type	access:public	signature:(const binding<Concept2>& other, const static_binding<Map>&, boost::mpl::false_)
boost::type_erasure::binding::impl_type::impl_type	type_erasure/binding.hpp	/^        impl_type(const binding<Concept2>& other, const static_binding<Map>&, boost::mpl::true_)$/;"	f	struct:boost::type_erasure::binding::impl_type	access:public	signature:(const binding<Concept2>& other, const static_binding<Map>&, boost::mpl::true_)
boost::type_erasure::binding::impl_type::impl_type	type_erasure/binding.hpp	/^        impl_type(const static_binding<Map>&)$/;"	f	struct:boost::type_erasure::binding::impl_type	access:public	signature:(const static_binding<Map>&)
boost::type_erasure::binding::impl_type::manager	type_erasure/binding.hpp	/^        ::boost::shared_ptr<table_type> manager;$/;"	m	struct:boost::type_erasure::binding::impl_type	access:public
boost::type_erasure::binding::impl_type::table	type_erasure/binding.hpp	/^        const table_type* table;$/;"	m	struct:boost::type_erasure::binding::impl_type	access:public
boost::type_erasure::binding::normalized	type_erasure/binding.hpp	/^        Concept>::type normalized;$/;"	t	class:boost::type_erasure::binding	access:private
boost::type_erasure::binding::operator !=	type_erasure/binding.hpp	/^    friend bool operator!=(const binding& lhs, const binding& rhs)$/;"	f	class:boost::type_erasure::binding	access:friend	signature:(const binding& lhs, const binding& rhs)
boost::type_erasure::binding::operator ==	type_erasure/binding.hpp	/^    friend bool operator==(const binding& lhs, const binding& rhs)$/;"	f	class:boost::type_erasure::binding	access:friend	signature:(const binding& lhs, const binding& rhs)
boost::type_erasure::binding::placeholder_subs	type_erasure/binding.hpp	/^    >::type placeholder_subs;$/;"	t	class:boost::type_erasure::binding	access:private
boost::type_erasure::binding::table_type	type_erasure/binding.hpp	/^        actual_concept>::type table_type;$/;"	t	class:boost::type_erasure::binding	access:private
boost::type_erasure::binding_of	type_erasure/binding_of.hpp	/^const binding<Concept>& binding_of(const any<Concept, T>& arg)$/;"	f	namespace:boost::type_erasure	signature:(const any<Concept, T>& arg)
boost::type_erasure::call	type_erasure/call.hpp	/^call(const Op&, U&&... args);$/;"	p	namespace:boost::type_erasure	signature:(const Op&, U&&... args)
boost::type_erasure::callable	type_erasure/callable.hpp	/^struct callable$/;"	s	namespace:boost::type_erasure
boost::type_erasure::callable::apply	type_erasure/callable.hpp	/^    static R apply(F& f, T... arg);$/;"	p	struct:boost::type_erasure::callable	access:public	signature:(F& f, T... arg)
boost::type_erasure::check_match	type_erasure/check_match.hpp	/^bool check_match(const Op& f, U&&... args);$/;"	p	namespace:boost::type_erasure	signature:(const Op& f, U&&... args)
boost::type_erasure::concept_interface	type_erasure/builtin.hpp	/^struct concept_interface<assignable<T, U>, Base, T> : Base$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/concept_interface.hpp	/^struct concept_interface : Base {};$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/constructible.hpp	/^struct concept_interface<$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/iterator.hpp	/^struct concept_interface<bidirectional_iterator<T, Reference, DifferenceType, ValueType>, Base, T>$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/iterator.hpp	/^struct concept_interface<forward_iterator<T, Reference, DifferenceType, ValueType>, Base, T>$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/iterator.hpp	/^struct concept_interface<iterator< ::boost::bidirectional_traversal_tag, T, Reference, DifferenceType, ValueType>, Base, T>$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/iterator.hpp	/^struct concept_interface<iterator< ::boost::forward_traversal_tag, T, Reference, DifferenceType, ValueType>, Base, T>$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/iterator.hpp	/^struct concept_interface<iterator< ::boost::no_traversal_tag, T, Reference, DifferenceType, ValueType>, Base, T>$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/iterator.hpp	/^struct concept_interface<iterator< ::boost::random_access_traversal_tag, T, Reference, DifferenceType, ValueType>, Base, T>$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/iterator.hpp	/^struct concept_interface<random_access_iterator<T, Reference, DifferenceType, ValueType>, Base, T>$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/operators.hpp	/^struct concept_interface<$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/operators.hpp	/^struct concept_interface<dereferenceable<R, T>, Base, T> : Base$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/operators.hpp	/^struct concept_interface<equality_comparable<T, U>, Base, T> : Base$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/operators.hpp	/^struct concept_interface<istreamable<Is, T>, Base, Is> : Base$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/operators.hpp	/^struct concept_interface<less_than_comparable<T, T>, Base, T> : Base$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/operators.hpp	/^struct concept_interface<less_than_comparable<T, U>, Base, T> : Base$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/operators.hpp	/^struct concept_interface<ostreamable<Os, T>, Base, Os> : Base$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface	type_erasure/operators.hpp	/^struct concept_interface<subscriptable<R, T, N>, Base, typename ::boost::remove_const<T>::type,$/;"	s	namespace:boost::type_erasure	inherits:Base
boost::type_erasure::concept_interface::_boost_type_erasure_deduce_assign	type_erasure/builtin.hpp	/^    assignable<T, U>* _boost_type_erasure_deduce_assign($/;"	f	struct:boost::type_erasure::concept_interface	access:public	signature:( typename ::boost::type_erasure::rebind_any<Base, const U&>::type)
boost::type_erasure::concept_interface::_boost_type_erasure_deduce_constructor	type_erasure/constructible.hpp	/^    _boost_type_erasure_deduce_constructor($/;"	f	struct:boost::type_erasure::concept_interface	access:public	signature:( typename ::boost::type_erasure::as_param<Base, T>::type...)
boost::type_erasure::concept_interface::difference_type	type_erasure/iterator.hpp	/^    typedef DifferenceType difference_type;$/;"	t	struct:boost::type_erasure::concept_interface	access:public
boost::type_erasure::concept_interface::iterator_category	type_erasure/iterator.hpp	/^    typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	struct:boost::type_erasure::concept_interface	access:public
boost::type_erasure::concept_interface::iterator_category	type_erasure/iterator.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	struct:boost::type_erasure::concept_interface	access:public
boost::type_erasure::concept_interface::iterator_category	type_erasure/iterator.hpp	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	struct:boost::type_erasure::concept_interface	access:public
boost::type_erasure::concept_interface::operator !=	type_erasure/operators.hpp	/^    friend bool operator!=(const T& lhs, const typename derived<Base>::type& rhs)$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const T& lhs, const typename derived<Base>::type& rhs)
boost::type_erasure::concept_interface::operator !=	type_erasure/operators.hpp	/^    friend bool operator!=(const typename derived<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, typename as_param<Base, const U&>::type rhs)
boost::type_erasure::concept_interface::operator *	type_erasure/operators.hpp	/^    typename ::boost::type_erasure::rebind_any<Base, R>::type operator*() const$/;"	f	struct:boost::type_erasure::concept_interface	access:public	signature:() const
boost::type_erasure::concept_interface::operator <	type_erasure/operators.hpp	/^    friend bool operator<(const T& lhs, const typename derived<Base>::type& rhs)$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const T& lhs, const typename derived<Base>::type& rhs)
boost::type_erasure::concept_interface::operator <	type_erasure/operators.hpp	/^    friend bool operator<(const typename derived<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, typename as_param<Base, const T&>::type rhs)
boost::type_erasure::concept_interface::operator <	type_erasure/operators.hpp	/^    friend bool operator<(const typename derived<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, typename as_param<Base, const U&>::type rhs)
boost::type_erasure::concept_interface::operator <<	type_erasure/operators.hpp	/^    operator<<(Os& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(Os& lhs, const typename ::boost::type_erasure::derived<Base>::type& rhs)
boost::type_erasure::concept_interface::operator <<	type_erasure/operators.hpp	/^    operator<<(typename detail::non_const_this_param<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(typename detail::non_const_this_param<Base>::type& lhs, typename ::boost::type_erasure::as_param<Base, const T&>::type rhs)
boost::type_erasure::concept_interface::operator <=	type_erasure/operators.hpp	/^    friend bool operator<=(const typename derived<Base>::type& lhs, const T& rhs)$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, const T& rhs)
boost::type_erasure::concept_interface::operator <=	type_erasure/operators.hpp	/^    friend bool operator<=(typename as_param<Base, const T&>::type lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(typename as_param<Base, const T&>::type lhs, const typename derived<Base>::type& rhs)
boost::type_erasure::concept_interface::operator <=	type_erasure/operators.hpp	/^    friend bool operator<=(typename as_param<Base, const U&>::type lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(typename as_param<Base, const U&>::type lhs, const typename derived<Base>::type& rhs)
boost::type_erasure::concept_interface::operator ==	type_erasure/operators.hpp	/^    friend bool operator==(const T& lhs, const typename derived<Base>::type& rhs)$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const T& lhs, const typename derived<Base>::type& rhs)
boost::type_erasure::concept_interface::operator ==	type_erasure/operators.hpp	/^    friend bool operator==(const typename derived<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, typename as_param<Base, const U&>::type rhs)
boost::type_erasure::concept_interface::operator >	type_erasure/operators.hpp	/^    friend bool operator>(const typename derived<Base>::type& lhs, const T& rhs)$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, const T& rhs)
boost::type_erasure::concept_interface::operator >	type_erasure/operators.hpp	/^    friend bool operator>(typename as_param<Base, const T&>::type lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(typename as_param<Base, const T&>::type lhs, const typename derived<Base>::type& rhs)
boost::type_erasure::concept_interface::operator >	type_erasure/operators.hpp	/^    friend bool operator>(typename as_param<Base, const U&>::type lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(typename as_param<Base, const U&>::type lhs, const typename derived<Base>::type& rhs)
boost::type_erasure::concept_interface::operator >=	type_erasure/operators.hpp	/^    friend bool operator>=(const T& lhs, const typename derived<Base>::type& rhs)$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const T& lhs, const typename derived<Base>::type& rhs)
boost::type_erasure::concept_interface::operator >=	type_erasure/operators.hpp	/^    friend bool operator>=(const typename derived<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, typename as_param<Base, const T&>::type rhs)
boost::type_erasure::concept_interface::operator >=	type_erasure/operators.hpp	/^    friend bool operator>=(const typename derived<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, typename as_param<Base, const U&>::type rhs)
boost::type_erasure::concept_interface::operator >>	type_erasure/operators.hpp	/^    operator>>(Is& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(Is& lhs, typename ::boost::type_erasure::derived<Base>::type& rhs)
boost::type_erasure::concept_interface::operator >>	type_erasure/operators.hpp	/^    operator>>(typename detail::non_const_this_param<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(typename detail::non_const_this_param<Base>::type& lhs, typename ::boost::type_erasure::as_param<Base, T&>::type rhs)
boost::type_erasure::concept_interface::operator []	type_erasure/operators.hpp	/^    typename ::boost::type_erasure::rebind_any<Base, R>::type operator[]($/;"	f	struct:boost::type_erasure::concept_interface	access:public	signature:( typename ::boost::type_erasure::as_param<Base, const N&>::type index)
boost::type_erasure::concept_interface::operator []	type_erasure/operators.hpp	/^    typename ::boost::type_erasure::rebind_any<Base, R>::type operator[]($/;"	f	struct:boost::type_erasure::concept_interface	access:public	signature:( typename ::boost::type_erasure::as_param<Base, const N&>::type index) const
boost::type_erasure::concept_interface::pointer	type_erasure/iterator.hpp	/^    >::type pointer;$/;"	t	struct:boost::type_erasure::concept_interface	access:public
boost::type_erasure::concept_interface::reference	type_erasure/iterator.hpp	/^    >::type reference;$/;"	t	struct:boost::type_erasure::concept_interface	access:public
boost::type_erasure::concept_interface::value_type	type_erasure/iterator.hpp	/^    typedef typename rebind_any<Base, ValueType>::type value_type;$/;"	t	struct:boost::type_erasure::concept_interface	access:public
boost::type_erasure::concept_of	type_erasure/concept_of.hpp	/^struct concept_of$/;"	s	namespace:boost::type_erasure
boost::type_erasure::concept_of	type_erasure/concept_of.hpp	/^struct concept_of< ::boost::type_erasure::any<Concept, T> >$/;"	s	namespace:boost::type_erasure
boost::type_erasure::concept_of	type_erasure/concept_of.hpp	/^struct concept_of< ::boost::type_erasure::param<Concept, T> >$/;"	s	namespace:boost::type_erasure
boost::type_erasure::concept_of::type	type_erasure/concept_of.hpp	/^    typedef Concept type;$/;"	t	struct:boost::type_erasure::concept_of	access:public
boost::type_erasure::concept_of::type	type_erasure/concept_of.hpp	/^    typedef detail::unspecified type;$/;"	t	struct:boost::type_erasure::concept_of	access:public
boost::type_erasure::constructible	type_erasure/constructible.hpp	/^struct constructible {};$/;"	s	namespace:boost::type_erasure
boost::type_erasure::constructible	type_erasure/constructible.hpp	/^struct constructible<R(T...)>$/;"	s	namespace:boost::type_erasure
boost::type_erasure::constructible::apply	type_erasure/constructible.hpp	/^    apply(T... arg)$/;"	f	struct:boost::type_erasure::constructible	access:public	signature:(T.... arg)
boost::type_erasure::copy_constructible	type_erasure/builtin.hpp	/^struct copy_constructible :$/;"	s	namespace:boost::type_erasure	inherits:::boost::mpl::vector
boost::type_erasure::deduced	type_erasure/deduced.hpp	/^struct deduced : ::boost::type_erasure::placeholder$/;"	s	namespace:boost::type_erasure	inherits:::boost::type_erasure::placeholder
boost::type_erasure::deduced::type	type_erasure/deduced.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::deduced	access:public
boost::type_erasure::dereferenceable	type_erasure/operators.hpp	/^struct dereferenceable$/;"	s	namespace:boost::type_erasure
boost::type_erasure::dereferenceable::apply	type_erasure/operators.hpp	/^    static R apply(const T& arg) { return *arg; }$/;"	f	struct:boost::type_erasure::dereferenceable	access:public	signature:(const T& arg)
boost::type_erasure::derived	type_erasure/derived.hpp	/^struct derived$/;"	s	namespace:boost::type_erasure
boost::type_erasure::derived::type	type_erasure/derived.hpp	/^    typedef detail::unspecified type;$/;"	t	struct:boost::type_erasure::derived	access:public
boost::type_erasure::destructible	type_erasure/builtin.hpp	/^struct destructible$/;"	s	namespace:boost::type_erasure
boost::type_erasure::destructible::apply	type_erasure/builtin.hpp	/^    static void apply(detail::storage& arg)$/;"	f	struct:boost::type_erasure::destructible	access:public	signature:(detail::storage& arg)
boost::type_erasure::destructible::type	type_erasure/builtin.hpp	/^    typedef void (*type)(detail::storage&);$/;"	t	struct:boost::type_erasure::destructible	access:public
boost::type_erasure::destructible::value	type_erasure/builtin.hpp	/^    static void value(detail::storage& arg)$/;"	f	struct:boost::type_erasure::destructible	access:public	signature:(detail::storage& arg)
boost::type_erasure::detail	type_erasure/any.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/any_cast.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/binding.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/builtin.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/call.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/callable.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/check_match.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/constructible.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/detail/access.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/detail/adapt_to_vtable.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/detail/check_call.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/detail/check_map.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/detail/const.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/detail/extract_concept.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/detail/get_placeholders.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/detail/get_signature.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/detail/instantiate.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/detail/normalize.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/detail/normalize_deduced.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/detail/null.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/detail/rebind_placeholders.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/detail/storage.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/detail/vtable.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/free.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/is_subconcept.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/iterator.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/operators.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/param.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/relaxed.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail	type_erasure/require_match.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
boost::type_erasure::detail::access	type_erasure/detail/access.hpp	/^struct access$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::access::data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, T&&> >& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, T&&> >& arg)
boost::type_erasure::detail::access::data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, const T&> >& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, const T&> >& arg)
boost::type_erasure::detail::access::data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::any_base<Derived>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::any_base<Derived>& arg)
boost::type_erasure::detail::access::data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::any_base<Derived>&& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::any_base<Derived>&& arg)
boost::type_erasure::detail::access::data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::param<Concept, T&&>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::param<Concept, T&&>& arg)
boost::type_erasure::detail::access::data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::param<Concept, T>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::param<Concept, T>& arg)
boost::type_erasure::detail::access::data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::param<Concept, T>&& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::param<Concept, T>&& arg)
boost::type_erasure::detail::access::data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::param<Concept, const T&>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::param<Concept, const T&>& arg)
boost::type_erasure::detail::access::data	type_erasure/detail/access.hpp	/^    data(const ::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, T&&> >& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, T&&> >& arg)
boost::type_erasure::detail::access::data	type_erasure/detail/access.hpp	/^    data(const ::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, T&> >& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, T&> >& arg)
boost::type_erasure::detail::access::data	type_erasure/detail/access.hpp	/^    data(const ::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, const T&> >& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, const T&> >& arg)
boost::type_erasure::detail::access::data	type_erasure/detail/access.hpp	/^    data(const ::boost::type_erasure::any_base<Derived>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::any_base<Derived>& arg)
boost::type_erasure::detail::access::data	type_erasure/detail/access.hpp	/^    data(const ::boost::type_erasure::param<Concept, T&&>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::param<Concept, T&&>& arg)
boost::type_erasure::detail::access::data	type_erasure/detail/access.hpp	/^    data(const ::boost::type_erasure::param<Concept, T>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::param<Concept, T>& arg)
boost::type_erasure::detail::access::table	type_erasure/detail/access.hpp	/^    table(const ::boost::type_erasure::any_base<Derived>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::any_base<Derived>& arg)
boost::type_erasure::detail::access::table	type_erasure/detail/access.hpp	/^    table(const ::boost::type_erasure::param<Concept, T>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::param<Concept, T>& arg)
boost::type_erasure::detail::adapt_to_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct adapt_to_vtable$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::adapt_to_vtable::type	type_erasure/detail/adapt_to_vtable.hpp	/^    > type;$/;"	t	struct:boost::type_erasure::detail::adapt_to_vtable	access:public
boost::type_erasure::detail::add_deduced	type_erasure/detail/normalize.hpp	/^struct add_deduced$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::add_deduced::BOOST_MPL_ASSERT	type_erasure/detail/normalize.hpp	/^    BOOST_MPL_ASSERT((boost::is_same<typename ::boost::mpl::at<type, typename P::second>::type, result>));$/;"	p	struct:boost::type_erasure::detail::add_deduced	access:public	signature:(boost::is_same<typename ::boost::mpl::at<type, typename P::second>::type, result>)
boost::type_erasure::detail::add_deduced::result	type_erasure/detail/normalize.hpp	/^    >::type result;$/;"	t	struct:boost::type_erasure::detail::add_deduced	access:public
boost::type_erasure::detail::add_deduced::type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::add_deduced	access:public
boost::type_erasure::detail::add_deductions	type_erasure/detail/normalize.hpp	/^struct add_deductions$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::add_deductions::type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::add_deductions	access:public
boost::type_erasure::detail::add_typeinfo	type_erasure/detail/normalize.hpp	/^struct add_typeinfo$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::add_typeinfo::placeholders	type_erasure/detail/normalize.hpp	/^    >::type placeholders;$/;"	t	struct:boost::type_erasure::detail::add_typeinfo	access:public
boost::type_erasure::detail::add_typeinfo::type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::add_typeinfo	access:public
boost::type_erasure::detail::append_typeinfo	type_erasure/detail/normalize.hpp	/^struct append_typeinfo$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::append_typeinfo::apply	type_erasure/detail/normalize.hpp	/^    struct apply$/;"	s	struct:boost::type_erasure::detail::append_typeinfo	access:public
boost::type_erasure::detail::append_typeinfo::apply::type	type_erasure/detail/normalize.hpp	/^        >::type type;$/;"	t	struct:boost::type_erasure::detail::append_typeinfo::apply	access:public
boost::type_erasure::detail::can_optimize_conversion	type_erasure/binding.hpp	/^struct can_optimize_conversion : ::boost::mpl::and_<$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::and_::type
boost::type_erasure::detail::check_any_cast	type_erasure/any_cast.hpp	/^bool check_any_cast(const any<Concept, Tag>& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(const any<Concept, Tag>& arg)
boost::type_erasure::detail::check_any_cast	type_erasure/any_cast.hpp	/^bool check_any_cast(const any<Concept, Tag>& arg, ::boost::mpl::false_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const any<Concept, Tag>& arg, ::boost::mpl::false_)
boost::type_erasure::detail::check_any_cast	type_erasure/any_cast.hpp	/^bool check_any_cast(const any<Concept, Tag>&, ::boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const any<Concept, Tag>&, ::boost::mpl::true_)
boost::type_erasure::detail::check_arg	type_erasure/detail/check_call.hpp	/^struct check_arg$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::check_arg::type	type_erasure/detail/check_call.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::check_arg	access:public
boost::type_erasure::detail::check_call	type_erasure/detail/check_call.hpp	/^struct check_call : ::boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::false_
boost::type_erasure::detail::check_map	type_erasure/detail/check_map.hpp	/^struct check_map {$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::check_map	type_erasure/detail/check_map.hpp	/^struct check_map<Concept, ::boost::type_erasure::static_binding<Map> > :$/;"	s	namespace:boost::type_erasure::detail	inherits:check_map
boost::type_erasure::detail::check_map::basic_components	type_erasure/detail/check_map.hpp	/^    typedef typename normalize_concept<Concept>::basic basic_components;$/;"	t	struct:boost::type_erasure::detail::check_map	access:public
boost::type_erasure::detail::check_map::indirect_deduced_placeholders	type_erasure/detail/check_map.hpp	/^    >::type indirect_deduced_placeholders;$/;"	t	struct:boost::type_erasure::detail::check_map	access:public
boost::type_erasure::detail::check_map::placeholder_subs	type_erasure/detail/check_map.hpp	/^        Concept>::type placeholder_subs;$/;"	t	struct:boost::type_erasure::detail::check_map	access:public
boost::type_erasure::detail::check_map::placeholders	type_erasure/detail/check_map.hpp	/^    >::type placeholders;$/;"	t	struct:boost::type_erasure::detail::check_map	access:public
boost::type_erasure::detail::check_map::type	type_erasure/detail/check_map.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::check_map	access:public
boost::type_erasure::detail::check_overload	type_erasure/any.hpp	/^no check_overload(const void*);$/;"	p	namespace:boost::type_erasure::detail	signature:(const void*)
boost::type_erasure::detail::check_overload	type_erasure/any.hpp	/^yes check_overload(const Op*);$/;"	p	namespace:boost::type_erasure::detail	signature:(const Op*)
boost::type_erasure::detail::check_placeholder_arg	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg :$/;"	s	namespace:boost::type_erasure::detail	inherits:check_placeholder_arg_impl::type
boost::type_erasure::detail::check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl : ::boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::false_
boost::type_erasure::detail::check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<P&&, P&&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
boost::type_erasure::detail::check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<P&, P&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
boost::type_erasure::detail::check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<P, P&&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
boost::type_erasure::detail::check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<P, P&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
boost::type_erasure::detail::check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<P, const P&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
boost::type_erasure::detail::check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<const P&, P&&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
boost::type_erasure::detail::check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<const P&, P&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
boost::type_erasure::detail::check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<const P&, const P&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
boost::type_erasure::detail::collect_concepts	type_erasure/detail/normalize.hpp	/^struct collect_concepts$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::collect_concepts::transformed	type_erasure/detail/normalize.hpp	/^    >::type transformed;$/;"	t	struct:boost::type_erasure::detail::collect_concepts	access:public
boost::type_erasure::detail::collect_concepts::type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::collect_concepts	access:public
boost::type_erasure::detail::collect_concepts::type1	type_erasure/detail/normalize.hpp	/^    >::type type1;$/;"	t	struct:boost::type_erasure::detail::collect_concepts	access:public
boost::type_erasure::detail::combine_concepts	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<T, T> { typedef T type; };$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::combine_concepts	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<T, void> { typedef T type; };$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::combine_concepts	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<void, T> { typedef T type; };$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::combine_concepts	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<void, void> { typedef void type; };$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::combine_concepts::type	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<T, T> { typedef T type; };$/;"	t	struct:boost::type_erasure::detail::combine_concepts	access:public
boost::type_erasure::detail::combine_concepts::type	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<T, void> { typedef T type; };$/;"	t	struct:boost::type_erasure::detail::combine_concepts	access:public
boost::type_erasure::detail::combine_concepts::type	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<void, T> { typedef T type; };$/;"	t	struct:boost::type_erasure::detail::combine_concepts	access:public
boost::type_erasure::detail::combine_concepts::type	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<void, void> { typedef void type; };$/;"	t	struct:boost::type_erasure::detail::combine_concepts	access:public
boost::type_erasure::detail::compare_vtable	type_erasure/detail/vtable.hpp	/^struct compare_vtable<> {$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::compare_vtable	type_erasure/detail/vtable.hpp	/^struct compare_vtable<T0, T...> {$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::compare_vtable::apply	type_erasure/detail/vtable.hpp	/^    static bool apply(const S& s1, const S& s2)$/;"	f	struct:boost::type_erasure::detail::compare_vtable	access:public	signature:(const S& s1, const S& s2)
boost::type_erasure::detail::compute_bases	type_erasure/any.hpp	/^struct compute_bases$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::compute_bases::type	type_erasure/any.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::compute_bases	access:public
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^::boost::type_erasure::detail::storage& convert_arg(any_base<T>& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(any_base<T>& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^T& convert_arg(T& arg, boost::mpl::false_) { return arg; }$/;"	f	namespace:boost::type_erasure::detail	signature:(T& arg, boost::mpl::false_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^T&& convert_arg(T&& arg, boost::mpl::false_) { return std::forward<T>(arg); }$/;"	f	namespace:boost::type_erasure::detail	signature:(T&& arg, boost::mpl::false_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(any_base<any<Concept, T&&> >& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(any_base<any<Concept, T&&> >& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(any_base<any<Concept, T&> >&& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(any_base<any<Concept, T&> >&& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(any_base<any<Concept, T> >&& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(any_base<any<Concept, T> >&& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(any_base<any<Concept, const T&> >& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(any_base<any<Concept, const T&> >& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(any_base<any<Concept, const T&> >&& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(any_base<any<Concept, const T&> >&& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(const any_base<T>& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const any_base<T>& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(const any_base<any<Concept, T&&> >& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const any_base<any<Concept, T&&> >& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(const any_base<any<Concept, T&> >& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const any_base<any<Concept, T&> >& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(const any_base<any<Concept, const T&> >& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const any_base<any<Concept, const T&> >& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(const param<Concept, T&&>& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const param<Concept, T&&>& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(const param<Concept, T>& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const param<Concept, T>& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(param<Concept, T&&>& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(param<Concept, T&&>& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(param<Concept, T&>&& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(param<Concept, T&>&& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(param<Concept, T>& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(param<Concept, T>& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(param<Concept, T>&& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(param<Concept, T>&& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(param<Concept, const T&>& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(param<Concept, const T&>& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_arg	type_erasure/call.hpp	/^convert_arg(param<Concept, const T&>&& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(param<Concept, const T&>&& arg, boost::mpl::true_)
boost::type_erasure::detail::convert_deduced	type_erasure/detail/normalize.hpp	/^struct convert_deduced$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::convert_deduced::BOOST_MPL_ASSERT	type_erasure/detail/normalize.hpp	/^    BOOST_MPL_ASSERT((boost::is_same<typename ::boost::mpl::at<type, typename P::second>::type, result>));$/;"	p	struct:boost::type_erasure::detail::convert_deduced	access:public	signature:(boost::is_same<typename ::boost::mpl::at<type, typename P::second>::type, result>)
boost::type_erasure::detail::convert_deduced::result	type_erasure/detail/normalize.hpp	/^    typedef typename ::boost::mpl::at<Sub, result1>::type result;$/;"	t	struct:boost::type_erasure::detail::convert_deduced	access:public
boost::type_erasure::detail::convert_deduced::result1	type_erasure/detail/normalize.hpp	/^    >::type result1;$/;"	t	struct:boost::type_erasure::detail::convert_deduced	access:public
boost::type_erasure::detail::convert_deduced::type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::convert_deduced	access:public
boost::type_erasure::detail::convert_deductions	type_erasure/detail/normalize.hpp	/^struct convert_deductions$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::convert_deductions::type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::convert_deductions	access:public
boost::type_erasure::detail::create_placeholder_map	type_erasure/detail/normalize.hpp	/^struct create_placeholder_map$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::create_placeholder_map::type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::create_placeholder_map	access:public
boost::type_erasure::detail::extract	type_erasure/detail/storage.hpp	/^T extract(T arg) { return arg; }$/;"	f	namespace:boost::type_erasure::detail	signature:(T arg)
boost::type_erasure::detail::extract	type_erasure/detail/storage.hpp	/^T extract(T arg) { return std::forward<T>(arg); }$/;"	f	namespace:boost::type_erasure::detail	signature:(T arg)
boost::type_erasure::detail::extract	type_erasure/detail/storage.hpp	/^T extract(const storage& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(const storage& arg)
boost::type_erasure::detail::extract	type_erasure/detail/storage.hpp	/^T extract(storage& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(storage& arg)
boost::type_erasure::detail::extract	type_erasure/detail/storage.hpp	/^T extract(storage&& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(storage&& arg)
boost::type_erasure::detail::extract_concept	type_erasure/detail/extract_concept.hpp	/^struct extract_concept<R(T0, T...), U0, U...>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::extract_concept	type_erasure/detail/extract_concept.hpp	/^struct extract_concept<void()>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::extract_concept::type	type_erasure/detail/extract_concept.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::extract_concept	access:public
boost::type_erasure::detail::extract_concept::type	type_erasure/detail/extract_concept.hpp	/^    typedef void type;$/;"	t	struct:boost::type_erasure::detail::extract_concept	access:public
boost::type_erasure::detail::fallback	type_erasure/any.hpp	/^struct fallback {};$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::first_placeholder	type_erasure/free.hpp	/^struct first_placeholder {$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::first_placeholder	type_erasure/free.hpp	/^struct first_placeholder<> {};$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::first_placeholder::type	type_erasure/free.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::first_placeholder	access:public
boost::type_erasure::detail::first_placeholder_index	type_erasure/free.hpp	/^struct first_placeholder_index :$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::eval_if::type
boost::type_erasure::detail::get_null_vtable_entry	type_erasure/builtin.hpp	/^struct get_null_vtable_entry< ::boost::type_erasure::destructible<T> >$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::get_null_vtable_entry	type_erasure/builtin.hpp	/^struct get_null_vtable_entry< ::boost::type_erasure::typeid_<T> >$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::get_null_vtable_entry	type_erasure/constructible.hpp	/^struct get_null_vtable_entry<vtable_adapter<constructible<T(const T&)>, R(U...)> >$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::get_null_vtable_entry	type_erasure/detail/null.hpp	/^struct get_null_vtable_entry {$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::get_null_vtable_entry::type	type_erasure/builtin.hpp	/^    typedef ::boost::type_erasure::detail::null_destroy type;$/;"	t	struct:boost::type_erasure::detail::get_null_vtable_entry	access:public
boost::type_erasure::detail::get_null_vtable_entry::type	type_erasure/builtin.hpp	/^    typedef typeid_<void> type;$/;"	t	struct:boost::type_erasure::detail::get_null_vtable_entry	access:public
boost::type_erasure::detail::get_null_vtable_entry::type	type_erasure/constructible.hpp	/^    typedef null_construct<void(U...)> type;$/;"	t	struct:boost::type_erasure::detail::get_null_vtable_entry	access:public
boost::type_erasure::detail::get_null_vtable_entry::type	type_erasure/detail/null.hpp	/^        typename ::boost::remove_pointer<typename Concept::type>::type> type;$/;"	t	struct:boost::type_erasure::detail::get_null_vtable_entry	access:public
boost::type_erasure::detail::get_placeholder_normalization_map	type_erasure/detail/normalize.hpp	/^struct get_placeholder_normalization_map$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::get_placeholder_normalization_map::type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::get_placeholder_normalization_map	access:public
boost::type_erasure::detail::get_placeholders	type_erasure/detail/get_placeholders.hpp	/^struct get_placeholders<T<U...>, Out>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::get_placeholders::type	type_erasure/detail/get_placeholders.hpp	/^    typedef typename get_placeholders_impl<Out, U...>::type type;$/;"	t	struct:boost::type_erasure::detail::get_placeholders	access:public
boost::type_erasure::detail::get_placeholders_impl	type_erasure/detail/get_placeholders.hpp	/^struct get_placeholders_impl<Out, T0, T...>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::get_placeholders_impl	type_erasure/detail/get_placeholders.hpp	/^struct get_placeholders_impl<Out>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::get_placeholders_impl::type	type_erasure/detail/get_placeholders.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::get_placeholders_impl	access:public
boost::type_erasure::detail::get_placeholders_impl::type	type_erasure/detail/get_placeholders.hpp	/^    typedef Out type;$/;"	t	struct:boost::type_erasure::detail::get_placeholders_impl	access:public
boost::type_erasure::detail::get_placeholders_in_argument	type_erasure/detail/get_placeholders.hpp	/^struct get_placeholders_in_argument$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::get_placeholders_in_argument	type_erasure/detail/get_placeholders.hpp	/^struct get_placeholders_in_argument<R(T...), Out>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::get_placeholders_in_argument	type_erasure/detail/get_placeholders.hpp	/^struct get_placeholders_in_argument<T&, Out>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::get_placeholders_in_argument	type_erasure/detail/get_placeholders.hpp	/^struct get_placeholders_in_argument<const T, Out>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::get_placeholders_in_argument::type	type_erasure/detail/get_placeholders.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::get_placeholders_in_argument	access:public
boost::type_erasure::detail::get_placeholders_in_argument::type	type_erasure/detail/get_placeholders.hpp	/^    typedef typename get_placeholders_impl<type0, T...>::type type;$/;"	t	struct:boost::type_erasure::detail::get_placeholders_in_argument	access:public
boost::type_erasure::detail::get_placeholders_in_argument::type0	type_erasure/detail/get_placeholders.hpp	/^    >::type type0;$/;"	t	struct:boost::type_erasure::detail::get_placeholders_in_argument	access:public
boost::type_erasure::detail::get_pointer	type_erasure/any_cast.hpp	/^const void* get_pointer(::boost::type_erasure::any<Concept, const T&>& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(::boost::type_erasure::any<Concept, const T&>& arg)
boost::type_erasure::detail::get_pointer	type_erasure/any_cast.hpp	/^const void* get_pointer(const ::boost::type_erasure::any<Concept, T>& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(const ::boost::type_erasure::any<Concept, T>& arg)
boost::type_erasure::detail::get_pointer	type_erasure/any_cast.hpp	/^const void* get_pointer(const ::boost::type_erasure::any<Concept, const T&>& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(const ::boost::type_erasure::any<Concept, const T&>& arg)
boost::type_erasure::detail::get_pointer	type_erasure/any_cast.hpp	/^void* get_pointer(::boost::type_erasure::any<Concept, T&>& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(::boost::type_erasure::any<Concept, T&>& arg)
boost::type_erasure::detail::get_pointer	type_erasure/any_cast.hpp	/^void* get_pointer(::boost::type_erasure::any<Concept, T>& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(::boost::type_erasure::any<Concept, T>& arg)
boost::type_erasure::detail::get_pointer	type_erasure/any_cast.hpp	/^void* get_pointer(const ::boost::type_erasure::any<Concept, T&>& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(const ::boost::type_erasure::any<Concept, T&>& arg)
boost::type_erasure::detail::get_signature	type_erasure/detail/get_signature.hpp	/^struct get_signature {$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::get_signature::type	type_erasure/detail/get_signature.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::get_signature	access:public
boost::type_erasure::detail::get_vtable_signature	type_erasure/detail/adapt_to_vtable.hpp	/^struct get_vtable_signature<R(T...)>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::get_vtable_signature::type	type_erasure/detail/adapt_to_vtable.hpp	/^    >::type type(typename ::boost::type_erasure::detail::replace_param_for_vtable<T>::type...);$/;"	t	struct:boost::type_erasure::detail::get_vtable_signature	access:public
boost::type_erasure::detail::identity	type_erasure/detail/rebind_placeholders.hpp	/^struct identity$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::identity::type	type_erasure/detail/rebind_placeholders.hpp	/^    typedef T type;$/;"	t	struct:boost::type_erasure::detail::identity	access:public
boost::type_erasure::detail::insert_concept	type_erasure/detail/normalize.hpp	/^struct insert_concept$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::insert_concept	type_erasure/detail/normalize.hpp	/^struct insert_concept<Out, ::boost::type_erasure::same_type<T, U> >$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::insert_concept::t1	type_erasure/detail/normalize.hpp	/^    >::type t1;$/;"	t	struct:boost::type_erasure::detail::insert_concept	access:public
boost::type_erasure::detail::insert_concept::t2	type_erasure/detail/normalize.hpp	/^    >::type t2;$/;"	t	struct:boost::type_erasure::detail::insert_concept	access:public
boost::type_erasure::detail::insert_concept::type	type_erasure/detail/normalize.hpp	/^    > type;$/;"	t	struct:boost::type_erasure::detail::insert_concept	access:public
boost::type_erasure::detail::is_any	type_erasure/any.hpp	/^struct is_any : ::boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::false_
boost::type_erasure::detail::is_any	type_erasure/any.hpp	/^struct is_any<any<Concept, T> > : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
boost::type_erasure::detail::is_deduced	type_erasure/detail/check_map.hpp	/^struct is_deduced : boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::false_
boost::type_erasure::detail::is_deduced	type_erasure/detail/check_map.hpp	/^struct is_deduced< ::boost::type_erasure::deduced<T> > : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
boost::type_erasure::detail::is_internal_concept	type_erasure/detail/adapt_to_vtable.hpp	/^struct is_internal_concept :$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::type_erasure::detail::has_type
boost::type_erasure::detail::is_non_const_ref	type_erasure/detail/const.hpp	/^struct is_non_const_ref : boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::false_
boost::type_erasure::detail::is_non_const_ref	type_erasure/detail/const.hpp	/^struct is_non_const_ref<T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
boost::type_erasure::detail::is_non_const_ref	type_erasure/detail/const.hpp	/^struct is_non_const_ref<const T&> : boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::false_
boost::type_erasure::detail::is_placeholder_arg	type_erasure/call.hpp	/^struct is_placeholder_arg :$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::type_erasure::is_placeholder
boost::type_erasure::detail::is_relaxed_impl	type_erasure/relaxed.hpp	/^struct is_relaxed_impl :$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::not_::type
boost::type_erasure::detail::is_subconcept_impl	type_erasure/is_subconcept.hpp	/^struct is_subconcept_impl {$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::is_subconcept_impl::bindings	type_erasure/is_subconcept.hpp	/^    >::type bindings;$/;"	t	struct:boost::type_erasure::detail::is_subconcept_impl	access:public
boost::type_erasure::detail::is_subconcept_impl::normalized_sub	type_erasure/is_subconcept.hpp	/^        Sub>::type normalized_sub;$/;"	t	struct:boost::type_erasure::detail::is_subconcept_impl	access:public
boost::type_erasure::detail::is_subconcept_impl::placeholder_subs_sub	type_erasure/is_subconcept.hpp	/^    >::type placeholder_subs_sub;$/;"	t	struct:boost::type_erasure::detail::is_subconcept_impl	access:public
boost::type_erasure::detail::is_subconcept_impl::placeholder_subs_super	type_erasure/is_subconcept.hpp	/^    >::type placeholder_subs_super;$/;"	t	struct:boost::type_erasure::detail::is_subconcept_impl	access:public
boost::type_erasure::detail::is_subconcept_impl::super_set	type_erasure/is_subconcept.hpp	/^        Super>::concept_set super_set;$/;"	t	struct:boost::type_erasure::detail::is_subconcept_impl	access:public
boost::type_erasure::detail::is_subconcept_impl::transform	type_erasure/is_subconcept.hpp	/^    >::type transform;$/;"	t	struct:boost::type_erasure::detail::is_subconcept_impl	access:public
boost::type_erasure::detail::is_subconcept_impl::type	type_erasure/is_subconcept.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::is_subconcept_impl	access:public
boost::type_erasure::detail::iterator_value_type_impl	type_erasure/iterator.hpp	/^struct iterator_value_type_impl$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::iterator_value_type_impl::type	type_erasure/iterator.hpp	/^    typedef typename ::std::iterator_traits<T>::value_type type;$/;"	t	struct:boost::type_erasure::detail::iterator_value_type_impl	access:public
boost::type_erasure::detail::less_impl	type_erasure/operators.hpp	/^bool less_impl(const F& f, const T& lhs, const U& rhs, ::boost::mpl::false_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const F& f, const T& lhs, const U& rhs, ::boost::mpl::false_)
boost::type_erasure::detail::less_impl	type_erasure/operators.hpp	/^bool less_impl(const F& f, const T& lhs, const U& rhs, ::boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const F& f, const T& lhs, const U& rhs, ::boost::mpl::true_)
boost::type_erasure::detail::make	type_erasure/any.hpp	/^T make(T*) { return T(); }$/;"	f	namespace:boost::type_erasure::detail	signature:(T*)
boost::type_erasure::detail::make_arg_pack	type_erasure/detail/vtable.hpp	/^struct make_arg_pack$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::make_arg_pack::type	type_erasure/detail/vtable.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::make_arg_pack	access:public
boost::type_erasure::detail::make_arg_pack_impl	type_erasure/detail/vtable.hpp	/^struct make_arg_pack_impl$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::make_arg_pack_impl	type_erasure/detail/vtable.hpp	/^struct make_arg_pack_impl<End, End, T...>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::make_arg_pack_impl::type	type_erasure/detail/vtable.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::make_arg_pack_impl	access:public
boost::type_erasure::detail::make_arg_pack_impl::type	type_erasure/detail/vtable.hpp	/^    typedef stored_arg_pack<T...> type;$/;"	t	struct:boost::type_erasure::detail::make_arg_pack_impl	access:public
boost::type_erasure::detail::make_fallback	type_erasure/any.hpp	/^const T& make_fallback(const T& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const T& arg, boost::mpl::true_)
boost::type_erasure::detail::make_fallback	type_erasure/any.hpp	/^fallback make_fallback(const T&, boost::mpl::false_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const T&, boost::mpl::false_)
boost::type_erasure::detail::make_instantiate_concept	type_erasure/detail/instantiate.hpp	/^struct make_instantiate_concept {$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::make_instantiate_concept::normalized	type_erasure/detail/instantiate.hpp	/^        Concept>::type normalized;$/;"	t	struct:boost::type_erasure::detail::make_instantiate_concept	access:public
boost::type_erasure::detail::make_instantiate_concept::type	type_erasure/detail/instantiate.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::make_instantiate_concept	access:public
boost::type_erasure::detail::make_vtable	type_erasure/detail/vtable.hpp	/^struct make_vtable$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::make_vtable::type	type_erasure/detail/vtable.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::make_vtable	access:public
boost::type_erasure::detail::make_vtable_impl	type_erasure/detail/vtable.hpp	/^struct make_vtable_impl<stored_arg_pack<T...> >$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::make_vtable_impl::type	type_erasure/detail/vtable.hpp	/^    typedef vtable_storage<T...> type;$/;"	t	struct:boost::type_erasure::detail::make_vtable_impl	access:public
boost::type_erasure::detail::make_vtable_init	type_erasure/detail/vtable.hpp	/^struct make_vtable_init$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::make_vtable_init::type	type_erasure/detail/vtable.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::make_vtable_init	access:public
boost::type_erasure::detail::make_vtable_init_impl	type_erasure/detail/vtable.hpp	/^struct make_vtable_init_impl<Table, stored_arg_pack<T...> >$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::make_vtable_init_impl::type	type_erasure/detail/vtable.hpp	/^    typedef vtable_init<Table, T...> type;$/;"	t	struct:boost::type_erasure::detail::make_vtable_init_impl	access:public
boost::type_erasure::detail::maybe_adapt_to_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct maybe_adapt_to_vtable$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::maybe_adapt_to_vtable::type	type_erasure/detail/adapt_to_vtable.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::maybe_adapt_to_vtable	access:public
boost::type_erasure::detail::maybe_check_table	type_erasure/check_match.hpp	/^bool maybe_check_table(const T& arg, const Table*& table, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const T& arg, const Table*& table, boost::mpl::true_)
boost::type_erasure::detail::maybe_check_table	type_erasure/check_match.hpp	/^bool maybe_check_table(const T&, const Table*&, boost::mpl::false_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const T&, const Table*&, boost::mpl::false_)
boost::type_erasure::detail::maybe_const_this_param	type_erasure/detail/const.hpp	/^struct maybe_const_this_param$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::maybe_const_this_param	type_erasure/detail/const.hpp	/^struct maybe_const_this_param<Placeholder&&, Base>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::maybe_const_this_param::plain_placeholder	type_erasure/detail/const.hpp	/^    typedef typename ::boost::remove_reference<Placeholder>::type plain_placeholder;$/;"	t	struct:boost::type_erasure::detail::maybe_const_this_param	access:public
boost::type_erasure::detail::maybe_const_this_param::plain_type	type_erasure/detail/const.hpp	/^    typedef typename ::boost::type_erasure::derived<Base>::type plain_type;$/;"	t	struct:boost::type_erasure::detail::maybe_const_this_param	access:public
boost::type_erasure::detail::maybe_const_this_param::self_placeholder	type_erasure/detail/const.hpp	/^    typedef typename ::boost::type_erasure::placeholder_of<plain_type>::type self_placeholder;$/;"	t	struct:boost::type_erasure::detail::maybe_const_this_param	access:public
boost::type_erasure::detail::maybe_const_this_param::type	type_erasure/detail/const.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::maybe_const_this_param	access:public
boost::type_erasure::detail::maybe_extract_concept	type_erasure/detail/extract_concept.hpp	/^struct maybe_extract_concept$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::maybe_extract_concept::type	type_erasure/detail/extract_concept.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::maybe_extract_concept	access:public
boost::type_erasure::detail::maybe_get_table	type_erasure/call.hpp	/^int maybe_get_table(const T& arg, const Table*& table, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const T& arg, const Table*& table, boost::mpl::true_)
boost::type_erasure::detail::maybe_get_table	type_erasure/call.hpp	/^int maybe_get_table(const T&, const Table*&, boost::mpl::false_) { return 0; }$/;"	f	namespace:boost::type_erasure::detail	signature:(const T&, const Table*&, boost::mpl::false_)
boost::type_erasure::detail::no	type_erasure/any.hpp	/^typedef char no;$/;"	t	namespace:boost::type_erasure::detail
boost::type_erasure::detail::non_const_this_param	type_erasure/detail/const.hpp	/^struct non_const_this_param$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::non_const_this_param::placeholder	type_erasure/detail/const.hpp	/^    typedef typename ::boost::type_erasure::placeholder_of<Base>::type placeholder;$/;"	t	struct:boost::type_erasure::detail::non_const_this_param	access:public
boost::type_erasure::detail::non_const_this_param::plain_type	type_erasure/detail/const.hpp	/^    typedef typename ::boost::type_erasure::derived<Base>::type plain_type;$/;"	t	struct:boost::type_erasure::detail::non_const_this_param	access:public
boost::type_erasure::detail::non_const_this_param::type	type_erasure/detail/const.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::non_const_this_param	access:public
boost::type_erasure::detail::normalize_concept	type_erasure/detail/normalize.hpp	/^struct normalize_concept$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::normalize_concept::basic	type_erasure/detail/normalize.hpp	/^    >::type basic;$/;"	t	struct:boost::type_erasure::detail::normalize_concept	access:public
boost::type_erasure::detail::normalize_concept::concept_set	type_erasure/detail/normalize.hpp	/^    >::type concept_set;$/;"	t	struct:boost::type_erasure::detail::normalize_concept	access:public
boost::type_erasure::detail::normalize_concept::impl	type_erasure/detail/normalize.hpp	/^    typedef typename normalize_concept_impl<Concept>::type impl;$/;"	t	struct:boost::type_erasure::detail::normalize_concept	access:public
boost::type_erasure::detail::normalize_concept::substitutions	type_erasure/detail/normalize.hpp	/^    >::type substitutions;$/;"	t	struct:boost::type_erasure::detail::normalize_concept	access:public
boost::type_erasure::detail::normalize_concept::type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::normalize_concept	access:public
boost::type_erasure::detail::normalize_concept_impl	type_erasure/detail/normalize.hpp	/^struct normalize_concept_impl$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::normalize_concept_impl::type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::normalize_concept_impl	access:public
boost::type_erasure::detail::normalize_placeholder	type_erasure/detail/normalize.hpp	/^struct normalize_placeholder$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::normalize_placeholder	type_erasure/detail/normalize.hpp	/^struct normalize_placeholder<M, ::boost::type_erasure::deduced<T> >$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::normalize_placeholder::type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::normalize_placeholder	access:public
boost::type_erasure::detail::null_construct	type_erasure/constructible.hpp	/^struct null_construct<void(T...)>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::null_construct::value	type_erasure/constructible.hpp	/^    value(T...)$/;"	f	struct:boost::type_erasure::detail::null_construct	access:public	signature:(T....)
boost::type_erasure::detail::null_destroy	type_erasure/builtin.hpp	/^struct null_destroy {$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::null_destroy::value	type_erasure/builtin.hpp	/^    static void value(::boost::type_erasure::detail::storage&) {}$/;"	f	struct:boost::type_erasure::detail::null_destroy	access:public	signature:(::boost::type_erasure::detail::storage&)
boost::type_erasure::detail::placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion : boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::false_
boost::type_erasure::detail::placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T&&, T&&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
boost::type_erasure::detail::placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T&&, T> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
boost::type_erasure::detail::placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T&&, const T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
boost::type_erasure::detail::placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T&, T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
boost::type_erasure::detail::placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T&, T> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
boost::type_erasure::detail::placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T&, const T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
boost::type_erasure::detail::placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T, T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
boost::type_erasure::detail::placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T, T> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
boost::type_erasure::detail::placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T, const T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
boost::type_erasure::detail::placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<const T&, T> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
boost::type_erasure::detail::placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<const T&, const T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
boost::type_erasure::detail::placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<const T, T> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
boost::type_erasure::detail::placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<const T, const T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
boost::type_erasure::detail::qualified_placeholder	type_erasure/detail/check_call.hpp	/^struct qualified_placeholder$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::qualified_placeholder	type_erasure/detail/check_call.hpp	/^struct qualified_placeholder<T&&, typename T::_boost_type_erasure_is_any>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::qualified_placeholder	type_erasure/detail/check_call.hpp	/^struct qualified_placeholder<T&, typename T::_boost_type_erasure_is_any>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::qualified_placeholder::add_const	type_erasure/detail/check_call.hpp	/^    >::type add_const;$/;"	t	struct:boost::type_erasure::detail::qualified_placeholder	access:public
boost::type_erasure::detail::qualified_placeholder::placeholder	type_erasure/detail/check_call.hpp	/^    typedef typename ::boost::type_erasure::placeholder_of<T>::type placeholder;$/;"	t	struct:boost::type_erasure::detail::qualified_placeholder	access:public
boost::type_erasure::detail::qualified_placeholder::type	type_erasure/detail/check_call.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::qualified_placeholder	access:public
boost::type_erasure::detail::qualified_placeholder::type	type_erasure/detail/check_call.hpp	/^    typedef placeholder&& type;$/;"	t	struct:boost::type_erasure::detail::qualified_placeholder	access:public
boost::type_erasure::detail::qualified_placeholder::type	type_erasure/detail/check_call.hpp	/^    typedef void type;$/;"	t	struct:boost::type_erasure::detail::qualified_placeholder	access:public
boost::type_erasure::detail::qualified_placeholder::unref	type_erasure/detail/check_call.hpp	/^    typedef typename ::boost::remove_reference<placeholder>::type unref;$/;"	t	struct:boost::type_erasure::detail::qualified_placeholder	access:public
boost::type_erasure::detail::rebind_placeholders	type_erasure/detail/adapt_to_vtable.hpp	/^struct rebind_placeholders<vtable_adapter<PrimitiveConcept, Sig>, Bindings>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::rebind_placeholders	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::rebind_placeholders	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders<T<U...>, Bindings>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::rebind_placeholders::type	type_erasure/detail/adapt_to_vtable.hpp	/^    > type;$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders	access:public
boost::type_erasure::detail::rebind_placeholders::type	type_erasure/detail/rebind_placeholders.hpp	/^    typedef T<typename rebind_placeholders_in_argument<U, Bindings>::type...> type;$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders	access:public
boost::type_erasure::detail::rebind_placeholders::type	type_erasure/detail/rebind_placeholders.hpp	/^    typedef void type;$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders	access:public
boost::type_erasure::detail::rebind_placeholders_in_argument	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders_in_argument$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::rebind_placeholders_in_argument	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders_in_argument<$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::rebind_placeholders_in_argument	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders_in_argument<R(T...), Bindings>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::rebind_placeholders_in_argument	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders_in_argument<T&&, Bindings>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::rebind_placeholders_in_argument	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders_in_argument<T&, Bindings>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::rebind_placeholders_in_argument	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders_in_argument<const T, Bindings>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::rebind_placeholders_in_argument::BOOST_MPL_ASSERT	type_erasure/detail/rebind_placeholders.hpp	/^    BOOST_MPL_ASSERT((boost::mpl::or_<$/;"	p	struct:boost::type_erasure::detail::rebind_placeholders_in_argument	access:public	signature:(boost::mpl::or_< ::boost::mpl::not_< ::boost::type_erasure::is_placeholder<T> >, ::boost::mpl::has_key<Bindings, T> >)
boost::type_erasure::detail::rebind_placeholders_in_argument::type	type_erasure/detail/rebind_placeholders.hpp	/^    >::type type(typename rebind_placeholders_in_argument<T, Bindings>::type...);$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders_in_argument	access:public
boost::type_erasure::detail::rebind_placeholders_in_argument::type	type_erasure/detail/rebind_placeholders.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders_in_argument	access:public
boost::type_erasure::detail::rebind_placeholders_in_argument::type	type_erasure/detail/rebind_placeholders.hpp	/^    >::type& type;$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders_in_argument	access:public
boost::type_erasure::detail::rebind_placeholders_in_argument::type	type_erasure/detail/rebind_placeholders.hpp	/^    >::type&& type;$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders_in_argument	access:public
boost::type_erasure::detail::rebind_placeholders_in_deduced	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders_in_deduced$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::rebind_placeholders_in_deduced::type	type_erasure/detail/rebind_placeholders.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders_in_deduced	access:public
boost::type_erasure::detail::replace_param_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_param_for_vtable$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::replace_param_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_param_for_vtable<T&&>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::replace_param_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_param_for_vtable<T&>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::replace_param_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_param_for_vtable<const T&>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::replace_param_for_vtable::type	type_erasure/detail/adapt_to_vtable.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::replace_param_for_vtable	access:public
boost::type_erasure::detail::replace_result_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_result_for_vtable$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::replace_result_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_result_for_vtable<T&&>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::replace_result_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_result_for_vtable<T&>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::replace_result_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_result_for_vtable<const T&>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::replace_result_for_vtable::type	type_erasure/detail/adapt_to_vtable.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::replace_result_for_vtable	access:public
boost::type_erasure::detail::require_match_impl	type_erasure/require_match.hpp	/^void require_match_impl($/;"	f	namespace:boost::type_erasure::detail	signature:( ::boost::mpl::false_, const ::boost::type_erasure::binding<Concept>&, const Op&, U&&...)
boost::type_erasure::detail::require_match_impl	type_erasure/require_match.hpp	/^void require_match_impl($/;"	f	namespace:boost::type_erasure::detail	signature:( ::boost::mpl::false_, const Op&, U&&...)
boost::type_erasure::detail::require_match_impl	type_erasure/require_match.hpp	/^void require_match_impl($/;"	f	namespace:boost::type_erasure::detail	signature:( ::boost::mpl::true_, const ::boost::type_erasure::binding<Concept>& table, const Op& op, U&&... arg)
boost::type_erasure::detail::require_match_impl	type_erasure/require_match.hpp	/^void require_match_impl($/;"	f	namespace:boost::type_erasure::detail	signature:( ::boost::mpl::true_, const Op& op, U&&... arg)
boost::type_erasure::detail::resolve_same_type	type_erasure/detail/normalize.hpp	/^struct resolve_same_type$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::resolve_same_type::type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::resolve_same_type	access:public
boost::type_erasure::detail::select_pair	type_erasure/detail/normalize.hpp	/^struct select_pair$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::select_pair	type_erasure/detail/normalize.hpp	/^struct select_pair< ::boost::type_erasure::deduced<T>, U>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::select_pair	type_erasure/detail/normalize.hpp	/^struct select_pair<$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::select_pair	type_erasure/detail/normalize.hpp	/^struct select_pair<T, ::boost::type_erasure::deduced<U> >$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::select_pair::BOOST_MPL_ASSERT	type_erasure/detail/normalize.hpp	/^    BOOST_MPL_ASSERT((::boost::is_same<T, U>));$/;"	p	struct:boost::type_erasure::detail::select_pair	access:public	signature:(::boost::is_same<T, U>)
boost::type_erasure::detail::select_pair::type	type_erasure/detail/normalize.hpp	/^    > type;$/;"	t	struct:boost::type_erasure::detail::select_pair	access:public
boost::type_erasure::detail::select_pair::type	type_erasure/detail/normalize.hpp	/^    typedef ::boost::mpl::pair< ::boost::type_erasure::deduced<T>, U> type;$/;"	t	struct:boost::type_erasure::detail::select_pair	access:public
boost::type_erasure::detail::select_pair::type	type_erasure/detail/normalize.hpp	/^    typedef ::boost::mpl::pair< ::boost::type_erasure::deduced<U>, T> type;$/;"	t	struct:boost::type_erasure::detail::select_pair	access:public
boost::type_erasure::detail::select_pair::type	type_erasure/detail/normalize.hpp	/^    typedef void type;$/;"	t	struct:boost::type_erasure::detail::select_pair	access:public
boost::type_erasure::detail::should_be_const	type_erasure/detail/const.hpp	/^struct should_be_const :$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::or_
boost::type_erasure::detail::should_be_non_const	type_erasure/detail/const.hpp	/^struct should_be_non_const :$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::and_
boost::type_erasure::detail::should_check	type_erasure/check_match.hpp	/^struct should_check :$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::and_
boost::type_erasure::detail::storage	type_erasure/detail/storage.hpp	/^struct storage$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::storage::data	type_erasure/detail/storage.hpp	/^    void* data;$/;"	m	struct:boost::type_erasure::detail::storage	access:public
boost::type_erasure::detail::storage::storage	type_erasure/detail/storage.hpp	/^    storage() {}$/;"	f	struct:boost::type_erasure::detail::storage	access:public	signature:()
boost::type_erasure::detail::storage::storage	type_erasure/detail/storage.hpp	/^    storage(const T& arg) : data(new T(arg)) {}$/;"	f	struct:boost::type_erasure::detail::storage	access:public	signature:(const T& arg)
boost::type_erasure::detail::substitution_map	type_erasure/detail/normalize.hpp	/^struct substitution_map$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::substitution_map::map_type	type_erasure/detail/normalize.hpp	/^    typedef M map_type;$/;"	t	struct:boost::type_erasure::detail::substitution_map	access:public
boost::type_erasure::detail::substitution_map::tag	type_erasure/detail/normalize.hpp	/^    typedef substitution_map_tag tag;$/;"	t	struct:boost::type_erasure::detail::substitution_map	access:public
boost::type_erasure::detail::substitution_map_tag	type_erasure/detail/normalize.hpp	/^struct substitution_map_tag {};$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::uncallable	type_erasure/detail/const.hpp	/^struct uncallable {};$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::vtable_adapter	type_erasure/detail/adapt_to_vtable.hpp	/^struct vtable_adapter$/;"	s	namespace:boost::type_erasure::detail	inherits:vtable_adapter_impl
boost::type_erasure::detail::vtable_adapter_impl	type_erasure/detail/adapt_to_vtable.hpp	/^struct vtable_adapter_impl<PrimitiveConcept, ::boost::type_erasure::detail::storage&&(T...), R2(U...)>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::vtable_adapter_impl	type_erasure/detail/adapt_to_vtable.hpp	/^struct vtable_adapter_impl<PrimitiveConcept, ::boost::type_erasure::detail::storage&(T...), R2(U...)>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::vtable_adapter_impl	type_erasure/detail/adapt_to_vtable.hpp	/^struct vtable_adapter_impl<PrimitiveConcept, R(T...), R2(U...)>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::vtable_adapter_impl::boost::type_erasure::detail::type	type_erasure/detail/adapt_to_vtable.hpp	/^    typedef ::boost::type_erasure::detail::storage (*type)(T...);$/;"	t	class:boost::type_erasure::detail::vtable_adapter_impl::boost::type_erasure::detail	access:public
boost::type_erasure::detail::vtable_adapter_impl::type	type_erasure/detail/adapt_to_vtable.hpp	/^    typedef R (*type)(T...);$/;"	t	struct:boost::type_erasure::detail::vtable_adapter_impl	access:public
boost::type_erasure::detail::vtable_adapter_impl::value	type_erasure/detail/adapt_to_vtable.hpp	/^    static ::boost::type_erasure::detail::storage value(T... arg)$/;"	f	struct:boost::type_erasure::detail::vtable_adapter_impl	access:public	signature:(T.... arg)
boost::type_erasure::detail::vtable_adapter_impl::value	type_erasure/detail/adapt_to_vtable.hpp	/^    static R value(T... arg)$/;"	f	struct:boost::type_erasure::detail::vtable_adapter_impl	access:public	signature:(T.... arg)
boost::type_erasure::detail::vtable_entry	type_erasure/detail/vtable.hpp	/^struct vtable_entry$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::vtable_entry::value	type_erasure/detail/vtable.hpp	/^    typename T::type value;$/;"	m	struct:boost::type_erasure::detail::vtable_entry	access:public
boost::type_erasure::detail::vtable_entry::vtable_entry	type_erasure/detail/vtable.hpp	/^    constexpr vtable_entry(typename T::type arg) : value(arg) {}$/;"	f	struct:boost::type_erasure::detail::vtable_entry	access:public	signature:(typename T::type arg)
boost::type_erasure::detail::vtable_entry::vtable_entry	type_erasure/detail/vtable.hpp	/^    vtable_entry() = default;$/;"	p	struct:boost::type_erasure::detail::vtable_entry	access:public	signature:()
boost::type_erasure::detail::vtable_init	type_erasure/detail/vtable.hpp	/^struct vtable_init$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::vtable_init::value	type_erasure/detail/vtable.hpp	/^    static constexpr Table value = Table(T::value...);$/;"	m	struct:boost::type_erasure::detail::vtable_init	access:public
boost::type_erasure::detail::vtable_init::value	type_erasure/detail/vtable.hpp	/^constexpr Table vtable_init<Table, T...>::value;$/;"	m	class:boost::type_erasure::detail::vtable_init
boost::type_erasure::detail::vtable_storage	type_erasure/detail/vtable.hpp	/^struct vtable_storage : vtable_entry<T>...$/;"	s	namespace:boost::type_erasure::detail	inherits:vtable_entry
boost::type_erasure::detail::vtable_storage	type_erasure/detail/vtable.hpp	/^struct vtable_storage<>$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::vtable_storage::convert_from	type_erasure/detail/vtable.hpp	/^    void convert_from(const Src& src) {}$/;"	f	struct:boost::type_erasure::detail::vtable_storage	access:public	signature:(const Src& src)
boost::type_erasure::detail::vtable_storage::convert_from	type_erasure/detail/vtable.hpp	/^    void convert_from(const Src& src)$/;"	f	struct:boost::type_erasure::detail::vtable_storage	access:public	signature:(const Src& src)
boost::type_erasure::detail::vtable_storage::lookup	type_erasure/detail/vtable.hpp	/^    typename U::type lookup(U*) const$/;"	f	struct:boost::type_erasure::detail::vtable_storage	access:public	signature:(U*) const
boost::type_erasure::detail::vtable_storage::operator ==	type_erasure/detail/vtable.hpp	/^    bool operator==(const vtable_storage& other) const$/;"	f	struct:boost::type_erasure::detail::vtable_storage	access:public	signature:(const vtable_storage& other) const
boost::type_erasure::detail::vtable_storage::vtable_storage	type_erasure/detail/vtable.hpp	/^    constexpr vtable_storage(typename T::type... arg)$/;"	f	struct:boost::type_erasure::detail::vtable_storage	access:public	signature:(typename T::type... arg)
boost::type_erasure::detail::vtable_storage::vtable_storage	type_erasure/detail/vtable.hpp	/^    vtable_storage() = default;$/;"	p	struct:boost::type_erasure::detail::vtable_storage	access:public	signature:()
boost::type_erasure::detail::yes	type_erasure/any.hpp	/^struct yes { no dummy[2]; };$/;"	s	namespace:boost::type_erasure::detail
boost::type_erasure::detail::yes::dummy	type_erasure/any.hpp	/^struct yes { no dummy[2]; };$/;"	m	struct:boost::type_erasure::detail::yes	access:public
boost::type_erasure::equality_comparable	type_erasure/operators.hpp	/^struct equality_comparable$/;"	s	namespace:boost::type_erasure
boost::type_erasure::equality_comparable::apply	type_erasure/operators.hpp	/^    static bool apply(const T& lhs, const U& rhs) { return lhs == rhs; }$/;"	f	struct:boost::type_erasure::equality_comparable	access:public	signature:(const T& lhs, const U& rhs)
boost::type_erasure::forward_iterator	type_erasure/iterator.hpp	/^struct forward_iterator :$/;"	s	namespace:boost::type_erasure	inherits:iterator
boost::type_erasure::get	type_erasure/tuple.hpp	/^any<Concept, TN>& get(tuple<Concept, T...>& arg);$/;"	p	namespace:boost::type_erasure	signature:(tuple<Concept, T...>& arg)
boost::type_erasure::get	type_erasure/tuple.hpp	/^const any<Concept, TN>& get(const tuple<Concept, T...>& arg);$/;"	p	namespace:boost::type_erasure	signature:(const tuple<Concept, T...>& arg)
boost::type_erasure::is_empty	type_erasure/is_empty.hpp	/^bool is_empty(const T& arg) {$/;"	f	namespace:boost::type_erasure	signature:(const T& arg)
boost::type_erasure::is_placeholder	type_erasure/is_placeholder.hpp	/^struct is_placeholder : ::boost::is_base_and_derived<placeholder, T> {};$/;"	s	namespace:boost::type_erasure	inherits:::boost::is_base_and_derived
boost::type_erasure::is_placeholder	type_erasure/is_placeholder.hpp	/^struct is_placeholder< ::boost::use_default> : ::boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure	inherits:::boost::mpl::false_
boost::type_erasure::is_relaxed	type_erasure/relaxed.hpp	/^struct is_relaxed :$/;"	s	namespace:boost::type_erasure	inherits:::boost::mpl::eval_if::type
boost::type_erasure::is_relaxed	type_erasure/relaxed.hpp	/^struct is_relaxed< ::boost::type_erasure::relaxed> :$/;"	s	namespace:boost::type_erasure	inherits:::boost::mpl::true_
boost::type_erasure::is_subconcept	type_erasure/is_subconcept.hpp	/^struct is_subconcept : ::boost::type_erasure::detail::is_subconcept_impl<Sub, Super, PlaceholderMap>::type {$/;"	s	namespace:boost::type_erasure	inherits:::boost::type_erasure::detail::is_subconcept_impl::type
boost::type_erasure::is_subconcept	type_erasure/is_subconcept.hpp	/^struct is_subconcept<Sub, Super, static_binding<PlaceholderMap> > :$/;"	s	namespace:boost::type_erasure	inherits:::boost::type_erasure::detail::is_subconcept_impl::type
boost::type_erasure::istreamable	type_erasure/operators.hpp	/^struct istreamable$/;"	s	namespace:boost::type_erasure
boost::type_erasure::istreamable::apply	type_erasure/operators.hpp	/^    static void apply(Is& out, T& arg) { out >> arg; }$/;"	f	struct:boost::type_erasure::istreamable	access:public	signature:(Is& out, T& arg)
boost::type_erasure::iterator	type_erasure/iterator.hpp	/^struct iterator$/;"	s	namespace:boost::type_erasure
boost::type_erasure::iterator	type_erasure/iterator.hpp	/^struct iterator< ::boost::bidirectional_traversal_tag, T, Reference, DifferenceType, ValueType> :$/;"	s	namespace:boost::type_erasure	inherits:boost::mpl::vector
boost::type_erasure::iterator	type_erasure/iterator.hpp	/^struct iterator< ::boost::forward_traversal_tag, T, Reference, DifferenceType, ValueType> :$/;"	s	namespace:boost::type_erasure	inherits:iterator
boost::type_erasure::iterator	type_erasure/iterator.hpp	/^struct iterator< ::boost::incrementable_traversal_tag, T, Reference, DifferenceType, ValueType> :$/;"	s	namespace:boost::type_erasure	inherits:boost::mpl::vector
boost::type_erasure::iterator	type_erasure/iterator.hpp	/^struct iterator< ::boost::no_traversal_tag, T, Reference, DifferenceType, ValueType> :$/;"	s	namespace:boost::type_erasure	inherits:boost::mpl::vector
boost::type_erasure::iterator	type_erasure/iterator.hpp	/^struct iterator< ::boost::random_access_traversal_tag, T, Reference, DifferenceType, ValueType> :$/;"	s	namespace:boost::type_erasure	inherits:boost::mpl::vector
boost::type_erasure::iterator	type_erasure/iterator.hpp	/^struct iterator< ::boost::single_pass_traversal_tag, T, Reference, DifferenceType, ValueType> :$/;"	s	namespace:boost::type_erasure	inherits:iterator
boost::type_erasure::iterator::difference_type	type_erasure/iterator.hpp	/^    typedef DifferenceType difference_type;$/;"	t	struct:boost::type_erasure::iterator	access:public
boost::type_erasure::iterator::reference	type_erasure/iterator.hpp	/^    typedef Reference reference;$/;"	t	struct:boost::type_erasure::iterator	access:public
boost::type_erasure::iterator::reference	type_erasure/iterator.hpp	/^    typedef typename iterator_reference<Reference, ValueType>::type reference;$/;"	t	struct:boost::type_erasure::iterator	access:public
boost::type_erasure::iterator::value_type	type_erasure/iterator.hpp	/^    typedef ValueType value_type;$/;"	t	struct:boost::type_erasure::iterator	access:public
boost::type_erasure::iterator::value_type	type_erasure/iterator.hpp	/^    typedef detail::unspecified value_type;$/;"	t	struct:boost::type_erasure::iterator	access:public
boost::type_erasure::iterator_reference	type_erasure/iterator.hpp	/^struct iterator_reference$/;"	s	namespace:boost::type_erasure
boost::type_erasure::iterator_reference	type_erasure/iterator.hpp	/^struct iterator_reference< ::boost::use_default, ValueType>$/;"	s	namespace:boost::type_erasure
boost::type_erasure::iterator_reference::type	type_erasure/iterator.hpp	/^    typedef Reference type;$/;"	t	struct:boost::type_erasure::iterator_reference	access:public
boost::type_erasure::iterator_reference::type	type_erasure/iterator.hpp	/^    typedef ValueType& type;$/;"	t	struct:boost::type_erasure::iterator_reference	access:public
boost::type_erasure::iterator_value_type	type_erasure/iterator.hpp	/^struct iterator_value_type$/;"	s	namespace:boost::type_erasure
boost::type_erasure::iterator_value_type::type	type_erasure/iterator.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::iterator_value_type	access:public
boost::type_erasure::less_than_comparable	type_erasure/operators.hpp	/^struct less_than_comparable$/;"	s	namespace:boost::type_erasure
boost::type_erasure::less_than_comparable::apply	type_erasure/operators.hpp	/^    static bool apply(const T& lhs, const U& rhs) { return lhs < rhs; }$/;"	f	struct:boost::type_erasure::less_than_comparable	access:public	signature:(const T& lhs, const U& rhs)
boost::type_erasure::make_binding	type_erasure/static_binding.hpp	/^static_binding<Map> make_binding() { return static_binding<Map>(); }$/;"	f	namespace:boost::type_erasure	signature:()
boost::type_erasure::ostreamable	type_erasure/operators.hpp	/^struct ostreamable$/;"	s	namespace:boost::type_erasure
boost::type_erasure::ostreamable::apply	type_erasure/operators.hpp	/^    static void apply(Os& out, const T& arg) { out << arg; }$/;"	f	struct:boost::type_erasure::ostreamable	access:public	signature:(Os& out, const T& arg)
boost::type_erasure::param	type_erasure/param.hpp	/^class param {$/;"	c	namespace:boost::type_erasure
boost::type_erasure::param	type_erasure/param.hpp	/^class param<Concept, T&&> : public param<Concept, const T&> {$/;"	c	namespace:boost::type_erasure	inherits:param
boost::type_erasure::param	type_erasure/param.hpp	/^class param<Concept, T&> : public param<Concept, const T&> {$/;"	c	namespace:boost::type_erasure	inherits:param
boost::type_erasure::param	type_erasure/param.hpp	/^class param<Concept, const T&> {$/;"	c	namespace:boost::type_erasure
boost::type_erasure::param::_boost_type_erasure_derived_type	type_erasure/param.hpp	/^    typedef param _boost_type_erasure_derived_type;$/;"	t	class:boost::type_erasure::param	access:public
boost::type_erasure::param::_boost_type_erasure_is_any	type_erasure/param.hpp	/^    typedef void _boost_type_erasure_is_any;$/;"	t	class:boost::type_erasure::param	access:public
boost::type_erasure::param::_impl	type_erasure/param.hpp	/^    any<Concept, T> _impl;$/;"	m	class:boost::type_erasure::param	access:private
boost::type_erasure::param::_impl	type_erasure/param.hpp	/^    any<Concept, const T&> _impl;$/;"	m	class:boost::type_erasure::param	access:protected
boost::type_erasure::param::get	type_erasure/param.hpp	/^    any<Concept, T&&> get() const$/;"	f	class:boost::type_erasure::param	access:public	signature:() const
boost::type_erasure::param::get	type_erasure/param.hpp	/^    any<Concept, T&> get() const$/;"	f	class:boost::type_erasure::param	access:public	signature:() const
boost::type_erasure::param::get	type_erasure/param.hpp	/^    any<Concept, T> get() const { return _impl; }$/;"	f	class:boost::type_erasure::param	access:public	signature:() const
boost::type_erasure::param::get	type_erasure/param.hpp	/^    any<Concept, const T&> get() const { return _impl; }$/;"	f	class:boost::type_erasure::param	access:public	signature:() const
boost::type_erasure::param::param	type_erasure/param.hpp	/^    param(U& u, typename boost::enable_if< ::boost::is_same<U, const any<Concept, T> > >::type* = 0) : _impl(u) {}$/;"	f	class:boost::type_erasure::param	access:public	signature:(U& u, typename boost::enable_if< ::boost::is_same<U, const any<Concept, T> > >::type* = 0)
boost::type_erasure::param::param	type_erasure/param.hpp	/^    param(any<Concept, U>& a$/;"	f	class:boost::type_erasure::param	access:public	signature:(any<Concept, U>& a , typename boost::enable_if< ::boost::type_erasure::detail::placeholder_conversion<U, T> >::type* = 0 )
boost::type_erasure::param::param	type_erasure/param.hpp	/^    param(any<Concept, U>&& a$/;"	f	class:boost::type_erasure::param	access:public	signature:(any<Concept, U>&& a , typename boost::enable_if< ::boost::type_erasure::detail::placeholder_conversion< U&&, T > >::type* = 0 )
boost::type_erasure::param::param	type_erasure/param.hpp	/^    param(const ::boost::type_erasure::detail::storage& data,$/;"	f	class:boost::type_erasure::param	access:public	signature:(const ::boost::type_erasure::detail::storage& data, const ::boost::type_erasure::binding<Concept>& table)
boost::type_erasure::param::param	type_erasure/param.hpp	/^    param(const any<Concept, U>& a$/;"	f	class:boost::type_erasure::param	access:public	signature:(const any<Concept, U>& a , typename boost::enable_if< ::boost::type_erasure::detail::placeholder_conversion< typename ::boost::add_const<U>::type, T > >::type* = 0 )
boost::type_erasure::placeholder	type_erasure/placeholder.hpp	/^struct placeholder {};$/;"	s	namespace:boost::type_erasure
boost::type_erasure::placeholder_of	type_erasure/placeholder_of.hpp	/^struct placeholder_of$/;"	s	namespace:boost::type_erasure
boost::type_erasure::placeholder_of	type_erasure/placeholder_of.hpp	/^struct placeholder_of< ::boost::type_erasure::any<Concept, T> >$/;"	s	namespace:boost::type_erasure
boost::type_erasure::placeholder_of	type_erasure/placeholder_of.hpp	/^struct placeholder_of< ::boost::type_erasure::param<Concept, T> >$/;"	s	namespace:boost::type_erasure
boost::type_erasure::placeholder_of::type	type_erasure/placeholder_of.hpp	/^    typedef T type;$/;"	t	struct:boost::type_erasure::placeholder_of	access:public
boost::type_erasure::placeholder_of::type	type_erasure/placeholder_of.hpp	/^    typedef detail::unspecified type;$/;"	t	struct:boost::type_erasure::placeholder_of	access:public
boost::type_erasure::random_access_iterator	type_erasure/iterator.hpp	/^struct random_access_iterator :$/;"	s	namespace:boost::type_erasure	inherits:iterator
boost::type_erasure::rebind_any	type_erasure/rebind_any.hpp	/^struct rebind_any$/;"	s	namespace:boost::type_erasure
boost::type_erasure::rebind_any::type	type_erasure/rebind_any.hpp	/^    typedef detail::unspecified type;$/;"	t	struct:boost::type_erasure::rebind_any	access:public
boost::type_erasure::relaxed	type_erasure/relaxed.hpp	/^struct relaxed : ::boost::mpl::vector0<> {};$/;"	s	namespace:boost::type_erasure	inherits:::boost::mpl::vector0
boost::type_erasure::require_match	type_erasure/require_match.hpp	/^void require_match($/;"	f	namespace:boost::type_erasure	signature:( const ::boost::type_erasure::binding<Concept>& table, const Op& op, U&&... arg)
boost::type_erasure::require_match	type_erasure/require_match.hpp	/^void require_match($/;"	f	namespace:boost::type_erasure	signature:( const Op& op, U&&... arg)
boost::type_erasure::require_match	type_erasure/require_match.hpp	/^void require_match(const Op& f, U&&... args);$/;"	p	namespace:boost::type_erasure	signature:(const Op& f, U&&... args)
boost::type_erasure::require_match	type_erasure/require_match.hpp	/^void require_match(const binding<Concept>& binding_arg, const Op& f, U&&... args);$/;"	p	namespace:boost::type_erasure	signature:(const binding<Concept>& binding_arg, const Op& f, U&&... args)
boost::type_erasure::same_type	type_erasure/same_type.hpp	/^struct same_type {};$/;"	s	namespace:boost::type_erasure
boost::type_erasure::static_binding	type_erasure/static_binding.hpp	/^struct static_binding {};$/;"	s	namespace:boost::type_erasure
boost::type_erasure::subscriptable	type_erasure/operators.hpp	/^struct subscriptable$/;"	s	namespace:boost::type_erasure
boost::type_erasure::subscriptable::apply	type_erasure/operators.hpp	/^    static R apply(T& arg, const N& index) { return arg[index]; }$/;"	f	struct:boost::type_erasure::subscriptable	access:public	signature:(T& arg, const N& index)
boost::type_erasure::tuple	type_erasure/tuple.hpp	/^class tuple$/;"	c	namespace:boost::type_erasure
boost::type_erasure::tuple::tuple	type_erasure/tuple.hpp	/^    explicit tuple(U&&... args);$/;"	p	class:boost::type_erasure::tuple	access:public	signature:(U&&.... args)
boost::type_erasure::typeid_	type_erasure/builtin.hpp	/^struct typeid_$/;"	s	namespace:boost::type_erasure
boost::type_erasure::typeid_::apply	type_erasure/builtin.hpp	/^    static const std::type_info& apply()$/;"	f	struct:boost::type_erasure::typeid_	access:public	signature:()
boost::type_erasure::typeid_::std::type	type_erasure/builtin.hpp	/^    typedef const std::type_info& (*type)();$/;"	t	class:boost::type_erasure::typeid_::std	access:public
boost::type_erasure::typeid_::value	type_erasure/builtin.hpp	/^    static const std::type_info& value()$/;"	f	struct:boost::type_erasure::typeid_	access:public	signature:()
boost::type_erasure::typeid_of	type_erasure/typeid_of.hpp	/^const std::type_info& typeid_of(const any<Concept, T>& arg)$/;"	f	namespace:boost::type_erasure	signature:(const any<Concept, T>& arg)
boost::type_erasure::typeid_of	type_erasure/typeid_of.hpp	/^const std::type_info& typeid_of(const binding<Concept>& binding_arg)$/;"	f	namespace:boost::type_erasure	signature:(const binding<Concept>& binding_arg)
boost::type_erasure::typeid_of	type_erasure/typeid_of.hpp	/^const std::type_info& typeid_of(const param<Concept, T>& arg)$/;"	f	namespace:boost::type_erasure	signature:(const param<Concept, T>& arg)
call	type_erasure/call.hpp	/^call(const Op&, U&&... args);$/;"	p	namespace:boost::type_erasure	signature:(const Op&, U&&... args)
callable	type_erasure/callable.hpp	/^struct callable$/;"	s	namespace:boost::type_erasure
can_optimize_conversion	type_erasure/binding.hpp	/^struct can_optimize_conversion : ::boost::mpl::and_<$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::and_::type
check_any_cast	type_erasure/any_cast.hpp	/^bool check_any_cast(const any<Concept, Tag>& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(const any<Concept, Tag>& arg)
check_any_cast	type_erasure/any_cast.hpp	/^bool check_any_cast(const any<Concept, Tag>& arg, ::boost::mpl::false_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const any<Concept, Tag>& arg, ::boost::mpl::false_)
check_any_cast	type_erasure/any_cast.hpp	/^bool check_any_cast(const any<Concept, Tag>&, ::boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const any<Concept, Tag>&, ::boost::mpl::true_)
check_arg	type_erasure/detail/check_call.hpp	/^struct check_arg$/;"	s	namespace:boost::type_erasure::detail
check_call	type_erasure/detail/check_call.hpp	/^struct check_call : ::boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::false_
check_map	type_erasure/detail/check_map.hpp	/^struct check_map {$/;"	s	namespace:boost::type_erasure::detail
check_map	type_erasure/detail/check_map.hpp	/^struct check_map<Concept, ::boost::type_erasure::static_binding<Map> > :$/;"	s	namespace:boost::type_erasure::detail	inherits:check_map
check_match	type_erasure/check_match.hpp	/^bool check_match(const Op& f, U&&... args);$/;"	p	namespace:boost::type_erasure	signature:(const Op& f, U&&... args)
check_overload	type_erasure/any.hpp	/^no check_overload(const void*);$/;"	p	namespace:boost::type_erasure::detail	signature:(const void*)
check_overload	type_erasure/any.hpp	/^yes check_overload(const Op*);$/;"	p	namespace:boost::type_erasure::detail	signature:(const Op*)
check_placeholder_arg	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg :$/;"	s	namespace:boost::type_erasure::detail	inherits:check_placeholder_arg_impl::type
check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl : ::boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::false_
check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<P&&, P&&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<P&, P&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<P, P&&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<P, P&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<P, const P&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<const P&, P&&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<const P&, P&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
check_placeholder_arg_impl	type_erasure/detail/check_call.hpp	/^struct check_placeholder_arg_impl<const P&, const P&> : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
collect_concepts	type_erasure/detail/normalize.hpp	/^struct collect_concepts$/;"	s	namespace:boost::type_erasure::detail
combine_concepts	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<T, T> { typedef T type; };$/;"	s	namespace:boost::type_erasure::detail
combine_concepts	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<T, void> { typedef T type; };$/;"	s	namespace:boost::type_erasure::detail
combine_concepts	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<void, T> { typedef T type; };$/;"	s	namespace:boost::type_erasure::detail
combine_concepts	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<void, void> { typedef void type; };$/;"	s	namespace:boost::type_erasure::detail
compare_vtable	type_erasure/detail/vtable.hpp	/^struct compare_vtable<> {$/;"	s	namespace:boost::type_erasure::detail
compare_vtable	type_erasure/detail/vtable.hpp	/^struct compare_vtable<T0, T...> {$/;"	s	namespace:boost::type_erasure::detail
compute_bases	type_erasure/any.hpp	/^struct compute_bases$/;"	s	namespace:boost::type_erasure::detail
concept_interface	type_erasure/builtin.hpp	/^struct concept_interface<assignable<T, U>, Base, T> : Base$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/concept_interface.hpp	/^struct concept_interface : Base {};$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/constructible.hpp	/^struct concept_interface<$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/iterator.hpp	/^struct concept_interface<bidirectional_iterator<T, Reference, DifferenceType, ValueType>, Base, T>$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/iterator.hpp	/^struct concept_interface<forward_iterator<T, Reference, DifferenceType, ValueType>, Base, T>$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/iterator.hpp	/^struct concept_interface<iterator< ::boost::bidirectional_traversal_tag, T, Reference, DifferenceType, ValueType>, Base, T>$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/iterator.hpp	/^struct concept_interface<iterator< ::boost::forward_traversal_tag, T, Reference, DifferenceType, ValueType>, Base, T>$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/iterator.hpp	/^struct concept_interface<iterator< ::boost::no_traversal_tag, T, Reference, DifferenceType, ValueType>, Base, T>$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/iterator.hpp	/^struct concept_interface<iterator< ::boost::random_access_traversal_tag, T, Reference, DifferenceType, ValueType>, Base, T>$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/iterator.hpp	/^struct concept_interface<random_access_iterator<T, Reference, DifferenceType, ValueType>, Base, T>$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/operators.hpp	/^struct concept_interface<$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/operators.hpp	/^struct concept_interface<dereferenceable<R, T>, Base, T> : Base$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/operators.hpp	/^struct concept_interface<equality_comparable<T, U>, Base, T> : Base$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/operators.hpp	/^struct concept_interface<istreamable<Is, T>, Base, Is> : Base$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/operators.hpp	/^struct concept_interface<less_than_comparable<T, T>, Base, T> : Base$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/operators.hpp	/^struct concept_interface<less_than_comparable<T, U>, Base, T> : Base$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/operators.hpp	/^struct concept_interface<ostreamable<Os, T>, Base, Os> : Base$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_interface	type_erasure/operators.hpp	/^struct concept_interface<subscriptable<R, T, N>, Base, typename ::boost::remove_const<T>::type,$/;"	s	namespace:boost::type_erasure	inherits:Base
concept_of	type_erasure/concept_of.hpp	/^struct concept_of$/;"	s	namespace:boost::type_erasure
concept_of	type_erasure/concept_of.hpp	/^struct concept_of< ::boost::type_erasure::any<Concept, T> >$/;"	s	namespace:boost::type_erasure
concept_of	type_erasure/concept_of.hpp	/^struct concept_of< ::boost::type_erasure::param<Concept, T> >$/;"	s	namespace:boost::type_erasure
concept_set	type_erasure/detail/normalize.hpp	/^    >::type concept_set;$/;"	t	struct:boost::type_erasure::detail::normalize_concept	access:public
constructible	type_erasure/constructible.hpp	/^struct constructible {};$/;"	s	namespace:boost::type_erasure
constructible	type_erasure/constructible.hpp	/^struct constructible<R(T...)>$/;"	s	namespace:boost::type_erasure
convert_arg	type_erasure/call.hpp	/^::boost::type_erasure::detail::storage& convert_arg(any_base<T>& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(any_base<T>& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^T& convert_arg(T& arg, boost::mpl::false_) { return arg; }$/;"	f	namespace:boost::type_erasure::detail	signature:(T& arg, boost::mpl::false_)
convert_arg	type_erasure/call.hpp	/^T&& convert_arg(T&& arg, boost::mpl::false_) { return std::forward<T>(arg); }$/;"	f	namespace:boost::type_erasure::detail	signature:(T&& arg, boost::mpl::false_)
convert_arg	type_erasure/call.hpp	/^convert_arg(any_base<any<Concept, T&&> >& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(any_base<any<Concept, T&&> >& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(any_base<any<Concept, T&> >&& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(any_base<any<Concept, T&> >&& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(any_base<any<Concept, T> >&& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(any_base<any<Concept, T> >&& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(any_base<any<Concept, const T&> >& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(any_base<any<Concept, const T&> >& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(any_base<any<Concept, const T&> >&& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(any_base<any<Concept, const T&> >&& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(const any_base<T>& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const any_base<T>& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(const any_base<any<Concept, T&&> >& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const any_base<any<Concept, T&&> >& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(const any_base<any<Concept, T&> >& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const any_base<any<Concept, T&> >& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(const any_base<any<Concept, const T&> >& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const any_base<any<Concept, const T&> >& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(const param<Concept, T&&>& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const param<Concept, T&&>& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(const param<Concept, T>& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const param<Concept, T>& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(param<Concept, T&&>& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(param<Concept, T&&>& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(param<Concept, T&>&& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(param<Concept, T&>&& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(param<Concept, T>& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(param<Concept, T>& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(param<Concept, T>&& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(param<Concept, T>&& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(param<Concept, const T&>& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(param<Concept, const T&>& arg, boost::mpl::true_)
convert_arg	type_erasure/call.hpp	/^convert_arg(param<Concept, const T&>&& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(param<Concept, const T&>&& arg, boost::mpl::true_)
convert_deduced	type_erasure/detail/normalize.hpp	/^struct convert_deduced$/;"	s	namespace:boost::type_erasure::detail
convert_deductions	type_erasure/detail/normalize.hpp	/^struct convert_deductions$/;"	s	namespace:boost::type_erasure::detail
convert_from	type_erasure/detail/vtable.hpp	/^    void convert_from(const Src& src) {}$/;"	f	struct:boost::type_erasure::detail::vtable_storage	access:public	signature:(const Src& src)
convert_from	type_erasure/detail/vtable.hpp	/^    void convert_from(const Src& src)$/;"	f	struct:boost::type_erasure::detail::vtable_storage	access:public	signature:(const Src& src)
copy_constructible	type_erasure/builtin.hpp	/^struct copy_constructible :$/;"	s	namespace:boost::type_erasure	inherits:::boost::mpl::vector
create_placeholder_map	type_erasure/detail/normalize.hpp	/^struct create_placeholder_map$/;"	s	namespace:boost::type_erasure::detail
data	type_erasure/any.hpp	/^    ::boost::type_erasure::detail::storage data;$/;"	m	class:boost::type_erasure::any	access:private
data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, T&&> >& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, T&&> >& arg)
data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, const T&> >& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, const T&> >& arg)
data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::any_base<Derived>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::any_base<Derived>& arg)
data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::any_base<Derived>&& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::any_base<Derived>&& arg)
data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::param<Concept, T&&>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::param<Concept, T&&>& arg)
data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::param<Concept, T>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::param<Concept, T>& arg)
data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::param<Concept, T>&& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::param<Concept, T>&& arg)
data	type_erasure/detail/access.hpp	/^    data(::boost::type_erasure::param<Concept, const T&>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(::boost::type_erasure::param<Concept, const T&>& arg)
data	type_erasure/detail/access.hpp	/^    data(const ::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, T&&> >& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, T&&> >& arg)
data	type_erasure/detail/access.hpp	/^    data(const ::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, T&> >& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, T&> >& arg)
data	type_erasure/detail/access.hpp	/^    data(const ::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, const T&> >& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::any_base< ::boost::type_erasure::any<Concept, const T&> >& arg)
data	type_erasure/detail/access.hpp	/^    data(const ::boost::type_erasure::any_base<Derived>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::any_base<Derived>& arg)
data	type_erasure/detail/access.hpp	/^    data(const ::boost::type_erasure::param<Concept, T&&>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::param<Concept, T&&>& arg)
data	type_erasure/detail/access.hpp	/^    data(const ::boost::type_erasure::param<Concept, T>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::param<Concept, T>& arg)
data	type_erasure/detail/storage.hpp	/^    void* data;$/;"	m	struct:boost::type_erasure::detail::storage	access:public
deduced	type_erasure/deduced.hpp	/^struct deduced : ::boost::type_erasure::placeholder$/;"	s	namespace:boost::type_erasure	inherits:::boost::type_erasure::placeholder
dereferenceable	type_erasure/operators.hpp	/^struct dereferenceable$/;"	s	namespace:boost::type_erasure
derived	type_erasure/derived.hpp	/^struct derived$/;"	s	namespace:boost::type_erasure
destructible	type_erasure/builtin.hpp	/^struct destructible$/;"	s	namespace:boost::type_erasure
detail	type_erasure/any.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/any_cast.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/binding.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/builtin.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/call.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/callable.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/check_match.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/constructible.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/detail/access.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/detail/adapt_to_vtable.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/detail/check_call.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/detail/check_map.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/detail/const.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/detail/extract_concept.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/detail/get_placeholders.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/detail/get_signature.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/detail/instantiate.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/detail/normalize.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/detail/normalize_deduced.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/detail/null.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/detail/rebind_placeholders.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/detail/storage.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/detail/vtable.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/free.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/is_subconcept.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/iterator.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/operators.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/param.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/relaxed.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
detail	type_erasure/require_match.hpp	/^namespace detail {$/;"	n	namespace:boost::type_erasure
difference_type	type_erasure/iterator.hpp	/^    typedef DifferenceType difference_type;$/;"	t	struct:boost::type_erasure::concept_interface	access:public
difference_type	type_erasure/iterator.hpp	/^    typedef DifferenceType difference_type;$/;"	t	struct:boost::type_erasure::iterator	access:public
dummy	type_erasure/any.hpp	/^struct yes { no dummy[2]; };$/;"	m	struct:boost::type_erasure::detail::yes	access:public
equality_comparable	type_erasure/operators.hpp	/^struct equality_comparable$/;"	s	namespace:boost::type_erasure
extract	type_erasure/detail/storage.hpp	/^T extract(T arg) { return arg; }$/;"	f	namespace:boost::type_erasure::detail	signature:(T arg)
extract	type_erasure/detail/storage.hpp	/^T extract(T arg) { return std::forward<T>(arg); }$/;"	f	namespace:boost::type_erasure::detail	signature:(T arg)
extract	type_erasure/detail/storage.hpp	/^T extract(const storage& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(const storage& arg)
extract	type_erasure/detail/storage.hpp	/^T extract(storage& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(storage& arg)
extract	type_erasure/detail/storage.hpp	/^T extract(storage&& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(storage&& arg)
extract_concept	type_erasure/detail/extract_concept.hpp	/^struct extract_concept<R(T0, T...), U0, U...>$/;"	s	namespace:boost::type_erasure::detail
extract_concept	type_erasure/detail/extract_concept.hpp	/^struct extract_concept<void()>$/;"	s	namespace:boost::type_erasure::detail
fallback	type_erasure/any.hpp	/^struct fallback {};$/;"	s	namespace:boost::type_erasure::detail
find	type_erasure/binding.hpp	/^    typename T::type find() const { return impl.table->lookup((T*)0); }$/;"	f	class:boost::type_erasure::binding	access:public	signature:() const
first_placeholder	type_erasure/free.hpp	/^struct first_placeholder {$/;"	s	namespace:boost::type_erasure::detail
first_placeholder	type_erasure/free.hpp	/^struct first_placeholder<> {};$/;"	s	namespace:boost::type_erasure::detail
first_placeholder_index	type_erasure/free.hpp	/^struct first_placeholder_index :$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::eval_if::type
forward_iterator	type_erasure/iterator.hpp	/^struct forward_iterator :$/;"	s	namespace:boost::type_erasure	inherits:iterator
get	type_erasure/param.hpp	/^    any<Concept, T&&> get() const$/;"	f	class:boost::type_erasure::param	access:public	signature:() const
get	type_erasure/param.hpp	/^    any<Concept, T&> get() const$/;"	f	class:boost::type_erasure::param	access:public	signature:() const
get	type_erasure/param.hpp	/^    any<Concept, T> get() const { return _impl; }$/;"	f	class:boost::type_erasure::param	access:public	signature:() const
get	type_erasure/param.hpp	/^    any<Concept, const T&> get() const { return _impl; }$/;"	f	class:boost::type_erasure::param	access:public	signature:() const
get	type_erasure/tuple.hpp	/^any<Concept, TN>& get(tuple<Concept, T...>& arg);$/;"	p	namespace:boost::type_erasure	signature:(tuple<Concept, T...>& arg)
get	type_erasure/tuple.hpp	/^const any<Concept, TN>& get(const tuple<Concept, T...>& arg);$/;"	p	namespace:boost::type_erasure	signature:(const tuple<Concept, T...>& arg)
get_null_vtable_entry	type_erasure/builtin.hpp	/^struct get_null_vtable_entry< ::boost::type_erasure::destructible<T> >$/;"	s	namespace:boost::type_erasure::detail
get_null_vtable_entry	type_erasure/builtin.hpp	/^struct get_null_vtable_entry< ::boost::type_erasure::typeid_<T> >$/;"	s	namespace:boost::type_erasure::detail
get_null_vtable_entry	type_erasure/constructible.hpp	/^struct get_null_vtable_entry<vtable_adapter<constructible<T(const T&)>, R(U...)> >$/;"	s	namespace:boost::type_erasure::detail
get_null_vtable_entry	type_erasure/detail/null.hpp	/^struct get_null_vtable_entry {$/;"	s	namespace:boost::type_erasure::detail
get_placeholder_normalization_map	type_erasure/detail/normalize.hpp	/^struct get_placeholder_normalization_map$/;"	s	namespace:boost::type_erasure::detail
get_placeholders	type_erasure/detail/get_placeholders.hpp	/^struct get_placeholders<T<U...>, Out>$/;"	s	namespace:boost::type_erasure::detail
get_placeholders_impl	type_erasure/detail/get_placeholders.hpp	/^struct get_placeholders_impl<Out, T0, T...>$/;"	s	namespace:boost::type_erasure::detail
get_placeholders_impl	type_erasure/detail/get_placeholders.hpp	/^struct get_placeholders_impl<Out>$/;"	s	namespace:boost::type_erasure::detail
get_placeholders_in_argument	type_erasure/detail/get_placeholders.hpp	/^struct get_placeholders_in_argument$/;"	s	namespace:boost::type_erasure::detail
get_placeholders_in_argument	type_erasure/detail/get_placeholders.hpp	/^struct get_placeholders_in_argument<R(T...), Out>$/;"	s	namespace:boost::type_erasure::detail
get_placeholders_in_argument	type_erasure/detail/get_placeholders.hpp	/^struct get_placeholders_in_argument<T&, Out>$/;"	s	namespace:boost::type_erasure::detail
get_placeholders_in_argument	type_erasure/detail/get_placeholders.hpp	/^struct get_placeholders_in_argument<const T, Out>$/;"	s	namespace:boost::type_erasure::detail
get_pointer	type_erasure/any_cast.hpp	/^const void* get_pointer(::boost::type_erasure::any<Concept, const T&>& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(::boost::type_erasure::any<Concept, const T&>& arg)
get_pointer	type_erasure/any_cast.hpp	/^const void* get_pointer(const ::boost::type_erasure::any<Concept, T>& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(const ::boost::type_erasure::any<Concept, T>& arg)
get_pointer	type_erasure/any_cast.hpp	/^const void* get_pointer(const ::boost::type_erasure::any<Concept, const T&>& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(const ::boost::type_erasure::any<Concept, const T&>& arg)
get_pointer	type_erasure/any_cast.hpp	/^void* get_pointer(::boost::type_erasure::any<Concept, T&>& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(::boost::type_erasure::any<Concept, T&>& arg)
get_pointer	type_erasure/any_cast.hpp	/^void* get_pointer(::boost::type_erasure::any<Concept, T>& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(::boost::type_erasure::any<Concept, T>& arg)
get_pointer	type_erasure/any_cast.hpp	/^void* get_pointer(const ::boost::type_erasure::any<Concept, T&>& arg)$/;"	f	namespace:boost::type_erasure::detail	signature:(const ::boost::type_erasure::any<Concept, T&>& arg)
get_signature	type_erasure/detail/get_signature.hpp	/^struct get_signature {$/;"	s	namespace:boost::type_erasure::detail
get_vtable_signature	type_erasure/detail/adapt_to_vtable.hpp	/^struct get_vtable_signature<R(T...)>$/;"	s	namespace:boost::type_erasure::detail
has_key_impl	type_erasure/detail/normalize.hpp	/^struct has_key_impl< ::boost::type_erasure::detail::substitution_map_tag>$/;"	s	namespace:boost::mpl
identity	type_erasure/detail/rebind_placeholders.hpp	/^struct identity$/;"	s	namespace:boost::type_erasure::detail
impl	type_erasure/binding.hpp	/^    } impl;$/;"	m	class:boost::type_erasure::binding	typeref:struct:boost::type_erasure::binding::impl_type	access:private
impl	type_erasure/detail/normalize.hpp	/^    typedef typename normalize_concept_impl<Concept>::type impl;$/;"	t	struct:boost::type_erasure::detail::normalize_concept	access:public
impl_type	type_erasure/binding.hpp	/^        impl_type() {$/;"	f	struct:boost::type_erasure::binding::impl_type	access:public	signature:()
impl_type	type_erasure/binding.hpp	/^        impl_type(const binding<Concept2>& other, const static_binding<Map>&, boost::mpl::false_)$/;"	f	struct:boost::type_erasure::binding::impl_type	access:public	signature:(const binding<Concept2>& other, const static_binding<Map>&, boost::mpl::false_)
impl_type	type_erasure/binding.hpp	/^        impl_type(const binding<Concept2>& other, const static_binding<Map>&, boost::mpl::true_)$/;"	f	struct:boost::type_erasure::binding::impl_type	access:public	signature:(const binding<Concept2>& other, const static_binding<Map>&, boost::mpl::true_)
impl_type	type_erasure/binding.hpp	/^        impl_type(const static_binding<Map>&)$/;"	f	struct:boost::type_erasure::binding::impl_type	access:public	signature:(const static_binding<Map>&)
impl_type	type_erasure/binding.hpp	/^    struct impl_type$/;"	s	class:boost::type_erasure::binding	access:private
indirect_deduced_placeholders	type_erasure/detail/check_map.hpp	/^    >::type indirect_deduced_placeholders;$/;"	t	struct:boost::type_erasure::detail::check_map	access:public
insert_concept	type_erasure/detail/normalize.hpp	/^struct insert_concept$/;"	s	namespace:boost::type_erasure::detail
insert_concept	type_erasure/detail/normalize.hpp	/^struct insert_concept<Out, ::boost::type_erasure::same_type<T, U> >$/;"	s	namespace:boost::type_erasure::detail
is_any	type_erasure/any.hpp	/^struct is_any : ::boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::false_
is_any	type_erasure/any.hpp	/^struct is_any<any<Concept, T> > : ::boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::true_
is_deduced	type_erasure/detail/check_map.hpp	/^struct is_deduced : boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::false_
is_deduced	type_erasure/detail/check_map.hpp	/^struct is_deduced< ::boost::type_erasure::deduced<T> > : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
is_empty	type_erasure/is_empty.hpp	/^bool is_empty(const T& arg) {$/;"	f	namespace:boost::type_erasure	signature:(const T& arg)
is_internal_concept	type_erasure/detail/adapt_to_vtable.hpp	/^struct is_internal_concept :$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::type_erasure::detail::has_type
is_non_const_ref	type_erasure/detail/const.hpp	/^struct is_non_const_ref : boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::false_
is_non_const_ref	type_erasure/detail/const.hpp	/^struct is_non_const_ref<T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
is_non_const_ref	type_erasure/detail/const.hpp	/^struct is_non_const_ref<const T&> : boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::false_
is_placeholder	type_erasure/is_placeholder.hpp	/^struct is_placeholder : ::boost::is_base_and_derived<placeholder, T> {};$/;"	s	namespace:boost::type_erasure	inherits:::boost::is_base_and_derived
is_placeholder	type_erasure/is_placeholder.hpp	/^struct is_placeholder< ::boost::use_default> : ::boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure	inherits:::boost::mpl::false_
is_placeholder_arg	type_erasure/call.hpp	/^struct is_placeholder_arg :$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::type_erasure::is_placeholder
is_relaxed	type_erasure/relaxed.hpp	/^struct is_relaxed :$/;"	s	namespace:boost::type_erasure	inherits:::boost::mpl::eval_if::type
is_relaxed	type_erasure/relaxed.hpp	/^struct is_relaxed< ::boost::type_erasure::relaxed> :$/;"	s	namespace:boost::type_erasure	inherits:::boost::mpl::true_
is_relaxed_impl	type_erasure/relaxed.hpp	/^struct is_relaxed_impl :$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::not_::type
is_subconcept	type_erasure/is_subconcept.hpp	/^struct is_subconcept : ::boost::type_erasure::detail::is_subconcept_impl<Sub, Super, PlaceholderMap>::type {$/;"	s	namespace:boost::type_erasure	inherits:::boost::type_erasure::detail::is_subconcept_impl::type
is_subconcept	type_erasure/is_subconcept.hpp	/^struct is_subconcept<Sub, Super, static_binding<PlaceholderMap> > :$/;"	s	namespace:boost::type_erasure	inherits:::boost::type_erasure::detail::is_subconcept_impl::type
is_subconcept_impl	type_erasure/is_subconcept.hpp	/^struct is_subconcept_impl {$/;"	s	namespace:boost::type_erasure::detail
istreamable	type_erasure/operators.hpp	/^struct istreamable$/;"	s	namespace:boost::type_erasure
iterator	type_erasure/iterator.hpp	/^struct iterator$/;"	s	namespace:boost::type_erasure
iterator	type_erasure/iterator.hpp	/^struct iterator< ::boost::bidirectional_traversal_tag, T, Reference, DifferenceType, ValueType> :$/;"	s	namespace:boost::type_erasure	inherits:boost::mpl::vector
iterator	type_erasure/iterator.hpp	/^struct iterator< ::boost::forward_traversal_tag, T, Reference, DifferenceType, ValueType> :$/;"	s	namespace:boost::type_erasure	inherits:iterator
iterator	type_erasure/iterator.hpp	/^struct iterator< ::boost::incrementable_traversal_tag, T, Reference, DifferenceType, ValueType> :$/;"	s	namespace:boost::type_erasure	inherits:boost::mpl::vector
iterator	type_erasure/iterator.hpp	/^struct iterator< ::boost::no_traversal_tag, T, Reference, DifferenceType, ValueType> :$/;"	s	namespace:boost::type_erasure	inherits:boost::mpl::vector
iterator	type_erasure/iterator.hpp	/^struct iterator< ::boost::random_access_traversal_tag, T, Reference, DifferenceType, ValueType> :$/;"	s	namespace:boost::type_erasure	inherits:boost::mpl::vector
iterator	type_erasure/iterator.hpp	/^struct iterator< ::boost::single_pass_traversal_tag, T, Reference, DifferenceType, ValueType> :$/;"	s	namespace:boost::type_erasure	inherits:iterator
iterator_category	type_erasure/iterator.hpp	/^    typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	struct:boost::type_erasure::concept_interface	access:public
iterator_category	type_erasure/iterator.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	struct:boost::type_erasure::concept_interface	access:public
iterator_category	type_erasure/iterator.hpp	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	struct:boost::type_erasure::concept_interface	access:public
iterator_reference	type_erasure/iterator.hpp	/^struct iterator_reference$/;"	s	namespace:boost::type_erasure
iterator_reference	type_erasure/iterator.hpp	/^struct iterator_reference< ::boost::use_default, ValueType>$/;"	s	namespace:boost::type_erasure
iterator_value_type	type_erasure/iterator.hpp	/^struct iterator_value_type$/;"	s	namespace:boost::type_erasure
iterator_value_type_impl	type_erasure/iterator.hpp	/^struct iterator_value_type_impl$/;"	s	namespace:boost::type_erasure::detail
less_impl	type_erasure/operators.hpp	/^bool less_impl(const F& f, const T& lhs, const U& rhs, ::boost::mpl::false_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const F& f, const T& lhs, const U& rhs, ::boost::mpl::false_)
less_impl	type_erasure/operators.hpp	/^bool less_impl(const F& f, const T& lhs, const U& rhs, ::boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const F& f, const T& lhs, const U& rhs, ::boost::mpl::true_)
less_than_comparable	type_erasure/operators.hpp	/^struct less_than_comparable$/;"	s	namespace:boost::type_erasure
lookup	type_erasure/detail/vtable.hpp	/^    typename U::type lookup(U*) const$/;"	f	struct:boost::type_erasure::detail::vtable_storage	access:public	signature:(U*) const
make	type_erasure/any.hpp	/^T make(T*) { return T(); }$/;"	f	namespace:boost::type_erasure::detail	signature:(T*)
make_arg_pack	type_erasure/detail/vtable.hpp	/^struct make_arg_pack$/;"	s	namespace:boost::type_erasure::detail
make_arg_pack_impl	type_erasure/detail/vtable.hpp	/^struct make_arg_pack_impl$/;"	s	namespace:boost::type_erasure::detail
make_arg_pack_impl	type_erasure/detail/vtable.hpp	/^struct make_arg_pack_impl<End, End, T...>$/;"	s	namespace:boost::type_erasure::detail
make_binding	type_erasure/static_binding.hpp	/^static_binding<Map> make_binding() { return static_binding<Map>(); }$/;"	f	namespace:boost::type_erasure	signature:()
make_fallback	type_erasure/any.hpp	/^const T& make_fallback(const T& arg, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const T& arg, boost::mpl::true_)
make_fallback	type_erasure/any.hpp	/^fallback make_fallback(const T&, boost::mpl::false_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const T&, boost::mpl::false_)
make_instantiate_concept	type_erasure/detail/instantiate.hpp	/^struct make_instantiate_concept {$/;"	s	namespace:boost::type_erasure::detail
make_vtable	type_erasure/detail/vtable.hpp	/^struct make_vtable$/;"	s	namespace:boost::type_erasure::detail
make_vtable_impl	type_erasure/detail/vtable.hpp	/^struct make_vtable_impl<stored_arg_pack<T...> >$/;"	s	namespace:boost::type_erasure::detail
make_vtable_init	type_erasure/detail/vtable.hpp	/^struct make_vtable_init$/;"	s	namespace:boost::type_erasure::detail
make_vtable_init_impl	type_erasure/detail/vtable.hpp	/^struct make_vtable_init_impl<Table, stored_arg_pack<T...> >$/;"	s	namespace:boost::type_erasure::detail
manager	type_erasure/binding.hpp	/^        ::boost::shared_ptr<table_type> manager;$/;"	m	struct:boost::type_erasure::binding::impl_type	access:public
map_type	type_erasure/detail/normalize.hpp	/^    typedef M map_type;$/;"	t	struct:boost::type_erasure::detail::substitution_map	access:public
maybe_adapt_to_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct maybe_adapt_to_vtable$/;"	s	namespace:boost::type_erasure::detail
maybe_check_table	type_erasure/check_match.hpp	/^bool maybe_check_table(const T& arg, const Table*& table, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const T& arg, const Table*& table, boost::mpl::true_)
maybe_check_table	type_erasure/check_match.hpp	/^bool maybe_check_table(const T&, const Table*&, boost::mpl::false_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const T&, const Table*&, boost::mpl::false_)
maybe_const_this_param	type_erasure/detail/const.hpp	/^struct maybe_const_this_param$/;"	s	namespace:boost::type_erasure::detail
maybe_const_this_param	type_erasure/detail/const.hpp	/^struct maybe_const_this_param<Placeholder&&, Base>$/;"	s	namespace:boost::type_erasure::detail
maybe_extract_concept	type_erasure/detail/extract_concept.hpp	/^struct maybe_extract_concept$/;"	s	namespace:boost::type_erasure::detail
maybe_get_table	type_erasure/call.hpp	/^int maybe_get_table(const T& arg, const Table*& table, boost::mpl::true_)$/;"	f	namespace:boost::type_erasure::detail	signature:(const T& arg, const Table*& table, boost::mpl::true_)
maybe_get_table	type_erasure/call.hpp	/^int maybe_get_table(const T&, const Table*&, boost::mpl::false_) { return 0; }$/;"	f	namespace:boost::type_erasure::detail	signature:(const T&, const Table*&, boost::mpl::false_)
mpl	type_erasure/detail/normalize.hpp	/^namespace mpl {$/;"	n	namespace:boost
no	type_erasure/any.hpp	/^typedef char no;$/;"	t	namespace:boost::type_erasure::detail
non_const_this_param	type_erasure/detail/const.hpp	/^struct non_const_this_param$/;"	s	namespace:boost::type_erasure::detail
normalize_concept	type_erasure/detail/normalize.hpp	/^struct normalize_concept$/;"	s	namespace:boost::type_erasure::detail
normalize_concept_impl	type_erasure/detail/normalize.hpp	/^struct normalize_concept_impl$/;"	s	namespace:boost::type_erasure::detail
normalize_placeholder	type_erasure/detail/normalize.hpp	/^struct normalize_placeholder$/;"	s	namespace:boost::type_erasure::detail
normalize_placeholder	type_erasure/detail/normalize.hpp	/^struct normalize_placeholder<M, ::boost::type_erasure::deduced<T> >$/;"	s	namespace:boost::type_erasure::detail
normalized	type_erasure/binding.hpp	/^        Concept>::type normalized;$/;"	t	class:boost::type_erasure::binding	access:private
normalized	type_erasure/detail/instantiate.hpp	/^        Concept>::type normalized;$/;"	t	struct:boost::type_erasure::detail::make_instantiate_concept	access:public
normalized_sub	type_erasure/is_subconcept.hpp	/^        Sub>::type normalized_sub;$/;"	t	struct:boost::type_erasure::detail::is_subconcept_impl	access:public
null_construct	type_erasure/constructible.hpp	/^struct null_construct<void(T...)>$/;"	s	namespace:boost::type_erasure::detail
null_destroy	type_erasure/builtin.hpp	/^struct null_destroy {$/;"	s	namespace:boost::type_erasure::detail
operator !=	type_erasure/binding.hpp	/^    friend bool operator!=(const binding& lhs, const binding& rhs)$/;"	f	class:boost::type_erasure::binding	access:friend	signature:(const binding& lhs, const binding& rhs)
operator !=	type_erasure/operators.hpp	/^    friend bool operator!=(const T& lhs, const typename derived<Base>::type& rhs)$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const T& lhs, const typename derived<Base>::type& rhs)
operator !=	type_erasure/operators.hpp	/^    friend bool operator!=(const typename derived<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, typename as_param<Base, const U&>::type rhs)
operator *	type_erasure/operators.hpp	/^    typename ::boost::type_erasure::rebind_any<Base, R>::type operator*() const$/;"	f	struct:boost::type_erasure::concept_interface	access:public	signature:() const
operator <	type_erasure/operators.hpp	/^    friend bool operator<(const T& lhs, const typename derived<Base>::type& rhs)$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const T& lhs, const typename derived<Base>::type& rhs)
operator <	type_erasure/operators.hpp	/^    friend bool operator<(const typename derived<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, typename as_param<Base, const T&>::type rhs)
operator <	type_erasure/operators.hpp	/^    friend bool operator<(const typename derived<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, typename as_param<Base, const U&>::type rhs)
operator <<	type_erasure/operators.hpp	/^    operator<<(Os& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(Os& lhs, const typename ::boost::type_erasure::derived<Base>::type& rhs)
operator <<	type_erasure/operators.hpp	/^    operator<<(typename detail::non_const_this_param<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(typename detail::non_const_this_param<Base>::type& lhs, typename ::boost::type_erasure::as_param<Base, const T&>::type rhs)
operator <=	type_erasure/operators.hpp	/^    friend bool operator<=(const typename derived<Base>::type& lhs, const T& rhs)$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, const T& rhs)
operator <=	type_erasure/operators.hpp	/^    friend bool operator<=(typename as_param<Base, const T&>::type lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(typename as_param<Base, const T&>::type lhs, const typename derived<Base>::type& rhs)
operator <=	type_erasure/operators.hpp	/^    friend bool operator<=(typename as_param<Base, const U&>::type lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(typename as_param<Base, const U&>::type lhs, const typename derived<Base>::type& rhs)
operator =	type_erasure/any.hpp	/^    any& operator=(U& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(U& other)
operator =	type_erasure/any.hpp	/^    any& operator=(const U& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const U& other)
operator =	type_erasure/any.hpp	/^    any& operator=(const any& other)$/;"	f	class:boost::type_erasure::any	access:public	signature:(const any& other)
operator ==	type_erasure/binding.hpp	/^    friend bool operator==(const binding& lhs, const binding& rhs)$/;"	f	class:boost::type_erasure::binding	access:friend	signature:(const binding& lhs, const binding& rhs)
operator ==	type_erasure/detail/vtable.hpp	/^    bool operator==(const vtable_storage& other) const$/;"	f	struct:boost::type_erasure::detail::vtable_storage	access:public	signature:(const vtable_storage& other) const
operator ==	type_erasure/operators.hpp	/^    friend bool operator==(const T& lhs, const typename derived<Base>::type& rhs)$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const T& lhs, const typename derived<Base>::type& rhs)
operator ==	type_erasure/operators.hpp	/^    friend bool operator==(const typename derived<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, typename as_param<Base, const U&>::type rhs)
operator >	type_erasure/operators.hpp	/^    friend bool operator>(const typename derived<Base>::type& lhs, const T& rhs)$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, const T& rhs)
operator >	type_erasure/operators.hpp	/^    friend bool operator>(typename as_param<Base, const T&>::type lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(typename as_param<Base, const T&>::type lhs, const typename derived<Base>::type& rhs)
operator >	type_erasure/operators.hpp	/^    friend bool operator>(typename as_param<Base, const U&>::type lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(typename as_param<Base, const U&>::type lhs, const typename derived<Base>::type& rhs)
operator >=	type_erasure/operators.hpp	/^    friend bool operator>=(const T& lhs, const typename derived<Base>::type& rhs)$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const T& lhs, const typename derived<Base>::type& rhs)
operator >=	type_erasure/operators.hpp	/^    friend bool operator>=(const typename derived<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, typename as_param<Base, const T&>::type rhs)
operator >=	type_erasure/operators.hpp	/^    friend bool operator>=(const typename derived<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(const typename derived<Base>::type& lhs, typename as_param<Base, const U&>::type rhs)
operator >>	type_erasure/operators.hpp	/^    operator>>(Is& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(Is& lhs, typename ::boost::type_erasure::derived<Base>::type& rhs)
operator >>	type_erasure/operators.hpp	/^    operator>>(typename detail::non_const_this_param<Base>::type& lhs,$/;"	f	struct:boost::type_erasure::concept_interface	access:friend	signature:(typename detail::non_const_this_param<Base>::type& lhs, typename ::boost::type_erasure::as_param<Base, T&>::type rhs)
operator []	type_erasure/operators.hpp	/^    typename ::boost::type_erasure::rebind_any<Base, R>::type operator[]($/;"	f	struct:boost::type_erasure::concept_interface	access:public	signature:( typename ::boost::type_erasure::as_param<Base, const N&>::type index)
operator []	type_erasure/operators.hpp	/^    typename ::boost::type_erasure::rebind_any<Base, R>::type operator[]($/;"	f	struct:boost::type_erasure::concept_interface	access:public	signature:( typename ::boost::type_erasure::as_param<Base, const N&>::type index) const
operator param<Concept, T&&>	type_erasure/any.hpp	/^    operator param<Concept, T&&>() && { return param<Concept, T&&>(data, table); }$/;"	f	class:boost::type_erasure::any	access:public	signature:()
operator param<Concept, T&&>	type_erasure/any.hpp	/^    operator param<Concept, T&&>() const { return param<Concept, T&&>(data, table); }$/;"	f	class:boost::type_erasure::any	access:public	signature:() const
operator param<Concept, T&>	type_erasure/any.hpp	/^    operator param<Concept, T&>() & { return param<Concept, T&>(data, table); }$/;"	f	class:boost::type_erasure::any	access:public	signature:()
operator param<Concept, T&>	type_erasure/any.hpp	/^    operator param<Concept, T&>() const { return param<Concept, T&>(data, table); }$/;"	f	class:boost::type_erasure::any	access:public	signature:() const
operator param<Concept, const T&>	type_erasure/any.hpp	/^    operator param<Concept, const T&>() const { return param<Concept, const T&>(data, table); }$/;"	f	class:boost::type_erasure::any	access:public	signature:() const
ostreamable	type_erasure/operators.hpp	/^struct ostreamable$/;"	s	namespace:boost::type_erasure
param	type_erasure/param.hpp	/^    param(U& u, typename boost::enable_if< ::boost::is_same<U, const any<Concept, T> > >::type* = 0) : _impl(u) {}$/;"	f	class:boost::type_erasure::param	access:public	signature:(U& u, typename boost::enable_if< ::boost::is_same<U, const any<Concept, T> > >::type* = 0)
param	type_erasure/param.hpp	/^    param(any<Concept, U>& a$/;"	f	class:boost::type_erasure::param	access:public	signature:(any<Concept, U>& a , typename boost::enable_if< ::boost::type_erasure::detail::placeholder_conversion<U, T> >::type* = 0 )
param	type_erasure/param.hpp	/^    param(any<Concept, U>&& a$/;"	f	class:boost::type_erasure::param	access:public	signature:(any<Concept, U>&& a , typename boost::enable_if< ::boost::type_erasure::detail::placeholder_conversion< U&&, T > >::type* = 0 )
param	type_erasure/param.hpp	/^    param(const ::boost::type_erasure::detail::storage& data,$/;"	f	class:boost::type_erasure::param	access:public	signature:(const ::boost::type_erasure::detail::storage& data, const ::boost::type_erasure::binding<Concept>& table)
param	type_erasure/param.hpp	/^    param(const any<Concept, U>& a$/;"	f	class:boost::type_erasure::param	access:public	signature:(const any<Concept, U>& a , typename boost::enable_if< ::boost::type_erasure::detail::placeholder_conversion< typename ::boost::add_const<U>::type, T > >::type* = 0 )
param	type_erasure/param.hpp	/^class param {$/;"	c	namespace:boost::type_erasure
param	type_erasure/param.hpp	/^class param<Concept, T&&> : public param<Concept, const T&> {$/;"	c	namespace:boost::type_erasure	inherits:param
param	type_erasure/param.hpp	/^class param<Concept, T&> : public param<Concept, const T&> {$/;"	c	namespace:boost::type_erasure	inherits:param
param	type_erasure/param.hpp	/^class param<Concept, const T&> {$/;"	c	namespace:boost::type_erasure
placeholder	type_erasure/detail/check_call.hpp	/^    typedef typename ::boost::type_erasure::placeholder_of<T>::type placeholder;$/;"	t	struct:boost::type_erasure::detail::qualified_placeholder	access:public
placeholder	type_erasure/detail/const.hpp	/^    typedef typename ::boost::type_erasure::placeholder_of<Base>::type placeholder;$/;"	t	struct:boost::type_erasure::detail::non_const_this_param	access:public
placeholder	type_erasure/placeholder.hpp	/^struct placeholder {};$/;"	s	namespace:boost::type_erasure
placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion : boost::mpl::false_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::false_
placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T&&, T&&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T&&, T> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T&&, const T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T&, T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T&, T> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T&, const T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T, T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T, T> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<T, const T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<const T&, T> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<const T&, const T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<const T, T> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
placeholder_conversion	type_erasure/param.hpp	/^struct placeholder_conversion<const T, const T&> : boost::mpl::true_ {};$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::true_
placeholder_of	type_erasure/placeholder_of.hpp	/^struct placeholder_of$/;"	s	namespace:boost::type_erasure
placeholder_of	type_erasure/placeholder_of.hpp	/^struct placeholder_of< ::boost::type_erasure::any<Concept, T> >$/;"	s	namespace:boost::type_erasure
placeholder_of	type_erasure/placeholder_of.hpp	/^struct placeholder_of< ::boost::type_erasure::param<Concept, T> >$/;"	s	namespace:boost::type_erasure
placeholder_subs	type_erasure/binding.hpp	/^    >::type placeholder_subs;$/;"	t	class:boost::type_erasure::binding	access:private
placeholder_subs	type_erasure/detail/check_map.hpp	/^        Concept>::type placeholder_subs;$/;"	t	struct:boost::type_erasure::detail::check_map	access:public
placeholder_subs_sub	type_erasure/is_subconcept.hpp	/^    >::type placeholder_subs_sub;$/;"	t	struct:boost::type_erasure::detail::is_subconcept_impl	access:public
placeholder_subs_super	type_erasure/is_subconcept.hpp	/^    >::type placeholder_subs_super;$/;"	t	struct:boost::type_erasure::detail::is_subconcept_impl	access:public
placeholders	type_erasure/detail/check_map.hpp	/^    >::type placeholders;$/;"	t	struct:boost::type_erasure::detail::check_map	access:public
placeholders	type_erasure/detail/normalize.hpp	/^    >::type placeholders;$/;"	t	struct:boost::type_erasure::detail::add_typeinfo	access:public
plain_placeholder	type_erasure/detail/const.hpp	/^    typedef typename ::boost::remove_reference<Placeholder>::type plain_placeholder;$/;"	t	struct:boost::type_erasure::detail::maybe_const_this_param	access:public
plain_type	type_erasure/detail/const.hpp	/^    typedef typename ::boost::type_erasure::derived<Base>::type plain_type;$/;"	t	struct:boost::type_erasure::detail::maybe_const_this_param	access:public
plain_type	type_erasure/detail/const.hpp	/^    typedef typename ::boost::type_erasure::derived<Base>::type plain_type;$/;"	t	struct:boost::type_erasure::detail::non_const_this_param	access:public
pointer	type_erasure/iterator.hpp	/^    >::type pointer;$/;"	t	struct:boost::type_erasure::concept_interface	access:public
qualified_placeholder	type_erasure/detail/check_call.hpp	/^struct qualified_placeholder$/;"	s	namespace:boost::type_erasure::detail
qualified_placeholder	type_erasure/detail/check_call.hpp	/^struct qualified_placeholder<T&&, typename T::_boost_type_erasure_is_any>$/;"	s	namespace:boost::type_erasure::detail
qualified_placeholder	type_erasure/detail/check_call.hpp	/^struct qualified_placeholder<T&, typename T::_boost_type_erasure_is_any>$/;"	s	namespace:boost::type_erasure::detail
random_access_iterator	type_erasure/iterator.hpp	/^struct random_access_iterator :$/;"	s	namespace:boost::type_erasure	inherits:iterator
rebind_any	type_erasure/rebind_any.hpp	/^struct rebind_any$/;"	s	namespace:boost::type_erasure
rebind_placeholders	type_erasure/detail/adapt_to_vtable.hpp	/^struct rebind_placeholders<vtable_adapter<PrimitiveConcept, Sig>, Bindings>$/;"	s	namespace:boost::type_erasure::detail
rebind_placeholders	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders$/;"	s	namespace:boost::type_erasure::detail
rebind_placeholders	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders<T<U...>, Bindings>$/;"	s	namespace:boost::type_erasure::detail
rebind_placeholders_in_argument	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders_in_argument$/;"	s	namespace:boost::type_erasure::detail
rebind_placeholders_in_argument	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders_in_argument<$/;"	s	namespace:boost::type_erasure::detail
rebind_placeholders_in_argument	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders_in_argument<R(T...), Bindings>$/;"	s	namespace:boost::type_erasure::detail
rebind_placeholders_in_argument	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders_in_argument<T&&, Bindings>$/;"	s	namespace:boost::type_erasure::detail
rebind_placeholders_in_argument	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders_in_argument<T&, Bindings>$/;"	s	namespace:boost::type_erasure::detail
rebind_placeholders_in_argument	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders_in_argument<const T, Bindings>$/;"	s	namespace:boost::type_erasure::detail
rebind_placeholders_in_deduced	type_erasure/detail/rebind_placeholders.hpp	/^struct rebind_placeholders_in_deduced$/;"	s	namespace:boost::type_erasure::detail
reference	type_erasure/iterator.hpp	/^    >::type reference;$/;"	t	struct:boost::type_erasure::concept_interface	access:public
reference	type_erasure/iterator.hpp	/^    typedef Reference reference;$/;"	t	struct:boost::type_erasure::iterator	access:public
reference	type_erasure/iterator.hpp	/^    typedef typename iterator_reference<Reference, ValueType>::type reference;$/;"	t	struct:boost::type_erasure::iterator	access:public
relaxed	type_erasure/relaxed.hpp	/^struct relaxed : ::boost::mpl::vector0<> {};$/;"	s	namespace:boost::type_erasure	inherits:::boost::mpl::vector0
replace_param_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_param_for_vtable$/;"	s	namespace:boost::type_erasure::detail
replace_param_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_param_for_vtable<T&&>$/;"	s	namespace:boost::type_erasure::detail
replace_param_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_param_for_vtable<T&>$/;"	s	namespace:boost::type_erasure::detail
replace_param_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_param_for_vtable<const T&>$/;"	s	namespace:boost::type_erasure::detail
replace_result_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_result_for_vtable$/;"	s	namespace:boost::type_erasure::detail
replace_result_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_result_for_vtable<T&&>$/;"	s	namespace:boost::type_erasure::detail
replace_result_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_result_for_vtable<T&>$/;"	s	namespace:boost::type_erasure::detail
replace_result_for_vtable	type_erasure/detail/adapt_to_vtable.hpp	/^struct replace_result_for_vtable<const T&>$/;"	s	namespace:boost::type_erasure::detail
require_match	type_erasure/require_match.hpp	/^void require_match($/;"	f	namespace:boost::type_erasure	signature:( const ::boost::type_erasure::binding<Concept>& table, const Op& op, U&&... arg)
require_match	type_erasure/require_match.hpp	/^void require_match($/;"	f	namespace:boost::type_erasure	signature:( const Op& op, U&&... arg)
require_match	type_erasure/require_match.hpp	/^void require_match(const Op& f, U&&... args);$/;"	p	namespace:boost::type_erasure	signature:(const Op& f, U&&... args)
require_match	type_erasure/require_match.hpp	/^void require_match(const binding<Concept>& binding_arg, const Op& f, U&&... args);$/;"	p	namespace:boost::type_erasure	signature:(const binding<Concept>& binding_arg, const Op& f, U&&... args)
require_match_impl	type_erasure/require_match.hpp	/^void require_match_impl($/;"	f	namespace:boost::type_erasure::detail	signature:( ::boost::mpl::false_, const ::boost::type_erasure::binding<Concept>&, const Op&, U&&...)
require_match_impl	type_erasure/require_match.hpp	/^void require_match_impl($/;"	f	namespace:boost::type_erasure::detail	signature:( ::boost::mpl::false_, const Op&, U&&...)
require_match_impl	type_erasure/require_match.hpp	/^void require_match_impl($/;"	f	namespace:boost::type_erasure::detail	signature:( ::boost::mpl::true_, const ::boost::type_erasure::binding<Concept>& table, const Op& op, U&&... arg)
require_match_impl	type_erasure/require_match.hpp	/^void require_match_impl($/;"	f	namespace:boost::type_erasure::detail	signature:( ::boost::mpl::true_, const Op& op, U&&... arg)
resolve_same_type	type_erasure/detail/normalize.hpp	/^struct resolve_same_type$/;"	s	namespace:boost::type_erasure::detail
result	type_erasure/detail/normalize.hpp	/^    >::type result;$/;"	t	struct:boost::type_erasure::detail::add_deduced	access:public
result	type_erasure/detail/normalize.hpp	/^    typedef typename ::boost::mpl::at<Sub, result1>::type result;$/;"	t	struct:boost::type_erasure::detail::convert_deduced	access:public
result1	type_erasure/detail/normalize.hpp	/^    >::type result1;$/;"	t	struct:boost::type_erasure::detail::convert_deduced	access:public
same_type	type_erasure/same_type.hpp	/^struct same_type {};$/;"	s	namespace:boost::type_erasure
select_pair	type_erasure/detail/normalize.hpp	/^struct select_pair$/;"	s	namespace:boost::type_erasure::detail
select_pair	type_erasure/detail/normalize.hpp	/^struct select_pair< ::boost::type_erasure::deduced<T>, U>$/;"	s	namespace:boost::type_erasure::detail
select_pair	type_erasure/detail/normalize.hpp	/^struct select_pair<$/;"	s	namespace:boost::type_erasure::detail
select_pair	type_erasure/detail/normalize.hpp	/^struct select_pair<T, ::boost::type_erasure::deduced<U> >$/;"	s	namespace:boost::type_erasure::detail
self_placeholder	type_erasure/detail/const.hpp	/^    typedef typename ::boost::type_erasure::placeholder_of<plain_type>::type self_placeholder;$/;"	t	struct:boost::type_erasure::detail::maybe_const_this_param	access:public
should_be_const	type_erasure/detail/const.hpp	/^struct should_be_const :$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::or_
should_be_non_const	type_erasure/detail/const.hpp	/^struct should_be_non_const :$/;"	s	namespace:boost::type_erasure::detail	inherits:::boost::mpl::and_
should_check	type_erasure/check_match.hpp	/^struct should_check :$/;"	s	namespace:boost::type_erasure::detail	inherits:boost::mpl::and_
static_binding	type_erasure/static_binding.hpp	/^struct static_binding {};$/;"	s	namespace:boost::type_erasure
storage	type_erasure/detail/storage.hpp	/^    storage() {}$/;"	f	struct:boost::type_erasure::detail::storage	access:public	signature:()
storage	type_erasure/detail/storage.hpp	/^    storage(const T& arg) : data(new T(arg)) {}$/;"	f	struct:boost::type_erasure::detail::storage	access:public	signature:(const T& arg)
storage	type_erasure/detail/storage.hpp	/^struct storage$/;"	s	namespace:boost::type_erasure::detail
subscriptable	type_erasure/operators.hpp	/^struct subscriptable$/;"	s	namespace:boost::type_erasure
substitution_map	type_erasure/detail/normalize.hpp	/^struct substitution_map$/;"	s	namespace:boost::type_erasure::detail
substitution_map_tag	type_erasure/detail/normalize.hpp	/^struct substitution_map_tag {};$/;"	s	namespace:boost::type_erasure::detail
substitutions	type_erasure/detail/normalize.hpp	/^    >::type substitutions;$/;"	t	struct:boost::type_erasure::detail::normalize_concept	access:public
super_set	type_erasure/is_subconcept.hpp	/^        Super>::concept_set super_set;$/;"	t	struct:boost::type_erasure::detail::is_subconcept_impl	access:public
t1	type_erasure/detail/normalize.hpp	/^    >::type t1;$/;"	t	struct:boost::type_erasure::detail::insert_concept	access:public
t2	type_erasure/detail/normalize.hpp	/^    >::type t2;$/;"	t	struct:boost::type_erasure::detail::insert_concept	access:public
table	type_erasure/any.hpp	/^    table_type table;$/;"	m	class:boost::type_erasure::any	access:private
table	type_erasure/binding.hpp	/^        const table_type* table;$/;"	m	struct:boost::type_erasure::binding::impl_type	access:public
table	type_erasure/detail/access.hpp	/^    table(const ::boost::type_erasure::any_base<Derived>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::any_base<Derived>& arg)
table	type_erasure/detail/access.hpp	/^    table(const ::boost::type_erasure::param<Concept, T>& arg)$/;"	f	struct:boost::type_erasure::detail::access	access:public	signature:(const ::boost::type_erasure::param<Concept, T>& arg)
table_type	type_erasure/any.hpp	/^    typedef ::boost::type_erasure::binding<Concept> table_type;$/;"	t	class:boost::type_erasure::any	access:private
table_type	type_erasure/binding.hpp	/^        actual_concept>::type table_type;$/;"	t	class:boost::type_erasure::binding	access:private
tag	type_erasure/detail/normalize.hpp	/^    typedef substitution_map_tag tag;$/;"	t	struct:boost::type_erasure::detail::substitution_map	access:public
transform	type_erasure/is_subconcept.hpp	/^    >::type transform;$/;"	t	struct:boost::type_erasure::detail::is_subconcept_impl	access:public
transformed	type_erasure/detail/normalize.hpp	/^    >::type transformed;$/;"	t	struct:boost::type_erasure::detail::collect_concepts	access:public
tuple	type_erasure/tuple.hpp	/^    explicit tuple(U&&... args);$/;"	p	class:boost::type_erasure::tuple	access:public	signature:(U&&.... args)
tuple	type_erasure/tuple.hpp	/^class tuple$/;"	c	namespace:boost::type_erasure
type	type_erasure/any.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::compute_bases	access:public
type	type_erasure/builtin.hpp	/^    typedef ::boost::type_erasure::detail::null_destroy type;$/;"	t	struct:boost::type_erasure::detail::get_null_vtable_entry	access:public
type	type_erasure/builtin.hpp	/^    typedef const std::type_info& (*type)();$/;"	t	class:boost::type_erasure::typeid_::std	access:public
type	type_erasure/builtin.hpp	/^    typedef typeid_<void> type;$/;"	t	struct:boost::type_erasure::detail::get_null_vtable_entry	access:public
type	type_erasure/builtin.hpp	/^    typedef void (*type)(detail::storage&);$/;"	t	struct:boost::type_erasure::destructible	access:public
type	type_erasure/concept_of.hpp	/^    typedef Concept type;$/;"	t	struct:boost::type_erasure::concept_of	access:public
type	type_erasure/concept_of.hpp	/^    typedef detail::unspecified type;$/;"	t	struct:boost::type_erasure::concept_of	access:public
type	type_erasure/constructible.hpp	/^    typedef null_construct<void(U...)> type;$/;"	t	struct:boost::type_erasure::detail::get_null_vtable_entry	access:public
type	type_erasure/deduced.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::deduced	access:public
type	type_erasure/derived.hpp	/^    typedef detail::unspecified type;$/;"	t	struct:boost::type_erasure::derived	access:public
type	type_erasure/detail/adapt_to_vtable.hpp	/^    > type;$/;"	t	struct:boost::type_erasure::detail::adapt_to_vtable	access:public
type	type_erasure/detail/adapt_to_vtable.hpp	/^    > type;$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders	access:public
type	type_erasure/detail/adapt_to_vtable.hpp	/^    >::type type(typename ::boost::type_erasure::detail::replace_param_for_vtable<T>::type...);$/;"	t	struct:boost::type_erasure::detail::get_vtable_signature	access:public
type	type_erasure/detail/adapt_to_vtable.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::maybe_adapt_to_vtable	access:public
type	type_erasure/detail/adapt_to_vtable.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::replace_param_for_vtable	access:public
type	type_erasure/detail/adapt_to_vtable.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::replace_result_for_vtable	access:public
type	type_erasure/detail/adapt_to_vtable.hpp	/^    typedef ::boost::type_erasure::detail::storage (*type)(T...);$/;"	t	class:boost::type_erasure::detail::vtable_adapter_impl::boost::type_erasure::detail	access:public
type	type_erasure/detail/adapt_to_vtable.hpp	/^    typedef R (*type)(T...);$/;"	t	struct:boost::type_erasure::detail::vtable_adapter_impl	access:public
type	type_erasure/detail/check_call.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::check_arg	access:public
type	type_erasure/detail/check_call.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::qualified_placeholder	access:public
type	type_erasure/detail/check_call.hpp	/^    typedef placeholder&& type;$/;"	t	struct:boost::type_erasure::detail::qualified_placeholder	access:public
type	type_erasure/detail/check_call.hpp	/^    typedef void type;$/;"	t	struct:boost::type_erasure::detail::qualified_placeholder	access:public
type	type_erasure/detail/check_map.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::check_map	access:public
type	type_erasure/detail/const.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::maybe_const_this_param	access:public
type	type_erasure/detail/const.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::non_const_this_param	access:public
type	type_erasure/detail/extract_concept.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::extract_concept	access:public
type	type_erasure/detail/extract_concept.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::maybe_extract_concept	access:public
type	type_erasure/detail/extract_concept.hpp	/^    typedef void type;$/;"	t	struct:boost::type_erasure::detail::extract_concept	access:public
type	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<T, T> { typedef T type; };$/;"	t	struct:boost::type_erasure::detail::combine_concepts	access:public
type	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<T, void> { typedef T type; };$/;"	t	struct:boost::type_erasure::detail::combine_concepts	access:public
type	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<void, T> { typedef T type; };$/;"	t	struct:boost::type_erasure::detail::combine_concepts	access:public
type	type_erasure/detail/extract_concept.hpp	/^struct combine_concepts<void, void> { typedef void type; };$/;"	t	struct:boost::type_erasure::detail::combine_concepts	access:public
type	type_erasure/detail/get_placeholders.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::get_placeholders_impl	access:public
type	type_erasure/detail/get_placeholders.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::get_placeholders_in_argument	access:public
type	type_erasure/detail/get_placeholders.hpp	/^    typedef Out type;$/;"	t	struct:boost::type_erasure::detail::get_placeholders_impl	access:public
type	type_erasure/detail/get_placeholders.hpp	/^    typedef typename get_placeholders_impl<Out, U...>::type type;$/;"	t	struct:boost::type_erasure::detail::get_placeholders	access:public
type	type_erasure/detail/get_placeholders.hpp	/^    typedef typename get_placeholders_impl<type0, T...>::type type;$/;"	t	struct:boost::type_erasure::detail::get_placeholders_in_argument	access:public
type	type_erasure/detail/get_signature.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::get_signature	access:public
type	type_erasure/detail/instantiate.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::make_instantiate_concept	access:public
type	type_erasure/detail/normalize.hpp	/^        >::type type;$/;"	t	struct:boost::mpl::at_impl::apply	access:public
type	type_erasure/detail/normalize.hpp	/^        >::type type;$/;"	t	struct:boost::type_erasure::detail::append_typeinfo::apply	access:public
type	type_erasure/detail/normalize.hpp	/^    > type;$/;"	t	struct:boost::type_erasure::detail::insert_concept	access:public
type	type_erasure/detail/normalize.hpp	/^    > type;$/;"	t	struct:boost::type_erasure::detail::select_pair	access:public
type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::add_deduced	access:public
type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::add_deductions	access:public
type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::add_typeinfo	access:public
type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::collect_concepts	access:public
type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::convert_deduced	access:public
type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::convert_deductions	access:public
type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::create_placeholder_map	access:public
type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::get_placeholder_normalization_map	access:public
type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::normalize_concept	access:public
type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::normalize_concept_impl	access:public
type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::normalize_placeholder	access:public
type	type_erasure/detail/normalize.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::resolve_same_type	access:public
type	type_erasure/detail/normalize.hpp	/^    typedef ::boost::mpl::pair< ::boost::type_erasure::deduced<T>, U> type;$/;"	t	struct:boost::type_erasure::detail::select_pair	access:public
type	type_erasure/detail/normalize.hpp	/^    typedef ::boost::mpl::pair< ::boost::type_erasure::deduced<U>, T> type;$/;"	t	struct:boost::type_erasure::detail::select_pair	access:public
type	type_erasure/detail/normalize.hpp	/^    typedef void type;$/;"	t	struct:boost::type_erasure::detail::select_pair	access:public
type	type_erasure/detail/null.hpp	/^        typename ::boost::remove_pointer<typename Concept::type>::type> type;$/;"	t	struct:boost::type_erasure::detail::get_null_vtable_entry	access:public
type	type_erasure/detail/rebind_placeholders.hpp	/^    >::type type(typename rebind_placeholders_in_argument<T, Bindings>::type...);$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders_in_argument	access:public
type	type_erasure/detail/rebind_placeholders.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders_in_argument	access:public
type	type_erasure/detail/rebind_placeholders.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders_in_deduced	access:public
type	type_erasure/detail/rebind_placeholders.hpp	/^    >::type& type;$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders_in_argument	access:public
type	type_erasure/detail/rebind_placeholders.hpp	/^    >::type&& type;$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders_in_argument	access:public
type	type_erasure/detail/rebind_placeholders.hpp	/^    typedef T type;$/;"	t	struct:boost::type_erasure::detail::identity	access:public
type	type_erasure/detail/rebind_placeholders.hpp	/^    typedef T<typename rebind_placeholders_in_argument<U, Bindings>::type...> type;$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders	access:public
type	type_erasure/detail/rebind_placeholders.hpp	/^    typedef void type;$/;"	t	struct:boost::type_erasure::detail::rebind_placeholders	access:public
type	type_erasure/detail/vtable.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::make_arg_pack	access:public
type	type_erasure/detail/vtable.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::make_arg_pack_impl	access:public
type	type_erasure/detail/vtable.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::make_vtable	access:public
type	type_erasure/detail/vtable.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::make_vtable_init	access:public
type	type_erasure/detail/vtable.hpp	/^    typedef stored_arg_pack<T...> type;$/;"	t	struct:boost::type_erasure::detail::make_arg_pack_impl	access:public
type	type_erasure/detail/vtable.hpp	/^    typedef vtable_init<Table, T...> type;$/;"	t	struct:boost::type_erasure::detail::make_vtable_init_impl	access:public
type	type_erasure/detail/vtable.hpp	/^    typedef vtable_storage<T...> type;$/;"	t	struct:boost::type_erasure::detail::make_vtable_impl	access:public
type	type_erasure/free.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::first_placeholder	access:public
type	type_erasure/is_subconcept.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::detail::is_subconcept_impl	access:public
type	type_erasure/iterator.hpp	/^    >::type type;$/;"	t	struct:boost::type_erasure::iterator_value_type	access:public
type	type_erasure/iterator.hpp	/^    typedef Reference type;$/;"	t	struct:boost::type_erasure::iterator_reference	access:public
type	type_erasure/iterator.hpp	/^    typedef ValueType& type;$/;"	t	struct:boost::type_erasure::iterator_reference	access:public
type	type_erasure/iterator.hpp	/^    typedef typename ::std::iterator_traits<T>::value_type type;$/;"	t	struct:boost::type_erasure::detail::iterator_value_type_impl	access:public
type	type_erasure/param.hpp	/^    typedef detail::unspecified type;$/;"	t	struct:boost::type_erasure::as_param	access:public
type	type_erasure/placeholder_of.hpp	/^    typedef T type;$/;"	t	struct:boost::type_erasure::placeholder_of	access:public
type	type_erasure/placeholder_of.hpp	/^    typedef detail::unspecified type;$/;"	t	struct:boost::type_erasure::placeholder_of	access:public
type	type_erasure/rebind_any.hpp	/^    typedef detail::unspecified type;$/;"	t	struct:boost::type_erasure::rebind_any	access:public
type0	type_erasure/detail/get_placeholders.hpp	/^    >::type type0;$/;"	t	struct:boost::type_erasure::detail::get_placeholders_in_argument	access:public
type1	type_erasure/detail/normalize.hpp	/^    >::type type1;$/;"	t	struct:boost::type_erasure::detail::collect_concepts	access:public
type_erasure	type_erasure/any.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/any_cast.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/binding.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/binding_of.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/builtin.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/call.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/callable.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/check_match.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/concept_interface.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/concept_of.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/constructible.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/deduced.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/derived.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/access.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/adapt_to_vtable.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/any_base.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/check_call.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/check_map.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/const.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/extract_concept.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/get_placeholders.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/get_signature.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/instantiate.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/normalize.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/normalize_deduced.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/null.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/rebind_placeholders.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/storage.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/detail/vtable.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/exception.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/free.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/is_empty.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/is_placeholder.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/is_subconcept.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/iterator.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/operators.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/param.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/placeholder.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/placeholder_of.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/rebind_any.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/relaxed.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/require_match.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/same_type.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/static_binding.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/tuple.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
type_erasure	type_erasure/typeid_of.hpp	/^namespace type_erasure {$/;"	n	namespace:boost
typeid_	type_erasure/builtin.hpp	/^struct typeid_$/;"	s	namespace:boost::type_erasure
typeid_of	type_erasure/typeid_of.hpp	/^const std::type_info& typeid_of(const any<Concept, T>& arg)$/;"	f	namespace:boost::type_erasure	signature:(const any<Concept, T>& arg)
typeid_of	type_erasure/typeid_of.hpp	/^const std::type_info& typeid_of(const binding<Concept>& binding_arg)$/;"	f	namespace:boost::type_erasure	signature:(const binding<Concept>& binding_arg)
typeid_of	type_erasure/typeid_of.hpp	/^const std::type_info& typeid_of(const param<Concept, T>& arg)$/;"	f	namespace:boost::type_erasure	signature:(const param<Concept, T>& arg)
uncallable	type_erasure/detail/const.hpp	/^struct uncallable {};$/;"	s	namespace:boost::type_erasure::detail
unref	type_erasure/detail/check_call.hpp	/^    typedef typename ::boost::remove_reference<placeholder>::type unref;$/;"	t	struct:boost::type_erasure::detail::qualified_placeholder	access:public
value	type_erasure/builtin.hpp	/^    static const std::type_info& value()$/;"	f	struct:boost::type_erasure::typeid_	access:public	signature:()
value	type_erasure/builtin.hpp	/^    static void value(::boost::type_erasure::detail::storage&) {}$/;"	f	struct:boost::type_erasure::detail::null_destroy	access:public	signature:(::boost::type_erasure::detail::storage&)
value	type_erasure/builtin.hpp	/^    static void value(detail::storage& arg)$/;"	f	struct:boost::type_erasure::destructible	access:public	signature:(detail::storage& arg)
value	type_erasure/constructible.hpp	/^    value(T...)$/;"	f	struct:boost::type_erasure::detail::null_construct	access:public	signature:(T....)
value	type_erasure/detail/adapt_to_vtable.hpp	/^    static ::boost::type_erasure::detail::storage value(T... arg)$/;"	f	struct:boost::type_erasure::detail::vtable_adapter_impl	access:public	signature:(T.... arg)
value	type_erasure/detail/adapt_to_vtable.hpp	/^    static R value(T... arg)$/;"	f	struct:boost::type_erasure::detail::vtable_adapter_impl	access:public	signature:(T.... arg)
value	type_erasure/detail/vtable.hpp	/^    static constexpr Table value = Table(T::value...);$/;"	m	struct:boost::type_erasure::detail::vtable_init	access:public
value	type_erasure/detail/vtable.hpp	/^    typename T::type value;$/;"	m	struct:boost::type_erasure::detail::vtable_entry	access:public
value	type_erasure/detail/vtable.hpp	/^constexpr Table vtable_init<Table, T...>::value;$/;"	m	class:boost::type_erasure::detail::vtable_init
value_type	type_erasure/iterator.hpp	/^    typedef ValueType value_type;$/;"	t	struct:boost::type_erasure::iterator	access:public
value_type	type_erasure/iterator.hpp	/^    typedef detail::unspecified value_type;$/;"	t	struct:boost::type_erasure::iterator	access:public
value_type	type_erasure/iterator.hpp	/^    typedef typename rebind_any<Base, ValueType>::type value_type;$/;"	t	struct:boost::type_erasure::concept_interface	access:public
vtable_adapter	type_erasure/detail/adapt_to_vtable.hpp	/^struct vtable_adapter$/;"	s	namespace:boost::type_erasure::detail	inherits:vtable_adapter_impl
vtable_adapter_impl	type_erasure/detail/adapt_to_vtable.hpp	/^struct vtable_adapter_impl<PrimitiveConcept, ::boost::type_erasure::detail::storage&&(T...), R2(U...)>$/;"	s	namespace:boost::type_erasure::detail
vtable_adapter_impl	type_erasure/detail/adapt_to_vtable.hpp	/^struct vtable_adapter_impl<PrimitiveConcept, ::boost::type_erasure::detail::storage&(T...), R2(U...)>$/;"	s	namespace:boost::type_erasure::detail
vtable_adapter_impl	type_erasure/detail/adapt_to_vtable.hpp	/^struct vtable_adapter_impl<PrimitiveConcept, R(T...), R2(U...)>$/;"	s	namespace:boost::type_erasure::detail
vtable_entry	type_erasure/detail/vtable.hpp	/^    constexpr vtable_entry(typename T::type arg) : value(arg) {}$/;"	f	struct:boost::type_erasure::detail::vtable_entry	access:public	signature:(typename T::type arg)
vtable_entry	type_erasure/detail/vtable.hpp	/^    vtable_entry() = default;$/;"	p	struct:boost::type_erasure::detail::vtable_entry	access:public	signature:()
vtable_entry	type_erasure/detail/vtable.hpp	/^struct vtable_entry$/;"	s	namespace:boost::type_erasure::detail
vtable_init	type_erasure/detail/vtable.hpp	/^struct vtable_init$/;"	s	namespace:boost::type_erasure::detail
vtable_storage	type_erasure/detail/vtable.hpp	/^    constexpr vtable_storage(typename T::type... arg)$/;"	f	struct:boost::type_erasure::detail::vtable_storage	access:public	signature:(typename T::type... arg)
vtable_storage	type_erasure/detail/vtable.hpp	/^    vtable_storage() = default;$/;"	p	struct:boost::type_erasure::detail::vtable_storage	access:public	signature:()
vtable_storage	type_erasure/detail/vtable.hpp	/^struct vtable_storage : vtable_entry<T>...$/;"	s	namespace:boost::type_erasure::detail	inherits:vtable_entry
vtable_storage	type_erasure/detail/vtable.hpp	/^struct vtable_storage<>$/;"	s	namespace:boost::type_erasure::detail
yes	type_erasure/any.hpp	/^struct yes { no dummy[2]; };$/;"	s	namespace:boost::type_erasure::detail
~any	type_erasure/any.hpp	/^    ~any()$/;"	f	class:boost::type_erasure::any	access:public	signature:()
