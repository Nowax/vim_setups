!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ActionArgBinding	xpressive/match_results.hpp	/^struct ActionArgBinding$/;"	s	namespace:boost::xpressive::detail	inherits:proto::assign
ActionableCases	xpressive/detail/static/grammar.hpp	/^        struct ActionableCases$/;"	s	namespace:boost::xpressive::grammar_detail
ActionableGrammar	xpressive/detail/static/grammar.hpp	/^    struct ActionableGrammar$/;"	s	namespace:boost::xpressive	inherits:proto::switch_
AssertionFunctor	xpressive/detail/core/matcher/predicate_matcher.hpp	/^    struct AssertionFunctor$/;"	s	namespace:boost::xpressive::detail	inherits:proto::function
BOOST_MPL_ASSERT	xpressive/detail/static/transmogrify.hpp	/^        BOOST_MPL_ASSERT((is_same<Char, char_type>));$/;"	p	struct:boost::xpressive::detail::transmogrify	access:public	signature:(is_same<Char, char_type>)
BOOST_MPL_ASSERT	xpressive/detail/utility/tracking_ptr.hpp	/^    BOOST_MPL_ASSERT((is_base_and_derived<enable_reference_tracking<Type>, Type>));$/;"	p	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:(is_base_and_derived<enable_reference_tracking<Type>, Type>)
BOOST_MPL_ASSERT	xpressive/detail/utility/traits_utils.hpp	/^        BOOST_MPL_ASSERT((is_same<FromChar, char>));$/;"	p	struct:boost::xpressive::detail::string_cast_	access:public	signature:(is_same<FromChar, char>)
BOOST_PROTO_FUSION_V2	xpressive/xpressive_fwd.hpp	23;"	d
BOOST_PROTO_LOCAL_LIMITS	xpressive/regex_actions.hpp	1509;"	d
BOOST_PROTO_LOCAL_MACRO	xpressive/regex_actions.hpp	1480;"	d
BOOST_PROTO_LOCAL_a	xpressive/regex_actions.hpp	1508;"	d
BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, ECMAScript         = regex_constants::ECMAScript);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, ECMAScript = regex_constants::ECMAScript)
BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, collate            = regex_constants::collate);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, collate = regex_constants::collate)
BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, icase              = regex_constants::icase_);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, icase = regex_constants::icase_)
BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, ignore_white_space = regex_constants::ignore_white_space);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, ignore_white_space = regex_constants::ignore_white_space)
BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, nosubs             = regex_constants::nosubs);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, nosubs = regex_constants::nosubs)
BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, not_dot_newline    = regex_constants::not_dot_newline);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, not_dot_newline = regex_constants::not_dot_newline)
BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, not_dot_null       = regex_constants::not_dot_null);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, not_dot_null = regex_constants::not_dot_null)
BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, optimize           = regex_constants::optimize);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, optimize = regex_constants::optimize)
BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, single_line        = regex_constants::single_line);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, single_line = regex_constants::single_line)
BOOST_STATIC_CONSTANT	xpressive/detail/core/quant_style.hpp	/^    BOOST_STATIC_CONSTANT(bool, pure = Pure);$/;"	p	struct:boost::xpressive::detail::quant_style	access:public	signature:(bool, pure = Pure)
BOOST_STATIC_CONSTANT	xpressive/detail/core/quant_style.hpp	/^    BOOST_STATIC_CONSTANT(int, quant = QuantStyle);$/;"	p	struct:boost::xpressive::detail::quant_style	access:public	signature:(int, quant = QuantStyle)
BOOST_STATIC_CONSTANT	xpressive/detail/core/quant_style.hpp	/^    BOOST_STATIC_CONSTANT(std::size_t, width = Width);$/;"	p	struct:boost::xpressive::detail::quant_style	access:public	signature:(std::size_t, width = Width)
BOOST_STATIC_CONSTANT	xpressive/detail/dynamic/dynamic.hpp	/^    BOOST_STATIC_CONSTANT(bool, pure = false);$/;"	p	struct:boost::xpressive::detail::alternates_vector	access:public	signature:(bool, pure = false)
BOOST_STATIC_CONSTANT	xpressive/detail/dynamic/dynamic.hpp	/^    BOOST_STATIC_CONSTANT(std::size_t, width = unknown_width::value);$/;"	p	struct:boost::xpressive::detail::alternates_vector	access:public	signature:(std::size_t, width = unknown_width::value)
BOOST_STATIC_CONSTANT	xpressive/detail/dynamic/matchable.hpp	/^    BOOST_STATIC_CONSTANT(bool, pure = false);$/;"	p	struct:boost::xpressive::detail::shared_matchable	access:public	signature:(bool, pure = false)
BOOST_STATIC_CONSTANT	xpressive/detail/dynamic/matchable.hpp	/^    BOOST_STATIC_CONSTANT(std::size_t, width = unknown_width::value);$/;"	p	struct:boost::xpressive::detail::shared_matchable	access:public	signature:(std::size_t, width = unknown_width::value)
BOOST_STATIC_CONSTANT	xpressive/detail/static/static.hpp	/^    BOOST_STATIC_CONSTANT($/;"	p	struct:boost::xpressive::detail::static_xpression	access:public	signature:( std::size_t , width = Matcher::width != unknown_width::value && Next::width != unknown_width::value ? Matcher::width + Next::width : unknown_width::value )
BOOST_STATIC_CONSTANT	xpressive/detail/static/static.hpp	/^    BOOST_STATIC_CONSTANT(bool, pure = Matcher::pure && Next::pure);$/;"	p	struct:boost::xpressive::detail::static_xpression	access:public	signature:(bool, pure = Matcher::pure && Next::pure)
BOOST_STATIC_CONSTANT	xpressive/detail/static/static.hpp	/^    BOOST_STATIC_CONSTANT(bool, pure = true);$/;"	p	struct:boost::xpressive::detail::no_next	access:public	signature:(bool, pure = true)
BOOST_STATIC_CONSTANT	xpressive/detail/static/static.hpp	/^    BOOST_STATIC_CONSTANT(std::size_t, width = 0);$/;"	p	struct:boost::xpressive::detail::no_next	access:public	signature:(std::size_t, width = 0)
BOOST_STATIC_CONSTANT	xpressive/detail/static/transforms/as_alternate.hpp	/^            BOOST_STATIC_CONSTANT(bool, pure = Head::pure && Tail::pure);$/;"	p	struct:boost::xpressive::detail::alternates_list	access:public	signature:(bool, pure = Head::pure && Tail::pure)
BOOST_STATIC_CONSTANT	xpressive/detail/static/transforms/as_alternate.hpp	/^            BOOST_STATIC_CONSTANT(bool, pure = Head::pure);$/;"	p	struct:boost::xpressive::detail::alternates_list	access:public	signature:(bool, pure = Head::pure)
BOOST_STATIC_CONSTANT	xpressive/detail/static/transforms/as_alternate.hpp	/^            BOOST_STATIC_CONSTANT(std::size_t, width = Head::width == Tail::width ? Head::width : detail::unknown_width::value);$/;"	p	struct:boost::xpressive::detail::alternates_list	access:public	signature:(std::size_t, width = Head::width == Tail::width ? Head::width : detail::unknown_width::value)
BOOST_STATIC_CONSTANT	xpressive/detail/static/transforms/as_alternate.hpp	/^            BOOST_STATIC_CONSTANT(std::size_t, width = Head::width);$/;"	p	struct:boost::xpressive::detail::alternates_list	access:public	signature:(std::size_t, width = Head::width)
BOOST_STATIC_CONSTANT	xpressive/detail/utility/literals.hpp	/^    BOOST_STATIC_CONSTANT(boost::intmax_t, value = Ch);$/;"	p	struct:boost::xpressive::detail::char_literal	access:public	signature:(boost::intmax_t, value = Ch)
BOOST_STATIC_CONSTANT	xpressive/match_results.hpp	/^    BOOST_STATIC_CONSTANT($/;"	p	struct:boost::xpressive::detail::formatter_arity	access:public	signature:( std::size_t , value = sizeof( check_is_formatter( formatter(what) , formatter(what, out) , formatter(what, out, regex_constants::format_default) ) ) - 1 )
BOOST_STATIC_CONSTANT	xpressive/regex_actions.hpp	/^                    BOOST_STATIC_CONSTANT(bool, is_iterator = (sizeof(yes_type) == sizeof(check_insert_return(scont_.insert(svalue_)))));$/;"	p	struct:boost::xpressive::op::insert::detail::result_detail	access:public	signature:(bool, is_iterator = (sizeof(yes_type) == sizeof(check_insert_return(scont_.insert(svalue_)))))
BOOST_STATIC_CONSTANT	xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = (unused_mask<In, (Out >> 1)>::value));$/;"	p	struct:boost::xpressive::detail::unused_mask	access:public	signature:(umaskex_t, value = (unused_mask<In, (Out >> 1)>::value))
BOOST_STATIC_CONSTANT	xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = 0227);$/;"	p	struct:boost::xpressive::detail::mask_cast	access:public	signature:(umaskex_t, value = 0227)
BOOST_STATIC_CONSTANT	xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = Out);$/;"	p	struct:boost::xpressive::detail::unused_mask	access:public	signature:(umaskex_t, value = Out)
BOOST_STATIC_CONSTANT	xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = static_cast<umask_t>(Mask));$/;"	p	struct:boost::xpressive::detail::mask_cast	access:public	signature:(umaskex_t, value = static_cast<umask_t>(Mask))
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_alpha         = 0x0002);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_alpha = 0x0002)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_blank         = 0x0004);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_blank = 0x0004)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_cntrl         = 0x0008);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_cntrl = 0x0008)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_digit         = 0x0010);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_digit = 0x0010)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_lower         = 0x0040);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_lower = 0x0040)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_newline       = 0x2000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_newline = 0x2000)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_newline = 01000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_newline = 01000)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_newline = 0x00020000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_newline = 0x00020000)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_newline = 0x2000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_newline = 0x2000)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_punct         = 0x0100);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_punct = 0x0100)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_space         = 0x0200);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_space = 0x0200)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_underscore    = 0x0800);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_underscore = 0x0800)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_underscore = 0400);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_underscore = 0400)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_underscore = 0x00010000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_underscore = 0x00010000)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_underscore = 0x1000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_underscore = 0x1000)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_upper         = 0x0400);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_upper = 0x0400)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_xdigit        = 0x1000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_xdigit = 0x1000)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(short, char_class_newline = 0x2000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(short, char_class_newline = 0x2000)
BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(short, char_class_underscore = 0x1000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(short, char_class_underscore = 0x1000)
BOOST_XPRESSIVE_ACTIONS_HPP_EAN_03_22_2007	xpressive/regex_actions.hpp	10;"	d
BOOST_XPRESSIVE_ALGORITHMS_HPP_EAN_10_04_2005	xpressive/regex_algorithms.hpp	10;"	d
BOOST_XPRESSIVE_BASIC_REGEX_HPP_EAN_10_04_2005	xpressive/basic_regex.hpp	11;"	d
BOOST_XPRESSIVE_BUGGY_CTYPE_FACET	xpressive/traits/cpp_regex_traits.hpp	40;"	d
BOOST_XPRESSIVE_CHECK_REGEX	xpressive/detail/static/grammar.hpp	33;"	d
BOOST_XPRESSIVE_DETAIL_BOYER_MOORE_HPP_EAN_10_04_2005	xpressive/detail/utility/boyer_moore.hpp	12;"	d
BOOST_XPRESSIVE_DETAIL_CHSET_CHSET_HPP_EAN_10_04_2005	xpressive/detail/utility/chset/chset.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_ACCESS_HPP_EAN_10_04_2005	xpressive/detail/core/access.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_ACTION_HPP_EAN_10_04_2005	xpressive/detail/core/action.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_ADAPTOR_HPP_EAN_10_04_2005	xpressive/detail/core/adaptor.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_FINDER_HPP_EAN_10_04_2005	xpressive/detail/core/finder.hpp	8;"	d
BOOST_XPRESSIVE_DETAIL_CORE_FLOW_CONTROL_HPP_EAN_10_04_2005	xpressive/detail/core/flow_control.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_ICASE_HPP_EAN_10_04_2005	xpressive/detail/core/icase.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_LINKER_HPP_EAN_10_04_2005	xpressive/detail/core/linker.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_LIST_HPP_EAN_10_26_2009	xpressive/detail/core/list.hpp	12;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHERS_HPP_EAN_10_04_2005	xpressive/detail/core/matchers.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_ACTION_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/action_matcher.hpp	12;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_ALTERNATE_END_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/alternate_end_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_ALTERNATE_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/alternate_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_ANY_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/any_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_ASSERT_BOL_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/assert_bol_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_ASSERT_BOS_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/assert_bos_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_ASSERT_EOL_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/assert_eol_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_ASSERT_EOS_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/assert_eos_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_ASSERT_WORD_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/assert_word_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_ATTR_BEGIN_MATCHER_HPP_EAN_06_09_2007	xpressive/detail/core/matcher/attr_begin_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_ATTR_END_MATCHER_HPP_EAN_06_09_2007	xpressive/detail/core/matcher/attr_end_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_ATTR_MATCHER_HPP_EAN_06_09_2007	xpressive/detail/core/matcher/attr_matcher.hpp	12;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_CHARSET_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/charset_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_DETAIL_ASSERT_LINE_BASE_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/assert_line_base.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_END_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/end_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_EPSILON_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/epsilon_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_KEEPER_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/keeper_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_LITERAL_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/literal_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_LOGICAL_NEWLINE_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/logical_newline_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_LOOKAHEAD_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/lookahead_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_LOOKBEHIND_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/lookbehind_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_MARK_BEGIN_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/mark_begin_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_MARK_END_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/mark_end_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_MARK_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/mark_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_OPTIONAL_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/optional_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_POSIX_CHARSET_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/posix_charset_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_PREDICATE_MATCHER_HPP_EAN_03_22_2007	xpressive/detail/core/matcher/predicate_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_RANGE_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/range_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_REGEX_BYREF_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/regex_byref_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_REGEX_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/regex_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_REPEAT_BEGIN_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/repeat_begin_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_REPEAT_END_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/repeat_end_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_SIMPLE_REPEAT_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_STRING_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/string_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_MATCHER_TRUE_MATCHER_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/true_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_OPTIMIZE_HPP_EAN_10_04_2005	xpressive/detail/core/optimize.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_PEEKER_HPP_EAN_10_04_2005	xpressive/detail/core/peeker.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_QUANT_STYLE_HPP_EAN_10_04_2005	xpressive/detail/core/quant_style.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_REGEX_DOMAIN_HPP_EAN_12_12_2009	xpressive/detail/core/regex_domain.hpp	10;"	d
BOOST_XPRESSIVE_DETAIL_CORE_REGEX_IMPL_HPP_EAN_10_04_2005	xpressive/detail/core/regex_impl.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_RESULTS_CACHE_HPP_EAN_10_04_2005	xpressive/detail/core/results_cache.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_STATE_HPP_EAN_10_04_2005	xpressive/detail/core/state.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_SUB_MATCH_IMPL_HPP_EAN_10_04_2005	xpressive/detail/core/sub_match_impl.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_CORE_SUB_MATCH_VECTOR_HPP_EAN_10_04_2005	xpressive/detail/core/sub_match_vector.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_DETAIL_FWD_HPP_EAN_10_04_2005	xpressive/detail/detail_fwd.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_DYNAMIC_DYNAMIC_HPP_EAN_10_04_2005	xpressive/detail/dynamic/dynamic.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_DYNAMIC_MATCHABLE_HPP_EAN_10_04_2005	xpressive/detail/dynamic/matchable.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_DYNAMIC_PARSER_ENUM_HPP_EAN_10_04_2005	xpressive/detail/dynamic/parser_enum.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_DYNAMIC_PARSER_HPP_EAN_10_04_2005	xpressive/detail/dynamic/parser.hpp	11;"	d
BOOST_XPRESSIVE_DETAIL_DYNAMIC_PARSER_TRAITS_HPP_EAN_10_04_2005	xpressive/detail/dynamic/parser_traits.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_DYNAMIC_PARSE_CHARSET_HPP_EAN_10_04_2005	xpressive/detail/dynamic/parse_charset.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_DYNAMIC_SEQUENCE_HPP_EAN_04_10_2006	xpressive/detail/dynamic/sequence.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_HASH_PEEK_BITSET_HPP_EAN_10_04_2005	xpressive/detail/utility/hash_peek_bitset.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_SEQUENCE_STACK_HPP_EAN_10_04_2005	xpressive/detail/utility/sequence_stack.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_SET_HPP_EAN_10_04_2005	xpressive/detail/core/matcher/set_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_COMPILE_HPP_EAN_10_04_2005	xpressive/detail/static/compile.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_GRAMMAR_HPP_EAN_11_12_2006	xpressive/detail/static/grammar.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_IS_PURE_HPP_EAN_10_04_2005	xpressive/detail/static/is_pure.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_MODIFIER_HPP_EAN_10_04_2005	xpressive/detail/static/modifier.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_PLACEHOLDERS_HPP_EAN_10_04_2005	xpressive/detail/static/placeholders.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_STATIC_HPP_EAN_10_04_2005	xpressive/detail/static/static.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_TRANSFORMS_AS_ACTION_HPP_EAN_04_05_2007	xpressive/detail/static/transforms/as_action.hpp	12;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_TRANSFORMS_AS_ALTERNATE_HPP_EAN_04_01_2007	xpressive/detail/static/transforms/as_alternate.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_TRANSFORMS_AS_INDEPENDENT_HPP_EAN_04_05_2007	xpressive/detail/static/transforms/as_independent.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_TRANSFORMS_AS_INVERSE_HPP_EAN_04_05_2007	xpressive/detail/static/transforms/as_inverse.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_TRANSFORMS_AS_MARKER_HPP_EAN_04_01_2007	xpressive/detail/static/transforms/as_marker.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_TRANSFORMS_AS_MATCHER_HPP_EAN_04_01_2007	xpressive/detail/static/transforms/as_matcher.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_TRANSFORMS_AS_MODIFIER_HPP_EAN_04_05_2007	xpressive/detail/static/transforms/as_modifier.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_TRANSFORMS_AS_QUANTIFIER_HPP_EAN_04_01_2007	xpressive/detail/static/transforms/as_quantifier.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_TRANSFORMS_AS_SEQUENCE_HPP_EAN_04_01_2007	xpressive/detail/static/transforms/as_sequence.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_TRANSFORMS_AS_SET_HPP_EAN_04_05_2007	xpressive/detail/static/transforms/as_set.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_TRANSMOGRIFY_HPP_EAN_10_04_2005	xpressive/detail/static/transmogrify.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_TYPE_TRAITS_HPP_EAN_10_04_2005	xpressive/detail/static/type_traits.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_VISITOR_HPP_EAN_10_04_2005	xpressive/detail/static/visitor.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_STATIC_WIDTH_OF_HPP_EAN_10_04_2005	xpressive/detail/static/width_of.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_SYMBOLS_HPP_DRJ_06_11_2007	xpressive/detail/utility/symbols.hpp	17;"	d
BOOST_XPRESSIVE_DETAIL_UTILITY_ALGORITHM_HPP_EAN_10_04_2005	xpressive/detail/utility/algorithm.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_UTILITY_ANY_HPP_EAN_11_19_2005	xpressive/detail/utility/any.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_UTILITY_CONS_HPP_EAN_11_19_2005	xpressive/detail/utility/cons.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_UTILITY_COUNTED_BASE_HPP_EAN_04_16_2006	xpressive/detail/utility/counted_base.hpp	8;"	d
BOOST_XPRESSIVE_DETAIL_UTILITY_DONT_CARE_HPP_EAN_10_04_2005	xpressive/detail/utility/dont_care.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_UTILITY_IGNORE_UNUSED_HPP_EAN_10_04_2005	xpressive/detail/utility/ignore_unused.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_UTILITY_LITERALS_HPP_EAN_10_04_2005	xpressive/detail/utility/literals.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_UTILITY_NEVER_TRUE_HPP_EAN_10_04_2005	xpressive/detail/utility/never_true.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_UTILITY_SAVE_RESTORE_HPP_EAN_10_04_2005	xpressive/detail/utility/save_restore.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_UTILITY_TRACKING_PTR_HPP_EAN_10_04_2005	xpressive/detail/utility/tracking_ptr.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_UTILITY_TRAITS_UTILS_HPP_EAN_10_04_2005	xpressive/detail/utility/traits_utils.hpp	9;"	d
BOOST_XPRESSIVE_DETAIL_UTILITY_WIDTH_HPP_EAN_04_07_2006	xpressive/detail/utility/width.hpp	9;"	d
BOOST_XPRESSIVE_DYNAMIC_HPP_EAN_10_04_2005	xpressive/xpressive_dynamic.hpp	10;"	d
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s0, 0);$/;"	p	namespace:boost::xpressive	signature:(s0, 0)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s1, 1);$/;"	p	namespace:boost::xpressive	signature:(s1, 1)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s2, 2);$/;"	p	namespace:boost::xpressive	signature:(s2, 2)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s3, 3);$/;"	p	namespace:boost::xpressive	signature:(s3, 3)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s4, 4);$/;"	p	namespace:boost::xpressive	signature:(s4, 4)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s5, 5);$/;"	p	namespace:boost::xpressive	signature:(s5, 5)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s6, 6);$/;"	p	namespace:boost::xpressive	signature:(s6, 6)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s7, 7);$/;"	p	namespace:boost::xpressive	signature:(s7, 7)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s8, 8);$/;"	p	namespace:boost::xpressive	signature:(s8, 8)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s9, 9);$/;"	p	namespace:boost::xpressive	signature:(s9, 9)
BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	577;"	d
BOOST_XPRESSIVE_HAS_MS_STACK_GUARD	xpressive/xpressive_fwd.hpp	47;"	d
BOOST_XPRESSIVE_HAS_MS_STACK_GUARD	xpressive/xpressive_fwd.hpp	49;"	d
BOOST_XPRESSIVE_HPP_EAN_10_04_2005	xpressive/xpressive.hpp	11;"	d
BOOST_XPRESSIVE_MATCH_RESULTS_HPP_EAN_10_04_2005	xpressive/match_results.hpp	16;"	d
BOOST_XPRESSIVE_NO_WREGEX	xpressive/xpressive_fwd.hpp	36;"	d
BOOST_XPRESSIVE_REGEX_COMPILER_HPP_EAN_10_04_2005	xpressive/regex_compiler.hpp	11;"	d
BOOST_XPRESSIVE_REGEX_CONSTANTS_HPP_EAN_10_04_2005	xpressive/regex_constants.hpp	11;"	d
BOOST_XPRESSIVE_REGEX_ERROR_HPP_EAN_10_04_2005	xpressive/regex_error.hpp	10;"	d
BOOST_XPRESSIVE_REGEX_ITERATOR_HPP_EAN_10_04_2005	xpressive/regex_iterator.hpp	11;"	d
BOOST_XPRESSIVE_REGEX_PRIMITIVES_HPP_EAN_10_04_2005	xpressive/regex_primitives.hpp	10;"	d
BOOST_XPRESSIVE_REGEX_TOKEN_ITERATOR_HPP_EAN_10_04_2005	xpressive/regex_token_iterator.hpp	11;"	d
BOOST_XPRESSIVE_REGEX_TRAITS_HPP_EAN_10_04_2005	xpressive/regex_traits.hpp	11;"	d
BOOST_XPRESSIVE_SPIRIT_BASIC_CHSET_HPP_EAN_10_04_2005	xpressive/detail/utility/chset/basic_chset.hpp	11;"	d
BOOST_XPRESSIVE_SPIRIT_RANGE_RUN_HPP_EAN_10_04_2005	xpressive/detail/utility/chset/range_run.hpp	10;"	d
BOOST_XPRESSIVE_STATIC_HPP_EAN_10_04_2005	xpressive/xpressive_static.hpp	11;"	d
BOOST_XPRESSIVE_SUB_MATCH_HPP_EAN_10_04_2005	xpressive/sub_match.hpp	11;"	d
BOOST_XPRESSIVE_TRAITS_CPP_REGEX_TRAITS_HPP_EAN_10_04_2005	xpressive/traits/cpp_regex_traits.hpp	12;"	d
BOOST_XPRESSIVE_TRAITS_C_REGEX_TRAITS_HPP_EAN_10_04_2005	xpressive/traits/c_regex_traits.hpp	12;"	d
BOOST_XPRESSIVE_TRAITS_DETAIL_C_CTYPE_HPP_EAN_10_04_2005	xpressive/traits/detail/c_ctype.hpp	9;"	d
BOOST_XPRESSIVE_TRAITS_NULL_REGEX_TRAITS_HPP_EAN_10_04_2005	xpressive/traits/null_regex_traits.hpp	12;"	d
BOOST_XPRESSIVE_USE_C_TRAITS	xpressive/xpressive_fwd.hpp	31;"	d
BOOST_XPRESSIVE_XPRESSIVE_FWD_HPP_EAN_10_04_2005	xpressive/xpressive_fwd.hpp	10;"	d
BOOST_XPRESSIVE_XPRESSIVE_TYPEOF_H	xpressive/xpressive_typeof.hpp	10;"	d
BOOST_XPR_CHAR_	xpressive/detail/utility/literals.hpp	73;"	d
BOOST_XPR_CHAR_	xpressive/detail/utility/literals.hpp	78;"	d
BOOST_XPR_CSTR_	xpressive/detail/utility/literals.hpp	74;"	d
BOOST_XPR_CSTR_	xpressive/detail/utility/literals.hpp	79;"	d
BOOST_XPR_ENSURE_	xpressive/regex_error.hpp	109;"	d
BOOST_XPR_NONDEDUCED_TYPE_	xpressive/regex_algorithms.hpp	34;"	d
BOOST_XPR_QUANT_STYLE	xpressive/detail/core/quant_style.hpp	67;"	d
BindActionArgs	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct BindActionArgs$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
BindArg	xpressive/regex_actions.hpp	/^        struct BindArg$/;"	s	namespace:boost::xpressive::detail
BindArgs	xpressive/regex_actions.hpp	/^        struct BindArgs$/;"	s	namespace:boost::xpressive::detail	inherits:proto::function
Cases	xpressive/detail/static/grammar.hpp	/^        struct Cases$/;"	s	namespace:boost::xpressive::grammar_detail
CharLiteral	xpressive/detail/static/transforms/as_set.hpp	/^    struct CharLiteral$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
CharLiteral	xpressive/detail/static/transforms/as_set.hpp	/^    struct CharLiteral<char>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:terminal
CheckAssertion	xpressive/detail/static/transforms/as_action.hpp	/^    struct CheckAssertion$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::function
DataMember	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct DataMember$/;"	s	namespace:boost::xpressive::detail	inherits:proto::mem_ptr
DeepCopy	xpressive/detail/static/transforms/as_action.hpp	/^    struct DeepCopy$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
ECMAScript	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::ECMAScript;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
ECMAScript	xpressive/regex_constants.hpp	/^    ECMAScript  = 0,        \/\/\/< Specifies that the grammar recognized by the regular expression$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
FindAttr	xpressive/detail/static/transforms/as_action.hpp	/^    struct FindAttr$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
Grammar	xpressive/detail/static/grammar.hpp	/^    struct Grammar$/;"	s	namespace:boost::xpressive	inherits:proto::switch_
INVALID_REGULAR_EXPRESSION	xpressive/detail/static/grammar.hpp	/^    struct INVALID_REGULAR_EXPRESSION$/;"	s	namespace:boost::xpressive	inherits:mpl::false_
IndependentEndXpression	xpressive/detail/static/transforms/as_independent.hpp	/^    struct IndependentEndXpression$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
InsertAttrs	xpressive/detail/static/transforms/as_action.hpp	/^    struct InsertAttrs$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:if_
InsertMark	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct InsertMark$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
InvertibleCases	xpressive/detail/static/grammar.hpp	/^        struct InvertibleCases$/;"	s	namespace:boost::xpressive::grammar_detail
IsMarkerOrRepeater	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct IsMarkerOrRepeater$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
ListSet	xpressive/detail/static/transforms/as_set.hpp	/^    struct ListSet$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
MaxAttr	xpressive/detail/static/transforms/as_action.hpp	/^    struct MaxAttr$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
NonGreedyRepeatCases	xpressive/detail/static/grammar.hpp	/^        struct NonGreedyRepeatCases$/;"	s	namespace:boost::xpressive::grammar_detail
NotHasAction	xpressive/detail/static/transforms/as_independent.hpp	/^    struct NotHasAction$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::switch_
NotHasActionCases	xpressive/detail/static/transforms/as_independent.hpp	/^    struct NotHasActionCases$/;"	s	namespace:boost::xpressive::grammar_detail
Primitives	xpressive/regex_primitives.hpp	/^    struct Primitives$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
ReplaceAlgo	xpressive/regex_actions.hpp	/^        struct ReplaceAlgo$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
SkipGrammar	xpressive/regex_primitives.hpp	/^    struct SkipGrammar$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
SubMatch	xpressive/regex_primitives.hpp	/^    struct SubMatch$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
SubMatchList	xpressive/regex_primitives.hpp	/^    struct SubMatchList$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
UNCV	xpressive/detail/static/transforms/as_inverse.hpp	22;"	d
UNCV	xpressive/detail/static/transforms/as_inverse.hpp	90;"	d
UNCV	xpressive/detail/static/transforms/as_modifier.hpp	21;"	d
UNCV	xpressive/detail/static/transforms/as_modifier.hpp	81;"	d
UNCVREF	xpressive/detail/static/transforms/as_inverse.hpp	24;"	d
UNCVREF	xpressive/detail/static/transforms/as_inverse.hpp	92;"	d
UNCVREF	xpressive/detail/static/transforms/as_modifier.hpp	23;"	d
UNCVREF	xpressive/detail/static/transforms/as_modifier.hpp	83;"	d
UNREF	xpressive/detail/static/transforms/as_inverse.hpp	23;"	d
UNREF	xpressive/detail/static/transforms/as_inverse.hpp	91;"	d
UNREF	xpressive/detail/static/transforms/as_modifier.hpp	22;"	d
UNREF	xpressive/detail/static/transforms/as_modifier.hpp	82;"	d
UNREF	xpressive/detail/static/width_of.hpp	268;"	d
XpressiveLocaleModifier	xpressive/detail/static/compile.hpp	/^    struct XpressiveLocaleModifier$/;"	s	namespace:boost::xpressive::detail	inherits:proto::binary_expr
_	xpressive/regex_primitives.hpp	/^proto::terminal<detail::any_matcher>::type const _ = {{}};$/;"	m	class:boost::xpressive::proto::terminal
_b	xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_word_boundary>::type const _b = {{}};$/;"	m	class:boost::xpressive::proto::terminal
_d	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const _d = {{"d", false}};$/;"	m	class:boost::xpressive::proto::terminal
_ln	xpressive/regex_primitives.hpp	/^detail::logical_newline_xpression const _ln = {{}};$/;"	m	class:boost::xpressive::detail
_n	xpressive/regex_primitives.hpp	/^proto::terminal<char>::type const _n = {'\\n'};$/;"	m	class:boost::xpressive::proto::terminal
_next	xpressive/detail/core/list.hpp	/^            node_base *_next;$/;"	m	struct:boost::xpressive::detail::list::node_base	access:public
_node	xpressive/detail/core/list.hpp	/^            node_base *_node;$/;"	m	struct:boost::xpressive::detail::list::list_iterator	access:private
_prev	xpressive/detail/core/list.hpp	/^            node_base *_prev;$/;"	m	struct:boost::xpressive::detail::list::node_base	access:public
_s	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const _s = {{"s", false}};$/;"	m	class:boost::xpressive::proto::terminal
_sentry	xpressive/detail/core/list.hpp	/^        node_base _sentry;$/;"	m	struct:boost::xpressive::detail::list	access:private
_value	xpressive/detail/core/list.hpp	/^            T _value;$/;"	m	struct:boost::xpressive::detail::list::node	access:public
_w	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const _w = {{"w", false}};$/;"	m	class:boost::xpressive::proto::terminal
a1	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<1> > >::type const a1 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a2	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<2> > >::type const a2 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a3	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<3> > >::type const a3 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a4	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<4> > >::type const a4 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a5	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<5> > >::type const a5 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a6	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<6> > >::type const a6 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a7	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<7> > >::type const a7 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a8	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<8> > >::type const a8 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
a9	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<9> > >::type const a9 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
accept	xpressive/detail/core/linker.hpp	/^    void accept(Matcher const &, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(Matcher const &, void const *)
accept	xpressive/detail/core/linker.hpp	/^    void accept(action_matcher<Action> const &, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(action_matcher<Action> const &, void const *)
accept	xpressive/detail/core/linker.hpp	/^    void accept(alternate_end_matcher const &matcher, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(alternate_end_matcher const &matcher, void const *)
accept	xpressive/detail/core/linker.hpp	/^    void accept(alternate_matcher<Alternates, Traits> const &matcher, void const *next)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(alternate_matcher<Alternates, Traits> const &matcher, void const *next)
accept	xpressive/detail/core/linker.hpp	/^    void accept(keeper_matcher<Xpr> const &matcher, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(keeper_matcher<Xpr> const &matcher, void const *)
accept	xpressive/detail/core/linker.hpp	/^    void accept(lookahead_matcher<Xpr> const &matcher, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(lookahead_matcher<Xpr> const &matcher, void const *)
accept	xpressive/detail/core/linker.hpp	/^    void accept(lookbehind_matcher<Xpr> const &matcher, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(lookbehind_matcher<Xpr> const &matcher, void const *)
accept	xpressive/detail/core/linker.hpp	/^    void accept(mark_matcher<Traits, ICase> const &, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(mark_matcher<Traits, ICase> const &, void const *)
accept	xpressive/detail/core/linker.hpp	/^    void accept(optional_mark_matcher<Xpr, Greedy> const &matcher, void const *next)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(optional_mark_matcher<Xpr, Greedy> const &matcher, void const *next)
accept	xpressive/detail/core/linker.hpp	/^    void accept(optional_matcher<Xpr, Greedy> const &matcher, void const *next)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(optional_matcher<Xpr, Greedy> const &matcher, void const *next)
accept	xpressive/detail/core/linker.hpp	/^    void accept(predicate_matcher<Predicate> const &, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(predicate_matcher<Predicate> const &, void const *)
accept	xpressive/detail/core/linker.hpp	/^    void accept(repeat_begin_matcher const &, void const *next)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(repeat_begin_matcher const &, void const *next)
accept	xpressive/detail/core/linker.hpp	/^    void accept(repeat_end_matcher<Greedy> const &matcher, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(repeat_end_matcher<Greedy> const &matcher, void const *)
accept	xpressive/detail/core/linker.hpp	/^    void accept(simple_repeat_matcher<Xpr, Greedy> const &matcher, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(simple_repeat_matcher<Xpr, Greedy> const &matcher, void const *)
accept	xpressive/detail/core/peeker.hpp	/^    accept(charset_matcher<Traits, ICase, basic_chset<Char> > const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(charset_matcher<Traits, ICase, basic_chset<Char> > const &xpr)
accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(Matcher const &)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(Matcher const &)
accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(alternate_matcher<Alternates, Traits> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(alternate_matcher<Alternates, Traits> const &xpr)
accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(attr_matcher<Matcher, Traits, ICase> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(attr_matcher<Matcher, Traits, ICase> const &xpr)
accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(keeper_matcher<Xpr> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(keeper_matcher<Xpr> const &xpr)
accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(literal_matcher<Traits, ICase, mpl::false_> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(literal_matcher<Traits, ICase, mpl::false_> const &xpr)
accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(optional_mark_matcher<Xpr, Greedy> const &)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(optional_mark_matcher<Xpr, Greedy> const &)
accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(optional_matcher<Xpr, Greedy> const &)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(optional_matcher<Xpr, Greedy> const &)
accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(posix_charset_matcher<Traits> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(posix_charset_matcher<Traits> const &xpr)
accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(range_matcher<Traits, ICase> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(range_matcher<Traits, ICase> const &xpr)
accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(simple_repeat_matcher<Xpr, Greedy> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(simple_repeat_matcher<Xpr, Greedy> const &xpr)
accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(string_matcher<Traits, ICase> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(string_matcher<Traits, ICase> const &xpr)
accept	xpressive/detail/core/peeker.hpp	/^    mpl::true_ accept(assert_bol_matcher<Traits> const &)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(assert_bol_matcher<Traits> const &)
accept	xpressive/detail/core/peeker.hpp	/^    mpl::true_ accept(mark_begin_matcher const &)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(mark_begin_matcher const &)
accept	xpressive/detail/core/peeker.hpp	/^    mpl::true_ accept(repeat_begin_matcher const &)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(repeat_begin_matcher const &)
access	xpressive/detail/core/results_cache.hpp	/^        typedef core_access<BidiIter> access;$/;"	t	struct:boost::xpressive::detail::results_cache	access:public
access	xpressive/detail/core/state.hpp	/^    typedef core_access<BidiIter> access;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
access	xpressive/regex_iterator.hpp	/^    typedef detail::core_access<BidiIter> access;$/;"	t	struct:boost::xpressive::detail::regex_iterator_impl	access:public
action	xpressive/detail/core/matcher/action_matcher.hpp	/^        action(Actor const &actor)$/;"	f	struct:boost::xpressive::detail::action	access:public	signature:(Actor const &actor)
action	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct action$/;"	s	namespace:boost::xpressive::detail	inherits:actionable
action_arg	xpressive/regex_actions.hpp	/^        struct action_arg$/;"	s	namespace:boost::xpressive::detail
action_arg_type	xpressive/regex_actions.hpp	/^        action_arg_type;$/;"	t	struct:boost::xpressive::placeholder	access:public
action_args_	xpressive/detail/core/matcher/action_matcher.hpp	/^        action_args_type *action_args_;$/;"	m	struct:boost::xpressive::detail::action_context	access:private
action_args_	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        action_args_type *action_args_;$/;"	m	struct:boost::xpressive::detail::predicate_context	access:public
action_args_	xpressive/detail/core/state.hpp	/^    action_args_type *action_args_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
action_args_type	xpressive/detail/detail_fwd.hpp	/^    typedef std::map<std::type_info const *, void *, type_info_less> action_args_type;$/;"	t	namespace:boost::xpressive::detail
action_context	xpressive/detail/core/matcher/action_matcher.hpp	/^        explicit action_context(action_args_type *action_args)$/;"	f	struct:boost::xpressive::detail::action_context	access:public	signature:(action_args_type *action_args)
action_context	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct action_context$/;"	s	namespace:boost::xpressive::detail
action_copy_type	xpressive/detail/static/transforms/as_action.hpp	/^            action_copy_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_action::impl	access:public
action_list_	xpressive/detail/core/state.hpp	/^    actionable action_list_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
action_list_head_	xpressive/detail/core/state.hpp	/^    actionable const *action_list_head_;$/;"	m	struct:boost::xpressive::detail::memento	access:public
action_list_tail_	xpressive/detail/core/state.hpp	/^    actionable const **action_list_tail_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
action_list_tail_	xpressive/detail/core/state.hpp	/^    actionable const **action_list_tail_;$/;"	m	struct:boost::xpressive::detail::memento	access:public
action_matcher	xpressive/detail/core/matcher/action_matcher.hpp	/^        action_matcher(Actor const &actor, int sub)$/;"	f	struct:boost::xpressive::detail::action_matcher	access:public	signature:(Actor const &actor, int sub)
action_matcher	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct action_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
action_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename proto::result_of::right<Expr>::type action_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_action::impl	access:public
actionable	xpressive/detail/core/action.hpp	/^        actionable()$/;"	f	struct:boost::xpressive::detail::actionable	access:public	signature:()
actionable	xpressive/detail/core/action.hpp	/^    struct actionable$/;"	s	namespace:boost::xpressive::detail
actionable	xpressive/detail/core/state.hpp	/^    typedef detail::actionable actionable;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
actor_	xpressive/detail/core/matcher/action_matcher.hpp	/^        Actor actor_;$/;"	m	struct:boost::xpressive::detail::action	access:private
actor_	xpressive/detail/core/matcher/action_matcher.hpp	/^        Actor actor_;$/;"	m	struct:boost::xpressive::detail::action_matcher	access:public
add_attrs	xpressive/detail/static/transforms/as_action.hpp	/^    struct add_attrs : proto::transform<add_attrs>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
add_hidden_mark	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct add_hidden_mark : proto::transform<add_hidden_mark>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
add_ref	xpressive/detail/utility/counted_base.hpp	/^        static void add_ref(counted_base<Derived> const *that)$/;"	f	struct:boost::xpressive::detail::counted_base_access	access:public	signature:(counted_base<Derived> const *that)
add_ref	xpressive/detail/utility/tracking_ptr.hpp	/^    void add_ref()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:public	signature:()
add_widths	xpressive/detail/static/width_of.hpp	/^    struct add_widths$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
add_widths	xpressive/detail/static/width_of.hpp	/^    struct add_widths<N, unknown_width::value>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
add_widths	xpressive/detail/static/width_of.hpp	/^    struct add_widths<unknown_width::value, M>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
add_widths	xpressive/detail/static/width_of.hpp	/^    struct add_widths<unknown_width::value, unknown_width::value>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
adl_swap	xpressive/detail/utility/tracking_ptr.hpp	/^void adl_swap(T &t1, T &t2)$/;"	f	namespace:boost::xpressive::detail	signature:(T &t1, T &t2)
advance_to	xpressive/detail/utility/algorithm.hpp	/^inline bool advance_to(Iter & iter, Diff diff, Iter end)$/;"	f	namespace:boost::xpressive::detail	signature:(Iter & iter, Diff diff, Iter end)
advance_to_impl	xpressive/detail/utility/algorithm.hpp	/^inline bool advance_to_impl(BidiIter & iter, Diff diff, BidiIter end, std::bidirectional_iterator_tag)$/;"	f	namespace:boost::xpressive::detail	signature:(BidiIter & iter, Diff diff, BidiIter end, std::bidirectional_iterator_tag)
advance_to_impl	xpressive/detail/utility/algorithm.hpp	/^inline bool advance_to_impl(RandIter & iter, Diff diff, RandIter end, std::random_access_iterator_tag)$/;"	f	namespace:boost::xpressive::detail	signature:(RandIter & iter, Diff diff, RandIter end, std::random_access_iterator_tag)
after	xpressive/regex_primitives.hpp	/^after(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
all_ctype_masks	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const all_ctype_masks = std_ctype_reserved$/;"	m	namespace:boost::xpressive::detail
allocate	xpressive/detail/utility/sequence_stack.hpp	/^    static T *allocate(std::size_t size, T const &t)$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:private	signature:(std::size_t size, T const &t)
allocate_guard_t	xpressive/detail/utility/sequence_stack.hpp	/^    struct allocate_guard_t$/;"	s	struct:boost::xpressive::detail::sequence_stack	access:public
alnum	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const alnum = {{"alnum", false}};$/;"	m	class:boost::xpressive::proto::terminal
alnum_	xpressive/detail/dynamic/parser_traits.hpp	/^    typename regex_traits::char_class_type alnum_;$/;"	m	struct:boost::xpressive::compiler_traits	access:private
alpha	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const alpha = {{"alpha", false}};$/;"	m	class:boost::xpressive::proto::terminal
alt_branch_link	xpressive/detail/core/linker.hpp	/^    void alt_branch_link(Xpr const &xpr, void const *next, xpression_peeker<Char> *peeker)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(Xpr const &xpr, void const *next, xpression_peeker<Char> *peeker)
alt_end_xpr_	xpressive/detail/dynamic/sequence.hpp	/^    intrusive_ptr<alt_end_xpr_type> alt_end_xpr_;$/;"	m	struct:boost::xpressive::detail::sequence	access:private
alt_end_xpr_type	xpressive/detail/dynamic/sequence.hpp	/^    typedef dynamic_xpression<alternate_end_matcher, BidiIter> alt_end_xpr_type;$/;"	t	struct:boost::xpressive::detail::sequence	access:private
alt_link	xpressive/detail/core/linker.hpp	/^    void alt_link$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:private	signature:( alternates_vector<BidiIter> const &alternates , void const *next , xpression_peeker<Char> *peeker )
alt_link	xpressive/detail/core/linker.hpp	/^    void alt_link$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:private	signature:( fusion::sequence_base<Alternates> const &alternates , void const *next , xpression_peeker<Char> *peeker )
alt_link_pred	xpressive/detail/core/linker.hpp	/^        alt_link_pred$/;"	f	struct:boost::xpressive::detail::xpression_linker::alt_link_pred	access:public	signature:( xpression_linker<Char> *linker , xpression_peeker<Char> *peeker , void const *next )
alt_link_pred	xpressive/detail/core/linker.hpp	/^    struct alt_link_pred$/;"	s	struct:boost::xpressive::detail::xpression_linker	access:private
alt_match	xpressive/detail/core/matcher/alternate_matcher.hpp	/^    inline bool alt_match$/;"	f	namespace:boost::xpressive::detail	signature:( alternates_list<Head, Tail> const &alts, match_state<BidiIter> &state, Next const & )
alt_match	xpressive/detail/core/matcher/alternate_matcher.hpp	/^    inline bool alt_match$/;"	f	namespace:boost::xpressive::detail	signature:( alternates_vector<BidiIter> const &alts, match_state<BidiIter> &state, Next const & )
alt_match_pred	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        alt_match_pred(match_state<BidiIter> &state)$/;"	f	struct:boost::xpressive::detail::alt_match_pred	access:public	signature:(match_state<BidiIter> &state)
alt_match_pred	xpressive/detail/core/matcher/alternate_matcher.hpp	/^    struct alt_match_pred$/;"	s	namespace:boost::xpressive::detail
alternate_end_matcher	xpressive/detail/core/matcher/alternate_end_matcher.hpp	/^        alternate_end_matcher()$/;"	f	struct:boost::xpressive::detail::alternate_end_matcher	access:public	signature:()
alternate_end_matcher	xpressive/detail/core/matcher/alternate_end_matcher.hpp	/^    struct alternate_end_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_assertion
alternate_end_xpression	xpressive/detail/detail_fwd.hpp	/^    typedef static_xpression<alternate_end_matcher, no_next> alternate_end_xpression;$/;"	t	namespace:boost::xpressive::detail
alternate_matcher	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        explicit alternate_matcher(Alternates const &alternates = Alternates())$/;"	f	struct:boost::xpressive::detail::alternate_matcher	access:public	signature:(Alternates const &alternates = Alternates())
alternate_matcher	xpressive/detail/core/matcher/alternate_matcher.hpp	/^    struct alternate_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
alternate_matcher	xpressive/regex_compiler.hpp	/^    typedef detail::alternate_matcher<detail::alternates_vector<BidiIter>, RegexTraits> alternate_matcher;$/;"	t	struct:boost::xpressive::regex_compiler	access:private
alternates_	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        Alternates alternates_;$/;"	m	struct:boost::xpressive::detail::alternate_matcher	access:public
alternates_	xpressive/detail/dynamic/sequence.hpp	/^    alternates_vector<BidiIter> *alternates_;$/;"	m	struct:boost::xpressive::detail::sequence	access:private
alternates_list	xpressive/detail/static/transforms/as_alternate.hpp	/^            alternates_list(Head const &head, Tail const &tail)$/;"	f	struct:boost::xpressive::detail::alternates_list	access:public	signature:(Head const &head, Tail const &tail)
alternates_list	xpressive/detail/static/transforms/as_alternate.hpp	/^            alternates_list(Head const &head, fusion::nil const &tail)$/;"	f	struct:boost::xpressive::detail::alternates_list	access:public	signature:(Head const &head, fusion::nil const &tail)
alternates_list	xpressive/detail/static/transforms/as_alternate.hpp	/^        struct alternates_list$/;"	s	namespace:boost::xpressive::detail	inherits:fusion::cons
alternates_list	xpressive/detail/static/transforms/as_alternate.hpp	/^        struct alternates_list<Head, fusion::nil>$/;"	s	namespace:boost::xpressive::detail	inherits:fusion::cons
alternates_type	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        typedef Alternates alternates_type;$/;"	t	struct:boost::xpressive::detail::alternate_matcher	access:public
alternates_vector	xpressive/detail/dynamic/dynamic.hpp	/^struct alternates_vector$/;"	s	namespace:boost::xpressive::detail	inherits:std::vector
any	xpressive/detail/utility/algorithm.hpp	/^inline bool any(InIter begin, InIter end, Pred pred)$/;"	f	namespace:boost::xpressive::detail	signature:(InIter begin, InIter end, Pred pred)
any	xpressive/detail/utility/any.hpp	/^        any(First const& first, Last const& last, F const& f, mpl::false_)$/;"	f	namespace:boost::fusion::detail	signature:(First const& first, Last const& last, F const& f, mpl::false_)
any	xpressive/detail/utility/any.hpp	/^        any(First const&, Last const&, F const&, mpl::true_)$/;"	f	namespace:boost::fusion::detail	signature:(First const&, Last const&, F const&, mpl::true_)
any	xpressive/detail/utility/any.hpp	/^        struct any$/;"	s	namespace:boost::fusion::function
any	xpressive/detail/utility/any.hpp	/^        struct any$/;"	s	namespace:boost::fusion::meta
any	xpressive/detail/utility/any.hpp	/^    function::any const any = function::any();$/;"	m	class:boost::fusion::function
any_dxpr	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    typedef matcher_wrapper<any_matcher> any_dxpr;$/;"	t	namespace:boost::xpressive::detail
any_matcher	xpressive/detail/core/matcher/any_matcher.hpp	/^    struct any_matcher$/;"	s	namespace:boost::xpressive::detail
any_sxpr	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    typedef static_xpression<any_matcher, true_xpression> any_sxpr;$/;"	t	namespace:boost::xpressive::detail
any_type	xpressive/match_results.hpp	/^struct any_type { any_type(...); };$/;"	p	struct:boost::xpressive::detail::any_type	access:public	signature:(....)
any_type	xpressive/match_results.hpp	/^struct any_type { any_type(...); };$/;"	s	namespace:boost::xpressive::detail
append_new	xpressive/detail/core/results_cache.hpp	/^        match_results<BidiIter> &append_new(nested_results<BidiIter> &out)$/;"	f	struct:boost::xpressive::detail::results_cache	access:public	signature:(nested_results<BidiIter> &out)
apply	xpressive/detail/core/linker.hpp	/^    struct apply {};$/;"	s	struct:boost::xpressive::detail::icase_modifier	access:public
apply	xpressive/detail/core/linker.hpp	/^    struct apply {};$/;"	s	struct:boost::xpressive::detail::locale_modifier	access:public
apply	xpressive/detail/core/linker.hpp	/^    struct apply<xpression_visitor<BidiIter, ICase, OtherTraits> >$/;"	s	struct:boost::xpressive::detail::locale_modifier	access:public
apply	xpressive/detail/core/linker.hpp	/^    struct apply<xpression_visitor<BidiIter, ICase, Traits> >$/;"	s	struct:boost::xpressive::detail::icase_modifier	access:public
apply	xpressive/detail/static/modifier.hpp	/^        struct apply$/;"	s	struct:boost::xpressive::detail::modifier_op	access:public
apply	xpressive/detail/static/visitor.hpp	/^        struct apply$/;"	s	struct:boost::xpressive::detail::xpression_visitor	access:public
apply	xpressive/detail/utility/any.hpp	/^            struct apply$/;"	s	struct:boost::fusion::function::any	access:public
apply	xpressive/detail/utility/cons.hpp	/^            struct apply : cons_detail::begin_traits_impl<Sequence>$/;"	s	struct:boost::fusion::meta::begin_impl	inherits:cons_detail::begin_traits_impl	access:public
apply	xpressive/detail/utility/cons.hpp	/^            struct apply : cons_detail::deref_traits_impl<Iterator> {};$/;"	s	struct:boost::fusion::meta::deref_impl	inherits:cons_detail::deref_traits_impl	access:public
apply	xpressive/detail/utility/cons.hpp	/^            struct apply : cons_detail::end_traits_impl<Sequence>$/;"	s	struct:boost::fusion::meta::end_impl	inherits:cons_detail::end_traits_impl	access:public
apply	xpressive/detail/utility/cons.hpp	/^            struct apply : cons_detail::next_traits_impl<Iterator> {};$/;"	s	struct:boost::fusion::meta::next_impl	inherits:cons_detail::next_traits_impl	access:public
apply	xpressive/detail/utility/cons.hpp	/^            struct apply : cons_detail::value_traits_impl<Iterator> {};$/;"	s	struct:boost::fusion::meta::value_impl	inherits:cons_detail::value_traits_impl	access:public
arg_type	xpressive/detail/static/transforms/as_independent.hpp	/^            typedef typename proto::result_of::child<Expr>::type arg_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_keeper::impl	access:public
arg_type	xpressive/detail/static/transforms/as_independent.hpp	/^            typedef typename proto::result_of::child<Expr>::type arg_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookahead::impl	access:public
arg_type	xpressive/detail/static/transforms/as_independent.hpp	/^            typedef typename proto::result_of::child<Expr>::type arg_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookbehind::impl	access:public
arg_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            arg_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_simple_quantifier::impl	access:public
args	xpressive/detail/core/matcher/action_matcher.hpp	/^        action_args_type const &args() const$/;"	f	struct:boost::xpressive::detail::action_context	access:public	signature:() const
args	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        action_args_type const &args() const$/;"	f	struct:boost::xpressive::detail::predicate_context	access:public	signature:() const
args_	xpressive/match_results.hpp	/^    detail::action_args_type args_;$/;"	m	struct:boost::xpressive::match_results	access:private
as	xpressive/regex_actions.hpp	/^        struct as$/;"	s	namespace:boost::xpressive::op
as	xpressive/regex_actions.hpp	/^    as(A const &a)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A const &a)
as_action	xpressive/detail/static/transforms/as_action.hpp	/^    struct as_action : proto::transform<as_action>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_alternate_matcher	xpressive/detail/static/transforms/as_alternate.hpp	/^        struct as_alternate_matcher : proto::transform<as_alternate_matcher<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_attr_matcher	xpressive/detail/static/transforms/as_action.hpp	/^    struct as_attr_matcher : proto::transform<as_attr_matcher>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_callable	xpressive/match_results.hpp	/^as_callable(T const &t)$/;"	f	namespace:boost::xpressive::detail	signature:(T const &t)
as_default_optional	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_default_optional : proto::transform<as_default_optional<Grammar, Greedy, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_default_quantifier	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_default_quantifier : proto::transform<as_default_quantifier<Greedy, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_default_quantifier_impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_default_quantifier_impl : proto::transform<as_default_quantifier_impl<Greedy, Min, Max> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_default_quantifier_impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_default_quantifier_impl<Greedy, 0, 1>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:call
as_default_quantifier_impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_default_quantifier_impl<Greedy, 0, Max>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:call
as_inverse	xpressive/detail/static/transforms/as_inverse.hpp	/^    struct as_inverse : proto::callable$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::callable
as_keeper	xpressive/detail/static/transforms/as_independent.hpp	/^    struct as_keeper : proto::transform<as_keeper<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_list_set_matcher	xpressive/detail/static/transforms/as_set.hpp	/^    struct as_list_set_matcher : proto::transform<as_list_set_matcher<Char, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_lookahead	xpressive/detail/static/transforms/as_independent.hpp	/^    struct as_lookahead : proto::transform<as_lookahead<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_lookbehind	xpressive/detail/static/transforms/as_independent.hpp	/^    struct as_lookbehind : proto::transform<as_lookbehind<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_mark_optional	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_mark_optional : proto::transform<as_mark_optional<Grammar, Greedy, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_marker	xpressive/detail/static/transforms/as_marker.hpp	/^    struct as_marker : proto::transform<as_marker>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_matcher	xpressive/detail/static/transforms/as_matcher.hpp	/^    struct as_matcher : proto::transform<as_matcher>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_modifier	xpressive/detail/static/transforms/as_modifier.hpp	/^    struct as_modifier : proto::transform<as_modifier<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_optional	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_optional$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
as_read_attr	xpressive/detail/static/transforms/as_action.hpp	/^    struct as_read_attr : proto::transform<as_read_attr>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_repeat	xpressive/detail/static/grammar.hpp	/^        struct as_repeat$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:if_
as_set_matcher	xpressive/detail/static/transforms/as_set.hpp	/^    struct as_set_matcher : proto::transform<as_set_matcher<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_simple_quantifier	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_simple_quantifier : proto::transform<as_simple_quantifier<Grammar, Greedy, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
as_xpr	xpressive/regex_primitives.hpp	/^proto::functional::as_expr<> const as_xpr = {};$/;"	m	class:boost::xpressive::proto::functional
as_xpr	xpressive/regex_primitives.hpp	/^template<typename Literal> detail::unspecified as_xpr(Literal const &literal) { return 0; }$/;"	f	namespace:boost::xpressive	signature:(Literal const &literal)
assert_bol_matcher	xpressive/detail/core/matcher/assert_bol_matcher.hpp	/^        assert_bol_matcher(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::assert_bol_matcher	access:public	signature:(Traits const &tr)
assert_bol_matcher	xpressive/detail/core/matcher/assert_bol_matcher.hpp	/^    struct assert_bol_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:assert_line_base
assert_bol_placeholder	xpressive/detail/static/placeholders.hpp	/^struct assert_bol_placeholder$/;"	s	namespace:boost::xpressive::detail
assert_bos_matcher	xpressive/detail/core/matcher/assert_bos_matcher.hpp	/^    struct assert_bos_matcher$/;"	s	namespace:boost::xpressive::detail
assert_eol_matcher	xpressive/detail/core/matcher/assert_eol_matcher.hpp	/^        assert_eol_matcher(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::assert_eol_matcher	access:public	signature:(Traits const &tr)
assert_eol_matcher	xpressive/detail/core/matcher/assert_eol_matcher.hpp	/^    struct assert_eol_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:assert_line_base
assert_eol_placeholder	xpressive/detail/static/placeholders.hpp	/^struct assert_eol_placeholder$/;"	s	namespace:boost::xpressive::detail
assert_eos_matcher	xpressive/detail/core/matcher/assert_eos_matcher.hpp	/^    struct assert_eos_matcher$/;"	s	namespace:boost::xpressive::detail
assert_line_base	xpressive/detail/core/matcher/assert_line_base.hpp	/^        assert_line_base(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::assert_line_base	access:protected	signature:(Traits const &tr)
assert_line_base	xpressive/detail/core/matcher/assert_line_base.hpp	/^    struct assert_line_base$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_assertion
assert_word_begin	xpressive/regex_primitives.hpp	/^    typedef assert_word_placeholder<word_begin> assert_word_begin;$/;"	t	namespace:boost::xpressive::detail
assert_word_boundary	xpressive/regex_primitives.hpp	/^    typedef assert_word_placeholder<word_boundary<mpl::true_> > assert_word_boundary;$/;"	t	namespace:boost::xpressive::detail
assert_word_end	xpressive/regex_primitives.hpp	/^    typedef assert_word_placeholder<word_end> assert_word_end;$/;"	t	namespace:boost::xpressive::detail
assert_word_matcher	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        assert_word_matcher(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::assert_word_matcher	access:public	signature:(Traits const &tr)
assert_word_matcher	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        assert_word_matcher(char_class_type word)$/;"	f	struct:boost::xpressive::detail::assert_word_matcher	access:public	signature:(char_class_type word)
assert_word_matcher	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^    struct assert_word_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_assertion
assert_word_placeholder	xpressive/detail/static/placeholders.hpp	/^struct assert_word_placeholder$/;"	s	namespace:boost::xpressive::detail
at	xpressive/regex_actions.hpp	/^        struct at$/;"	s	namespace:boost::xpressive::op
at	xpressive/regex_actions.hpp	/^    function<op::at>::type const at = {{}};$/;"	m	class:boost::xpressive::function
at_	xpressive/match_results.hpp	/^    const_reference at_(char_type const *name) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(char_type const *name) const
at_	xpressive/match_results.hpp	/^    const_reference at_(detail::basic_mark_tag const &mark) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(detail::basic_mark_tag const &mark) const
at_	xpressive/match_results.hpp	/^    const_reference at_(size_type sub) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(size_type sub) const
at_	xpressive/match_results.hpp	/^    const_reference at_(string_type const &name) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(string_type const &name) const
attr_begin_matcher	xpressive/detail/core/matcher/attr_begin_matcher.hpp	/^    struct attr_begin_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
attr_context	xpressive/detail/core/state.hpp	/^struct attr_context$/;"	s	namespace:boost::xpressive::detail
attr_context_	xpressive/detail/core/state.hpp	/^    attr_context attr_context_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
attr_context_	xpressive/detail/core/state.hpp	/^    attr_context attr_context_;$/;"	m	struct:boost::xpressive::detail::memento	access:public
attr_end_matcher	xpressive/detail/core/matcher/attr_end_matcher.hpp	/^    struct attr_end_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
attr_matcher	xpressive/detail/core/matcher/attr_matcher.hpp	/^        attr_matcher(int slot, Matcher const &matcher, Traits const& tr)$/;"	f	struct:boost::xpressive::detail::attr_matcher	access:public	signature:(int slot, Matcher const &matcher, Traits const& tr)
attr_matcher	xpressive/detail/core/matcher/attr_matcher.hpp	/^    struct attr_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
attr_nbr	xpressive/detail/static/transforms/as_action.hpp	/^    struct attr_nbr : proto::transform<attr_nbr>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
attr_slots_	xpressive/detail/core/state.hpp	/^    void const **attr_slots_;$/;"	m	struct:boost::xpressive::detail::attr_context	access:public
attr_transform	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct attr_transform : proto::transform<attr_transform>$/;"	s	namespace:boost::xpressive::detail	inherits:proto::transform
attr_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            attr_type;$/;"	t	struct:boost::xpressive::detail::attr_transform::impl	access:public
attr_type	xpressive/detail/static/transforms/as_action.hpp	/^            attr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_read_attr::impl	access:public
attr_with_default_tag	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct attr_with_default_tag$/;"	s	namespace:boost::xpressive::detail
attr_with_default_transform	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct attr_with_default_transform : proto::transform<attr_with_default_transform<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::detail	inherits:proto::transform
attribute_placeholder	xpressive/detail/static/placeholders.hpp	/^struct attribute_placeholder$/;"	s	namespace:boost::xpressive::detail
back	xpressive/detail/core/list.hpp	/^        const_reference back() const$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:() const
back	xpressive/detail/core/list.hpp	/^        reference back()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
back	xpressive/regex_actions.hpp	/^        struct back$/;"	s	namespace:boost::xpressive::op
back	xpressive/regex_actions.hpp	/^    function<op::back>::type const back = {{}};$/;"	m	class:boost::xpressive::function
back_	xpressive/detail/core/matcher/alternate_end_matcher.hpp	/^        mutable void const *back_;$/;"	m	struct:boost::xpressive::detail::alternate_end_matcher	access:public
back_	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        mutable void const *back_;$/;"	m	struct:boost::xpressive::detail::repeat_end_matcher	access:public
back_	xpressive/detail/utility/sequence_stack.hpp	/^        chunk *back_, *next_;$/;"	m	struct:boost::xpressive::detail::sequence_stack::chunk	access:public
back_stack_	xpressive/detail/core/linker.hpp	/^    std::stack<void const *> back_stack_;$/;"	m	struct:boost::xpressive::detail::xpression_linker	access:private
base	xpressive/detail/utility/chset/basic_chset.hpp	/^    std::bitset<256> const &base() const;$/;"	p	class:boost::xpressive::detail::basic_chset_8bit::std	access:public	signature:() const
base	xpressive/detail/utility/chset/chset.hpp	/^    basic_chset<char_type> const &base() const$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:() const
base	xpressive/match_results.hpp	/^    OutputIterator base() const$/;"	f	struct:boost::xpressive::detail::case_converting_iterator	access:public	signature:() const
base_	xpressive/match_results.hpp	/^    boost::optional<BidiIter> base_;$/;"	m	struct:boost::xpressive::match_results	access:private
base_iterator	xpressive/detail/utility/tracking_ptr.hpp	/^    typedef typename set_type::iterator base_iterator;$/;"	t	struct:boost::xpressive::detail::weak_iterator	access:public
base_t	xpressive/detail/core/sub_match_vector.hpp	/^    > base_t;$/;"	t	struct:boost::xpressive::detail::sub_match_iterator	access:public
base_type	xpressive/basic_regex.hpp	/^    typedef proto::extends<pimpl_type, basic_regex<BidiIter>, detail::regex_domain> base_type;$/;"	t	struct:boost::xpressive::basic_regex	access:private
base_type	xpressive/detail/utility/chset/chset.hpp	/^    typedef basic_chset<char_type> base_type;$/;"	t	struct:boost::xpressive::detail::compound_charset	access:public
base_type	xpressive/regex_actions.hpp	/^        typedef proto::extends<typename proto::terminal<T>::type, value<T> > base_type;$/;"	t	struct:boost::xpressive::value	access:public
base_type	xpressive/regex_actions.hpp	/^        typedef proto::extends<typename proto::terminal<reference_wrapper<T> >::type, reference<T> > base_type;$/;"	t	struct:boost::xpressive::reference	access:public
base_type	xpressive/regex_actions.hpp	/^        typedef typename proto::terminal<reference_wrapper<T> >::type base_type;$/;"	t	struct:boost::xpressive::local	access:public
base_type	xpressive/regex_primitives.hpp	/^    typedef proto::extends<detail::basic_mark_tag, mark_tag, detail::regex_domain> base_type;$/;"	t	struct:boost::xpressive::mark_tag	access:private
base_type	xpressive/traits/c_regex_traits.hpp	/^    typedef detail::c_regex_traits_base<Char> base_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
base_type	xpressive/traits/cpp_regex_traits.hpp	/^    typedef detail::cpp_regex_traits_base<Char> base_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
basic_chset	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset();$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:()
basic_chset	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset(basic_chset const &arg);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(basic_chset const &arg)
basic_chset	xpressive/detail/utility/chset/basic_chset.hpp	/^struct basic_chset$/;"	s	namespace:boost::xpressive::detail
basic_chset	xpressive/detail/utility/chset/basic_chset.hpp	/^struct basic_chset<char>$/;"	s	namespace:boost::xpressive::detail	inherits:basic_chset_8bit
basic_chset	xpressive/detail/utility/chset/basic_chset.hpp	/^struct basic_chset<signed char>$/;"	s	namespace:boost::xpressive::detail	inherits:basic_chset_8bit
basic_chset	xpressive/detail/utility/chset/basic_chset.hpp	/^struct basic_chset<unsigned char>$/;"	s	namespace:boost::xpressive::detail	inherits:basic_chset_8bit
basic_chset_8bit	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset_8bit();$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:()
basic_chset_8bit	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset_8bit(basic_chset_8bit const &arg);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(basic_chset_8bit const &arg)
basic_chset_8bit	xpressive/detail/utility/chset/basic_chset.hpp	/^struct basic_chset_8bit$/;"	s	namespace:boost::xpressive::detail
basic_mark_tag	xpressive/xpressive_fwd.hpp	/^        typedef proto::expr<proto::tag::terminal, proto::term<mark_placeholder>, 0> basic_mark_tag;$/;"	t	namespace:boost::xpressive::detail
basic_regex	xpressive/basic_regex.hpp	/^    basic_regex()$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:()
basic_regex	xpressive/basic_regex.hpp	/^    basic_regex(Expr const &expr)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(Expr const &expr)
basic_regex	xpressive/basic_regex.hpp	/^    basic_regex(basic_regex<BidiIter> const &that)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(basic_regex<BidiIter> const &that)
basic_regex	xpressive/basic_regex.hpp	/^    basic_regex(char_type const *);$/;"	p	struct:boost::xpressive::basic_regex	access:private	signature:(char_type const *)
basic_regex	xpressive/basic_regex.hpp	/^    basic_regex(string_type const &);$/;"	p	struct:boost::xpressive::basic_regex	access:private	signature:(string_type const &)
basic_regex	xpressive/basic_regex.hpp	/^struct basic_regex$/;"	s	namespace:boost::xpressive	inherits:proto::extends
before	xpressive/regex_primitives.hpp	/^before(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
begin	xpressive/detail/core/list.hpp	/^        const_iterator begin() const$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:() const
begin	xpressive/detail/core/list.hpp	/^        iterator begin()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
begin	xpressive/detail/core/sub_match_vector.hpp	/^    const_iterator begin() const$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:() const
begin	xpressive/detail/utility/chset/range_run.hpp	/^    const_iterator begin() const;$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:() const
begin	xpressive/match_results.hpp	/^    const_iterator begin() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
begin	xpressive/regex_algorithms.hpp	/^        BOOST_XPR_NONDEDUCED_TYPE_(BidiIter) begin$/;"	m	namespace:boost::xpressive::detail
begin_	xpressive/detail/core/peeker.hpp	/^    Char const *begin_;$/;"	m	struct:boost::xpressive::detail::peeker_string	access:public
begin_	xpressive/detail/core/state.hpp	/^    BidiIter begin_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
begin_	xpressive/detail/core/sub_match_impl.hpp	/^    BidiIter begin_;$/;"	m	struct:boost::xpressive::detail::sub_match_impl	access:public
begin_	xpressive/detail/utility/boyer_moore.hpp	/^    char_type const *begin_;$/;"	m	struct:boost::xpressive::detail::boyer_moore	access:private
begin_	xpressive/detail/utility/sequence_stack.hpp	/^        T *const begin_, *curr_, *const end_;$/;"	m	struct:boost::xpressive::detail::sequence_stack::chunk	access:public
begin_	xpressive/detail/utility/sequence_stack.hpp	/^    T *begin_;$/;"	m	struct:boost::xpressive::detail::sequence_stack	access:private
begin_impl	xpressive/detail/utility/cons.hpp	/^        struct begin_impl<cons_tag>$/;"	s	namespace:boost::fusion::meta
begin_impl	xpressive/detail/utility/cons.hpp	/^    struct begin_impl<fusion::cons_tag>$/;"	s	namespace:boost::mpl	inherits:fusion::meta::begin_impl
begin_traits_impl	xpressive/detail/utility/cons.hpp	/^        struct begin_traits_impl$/;"	s	namespace:boost::fusion::cons_detail
begin_type	xpressive/detail/static/transforms/as_action.hpp	/^            begin_type;$/;"	t	struct:boost::xpressive::grammar_detail::add_attrs::impl	access:public
binary_fun	xpressive/match_results.hpp	/^    typedef binary_type (*binary_fun)(any_type, any_type);$/;"	t	struct:boost::xpressive::detail::unary_binary_ternary	access:public
binary_type	xpressive/match_results.hpp	/^typedef char (&binary_type)[3];$/;"	t	namespace:boost::xpressive::detail
bind_args	xpressive/detail/detail_fwd.hpp	/^    void bind_args(let_<Args> const &, match_results<BidiIter> &);$/;"	p	namespace:boost::xpressive::detail	signature:(let_<Args> const &, match_results<BidiIter> &)
bind_args	xpressive/regex_actions.hpp	/^        void bind_args(let_<Args> const &args, match_results<BidiIter> &what)$/;"	f	namespace:boost::xpressive::detail	signature:(let_<Args> const &args, match_results<BidiIter> &what)
bits_	xpressive/detail/core/finder.hpp	/^    bool bits_[256];$/;"	m	struct:boost::xpressive::detail::line_start_finder	access:private
bitset	xpressive/detail/core/peeker.hpp	/^    hash_peek_bitset<Char> const &bitset() const$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:() const
blank	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const blank = {{"blank", false}};$/;"	m	class:boost::xpressive::proto::terminal
bm_	xpressive/detail/core/finder.hpp	/^    boyer_moore<BidiIter, Traits> bm_;$/;"	m	struct:boost::xpressive::detail::boyer_moore_finder	access:private
bol	xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_bol_placeholder>::type const bol = {{}};$/;"	m	class:boost::xpressive::proto::terminal
bool_type	xpressive/detail/core/sub_match_vector.hpp	/^    typedef int dummy::*bool_type;$/;"	t	class:boost::xpressive::detail::sub_match_vector::dummy	access:private
bool_type	xpressive/match_results.hpp	/^    typedef int dummy::*bool_type;$/;"	t	class:boost::xpressive::match_results::dummy	access:private
bool_type	xpressive/sub_match.hpp	/^    typedef int dummy::*bool_type;$/;"	t	class:boost::xpressive::sub_match::dummy	access:private
boost	xpressive/basic_regex.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	xpressive/detail/core/access.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/action.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/adaptor.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/finder.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/flow_control.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/icase.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n
boost	xpressive/detail/core/linker.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/list.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/action_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/alternate_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/alternate_matcher.hpp	/^namespace boost { namespace fusion$/;"	n
boost	xpressive/detail/core/matcher/alternate_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/any_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/assert_bol_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/assert_bos_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/assert_eol_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/assert_eos_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/assert_line_base.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/attr_begin_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/attr_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/attr_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/charset_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/epsilon_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/keeper_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/literal_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/mark_begin_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/mark_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/mark_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/optional_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/predicate_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/range_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/regex_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/repeat_begin_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/set_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/string_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/matcher/true_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/optimize.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/peeker.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/quant_style.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/regex_domain.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/regex_impl.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/results_cache.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/state.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/sub_match_impl.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/core/sub_match_vector.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n
boost	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive { namespace op$/;"	n
boost	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	xpressive/detail/dynamic/dynamic.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/dynamic/matchable.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/dynamic/parse_charset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/dynamic/parser.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/dynamic/parser_enum.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n
boost	xpressive/detail/dynamic/parser_traits.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	xpressive/detail/dynamic/sequence.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/static/compile.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/static/grammar.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	xpressive/detail/static/is_pure.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/static/modifier.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/static/placeholders.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/static/static.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/static/transforms/as_action.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/static/transforms/as_action.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n
boost	xpressive/detail/static/transforms/as_alternate.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	xpressive/detail/static/transforms/as_independent.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/static/transforms/as_independent.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n
boost	xpressive/detail/static/transforms/as_inverse.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n
boost	xpressive/detail/static/transforms/as_marker.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n
boost	xpressive/detail/static/transforms/as_matcher.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n
boost	xpressive/detail/static/transforms/as_modifier.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/static/transforms/as_modifier.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n
boost	xpressive/detail/static/transforms/as_quantifier.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/static/transforms/as_quantifier.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n
boost	xpressive/detail/static/transforms/as_sequence.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n
boost	xpressive/detail/static/transforms/as_set.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n
boost	xpressive/detail/static/transmogrify.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/static/type_traits.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/static/visitor.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/static/width_of.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/algorithm.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/any.hpp	/^namespace boost { namespace fusion$/;"	n
boost	xpressive/detail/utility/boyer_moore.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/chset/basic_chset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/chset/chset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/chset/range_run.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/cons.hpp	/^namespace boost { namespace fusion$/;"	n
boost	xpressive/detail/utility/cons.hpp	/^namespace boost { namespace mpl$/;"	n
boost	xpressive/detail/utility/counted_base.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/dont_care.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/hash_peek_bitset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/ignore_unused.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/literals.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/never_true.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/save_restore.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/sequence_stack.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/symbols.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/tracking_ptr.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/traits_utils.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/detail/utility/width.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/match_results.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/regex_actions.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	xpressive/regex_algorithms.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	xpressive/regex_compiler.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	xpressive/regex_constants.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n
boost	xpressive/regex_error.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	xpressive/regex_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/regex_primitives.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/regex_token_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	xpressive/sub_match.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	xpressive/sub_match.hpp	/^namespace boost$/;"	n
boost	xpressive/traits/c_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	xpressive/traits/cpp_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	xpressive/traits/detail/c_ctype.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n
boost	xpressive/traits/null_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n
boost	xpressive/xpressive_fwd.hpp	/^namespace boost { namespace xpressive$/;"	n
boost::fusion	xpressive/detail/core/matcher/alternate_matcher.hpp	/^namespace boost { namespace fusion$/;"	n	namespace:boost
boost::fusion	xpressive/detail/utility/any.hpp	/^namespace boost { namespace fusion$/;"	n	namespace:boost
boost::fusion	xpressive/detail/utility/cons.hpp	/^namespace boost { namespace fusion$/;"	n	namespace:boost
boost::fusion::cons	xpressive/detail/utility/cons.hpp	/^    struct cons : sequence_base<cons<Car,Cdr> >$/;"	s	namespace:boost::fusion	inherits:sequence_base
boost::fusion::cons::car	xpressive/detail/utility/cons.hpp	/^        car_type car;$/;"	m	struct:boost::fusion::cons	access:public
boost::fusion::cons::car_type	xpressive/detail/utility/cons.hpp	/^        typedef typename call_traits<Car>::value_type car_type;$/;"	t	struct:boost::fusion::cons	access:public
boost::fusion::cons::cdr	xpressive/detail/utility/cons.hpp	/^        cdr_type cdr;$/;"	m	struct:boost::fusion::cons	access:public
boost::fusion::cons::cdr_type	xpressive/detail/utility/cons.hpp	/^        typedef Cdr cdr_type;$/;"	t	struct:boost::fusion::cons	access:public
boost::fusion::cons::cons	xpressive/detail/utility/cons.hpp	/^        cons()$/;"	f	struct:boost::fusion::cons	access:public	signature:()
boost::fusion::cons::cons	xpressive/detail/utility/cons.hpp	/^        explicit cons($/;"	f	struct:boost::fusion::cons	access:public	signature:( typename call_traits<Car>::param_type car_ , typename call_traits<Cdr>::param_type cdr_ = Cdr())
boost::fusion::cons::tag	xpressive/detail/utility/cons.hpp	/^        typedef cons_tag tag;$/;"	t	struct:boost::fusion::cons	access:public
boost::fusion::cons_detail	xpressive/detail/utility/cons.hpp	/^    namespace cons_detail$/;"	n	namespace:boost::fusion
boost::fusion::cons_detail::begin_traits_impl	xpressive/detail/utility/cons.hpp	/^        struct begin_traits_impl$/;"	s	namespace:boost::fusion::cons_detail
boost::fusion::cons_detail::begin_traits_impl::call	xpressive/detail/utility/cons.hpp	/^            call(Cons& t)$/;"	f	struct:boost::fusion::cons_detail::begin_traits_impl	access:public	signature:(Cons& t)
boost::fusion::cons_detail::begin_traits_impl::type	xpressive/detail/utility/cons.hpp	/^            typedef cons_iterator<Cons> type;$/;"	t	struct:boost::fusion::cons_detail::begin_traits_impl	access:public
boost::fusion::cons_detail::deref_traits_impl	xpressive/detail/utility/cons.hpp	/^        struct deref_traits_impl$/;"	s	namespace:boost::fusion::cons_detail
boost::fusion::cons_detail::deref_traits_impl::call	xpressive/detail/utility/cons.hpp	/^            call(Iterator const& i)$/;"	f	struct:boost::fusion::cons_detail::deref_traits_impl	access:public	signature:(Iterator const& i)
boost::fusion::cons_detail::deref_traits_impl::cons_type	xpressive/detail/utility/cons.hpp	/^            typedef typename Iterator::cons_type cons_type;$/;"	t	struct:boost::fusion::cons_detail::deref_traits_impl	access:public
boost::fusion::cons_detail::deref_traits_impl::type	xpressive/detail/utility/cons.hpp	/^            type;$/;"	t	struct:boost::fusion::cons_detail::deref_traits_impl	access:public
boost::fusion::cons_detail::deref_traits_impl::value_type	xpressive/detail/utility/cons.hpp	/^            typedef typename cons_type::car_type value_type;$/;"	t	struct:boost::fusion::cons_detail::deref_traits_impl	access:public
boost::fusion::cons_detail::end_traits_impl	xpressive/detail/utility/cons.hpp	/^        struct end_traits_impl$/;"	s	namespace:boost::fusion::cons_detail
boost::fusion::cons_detail::end_traits_impl::call	xpressive/detail/utility/cons.hpp	/^            call(Cons& t)$/;"	f	struct:boost::fusion::cons_detail::end_traits_impl	access:public	signature:(Cons& t)
boost::fusion::cons_detail::end_traits_impl::type	xpressive/detail/utility/cons.hpp	/^            type;$/;"	t	struct:boost::fusion::cons_detail::end_traits_impl	access:public
boost::fusion::cons_detail::next_traits_impl	xpressive/detail/utility/cons.hpp	/^        struct next_traits_impl$/;"	s	namespace:boost::fusion::cons_detail
boost::fusion::cons_detail::next_traits_impl::call	xpressive/detail/utility/cons.hpp	/^            call(Iterator const& i)$/;"	f	struct:boost::fusion::cons_detail::next_traits_impl	access:public	signature:(Iterator const& i)
boost::fusion::cons_detail::next_traits_impl::cdr_type	xpressive/detail/utility/cons.hpp	/^            typedef typename cons_type::cdr_type cdr_type;$/;"	t	struct:boost::fusion::cons_detail::next_traits_impl	access:public
boost::fusion::cons_detail::next_traits_impl::cons_type	xpressive/detail/utility/cons.hpp	/^            typedef typename Iterator::cons_type cons_type;$/;"	t	struct:boost::fusion::cons_detail::next_traits_impl	access:public
boost::fusion::cons_detail::next_traits_impl::type	xpressive/detail/utility/cons.hpp	/^            type;$/;"	t	struct:boost::fusion::cons_detail::next_traits_impl	access:public
boost::fusion::cons_detail::value_traits_impl	xpressive/detail/utility/cons.hpp	/^        struct value_traits_impl$/;"	s	namespace:boost::fusion::cons_detail
boost::fusion::cons_detail::value_traits_impl::cons_type	xpressive/detail/utility/cons.hpp	/^            typedef typename Iterator::cons_type cons_type;$/;"	t	struct:boost::fusion::cons_detail::value_traits_impl	access:public
boost::fusion::cons_detail::value_traits_impl::type	xpressive/detail/utility/cons.hpp	/^            typedef typename cons_type::car_type type;$/;"	t	struct:boost::fusion::cons_detail::value_traits_impl	access:public
boost::fusion::cons_iterator	xpressive/detail/utility/cons.hpp	/^    struct cons_iterator : iterator_base<cons_iterator<Cons> >$/;"	s	namespace:boost::fusion	inherits:iterator_base
boost::fusion::cons_iterator	xpressive/detail/utility/cons.hpp	/^    struct cons_iterator<nil const> : iterator_base<cons_iterator<nil const> >$/;"	s	namespace:boost::fusion	inherits:iterator_base
boost::fusion::cons_iterator	xpressive/detail/utility/cons.hpp	/^    struct cons_iterator<nil> : iterator_base<cons_iterator<nil> >$/;"	s	namespace:boost::fusion	inherits:iterator_base
boost::fusion::cons_iterator::cons	xpressive/detail/utility/cons.hpp	/^        cons_type& cons;$/;"	m	struct:boost::fusion::cons_iterator	access:public
boost::fusion::cons_iterator::cons_iterator	xpressive/detail/utility/cons.hpp	/^        cons_iterator() {}$/;"	f	struct:boost::fusion::cons_iterator	access:public	signature:()
boost::fusion::cons_iterator::cons_iterator	xpressive/detail/utility/cons.hpp	/^        explicit cons_iterator(cons_type& cons_)$/;"	f	struct:boost::fusion::cons_iterator	access:public	signature:(cons_type& cons_)
boost::fusion::cons_iterator::cons_iterator	xpressive/detail/utility/cons.hpp	/^        explicit cons_iterator(nil const&) {}$/;"	f	struct:boost::fusion::cons_iterator	access:public	signature:(nil const&)
boost::fusion::cons_iterator::cons_type	xpressive/detail/utility/cons.hpp	/^        typedef Cons cons_type;$/;"	t	struct:boost::fusion::cons_iterator	access:public
boost::fusion::cons_iterator::cons_type	xpressive/detail/utility/cons.hpp	/^        typedef nil cons_type;$/;"	t	struct:boost::fusion::cons_iterator	access:public
boost::fusion::cons_iterator::cons_type	xpressive/detail/utility/cons.hpp	/^        typedef nil const cons_type;$/;"	t	struct:boost::fusion::cons_iterator	access:public
boost::fusion::cons_iterator::tag	xpressive/detail/utility/cons.hpp	/^        typedef cons_iterator_tag tag;$/;"	t	struct:boost::fusion::cons_iterator	access:public
boost::fusion::detail	xpressive/detail/core/matcher/alternate_matcher.hpp	/^    namespace detail { struct iterator_root; }$/;"	n	namespace:boost::fusion
boost::fusion::detail	xpressive/detail/utility/any.hpp	/^    namespace detail$/;"	n	namespace:boost::fusion
boost::fusion::detail::any	xpressive/detail/utility/any.hpp	/^        any(First const& first, Last const& last, F const& f, mpl::false_)$/;"	f	namespace:boost::fusion::detail	signature:(First const& first, Last const& last, F const& f, mpl::false_)
boost::fusion::detail::any	xpressive/detail/utility/any.hpp	/^        any(First const&, Last const&, F const&, mpl::true_)$/;"	f	namespace:boost::fusion::detail	signature:(First const&, Last const&, F const&, mpl::true_)
boost::fusion::function	xpressive/detail/utility/any.hpp	/^    namespace function$/;"	n	namespace:boost::fusion
boost::fusion::function::any	xpressive/detail/utility/any.hpp	/^        struct any$/;"	s	namespace:boost::fusion::function
boost::fusion::function::any	xpressive/detail/utility/any.hpp	/^    function::any const any = function::any();$/;"	m	class:boost::fusion::function
boost::fusion::function::any::apply	xpressive/detail/utility/any.hpp	/^            struct apply$/;"	s	struct:boost::fusion::function::any	access:public
boost::fusion::function::any::apply::type	xpressive/detail/utility/any.hpp	/^                typedef bool type;$/;"	t	struct:boost::fusion::function::any::apply	access:public
boost::fusion::function::any::operator ()	xpressive/detail/utility/any.hpp	/^            operator()(Sequence const& seq, F const& f) const$/;"	f	struct:boost::fusion::function::any	access:public	signature:(Sequence const& seq, F const& f) const
boost::fusion::function::any::operator ()	xpressive/detail/utility/any.hpp	/^            operator()(Sequence& seq, F const& f) const$/;"	f	struct:boost::fusion::function::any	access:public	signature:(Sequence& seq, F const& f) const
boost::fusion::make_cons	xpressive/detail/utility/cons.hpp	/^    make_cons(Car const& car)$/;"	f	namespace:boost::fusion	signature:(Car const& car)
boost::fusion::make_cons	xpressive/detail/utility/cons.hpp	/^    make_cons(Car const& car, Cdr const& cdr)$/;"	f	namespace:boost::fusion	signature:(Car const& car, Cdr const& cdr)
boost::fusion::meta	xpressive/detail/utility/any.hpp	/^    namespace meta$/;"	n	namespace:boost::fusion
boost::fusion::meta	xpressive/detail/utility/cons.hpp	/^    namespace meta$/;"	n	namespace:boost::fusion
boost::fusion::meta::any	xpressive/detail/utility/any.hpp	/^        struct any$/;"	s	namespace:boost::fusion::meta
boost::fusion::meta::any::type	xpressive/detail/utility/any.hpp	/^            typedef bool type;$/;"	t	struct:boost::fusion::meta::any	access:public
boost::fusion::meta::begin_impl	xpressive/detail/utility/cons.hpp	/^        struct begin_impl<cons_tag>$/;"	s	namespace:boost::fusion::meta
boost::fusion::meta::begin_impl::apply	xpressive/detail/utility/cons.hpp	/^            struct apply : cons_detail::begin_traits_impl<Sequence>$/;"	s	struct:boost::fusion::meta::begin_impl	inherits:cons_detail::begin_traits_impl	access:public
boost::fusion::meta::deref_impl	xpressive/detail/utility/cons.hpp	/^        struct deref_impl<cons_iterator_tag>$/;"	s	namespace:boost::fusion::meta
boost::fusion::meta::deref_impl::apply	xpressive/detail/utility/cons.hpp	/^            struct apply : cons_detail::deref_traits_impl<Iterator> {};$/;"	s	struct:boost::fusion::meta::deref_impl	inherits:cons_detail::deref_traits_impl	access:public
boost::fusion::meta::end_impl	xpressive/detail/utility/cons.hpp	/^        struct end_impl<cons_tag>$/;"	s	namespace:boost::fusion::meta
boost::fusion::meta::end_impl::apply	xpressive/detail/utility/cons.hpp	/^            struct apply : cons_detail::end_traits_impl<Sequence>$/;"	s	struct:boost::fusion::meta::end_impl	inherits:cons_detail::end_traits_impl	access:public
boost::fusion::meta::next_impl	xpressive/detail/utility/cons.hpp	/^        struct next_impl<cons_iterator_tag>$/;"	s	namespace:boost::fusion::meta
boost::fusion::meta::next_impl::apply	xpressive/detail/utility/cons.hpp	/^            struct apply : cons_detail::next_traits_impl<Iterator> {};$/;"	s	struct:boost::fusion::meta::next_impl	inherits:cons_detail::next_traits_impl	access:public
boost::fusion::meta::value_impl	xpressive/detail/utility/cons.hpp	/^        struct value_impl<cons_iterator_tag>$/;"	s	namespace:boost::fusion::meta
boost::fusion::meta::value_impl::apply	xpressive/detail/utility/cons.hpp	/^            struct apply : cons_detail::value_traits_impl<Iterator> {};$/;"	s	struct:boost::fusion::meta::value_impl	inherits:cons_detail::value_traits_impl	access:public
boost::fusion::nil	xpressive/detail/utility/cons.hpp	/^    struct nil : sequence_base<nil>$/;"	s	namespace:boost::fusion	inherits:sequence_base
boost::fusion::nil::car_type	xpressive/detail/utility/cons.hpp	/^        typedef void_t car_type;$/;"	t	struct:boost::fusion::nil	access:public
boost::fusion::nil::cdr_type	xpressive/detail/utility/cons.hpp	/^        typedef void_t cdr_type;$/;"	t	struct:boost::fusion::nil	access:public
boost::fusion::nil::tag	xpressive/detail/utility/cons.hpp	/^        typedef cons_tag tag;$/;"	t	struct:boost::fusion::nil	access:public
boost::mpl	xpressive/detail/utility/cons.hpp	/^namespace boost { namespace mpl$/;"	n	namespace:boost
boost::mpl::begin_impl	xpressive/detail/utility/cons.hpp	/^    struct begin_impl<fusion::cons_tag>$/;"	s	namespace:boost::mpl	inherits:fusion::meta::begin_impl
boost::mpl::deref	xpressive/detail/utility/cons.hpp	/^    struct deref<fusion::cons_iterator<Cons> >$/;"	s	namespace:boost::mpl	inherits:fusion::cons_detail::value_traits_impl
boost::mpl::end_impl	xpressive/detail/utility/cons.hpp	/^    struct end_impl<fusion::cons_tag>$/;"	s	namespace:boost::mpl	inherits:fusion::meta::end_impl
boost::mpl::next	xpressive/detail/utility/cons.hpp	/^    struct next<fusion::cons_iterator<Cons> >$/;"	s	namespace:boost::mpl	inherits:fusion::cons_detail::next_traits_impl
boost::range_const_iterator	xpressive/sub_match.hpp	/^    struct range_const_iterator<xpressive::sub_match<BidiIter> >$/;"	s	namespace:boost
boost::range_const_iterator::type	xpressive/sub_match.hpp	/^        typedef BidiIter type;$/;"	t	struct:boost::range_const_iterator	access:public
boost::range_mutable_iterator	xpressive/sub_match.hpp	/^    struct range_mutable_iterator<xpressive::sub_match<BidiIter> >$/;"	s	namespace:boost
boost::range_mutable_iterator::type	xpressive/sub_match.hpp	/^        typedef BidiIter type;$/;"	t	struct:boost::range_mutable_iterator	access:public
boost::xpressive	xpressive/basic_regex.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/access.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/action.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/adaptor.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/finder.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/flow_control.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/icase.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/linker.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/list.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/action_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/alternate_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/alternate_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/any_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/assert_bol_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/assert_bos_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/assert_eol_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/assert_eos_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/assert_line_base.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/attr_begin_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/attr_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/attr_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/charset_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/epsilon_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/keeper_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/literal_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/mark_begin_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/mark_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/mark_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/optional_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/predicate_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/range_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/regex_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/repeat_begin_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/set_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/string_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/matcher/true_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/optimize.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/peeker.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/quant_style.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/regex_domain.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/regex_impl.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/results_cache.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/state.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/sub_match_impl.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/core/sub_match_vector.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive { namespace op$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/dynamic/dynamic.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/dynamic/matchable.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/dynamic/parse_charset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/dynamic/parser.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/dynamic/parser_enum.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/dynamic/parser_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/dynamic/sequence.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/compile.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/grammar.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/is_pure.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/modifier.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/placeholders.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/static.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/transforms/as_action.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/transforms/as_action.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/transforms/as_alternate.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/transforms/as_independent.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/transforms/as_independent.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/transforms/as_inverse.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/transforms/as_marker.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/transforms/as_matcher.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/transforms/as_modifier.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/transforms/as_modifier.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/transforms/as_quantifier.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/transforms/as_quantifier.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/transforms/as_sequence.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/transforms/as_set.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/transmogrify.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/type_traits.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/visitor.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/static/width_of.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/algorithm.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/boyer_moore.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/chset/basic_chset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/chset/chset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/chset/range_run.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/counted_base.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/dont_care.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/hash_peek_bitset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/ignore_unused.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/literals.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/never_true.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/save_restore.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/sequence_stack.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/symbols.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/tracking_ptr.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/traits_utils.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/detail/utility/width.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/match_results.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/regex_actions.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	xpressive/regex_algorithms.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	xpressive/regex_compiler.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	xpressive/regex_constants.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost
boost::xpressive	xpressive/regex_error.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	xpressive/regex_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/regex_primitives.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/regex_token_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	xpressive/sub_match.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	xpressive/traits/c_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	xpressive/traits/cpp_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	xpressive/traits/detail/c_ctype.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
boost::xpressive	xpressive/traits/null_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive	xpressive/xpressive_fwd.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
boost::xpressive::ActionableGrammar	xpressive/detail/static/grammar.hpp	/^    struct ActionableGrammar$/;"	s	namespace:boost::xpressive	inherits:proto::switch_
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s0, 0);$/;"	p	namespace:boost::xpressive	signature:(s0, 0)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s1, 1);$/;"	p	namespace:boost::xpressive	signature:(s1, 1)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s2, 2);$/;"	p	namespace:boost::xpressive	signature:(s2, 2)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s3, 3);$/;"	p	namespace:boost::xpressive	signature:(s3, 3)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s4, 4);$/;"	p	namespace:boost::xpressive	signature:(s4, 4)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s5, 5);$/;"	p	namespace:boost::xpressive	signature:(s5, 5)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s6, 6);$/;"	p	namespace:boost::xpressive	signature:(s6, 6)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s7, 7);$/;"	p	namespace:boost::xpressive	signature:(s7, 7)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s8, 8);$/;"	p	namespace:boost::xpressive	signature:(s8, 8)
boost::xpressive::BOOST_XPRESSIVE_GLOBAL_MARK_TAG	xpressive/regex_primitives.hpp	/^BOOST_XPRESSIVE_GLOBAL_MARK_TAG(s9, 9);$/;"	p	namespace:boost::xpressive	signature:(s9, 9)
boost::xpressive::Grammar	xpressive/detail/static/grammar.hpp	/^    struct Grammar$/;"	s	namespace:boost::xpressive	inherits:proto::switch_
boost::xpressive::INVALID_REGULAR_EXPRESSION	xpressive/detail/static/grammar.hpp	/^    struct INVALID_REGULAR_EXPRESSION$/;"	s	namespace:boost::xpressive	inherits:mpl::false_
boost::xpressive::as_xpr	xpressive/regex_primitives.hpp	/^template<typename Literal> detail::unspecified as_xpr(Literal const &literal) { return 0; }$/;"	f	namespace:boost::xpressive	signature:(Literal const &literal)
boost::xpressive::basic_regex	xpressive/basic_regex.hpp	/^struct basic_regex$/;"	s	namespace:boost::xpressive	inherits:proto::extends
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, ECMAScript         = regex_constants::ECMAScript);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, ECMAScript = regex_constants::ECMAScript)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, collate            = regex_constants::collate);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, collate = regex_constants::collate)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, icase              = regex_constants::icase_);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, icase = regex_constants::icase_)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, ignore_white_space = regex_constants::ignore_white_space);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, ignore_white_space = regex_constants::ignore_white_space)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, nosubs             = regex_constants::nosubs);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, nosubs = regex_constants::nosubs)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, not_dot_newline    = regex_constants::not_dot_newline);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, not_dot_newline = regex_constants::not_dot_newline)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, not_dot_null       = regex_constants::not_dot_null);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, not_dot_null = regex_constants::not_dot_null)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, optimize           = regex_constants::optimize);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, optimize = regex_constants::optimize)
boost::xpressive::basic_regex::BOOST_STATIC_CONSTANT	xpressive/basic_regex.hpp	/^    BOOST_STATIC_CONSTANT(regex_constants::syntax_option_type, single_line        = regex_constants::single_line);$/;"	p	struct:boost::xpressive::basic_regex	access:public	signature:(regex_constants::syntax_option_type, single_line = regex_constants::single_line)
boost::xpressive::basic_regex::base_type	xpressive/basic_regex.hpp	/^    typedef proto::extends<pimpl_type, basic_regex<BidiIter>, detail::regex_domain> base_type;$/;"	t	struct:boost::xpressive::basic_regex	access:private
boost::xpressive::basic_regex::basic_regex	xpressive/basic_regex.hpp	/^    basic_regex()$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:()
boost::xpressive::basic_regex::basic_regex	xpressive/basic_regex.hpp	/^    basic_regex(Expr const &expr)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(Expr const &expr)
boost::xpressive::basic_regex::basic_regex	xpressive/basic_regex.hpp	/^    basic_regex(basic_regex<BidiIter> const &that)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(basic_regex<BidiIter> const &that)
boost::xpressive::basic_regex::basic_regex	xpressive/basic_regex.hpp	/^    basic_regex(char_type const *);$/;"	p	struct:boost::xpressive::basic_regex	access:private	signature:(char_type const *)
boost::xpressive::basic_regex::basic_regex	xpressive/basic_regex.hpp	/^    basic_regex(string_type const &);$/;"	p	struct:boost::xpressive::basic_regex	access:private	signature:(string_type const &)
boost::xpressive::basic_regex::char_type	xpressive/basic_regex.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
boost::xpressive::basic_regex::compile	xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)
boost::xpressive::basic_regex::compile	xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)
boost::xpressive::basic_regex::compile	xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(char_type const *begin, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(char_type const *begin, flag_type flags = regex_constants::ECMAScript)
boost::xpressive::basic_regex::compile	xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(char_type const *begin, std::size_t len, flag_type flags)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(char_type const *begin, std::size_t len, flag_type flags)
boost::xpressive::basic_regex::compile_	xpressive/basic_regex.hpp	/^    void compile_(Expr const &, mpl::false_)$/;"	f	struct:boost::xpressive::basic_regex	access:private	signature:(Expr const &, mpl::false_)
boost::xpressive::basic_regex::compile_	xpressive/basic_regex.hpp	/^    void compile_(Expr const &expr, mpl::true_)$/;"	f	struct:boost::xpressive::basic_regex	access:private	signature:(Expr const &expr, mpl::true_)
boost::xpressive::basic_regex::flag_type	xpressive/basic_regex.hpp	/^    typedef regex_constants::syntax_option_type flag_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
boost::xpressive::basic_regex::iterator_type	xpressive/basic_regex.hpp	/^    typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
boost::xpressive::basic_regex::mark_count	xpressive/basic_regex.hpp	/^    std::size_t mark_count() const$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:() const
boost::xpressive::basic_regex::match_	xpressive/basic_regex.hpp	/^    bool match_(detail::match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::basic_regex	access:private	signature:(detail::match_state<BidiIter> &state) const
boost::xpressive::basic_regex::operator =	xpressive/basic_regex.hpp	/^    basic_regex<BidiIter> &operator =(Expr const &expr)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(Expr const &expr)
boost::xpressive::basic_regex::operator =	xpressive/basic_regex.hpp	/^    basic_regex<BidiIter> &operator =(basic_regex<BidiIter> const &that)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(basic_regex<BidiIter> const &that)
boost::xpressive::basic_regex::pimpl_type	xpressive/basic_regex.hpp	/^    typedef proto::expr<proto::tag::terminal, proto::term<detail::tracking_ptr<detail::regex_impl<BidiIter> > >, 0> pimpl_type;$/;"	t	struct:boost::xpressive::basic_regex	access:private
boost::xpressive::basic_regex::regex_id	xpressive/basic_regex.hpp	/^    regex_id_type regex_id() const$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:() const
boost::xpressive::basic_regex::string_type	xpressive/basic_regex.hpp	/^    typedef typename detail::string_type<char_type>::type string_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
boost::xpressive::basic_regex::swap	xpressive/basic_regex.hpp	/^    void swap(basic_regex<BidiIter> &that) \/\/ throw()$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(basic_regex<BidiIter> &that)
boost::xpressive::basic_regex::value_type	xpressive/basic_regex.hpp	/^    typedef typename iterator_value<BidiIter>::type value_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
boost::xpressive::c_regex_traits	xpressive/traits/c_regex_traits.hpp	/^struct c_regex_traits$/;"	s	namespace:boost::xpressive	inherits:detail::c_regex_traits_base
boost::xpressive::c_regex_traits::base_type	xpressive/traits/c_regex_traits.hpp	/^    typedef detail::c_regex_traits_base<Char> base_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
boost::xpressive::c_regex_traits::c_regex_traits	xpressive/traits/c_regex_traits.hpp	/^    c_regex_traits(locale_type const &loc = locale_type())$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(locale_type const &loc = locale_type())
boost::xpressive::c_regex_traits::char_class_type	xpressive/traits/c_regex_traits.hpp	/^    typedef typename detail::char_class_impl<Char>::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
boost::xpressive::c_regex_traits::char_type	xpressive/traits/c_regex_traits.hpp	/^    typedef Char char_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
boost::xpressive::c_regex_traits::fold_case	xpressive/traits/c_regex_traits.hpp	/^    string_type fold_case(char_type ch) const$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch) const
boost::xpressive::c_regex_traits::getloc	xpressive/traits/c_regex_traits.hpp	/^    static locale_type getloc()$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:()
boost::xpressive::c_regex_traits::hash	xpressive/traits/c_regex_traits.hpp	/^    static unsigned char hash(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::c_regex_traits::hash	xpressive/traits/c_regex_traits.hpp	/^inline unsigned char c_regex_traits<char>::hash(char ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch)
boost::xpressive::c_regex_traits::hash	xpressive/traits/c_regex_traits.hpp	/^inline unsigned char c_regex_traits<wchar_t>::hash(wchar_t ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(wchar_t ch)
boost::xpressive::c_regex_traits::imbue	xpressive/traits/c_regex_traits.hpp	/^    locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(locale_type loc)
boost::xpressive::c_regex_traits::in_range	xpressive/traits/c_regex_traits.hpp	/^    static bool in_range(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
boost::xpressive::c_regex_traits::in_range_nocase	xpressive/traits/c_regex_traits.hpp	/^    static bool in_range_nocase(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
boost::xpressive::c_regex_traits::isctype	xpressive/traits/c_regex_traits.hpp	/^    static bool isctype(char_type ch, char_class_type mask)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch, char_class_type mask)
boost::xpressive::c_regex_traits::locale_type	xpressive/traits/c_regex_traits.hpp	/^    typedef detail::empty_locale locale_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
boost::xpressive::c_regex_traits::lookup_classname	xpressive/traits/c_regex_traits.hpp	/^    static char_class_type lookup_classname(FwdIter begin, FwdIter end, bool icase)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end, bool icase)
boost::xpressive::c_regex_traits::lookup_collatename	xpressive/traits/c_regex_traits.hpp	/^    static string_type lookup_collatename(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
boost::xpressive::c_regex_traits::operator !=	xpressive/traits/c_regex_traits.hpp	/^    bool operator !=(c_regex_traits<char_type> const &) const$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(c_regex_traits<char_type> const &) const
boost::xpressive::c_regex_traits::operator ==	xpressive/traits/c_regex_traits.hpp	/^    bool operator ==(c_regex_traits<char_type> const &) const$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(c_regex_traits<char_type> const &) const
boost::xpressive::c_regex_traits::string_type	xpressive/traits/c_regex_traits.hpp	/^    typedef std::basic_string<char_type> string_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
boost::xpressive::c_regex_traits::tolower	xpressive/traits/c_regex_traits.hpp	/^    static char_type tolower(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::c_regex_traits::toupper	xpressive/traits/c_regex_traits.hpp	/^    static char_type toupper(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::c_regex_traits::transform	xpressive/traits/c_regex_traits.hpp	/^    static string_type transform(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
boost::xpressive::c_regex_traits::transform_primary	xpressive/traits/c_regex_traits.hpp	/^    static string_type transform_primary(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
boost::xpressive::c_regex_traits::translate	xpressive/traits/c_regex_traits.hpp	/^    static char_type translate(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::c_regex_traits::translate_nocase	xpressive/traits/c_regex_traits.hpp	/^    static char_type translate_nocase(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::c_regex_traits::value	xpressive/traits/c_regex_traits.hpp	/^    static int value(char_type ch, int radix);$/;"	p	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch, int radix)
boost::xpressive::c_regex_traits::value	xpressive/traits/c_regex_traits.hpp	/^inline int c_regex_traits<char>::value(char ch, int radix)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch, int radix)
boost::xpressive::c_regex_traits::value	xpressive/traits/c_regex_traits.hpp	/^inline int c_regex_traits<wchar_t>::value(wchar_t ch, int radix)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(wchar_t ch, int radix)
boost::xpressive::c_regex_traits::version_tag	xpressive/traits/c_regex_traits.hpp	/^    typedef regex_traits_version_2_tag version_tag;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
boost::xpressive::c_regex_traits::widen	xpressive/traits/c_regex_traits.hpp	/^    static char_type widen(char ch);$/;"	p	struct:boost::xpressive::c_regex_traits	access:public	signature:(char ch)
boost::xpressive::c_regex_traits::widen	xpressive/traits/c_regex_traits.hpp	/^inline char c_regex_traits<char>::widen(char ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch)
boost::xpressive::c_regex_traits::widen	xpressive/traits/c_regex_traits.hpp	/^inline wchar_t c_regex_traits<wchar_t>::widen(char ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch)
boost::xpressive::check	xpressive/regex_actions.hpp	/^    detail::unspecified check(T const &t);$/;"	p	namespace:boost::xpressive	signature:(T const &t)
boost::xpressive::cmatch	xpressive/xpressive_fwd.hpp	/^    typedef match_results<char const *>                             cmatch;$/;"	t	namespace:boost::xpressive
boost::xpressive::compiler_traits	xpressive/detail/dynamic/parser_traits.hpp	/^struct compiler_traits$/;"	s	namespace:boost::xpressive
boost::xpressive::compiler_traits::alnum_	xpressive/detail/dynamic/parser_traits.hpp	/^    typename regex_traits::char_class_type alnum_;$/;"	m	struct:boost::xpressive::compiler_traits	access:private
boost::xpressive::compiler_traits::char_type	xpressive/detail/dynamic/parser_traits.hpp	/^    typedef typename regex_traits::char_type char_type;$/;"	t	struct:boost::xpressive::compiler_traits	access:public
boost::xpressive::compiler_traits::compiler_traits	xpressive/detail/dynamic/parser_traits.hpp	/^    explicit compiler_traits(RegexTraits const &traits = RegexTraits())$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(RegexTraits const &traits = RegexTraits())
boost::xpressive::compiler_traits::eat_ws_	xpressive/detail/dynamic/parser_traits.hpp	/^    FwdIter &eat_ws_(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::compiler_traits	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::compiler_traits::flag_	xpressive/detail/dynamic/parser_traits.hpp	/^    void flag_(bool set, regex_constants::syntax_option_type flag)$/;"	f	struct:boost::xpressive::compiler_traits	access:private	signature:(bool set, regex_constants::syntax_option_type flag)
boost::xpressive::compiler_traits::flags	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_constants::syntax_option_type flags() const$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:() const
boost::xpressive::compiler_traits::flags	xpressive/detail/dynamic/parser_traits.hpp	/^    void flags(regex_constants::syntax_option_type flags)$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(regex_constants::syntax_option_type flags)
boost::xpressive::compiler_traits::flags_	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_constants::syntax_option_type flags_;$/;"	m	struct:boost::xpressive::compiler_traits	access:private
boost::xpressive::compiler_traits::get_charset_token	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_constants::compiler_token_type get_charset_token(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::compiler_traits::get_escape_token	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_constants::compiler_token_type get_escape_token(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::compiler_traits::get_group_type	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_constants::compiler_token_type get_group_type(FwdIter &begin, FwdIter end, string_type &name)$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(FwdIter &begin, FwdIter end, string_type &name)
boost::xpressive::compiler_traits::get_name_	xpressive/detail/dynamic/parser_traits.hpp	/^    void get_name_(FwdIter &begin, FwdIter end, string_type &name)$/;"	f	struct:boost::xpressive::compiler_traits	access:private	signature:(FwdIter &begin, FwdIter end, string_type &name)
boost::xpressive::compiler_traits::get_quant_spec	xpressive/detail/dynamic/parser_traits.hpp	/^    bool get_quant_spec(FwdIter &begin, FwdIter end, detail::quant_spec &spec)$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(FwdIter &begin, FwdIter end, detail::quant_spec &spec)
boost::xpressive::compiler_traits::get_token	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_constants::compiler_token_type get_token(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::compiler_traits::getloc	xpressive/detail/dynamic/parser_traits.hpp	/^    locale_type getloc() const$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:() const
boost::xpressive::compiler_traits::imbue	xpressive/detail/dynamic/parser_traits.hpp	/^    locale_type imbue(locale_type const &loc)$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(locale_type const &loc)
boost::xpressive::compiler_traits::is_alnum_	xpressive/detail/dynamic/parser_traits.hpp	/^    bool is_alnum_(char_type ch) const$/;"	f	struct:boost::xpressive::compiler_traits	access:private	signature:(char_type ch) const
boost::xpressive::compiler_traits::is_space_	xpressive/detail/dynamic/parser_traits.hpp	/^    bool is_space_(char_type ch) const$/;"	f	struct:boost::xpressive::compiler_traits	access:private	signature:(char_type ch) const
boost::xpressive::compiler_traits::locale_type	xpressive/detail/dynamic/parser_traits.hpp	/^    typedef typename regex_traits::locale_type locale_type;$/;"	t	struct:boost::xpressive::compiler_traits	access:public
boost::xpressive::compiler_traits::parse_mods_	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_constants::compiler_token_type parse_mods_(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::compiler_traits	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::compiler_traits::regex_traits	xpressive/detail/dynamic/parser_traits.hpp	/^    typedef RegexTraits regex_traits;$/;"	t	struct:boost::xpressive::compiler_traits	access:public
boost::xpressive::compiler_traits::space_	xpressive/detail/dynamic/parser_traits.hpp	/^    typename regex_traits::char_class_type space_;$/;"	m	struct:boost::xpressive::compiler_traits	access:private
boost::xpressive::compiler_traits::string_type	xpressive/detail/dynamic/parser_traits.hpp	/^    typedef typename regex_traits::string_type string_type;$/;"	t	struct:boost::xpressive::compiler_traits	access:public
boost::xpressive::compiler_traits::traits	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_traits &traits()$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:()
boost::xpressive::compiler_traits::traits	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_traits const &traits() const$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:() const
boost::xpressive::compiler_traits::traits_	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_traits traits_;$/;"	m	struct:boost::xpressive::compiler_traits	access:private
boost::xpressive::construct	xpressive/regex_actions.hpp	/^    detail::unspecified construct(Args const &...args);$/;"	p	namespace:boost::xpressive	signature:(Args const &....args)
boost::xpressive::cpp_regex_traits	xpressive/traits/cpp_regex_traits.hpp	/^struct cpp_regex_traits$/;"	s	namespace:boost::xpressive	inherits:detail::cpp_regex_traits_base
boost::xpressive::cpp_regex_traits::base_type	xpressive/traits/cpp_regex_traits.hpp	/^    typedef detail::cpp_regex_traits_base<Char> base_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
boost::xpressive::cpp_regex_traits::char_class	xpressive/traits/cpp_regex_traits.hpp	/^    static char_class_pair const &char_class(std::size_t j)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:private	signature:(std::size_t j)
boost::xpressive::cpp_regex_traits::char_class_pair	xpressive/traits/cpp_regex_traits.hpp	/^    struct char_class_pair$/;"	s	struct:boost::xpressive::cpp_regex_traits	access:private
boost::xpressive::cpp_regex_traits::char_class_pair::class_name_	xpressive/traits/cpp_regex_traits.hpp	/^        char_type const *class_name_;$/;"	m	struct:boost::xpressive::cpp_regex_traits::char_class_pair	access:public
boost::xpressive::cpp_regex_traits::char_class_pair::class_type_	xpressive/traits/cpp_regex_traits.hpp	/^        char_class_type class_type_;$/;"	m	struct:boost::xpressive::cpp_regex_traits::char_class_pair	access:public
boost::xpressive::cpp_regex_traits::char_class_type	xpressive/traits/cpp_regex_traits.hpp	/^    typedef detail::umaskex_t char_class_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
boost::xpressive::cpp_regex_traits::char_type	xpressive/traits/cpp_regex_traits.hpp	/^    typedef Char char_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
boost::xpressive::cpp_regex_traits::compare_	xpressive/traits/cpp_regex_traits.hpp	/^    static bool compare_(char_type const *name, FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:private	signature:(char_type const *name, FwdIter begin, FwdIter end)
boost::xpressive::cpp_regex_traits::cpp_regex_traits	xpressive/traits/cpp_regex_traits.hpp	/^    cpp_regex_traits(locale_type const &loc = locale_type())$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(locale_type const &loc = locale_type())
boost::xpressive::cpp_regex_traits::fold_case	xpressive/traits/cpp_regex_traits.hpp	/^    string_type fold_case(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
boost::xpressive::cpp_regex_traits::getloc	xpressive/traits/cpp_regex_traits.hpp	/^    locale_type getloc() const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:() const
boost::xpressive::cpp_regex_traits::hash	xpressive/traits/cpp_regex_traits.hpp	/^    static unsigned char hash(char_type ch)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::cpp_regex_traits::hash	xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<char>::hash(char ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(char ch)
boost::xpressive::cpp_regex_traits::hash	xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<signed char>::hash(signed char ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(signed char ch)
boost::xpressive::cpp_regex_traits::hash	xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<unsigned char>::hash(unsigned char ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(unsigned char ch)
boost::xpressive::cpp_regex_traits::hash	xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<wchar_t>::hash(wchar_t ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(wchar_t ch)
boost::xpressive::cpp_regex_traits::imbue	xpressive/traits/cpp_regex_traits.hpp	/^    locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(locale_type loc)
boost::xpressive::cpp_regex_traits::in_range	xpressive/traits/cpp_regex_traits.hpp	/^    static bool in_range(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
boost::xpressive::cpp_regex_traits::in_range_nocase	xpressive/traits/cpp_regex_traits.hpp	/^    bool in_range_nocase(char_type first, char_type last, char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch) const
boost::xpressive::cpp_regex_traits::isctype	xpressive/traits/cpp_regex_traits.hpp	/^    bool isctype(char_type ch, char_class_type mask) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch, char_class_type mask) const
boost::xpressive::cpp_regex_traits::loc_	xpressive/traits/cpp_regex_traits.hpp	/^    locale_type loc_;$/;"	m	struct:boost::xpressive::cpp_regex_traits	access:private
boost::xpressive::cpp_regex_traits::locale_type	xpressive/traits/cpp_regex_traits.hpp	/^    typedef std::locale locale_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
boost::xpressive::cpp_regex_traits::lookup_classname	xpressive/traits/cpp_regex_traits.hpp	/^    char_class_type lookup_classname(FwdIter begin, FwdIter end, bool icase) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter begin, FwdIter end, bool icase) const
boost::xpressive::cpp_regex_traits::lookup_classname_impl_	xpressive/traits/cpp_regex_traits.hpp	/^    static char_class_type lookup_classname_impl_(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:private	signature:(FwdIter begin, FwdIter end)
boost::xpressive::cpp_regex_traits::lookup_collatename	xpressive/traits/cpp_regex_traits.hpp	/^    string_type lookup_collatename(FwdIter, FwdIter) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter, FwdIter) const
boost::xpressive::cpp_regex_traits::operator !=	xpressive/traits/cpp_regex_traits.hpp	/^    bool operator !=(cpp_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(cpp_regex_traits<char_type> const &that) const
boost::xpressive::cpp_regex_traits::operator ==	xpressive/traits/cpp_regex_traits.hpp	/^    bool operator ==(cpp_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(cpp_regex_traits<char_type> const &that) const
boost::xpressive::cpp_regex_traits::std::ctype_	xpressive/traits/cpp_regex_traits.hpp	/^    std::ctype<char_type> const *ctype_;$/;"	m	class:boost::xpressive::cpp_regex_traits::std	access:private
boost::xpressive::cpp_regex_traits::string_type	xpressive/traits/cpp_regex_traits.hpp	/^    typedef std::basic_string<char_type> string_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
boost::xpressive::cpp_regex_traits::tolower	xpressive/traits/cpp_regex_traits.hpp	/^    char_type tolower(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
boost::xpressive::cpp_regex_traits::toupper	xpressive/traits/cpp_regex_traits.hpp	/^    char_type toupper(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
boost::xpressive::cpp_regex_traits::transform	xpressive/traits/cpp_regex_traits.hpp	/^    string_type transform(FwdIter, FwdIter) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter, FwdIter) const
boost::xpressive::cpp_regex_traits::transform_primary	xpressive/traits/cpp_regex_traits.hpp	/^    string_type transform_primary(FwdIter, FwdIter ) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter, FwdIter ) const
boost::xpressive::cpp_regex_traits::translate	xpressive/traits/cpp_regex_traits.hpp	/^    static char_type translate(char_type ch)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::cpp_regex_traits::translate_nocase	xpressive/traits/cpp_regex_traits.hpp	/^    char_type translate_nocase(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
boost::xpressive::cpp_regex_traits::value	xpressive/traits/cpp_regex_traits.hpp	/^    int value(char_type ch, int radix) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch, int radix) const
boost::xpressive::cpp_regex_traits::version_tag	xpressive/traits/cpp_regex_traits.hpp	/^    typedef regex_traits_version_2_tag version_tag;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
boost::xpressive::cpp_regex_traits::widen	xpressive/traits/cpp_regex_traits.hpp	/^    char_type widen(char ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char ch) const
boost::xpressive::cref	xpressive/regex_actions.hpp	/^    reference<T const> const cref(T const &t)$/;"	f	namespace:boost::xpressive	signature:(T const &t)
boost::xpressive::cregex	xpressive/xpressive_fwd.hpp	/^    typedef basic_regex<char const *>                               cregex;$/;"	t	namespace:boost::xpressive
boost::xpressive::cregex_compiler	xpressive/xpressive_fwd.hpp	/^    typedef regex_compiler<char const *>                            cregex_compiler;$/;"	t	namespace:boost::xpressive
boost::xpressive::cregex_id_filter_predicate	xpressive/xpressive_fwd.hpp	/^    typedef regex_id_filter_predicate<char const *>                 cregex_id_filter_predicate;$/;"	t	namespace:boost::xpressive
boost::xpressive::cregex_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_iterator<char const *>                            cregex_iterator;$/;"	t	namespace:boost::xpressive
boost::xpressive::cregex_token_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_token_iterator<char const *>                      cregex_token_iterator;$/;"	t	namespace:boost::xpressive
boost::xpressive::csub_match	xpressive/xpressive_fwd.hpp	/^    typedef sub_match<char const *>                                 csub_match;$/;"	t	namespace:boost::xpressive
boost::xpressive::detail	xpressive/basic_regex.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/access.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/action.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/adaptor.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/finder.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/flow_control.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/icase.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/linker.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/list.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/action_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/alternate_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/alternate_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/any_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/assert_bol_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/assert_bos_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/assert_eol_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/assert_eos_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/assert_line_base.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/attr_begin_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/attr_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/attr_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/charset_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/epsilon_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/keeper_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/literal_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/mark_begin_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/mark_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/mark_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/optional_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/predicate_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/range_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/regex_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/repeat_begin_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/set_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/string_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/matcher/true_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/optimize.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/peeker.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/quant_style.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/regex_domain.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/regex_impl.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/results_cache.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/state.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/sub_match_impl.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/core/sub_match_vector.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/dynamic/dynamic.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/dynamic/matchable.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/dynamic/parse_charset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/dynamic/parser.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/dynamic/sequence.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/static/compile.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/static/is_pure.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/static/modifier.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/static/placeholders.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/static/static.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/static/transforms/as_action.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/static/transforms/as_alternate.hpp	/^    namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/static/transforms/as_independent.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/static/transforms/as_modifier.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/static/transforms/as_quantifier.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/static/transmogrify.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/static/type_traits.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/static/visitor.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/static/width_of.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/algorithm.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/boyer_moore.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/chset/basic_chset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/chset/chset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/chset/range_run.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/counted_base.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/dont_care.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/hash_peek_bitset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/ignore_unused.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/literals.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/never_true.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/save_restore.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/sequence_stack.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/symbols.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/tracking_ptr.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/traits_utils.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/detail/utility/width.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/match_results.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/regex_actions.hpp	/^    namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/regex_algorithms.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/regex_error.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/regex_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/regex_primitives.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/regex_primitives.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/regex_token_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/traits/c_regex_traits.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/traits/cpp_regex_traits.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/traits/detail/c_ctype.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/traits/null_regex_traits.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail	xpressive/xpressive_fwd.hpp	/^    namespace detail$/;"	n	namespace:boost::xpressive
boost::xpressive::detail::ActionArgBinding	xpressive/match_results.hpp	/^struct ActionArgBinding$/;"	s	namespace:boost::xpressive::detail	inherits:proto::assign
boost::xpressive::detail::AssertionFunctor	xpressive/detail/core/matcher/predicate_matcher.hpp	/^    struct AssertionFunctor$/;"	s	namespace:boost::xpressive::detail	inherits:proto::function
boost::xpressive::detail::BindActionArgs	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct BindActionArgs$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
boost::xpressive::detail::BindArg	xpressive/regex_actions.hpp	/^        struct BindArg$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::BindArg::operator ()	xpressive/regex_actions.hpp	/^            Expr const & operator ()(MatchResults &what, Expr const &expr) const$/;"	f	struct:boost::xpressive::detail::BindArg	access:public	signature:(MatchResults &what, Expr const &expr) const
boost::xpressive::detail::BindArg::result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::detail::BindArg	access:public
boost::xpressive::detail::BindArg::result	xpressive/regex_actions.hpp	/^            struct result<This(MatchResults, Expr)>$/;"	s	struct:boost::xpressive::detail::BindArg	access:public
boost::xpressive::detail::BindArg::result::type	xpressive/regex_actions.hpp	/^                typedef Expr type;$/;"	t	struct:boost::xpressive::detail::BindArg::result	access:public
boost::xpressive::detail::BindArgs	xpressive/regex_actions.hpp	/^        struct BindArgs$/;"	s	namespace:boost::xpressive::detail	inherits:proto::function
boost::xpressive::detail::DataMember	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct DataMember$/;"	s	namespace:boost::xpressive::detail	inherits:proto::mem_ptr
boost::xpressive::detail::Primitives	xpressive/regex_primitives.hpp	/^    struct Primitives$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
boost::xpressive::detail::ReplaceAlgo	xpressive/regex_actions.hpp	/^        struct ReplaceAlgo$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
boost::xpressive::detail::SkipGrammar	xpressive/regex_primitives.hpp	/^    struct SkipGrammar$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
boost::xpressive::detail::SubMatch	xpressive/regex_primitives.hpp	/^    struct SubMatch$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
boost::xpressive::detail::SubMatchList	xpressive/regex_primitives.hpp	/^    struct SubMatchList$/;"	s	namespace:boost::xpressive::detail	inherits:proto::or_
boost::xpressive::detail::XpressiveLocaleModifier	xpressive/detail/static/compile.hpp	/^    struct XpressiveLocaleModifier$/;"	s	namespace:boost::xpressive::detail	inherits:proto::binary_expr
boost::xpressive::detail::_ln	xpressive/regex_primitives.hpp	/^detail::logical_newline_xpression const _ln = {{}};$/;"	m	class:boost::xpressive::detail
boost::xpressive::detail::action	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct action$/;"	s	namespace:boost::xpressive::detail	inherits:actionable
boost::xpressive::detail::action::action	xpressive/detail/core/matcher/action_matcher.hpp	/^        action(Actor const &actor)$/;"	f	struct:boost::xpressive::detail::action	access:public	signature:(Actor const &actor)
boost::xpressive::detail::action::actor_	xpressive/detail/core/matcher/action_matcher.hpp	/^        Actor actor_;$/;"	m	struct:boost::xpressive::detail::action	access:private
boost::xpressive::detail::action::execute	xpressive/detail/core/matcher/action_matcher.hpp	/^        virtual void execute(action_args_type *action_args) const$/;"	f	struct:boost::xpressive::detail::action	access:public	signature:(action_args_type *action_args) const
boost::xpressive::detail::action_arg	xpressive/regex_actions.hpp	/^        struct action_arg$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::action_arg::cast	xpressive/regex_actions.hpp	/^            reference cast(void *pv) const$/;"	f	struct:boost::xpressive::detail::action_arg	access:public	signature:(void *pv) const
boost::xpressive::detail::action_arg::reference	xpressive/regex_actions.hpp	/^            typedef typename add_reference<T>::type reference;$/;"	t	struct:boost::xpressive::detail::action_arg	access:public
boost::xpressive::detail::action_arg::type	xpressive/regex_actions.hpp	/^            typedef T type;$/;"	t	struct:boost::xpressive::detail::action_arg	access:public
boost::xpressive::detail::action_args_type	xpressive/detail/detail_fwd.hpp	/^    typedef std::map<std::type_info const *, void *, type_info_less> action_args_type;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::action_context	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct action_context$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::action_context::action_args_	xpressive/detail/core/matcher/action_matcher.hpp	/^        action_args_type *action_args_;$/;"	m	struct:boost::xpressive::detail::action_context	access:private
boost::xpressive::detail::action_context::action_context	xpressive/detail/core/matcher/action_matcher.hpp	/^        explicit action_context(action_args_type *action_args)$/;"	f	struct:boost::xpressive::detail::action_context	access:public	signature:(action_args_type *action_args)
boost::xpressive::detail::action_context::args	xpressive/detail/core/matcher/action_matcher.hpp	/^        action_args_type const &args() const$/;"	f	struct:boost::xpressive::detail::action_context	access:public	signature:() const
boost::xpressive::detail::action_context::eval	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval$/;"	s	struct:boost::xpressive::detail::action_context	inherits:proto::default_eval	access:public
boost::xpressive::detail::action_context::eval	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval<Expr, attr_with_default_tag>$/;"	s	struct:boost::xpressive::detail::action_context	access:public
boost::xpressive::detail::action_context::eval	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval<Expr, proto::tag::mem_ptr>$/;"	s	struct:boost::xpressive::detail::action_context	inherits:mem_ptr_eval	access:public
boost::xpressive::detail::action_context::eval	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval<Expr, proto::tag::terminal>$/;"	s	struct:boost::xpressive::detail::action_context	inherits:eval_terminal	access:public
boost::xpressive::detail::action_context::eval::operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator ()(Expr const &expr, action_context const &ctx) const$/;"	f	struct:boost::xpressive::detail::action_context::eval	access:public	signature:(Expr const &expr, action_context const &ctx) const
boost::xpressive::detail::action_context::eval::result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            typedef typename temp_type::type result_type;$/;"	t	struct:boost::xpressive::detail::action_context::eval	access:public
boost::xpressive::detail::action_context::eval::temp_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            temp_type;$/;"	t	struct:boost::xpressive::detail::action_context::eval	access:public
boost::xpressive::detail::action_context::eval_terminal	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval_terminal$/;"	s	struct:boost::xpressive::detail::action_context	inherits:proto::default_eval	access:public
boost::xpressive::detail::action_context::eval_terminal	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval_terminal<Expr, action_arg<Type, Int> >$/;"	s	struct:boost::xpressive::detail::action_context	access:public
boost::xpressive::detail::action_context::eval_terminal	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval_terminal<Expr, opt<Arg> >$/;"	s	struct:boost::xpressive::detail::action_context	access:public
boost::xpressive::detail::action_context::eval_terminal	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval_terminal<Expr, reference_wrapper<Arg> >$/;"	s	struct:boost::xpressive::detail::action_context	access:public
boost::xpressive::detail::action_context::eval_terminal::operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator()(Expr &expr, action_context const &) const$/;"	f	struct:boost::xpressive::detail::action_context::eval_terminal	access:public	signature:(Expr &expr, action_context const &) const
boost::xpressive::detail::action_context::eval_terminal::operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator()(Expr &expr, action_context const &ctx) const$/;"	f	struct:boost::xpressive::detail::action_context::eval_terminal	access:public	signature:(Expr &expr, action_context const &ctx) const
boost::xpressive::detail::action_context::eval_terminal::result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            typedef Arg &result_type;$/;"	t	struct:boost::xpressive::detail::action_context::eval_terminal	access:public
boost::xpressive::detail::action_context::eval_terminal::result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            typedef Arg const &result_type;$/;"	t	struct:boost::xpressive::detail::action_context::eval_terminal	access:public
boost::xpressive::detail::action_context::eval_terminal::result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            typedef typename action_arg<Type, Int>::reference result_type;$/;"	t	struct:boost::xpressive::detail::action_context::eval_terminal	access:public
boost::xpressive::detail::action_matcher	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct action_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::action_matcher::action_matcher	xpressive/detail/core/matcher/action_matcher.hpp	/^        action_matcher(Actor const &actor, int sub)$/;"	f	struct:boost::xpressive::detail::action_matcher	access:public	signature:(Actor const &actor, int sub)
boost::xpressive::detail::action_matcher::actor_	xpressive/detail/core/matcher/action_matcher.hpp	/^        Actor actor_;$/;"	m	struct:boost::xpressive::detail::action_matcher	access:public
boost::xpressive::detail::action_matcher::match	xpressive/detail/core/matcher/action_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::action_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::action_matcher::sub_	xpressive/detail/core/matcher/action_matcher.hpp	/^        int sub_;$/;"	m	struct:boost::xpressive::detail::action_matcher	access:public
boost::xpressive::detail::actionable	xpressive/detail/core/action.hpp	/^    struct actionable$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::actionable::actionable	xpressive/detail/core/action.hpp	/^        actionable()$/;"	f	struct:boost::xpressive::detail::actionable	access:public	signature:()
boost::xpressive::detail::actionable::execute	xpressive/detail/core/action.hpp	/^        virtual void execute(action_args_type *) const {}$/;"	f	struct:boost::xpressive::detail::actionable	access:public	signature:(action_args_type *) const
boost::xpressive::detail::actionable::next	xpressive/detail/core/action.hpp	/^        actionable const *next;$/;"	m	struct:boost::xpressive::detail::actionable	access:public
boost::xpressive::detail::actionable::~actionable	xpressive/detail/core/action.hpp	/^        virtual ~actionable() {}$/;"	f	struct:boost::xpressive::detail::actionable	access:public	signature:()
boost::xpressive::detail::add_widths	xpressive/detail/static/width_of.hpp	/^    struct add_widths$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
boost::xpressive::detail::add_widths	xpressive/detail/static/width_of.hpp	/^    struct add_widths<N, unknown_width::value>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
boost::xpressive::detail::add_widths	xpressive/detail/static/width_of.hpp	/^    struct add_widths<unknown_width::value, M>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
boost::xpressive::detail::add_widths	xpressive/detail/static/width_of.hpp	/^    struct add_widths<unknown_width::value, unknown_width::value>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
boost::xpressive::detail::adl_swap	xpressive/detail/utility/tracking_ptr.hpp	/^void adl_swap(T &t1, T &t2)$/;"	f	namespace:boost::xpressive::detail	signature:(T &t1, T &t2)
boost::xpressive::detail::advance_to	xpressive/detail/utility/algorithm.hpp	/^inline bool advance_to(Iter & iter, Diff diff, Iter end)$/;"	f	namespace:boost::xpressive::detail	signature:(Iter & iter, Diff diff, Iter end)
boost::xpressive::detail::advance_to_impl	xpressive/detail/utility/algorithm.hpp	/^inline bool advance_to_impl(BidiIter & iter, Diff diff, BidiIter end, std::bidirectional_iterator_tag)$/;"	f	namespace:boost::xpressive::detail	signature:(BidiIter & iter, Diff diff, BidiIter end, std::bidirectional_iterator_tag)
boost::xpressive::detail::advance_to_impl	xpressive/detail/utility/algorithm.hpp	/^inline bool advance_to_impl(RandIter & iter, Diff diff, RandIter end, std::random_access_iterator_tag)$/;"	f	namespace:boost::xpressive::detail	signature:(RandIter & iter, Diff diff, RandIter end, std::random_access_iterator_tag)
boost::xpressive::detail::all_ctype_masks	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const all_ctype_masks = std_ctype_reserved$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::alt_match	xpressive/detail/core/matcher/alternate_matcher.hpp	/^    inline bool alt_match$/;"	f	namespace:boost::xpressive::detail	signature:( alternates_list<Head, Tail> const &alts, match_state<BidiIter> &state, Next const & )
boost::xpressive::detail::alt_match	xpressive/detail/core/matcher/alternate_matcher.hpp	/^    inline bool alt_match$/;"	f	namespace:boost::xpressive::detail	signature:( alternates_vector<BidiIter> const &alts, match_state<BidiIter> &state, Next const & )
boost::xpressive::detail::alt_match_pred	xpressive/detail/core/matcher/alternate_matcher.hpp	/^    struct alt_match_pred$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::alt_match_pred::alt_match_pred	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        alt_match_pred(match_state<BidiIter> &state)$/;"	f	struct:boost::xpressive::detail::alt_match_pred	access:public	signature:(match_state<BidiIter> &state)
boost::xpressive::detail::alt_match_pred::operator ()	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        bool operator ()(Xpr const &xpr) const$/;"	f	struct:boost::xpressive::detail::alt_match_pred	access:public	signature:(Xpr const &xpr) const
boost::xpressive::detail::alt_match_pred::state_	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        match_state<BidiIter> *state_;$/;"	m	struct:boost::xpressive::detail::alt_match_pred	access:private
boost::xpressive::detail::alternate_end_matcher	xpressive/detail/core/matcher/alternate_end_matcher.hpp	/^    struct alternate_end_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_assertion
boost::xpressive::detail::alternate_end_matcher::alternate_end_matcher	xpressive/detail/core/matcher/alternate_end_matcher.hpp	/^        alternate_end_matcher()$/;"	f	struct:boost::xpressive::detail::alternate_end_matcher	access:public	signature:()
boost::xpressive::detail::alternate_end_matcher::back_	xpressive/detail/core/matcher/alternate_end_matcher.hpp	/^        mutable void const *back_;$/;"	m	struct:boost::xpressive::detail::alternate_end_matcher	access:public
boost::xpressive::detail::alternate_end_matcher::match	xpressive/detail/core/matcher/alternate_end_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::alternate_end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::alternate_end_xpression	xpressive/detail/detail_fwd.hpp	/^    typedef static_xpression<alternate_end_matcher, no_next> alternate_end_xpression;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::alternate_matcher	xpressive/detail/core/matcher/alternate_matcher.hpp	/^    struct alternate_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::alternate_matcher::alternate_matcher	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        explicit alternate_matcher(Alternates const &alternates = Alternates())$/;"	f	struct:boost::xpressive::detail::alternate_matcher	access:public	signature:(Alternates const &alternates = Alternates())
boost::xpressive::detail::alternate_matcher::alternates_	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        Alternates alternates_;$/;"	m	struct:boost::xpressive::detail::alternate_matcher	access:public
boost::xpressive::detail::alternate_matcher::alternates_type	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        typedef Alternates alternates_type;$/;"	t	struct:boost::xpressive::detail::alternate_matcher	access:public
boost::xpressive::detail::alternate_matcher::bset_	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        mutable hash_peek_bitset<char_type> bset_;$/;"	m	struct:boost::xpressive::detail::alternate_matcher	access:public
boost::xpressive::detail::alternate_matcher::can_match_	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        bool can_match_(char_type ch, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::alternate_matcher	access:private	signature:(char_type ch, Traits const &tr) const
boost::xpressive::detail::alternate_matcher::char_type	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::alternate_matcher	access:public
boost::xpressive::detail::alternate_matcher::get_width	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        detail::width get_width() const$/;"	f	struct:boost::xpressive::detail::alternate_matcher	access:public	signature:() const
boost::xpressive::detail::alternate_matcher::match	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::alternate_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::alternate_matcher::operator =	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        alternate_matcher &operator =(alternate_matcher const &);$/;"	p	struct:boost::xpressive::detail::alternate_matcher	access:private	signature:(alternate_matcher const &)
boost::xpressive::detail::alternates_list	xpressive/detail/static/transforms/as_alternate.hpp	/^        struct alternates_list$/;"	s	namespace:boost::xpressive::detail	inherits:fusion::cons
boost::xpressive::detail::alternates_list	xpressive/detail/static/transforms/as_alternate.hpp	/^        struct alternates_list<Head, fusion::nil>$/;"	s	namespace:boost::xpressive::detail	inherits:fusion::cons
boost::xpressive::detail::alternates_list::BOOST_STATIC_CONSTANT	xpressive/detail/static/transforms/as_alternate.hpp	/^            BOOST_STATIC_CONSTANT(bool, pure = Head::pure && Tail::pure);$/;"	p	struct:boost::xpressive::detail::alternates_list	access:public	signature:(bool, pure = Head::pure && Tail::pure)
boost::xpressive::detail::alternates_list::BOOST_STATIC_CONSTANT	xpressive/detail/static/transforms/as_alternate.hpp	/^            BOOST_STATIC_CONSTANT(bool, pure = Head::pure);$/;"	p	struct:boost::xpressive::detail::alternates_list	access:public	signature:(bool, pure = Head::pure)
boost::xpressive::detail::alternates_list::BOOST_STATIC_CONSTANT	xpressive/detail/static/transforms/as_alternate.hpp	/^            BOOST_STATIC_CONSTANT(std::size_t, width = Head::width == Tail::width ? Head::width : detail::unknown_width::value);$/;"	p	struct:boost::xpressive::detail::alternates_list	access:public	signature:(std::size_t, width = Head::width == Tail::width ? Head::width : detail::unknown_width::value)
boost::xpressive::detail::alternates_list::BOOST_STATIC_CONSTANT	xpressive/detail/static/transforms/as_alternate.hpp	/^            BOOST_STATIC_CONSTANT(std::size_t, width = Head::width);$/;"	p	struct:boost::xpressive::detail::alternates_list	access:public	signature:(std::size_t, width = Head::width)
boost::xpressive::detail::alternates_list::alternates_list	xpressive/detail/static/transforms/as_alternate.hpp	/^            alternates_list(Head const &head, Tail const &tail)$/;"	f	struct:boost::xpressive::detail::alternates_list	access:public	signature:(Head const &head, Tail const &tail)
boost::xpressive::detail::alternates_list::alternates_list	xpressive/detail/static/transforms/as_alternate.hpp	/^            alternates_list(Head const &head, fusion::nil const &tail)$/;"	f	struct:boost::xpressive::detail::alternates_list	access:public	signature:(Head const &head, fusion::nil const &tail)
boost::xpressive::detail::alternates_vector	xpressive/detail/dynamic/dynamic.hpp	/^struct alternates_vector$/;"	s	namespace:boost::xpressive::detail	inherits:std::vector
boost::xpressive::detail::alternates_vector::BOOST_STATIC_CONSTANT	xpressive/detail/dynamic/dynamic.hpp	/^    BOOST_STATIC_CONSTANT(bool, pure = false);$/;"	p	struct:boost::xpressive::detail::alternates_vector	access:public	signature:(bool, pure = false)
boost::xpressive::detail::alternates_vector::BOOST_STATIC_CONSTANT	xpressive/detail/dynamic/dynamic.hpp	/^    BOOST_STATIC_CONSTANT(std::size_t, width = unknown_width::value);$/;"	p	struct:boost::xpressive::detail::alternates_vector	access:public	signature:(std::size_t, width = unknown_width::value)
boost::xpressive::detail::any	xpressive/detail/utility/algorithm.hpp	/^inline bool any(InIter begin, InIter end, Pred pred)$/;"	f	namespace:boost::xpressive::detail	signature:(InIter begin, InIter end, Pred pred)
boost::xpressive::detail::any_dxpr	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    typedef matcher_wrapper<any_matcher> any_dxpr;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::any_matcher	xpressive/detail/core/matcher/any_matcher.hpp	/^    struct any_matcher$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::any_matcher::match	xpressive/detail/core/matcher/any_matcher.hpp	/^        static bool match(match_state<BidiIter> &state, Next const &next)$/;"	f	struct:boost::xpressive::detail::any_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next)
boost::xpressive::detail::any_sxpr	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    typedef static_xpression<any_matcher, true_xpression> any_sxpr;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::any_type	xpressive/match_results.hpp	/^struct any_type { any_type(...); };$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::any_type::any_type	xpressive/match_results.hpp	/^struct any_type { any_type(...); };$/;"	p	struct:boost::xpressive::detail::any_type	access:public	signature:(....)
boost::xpressive::detail::as_callable	xpressive/match_results.hpp	/^as_callable(T const &t)$/;"	f	namespace:boost::xpressive::detail	signature:(T const &t)
boost::xpressive::detail::assert_bol_matcher	xpressive/detail/core/matcher/assert_bol_matcher.hpp	/^    struct assert_bol_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:assert_line_base
boost::xpressive::detail::assert_bol_matcher::assert_bol_matcher	xpressive/detail/core/matcher/assert_bol_matcher.hpp	/^        assert_bol_matcher(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::assert_bol_matcher	access:public	signature:(Traits const &tr)
boost::xpressive::detail::assert_bol_matcher::char_type	xpressive/detail/core/matcher/assert_bol_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::assert_bol_matcher	access:public
boost::xpressive::detail::assert_bol_matcher::match	xpressive/detail/core/matcher/assert_bol_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::assert_bol_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::assert_bol_placeholder	xpressive/detail/static/placeholders.hpp	/^struct assert_bol_placeholder$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::assert_bos_matcher	xpressive/detail/core/matcher/assert_bos_matcher.hpp	/^    struct assert_bos_matcher$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::assert_bos_matcher::match	xpressive/detail/core/matcher/assert_bos_matcher.hpp	/^        static bool match(match_state<BidiIter> &state, Next const &next)$/;"	f	struct:boost::xpressive::detail::assert_bos_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next)
boost::xpressive::detail::assert_eol_matcher	xpressive/detail/core/matcher/assert_eol_matcher.hpp	/^    struct assert_eol_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:assert_line_base
boost::xpressive::detail::assert_eol_matcher::assert_eol_matcher	xpressive/detail/core/matcher/assert_eol_matcher.hpp	/^        assert_eol_matcher(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::assert_eol_matcher	access:public	signature:(Traits const &tr)
boost::xpressive::detail::assert_eol_matcher::char_type	xpressive/detail/core/matcher/assert_eol_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::assert_eol_matcher	access:public
boost::xpressive::detail::assert_eol_matcher::match	xpressive/detail/core/matcher/assert_eol_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::assert_eol_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::assert_eol_placeholder	xpressive/detail/static/placeholders.hpp	/^struct assert_eol_placeholder$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::assert_eos_matcher	xpressive/detail/core/matcher/assert_eos_matcher.hpp	/^    struct assert_eos_matcher$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::assert_eos_matcher::match	xpressive/detail/core/matcher/assert_eos_matcher.hpp	/^        static bool match(match_state<BidiIter> &state, Next const &next)$/;"	f	struct:boost::xpressive::detail::assert_eos_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next)
boost::xpressive::detail::assert_line_base	xpressive/detail/core/matcher/assert_line_base.hpp	/^    struct assert_line_base$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_assertion
boost::xpressive::detail::assert_line_base::assert_line_base	xpressive/detail/core/matcher/assert_line_base.hpp	/^        assert_line_base(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::assert_line_base	access:protected	signature:(Traits const &tr)
boost::xpressive::detail::assert_line_base::char_class_type	xpressive/detail/core/matcher/assert_line_base.hpp	/^        typedef typename Traits::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::detail::assert_line_base	access:public
boost::xpressive::detail::assert_line_base::char_type	xpressive/detail/core/matcher/assert_line_base.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::assert_line_base	access:public
boost::xpressive::detail::assert_line_base::cr_	xpressive/detail/core/matcher/assert_line_base.hpp	/^        char_type nl_, cr_;$/;"	m	struct:boost::xpressive::detail::assert_line_base	access:protected
boost::xpressive::detail::assert_line_base::newline_	xpressive/detail/core/matcher/assert_line_base.hpp	/^        char_class_type newline_;$/;"	m	struct:boost::xpressive::detail::assert_line_base	access:protected
boost::xpressive::detail::assert_line_base::nl_	xpressive/detail/core/matcher/assert_line_base.hpp	/^        char_type nl_, cr_;$/;"	m	struct:boost::xpressive::detail::assert_line_base	access:protected
boost::xpressive::detail::assert_word_begin	xpressive/regex_primitives.hpp	/^    typedef assert_word_placeholder<word_begin> assert_word_begin;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::assert_word_boundary	xpressive/regex_primitives.hpp	/^    typedef assert_word_placeholder<word_boundary<mpl::true_> > assert_word_boundary;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::assert_word_end	xpressive/regex_primitives.hpp	/^    typedef assert_word_placeholder<word_end> assert_word_end;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::assert_word_matcher	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^    struct assert_word_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_assertion
boost::xpressive::detail::assert_word_matcher::assert_word_matcher	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        assert_word_matcher(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::assert_word_matcher	access:public	signature:(Traits const &tr)
boost::xpressive::detail::assert_word_matcher::assert_word_matcher	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        assert_word_matcher(char_class_type word)$/;"	f	struct:boost::xpressive::detail::assert_word_matcher	access:public	signature:(char_class_type word)
boost::xpressive::detail::assert_word_matcher::char_class_type	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        typedef typename Traits::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::detail::assert_word_matcher	access:public
boost::xpressive::detail::assert_word_matcher::char_type	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::assert_word_matcher	access:public
boost::xpressive::detail::assert_word_matcher::is_word	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        bool is_word(Traits const &tr, char_type ch) const$/;"	f	struct:boost::xpressive::detail::assert_word_matcher	access:public	signature:(Traits const &tr, char_type ch) const
boost::xpressive::detail::assert_word_matcher::match	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::assert_word_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::assert_word_matcher::word	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        char_class_type word() const$/;"	f	struct:boost::xpressive::detail::assert_word_matcher	access:public	signature:() const
boost::xpressive::detail::assert_word_matcher::word_	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        char_class_type word_;$/;"	m	struct:boost::xpressive::detail::assert_word_matcher	access:private
boost::xpressive::detail::assert_word_placeholder	xpressive/detail/static/placeholders.hpp	/^struct assert_word_placeholder$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::attr_begin_matcher	xpressive/detail/core/matcher/attr_begin_matcher.hpp	/^    struct attr_begin_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::attr_begin_matcher::match	xpressive/detail/core/matcher/attr_begin_matcher.hpp	/^        static bool match(match_state<BidiIter> &state, Next const &next)$/;"	f	struct:boost::xpressive::detail::attr_begin_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next)
boost::xpressive::detail::attr_context	xpressive/detail/core/state.hpp	/^struct attr_context$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::attr_context::attr_slots_	xpressive/detail/core/state.hpp	/^    void const **attr_slots_;$/;"	m	struct:boost::xpressive::detail::attr_context	access:public
boost::xpressive::detail::attr_context::prev_attr_context_	xpressive/detail/core/state.hpp	/^    attr_context *prev_attr_context_;$/;"	m	struct:boost::xpressive::detail::attr_context	access:public
boost::xpressive::detail::attr_end_matcher	xpressive/detail/core/matcher/attr_end_matcher.hpp	/^    struct attr_end_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::attr_end_matcher::match	xpressive/detail/core/matcher/attr_end_matcher.hpp	/^        static bool match(match_state<BidiIter> &state, Next const &next)$/;"	f	struct:boost::xpressive::detail::attr_end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next)
boost::xpressive::detail::attr_matcher	xpressive/detail/core/matcher/attr_matcher.hpp	/^    struct attr_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::attr_matcher::Matcher::value_type::result_type	xpressive/detail/core/matcher/attr_matcher.hpp	/^        typedef typename Matcher::value_type::second_type const* result_type;$/;"	t	class:boost::xpressive::detail::attr_matcher::Matcher::value_type	access:public
boost::xpressive::detail::attr_matcher::attr_matcher	xpressive/detail/core/matcher/attr_matcher.hpp	/^        attr_matcher(int slot, Matcher const &matcher, Traits const& tr)$/;"	f	struct:boost::xpressive::detail::attr_matcher	access:public	signature:(int slot, Matcher const &matcher, Traits const& tr)
boost::xpressive::detail::attr_matcher::match	xpressive/detail/core/matcher/attr_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::attr_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::attr_matcher::slot_	xpressive/detail/core/matcher/attr_matcher.hpp	/^        int slot_;$/;"	m	struct:boost::xpressive::detail::attr_matcher	access:public
boost::xpressive::detail::attr_matcher::sym_	xpressive/detail/core/matcher/attr_matcher.hpp	/^        boost::xpressive::detail::symbols<Matcher> sym_;$/;"	m	struct:boost::xpressive::detail::attr_matcher	access:public
boost::xpressive::detail::attr_transform	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct attr_transform : proto::transform<attr_transform>$/;"	s	namespace:boost::xpressive::detail	inherits:proto::transform
boost::xpressive::detail::attr_transform::impl	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::detail::attr_transform	inherits:proto::transform_impl	access:public
boost::xpressive::detail::attr_transform::impl::attr_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            attr_type;$/;"	t	struct:boost::xpressive::detail::attr_transform::impl	access:public
boost::xpressive::detail::attr_transform::impl::expr_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::detail::attr_transform::impl	access:public
boost::xpressive::detail::attr_transform::impl::operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::detail::attr_transform::impl	access:public	signature:( typename impl::expr_param , typename impl::state_param state , typename impl::data_param ) const
boost::xpressive::detail::attr_transform::impl::result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::detail::attr_transform::impl	access:public
boost::xpressive::detail::attr_with_default_tag	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct attr_with_default_tag$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::attr_with_default_transform	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct attr_with_default_transform : proto::transform<attr_with_default_transform<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::detail	inherits:proto::transform
boost::xpressive::detail::attr_with_default_transform::impl	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::detail::attr_with_default_transform	inherits:proto::transform_impl	access:public
boost::xpressive::detail::attr_with_default_transform::impl::operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::detail::attr_with_default_transform::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
boost::xpressive::detail::attr_with_default_transform::impl::result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::detail::attr_with_default_transform::impl	access:public
boost::xpressive::detail::attribute_placeholder	xpressive/detail/static/placeholders.hpp	/^struct attribute_placeholder$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::attribute_placeholder::nbr	xpressive/detail/static/placeholders.hpp	/^    static Nbr nbr() { return Nbr(); }$/;"	f	struct:boost::xpressive::detail::attribute_placeholder	access:public	signature:()
boost::xpressive::detail::attribute_placeholder::nbr_type	xpressive/detail/static/placeholders.hpp	/^    typedef Nbr nbr_type;$/;"	t	struct:boost::xpressive::detail::attribute_placeholder	access:public
boost::xpressive::detail::basic_chset	xpressive/detail/utility/chset/basic_chset.hpp	/^struct basic_chset$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::basic_chset	xpressive/detail/utility/chset/basic_chset.hpp	/^struct basic_chset<char>$/;"	s	namespace:boost::xpressive::detail	inherits:basic_chset_8bit
boost::xpressive::detail::basic_chset	xpressive/detail/utility/chset/basic_chset.hpp	/^struct basic_chset<signed char>$/;"	s	namespace:boost::xpressive::detail	inherits:basic_chset_8bit
boost::xpressive::detail::basic_chset	xpressive/detail/utility/chset/basic_chset.hpp	/^struct basic_chset<unsigned char>$/;"	s	namespace:boost::xpressive::detail	inherits:basic_chset_8bit
boost::xpressive::detail::basic_chset::basic_chset	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset();$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:()
boost::xpressive::detail::basic_chset::basic_chset	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset(basic_chset const &arg);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(basic_chset const &arg)
boost::xpressive::detail::basic_chset::clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear();$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:()
boost::xpressive::detail::basic_chset::clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char c);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char c)
boost::xpressive::detail::basic_chset::clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char c, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char c, Traits const &tr)
boost::xpressive::detail::basic_chset::clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char from, Char to);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char from, Char to)
boost::xpressive::detail::basic_chset::clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char from, Char to, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char from, Char to, Traits const &tr)
boost::xpressive::detail::basic_chset::empty	xpressive/detail/utility/chset/basic_chset.hpp	/^    bool empty() const;$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:() const
boost::xpressive::detail::basic_chset::inverse	xpressive/detail/utility/chset/basic_chset.hpp	/^    void inverse();$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:()
boost::xpressive::detail::basic_chset::operator &=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset &operator &=(basic_chset const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(basic_chset const &x)
boost::xpressive::detail::basic_chset::operator -=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset &operator -=(basic_chset const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(basic_chset const &x)
boost::xpressive::detail::basic_chset::operator ^=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset &operator ^=(basic_chset const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(basic_chset const &x)
boost::xpressive::detail::basic_chset::operator |=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset &operator |=(basic_chset const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(basic_chset const &x)
boost::xpressive::detail::basic_chset::rr_	xpressive/detail/utility/chset/basic_chset.hpp	/^    range_run<Char> rr_;$/;"	m	struct:boost::xpressive::detail::basic_chset	access:private
boost::xpressive::detail::basic_chset::set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char c);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char c)
boost::xpressive::detail::basic_chset::set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char c, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char c, Traits const &tr)
boost::xpressive::detail::basic_chset::set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char from, Char to);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char from, Char to)
boost::xpressive::detail::basic_chset::set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char from, Char to, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char from, Char to, Traits const &tr)
boost::xpressive::detail::basic_chset::swap	xpressive/detail/utility/chset/basic_chset.hpp	/^    void swap(basic_chset& x);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(basic_chset& x)
boost::xpressive::detail::basic_chset::test	xpressive/detail/utility/chset/basic_chset.hpp	/^    bool test(Char v, Traits const &tr, mpl::false_) const; \/\/ case-sensitive$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char v, Traits const &tr, mpl::false_) const
boost::xpressive::detail::basic_chset::test	xpressive/detail/utility/chset/basic_chset.hpp	/^    bool test(Char v, Traits const &tr, mpl::true_) const; \/\/ case-insensitive$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char v, Traits const &tr, mpl::true_) const
boost::xpressive::detail::basic_chset_8bit	xpressive/detail/utility/chset/basic_chset.hpp	/^struct basic_chset_8bit$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::basic_chset_8bit::basic_chset_8bit	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset_8bit();$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:()
boost::xpressive::detail::basic_chset_8bit::basic_chset_8bit	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset_8bit(basic_chset_8bit const &arg);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(basic_chset_8bit const &arg)
boost::xpressive::detail::basic_chset_8bit::bset_	xpressive/detail/utility/chset/basic_chset.hpp	/^    std::bitset<256> bset_; \/\/ BUGBUG range-checking slows this down$/;"	m	struct:boost::xpressive::detail::basic_chset_8bit	access:private
boost::xpressive::detail::basic_chset_8bit::clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear();$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:()
boost::xpressive::detail::basic_chset_8bit::clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char c);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char c)
boost::xpressive::detail::basic_chset_8bit::clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char c, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char c, Traits const &tr)
boost::xpressive::detail::basic_chset_8bit::clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char from, Char to);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char from, Char to)
boost::xpressive::detail::basic_chset_8bit::clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char from, Char to, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char from, Char to, Traits const &tr)
boost::xpressive::detail::basic_chset_8bit::empty	xpressive/detail/utility/chset/basic_chset.hpp	/^    bool empty() const;$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:() const
boost::xpressive::detail::basic_chset_8bit::inverse	xpressive/detail/utility/chset/basic_chset.hpp	/^    void inverse();$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:()
boost::xpressive::detail::basic_chset_8bit::operator &=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset_8bit &operator &=(basic_chset_8bit const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(basic_chset_8bit const &x)
boost::xpressive::detail::basic_chset_8bit::operator -=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset_8bit &operator -=(basic_chset_8bit const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(basic_chset_8bit const &x)
boost::xpressive::detail::basic_chset_8bit::operator ^=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset_8bit &operator ^=(basic_chset_8bit const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(basic_chset_8bit const &x)
boost::xpressive::detail::basic_chset_8bit::operator |=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset_8bit &operator |=(basic_chset_8bit const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(basic_chset_8bit const &x)
boost::xpressive::detail::basic_chset_8bit::set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char c);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char c)
boost::xpressive::detail::basic_chset_8bit::set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char c, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char c, Traits const &tr)
boost::xpressive::detail::basic_chset_8bit::set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char from, Char to);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char from, Char to)
boost::xpressive::detail::basic_chset_8bit::set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char from, Char to, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char from, Char to, Traits const &tr)
boost::xpressive::detail::basic_chset_8bit::std::base	xpressive/detail/utility/chset/basic_chset.hpp	/^    std::bitset<256> const &base() const;$/;"	p	class:boost::xpressive::detail::basic_chset_8bit::std	access:public	signature:() const
boost::xpressive::detail::basic_chset_8bit::swap	xpressive/detail/utility/chset/basic_chset.hpp	/^    void swap(basic_chset_8bit& x);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(basic_chset_8bit& x)
boost::xpressive::detail::basic_chset_8bit::test	xpressive/detail/utility/chset/basic_chset.hpp	/^    bool test(Char v, Traits const &tr, mpl::false_) const; \/\/ case-sensitive$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char v, Traits const &tr, mpl::false_) const
boost::xpressive::detail::basic_chset_8bit::test	xpressive/detail/utility/chset/basic_chset.hpp	/^    bool test(Char v, Traits const &tr, mpl::true_) const; \/\/ case-insensitive$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char v, Traits const &tr, mpl::true_) const
boost::xpressive::detail::basic_mark_tag	xpressive/xpressive_fwd.hpp	/^        typedef proto::expr<proto::tag::terminal, proto::term<mark_placeholder>, 0> basic_mark_tag;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::begin	xpressive/regex_algorithms.hpp	/^        BOOST_XPR_NONDEDUCED_TYPE_(BidiIter) begin$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::binary_type	xpressive/match_results.hpp	/^typedef char (&binary_type)[3];$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::bind_args	xpressive/detail/detail_fwd.hpp	/^    void bind_args(let_<Args> const &, match_results<BidiIter> &);$/;"	p	namespace:boost::xpressive::detail	signature:(let_<Args> const &, match_results<BidiIter> &)
boost::xpressive::detail::bind_args	xpressive/regex_actions.hpp	/^        void bind_args(let_<Args> const &args, match_results<BidiIter> &what)$/;"	f	namespace:boost::xpressive::detail	signature:(let_<Args> const &args, match_results<BidiIter> &what)
boost::xpressive::detail::boost::char_literal::value	xpressive/detail/utility/literals.hpp	/^boost::intmax_t const char_literal<Char, Ch, Ch>::value;$/;"	m	class:boost::xpressive::detail::boost::char_literal
boost::xpressive::detail::boyer_moore	xpressive/detail/utility/boyer_moore.hpp	/^struct boyer_moore$/;"	s	namespace:boost::xpressive::detail	inherits:noncopyable
boost::xpressive::detail::boyer_moore::begin_	xpressive/detail/utility/boyer_moore.hpp	/^    char_type const *begin_;$/;"	m	struct:boost::xpressive::detail::boyer_moore	access:private
boost::xpressive::detail::boyer_moore::boyer_moore	xpressive/detail/utility/boyer_moore.hpp	/^    boyer_moore(char_type const *begin, char_type const *end, Traits const &tr, bool icase)$/;"	f	struct:boost::xpressive::detail::boyer_moore	access:public	signature:(char_type const *begin, char_type const *end, Traits const &tr, bool icase)
boost::xpressive::detail::boyer_moore::case_fold	xpressive/detail/utility/boyer_moore.hpp	/^    typedef has_fold_case<Traits> case_fold;$/;"	t	struct:boost::xpressive::detail::boyer_moore	access:public
boost::xpressive::detail::boyer_moore::char_type	xpressive/detail/utility/boyer_moore.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::boyer_moore	access:public
boost::xpressive::detail::boyer_moore::find	xpressive/detail/utility/boyer_moore.hpp	/^    BidiIter find(BidiIter begin, BidiIter end, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::boyer_moore	access:public	signature:(BidiIter begin, BidiIter end, Traits const &tr) const
boost::xpressive::detail::boyer_moore::find_	xpressive/detail/utility/boyer_moore.hpp	/^    BidiIter find_(BidiIter begin, BidiIter end, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::boyer_moore	access:private	signature:(BidiIter begin, BidiIter end, Traits const &tr) const
boost::xpressive::detail::boyer_moore::find_fun_	xpressive/detail/utility/boyer_moore.hpp	/^    BidiIter (boyer_moore::*const find_fun_)(BidiIter, BidiIter, Traits const &) const;$/;"	m	struct:boost::xpressive::detail::boyer_moore	access:private
boost::xpressive::detail::boyer_moore::find_nocase_	xpressive/detail/utility/boyer_moore.hpp	/^    BidiIter find_nocase_(BidiIter begin, BidiIter end, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::boyer_moore	access:private	signature:(BidiIter begin, BidiIter end, Traits const &tr) const
boost::xpressive::detail::boyer_moore::find_nocase_fold_	xpressive/detail/utility/boyer_moore.hpp	/^    BidiIter find_nocase_fold_(BidiIter begin, BidiIter end, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::boyer_moore	access:private	signature:(BidiIter begin, BidiIter end, Traits const &tr) const
boost::xpressive::detail::boyer_moore::fold_	xpressive/detail/utility/boyer_moore.hpp	/^    std::vector<string_type> fold_;$/;"	m	struct:boost::xpressive::detail::boyer_moore	access:private
boost::xpressive::detail::boyer_moore::init_	xpressive/detail/utility/boyer_moore.hpp	/^    void init_(Traits const &tr, mpl::false_)$/;"	f	struct:boost::xpressive::detail::boyer_moore	access:private	signature:(Traits const &tr, mpl::false_)
boost::xpressive::detail::boyer_moore::init_	xpressive/detail/utility/boyer_moore.hpp	/^    void init_(Traits const &tr, mpl::true_)$/;"	f	struct:boost::xpressive::detail::boyer_moore	access:private	signature:(Traits const &tr, mpl::true_)
boost::xpressive::detail::boyer_moore::last_	xpressive/detail/utility/boyer_moore.hpp	/^    char_type const *last_;$/;"	m	struct:boost::xpressive::detail::boyer_moore	access:private
boost::xpressive::detail::boyer_moore::length_	xpressive/detail/utility/boyer_moore.hpp	/^    unsigned char length_;$/;"	m	struct:boost::xpressive::detail::boyer_moore	access:private
boost::xpressive::detail::boyer_moore::offsets_	xpressive/detail/utility/boyer_moore.hpp	/^    unsigned char offsets_[UCHAR_MAX + 1];$/;"	m	struct:boost::xpressive::detail::boyer_moore	access:private
boost::xpressive::detail::boyer_moore::string_type	xpressive/detail/utility/boyer_moore.hpp	/^    typedef typename Traits::string_type string_type;$/;"	t	struct:boost::xpressive::detail::boyer_moore	access:public
boost::xpressive::detail::boyer_moore::traits_type	xpressive/detail/utility/boyer_moore.hpp	/^    typedef Traits traits_type;$/;"	t	struct:boost::xpressive::detail::boyer_moore	access:public
boost::xpressive::detail::boyer_moore_finder	xpressive/detail/core/finder.hpp	/^struct boyer_moore_finder$/;"	s	namespace:boost::xpressive::detail	inherits:finder
boost::xpressive::detail::boyer_moore_finder::bm_	xpressive/detail/core/finder.hpp	/^    boyer_moore<BidiIter, Traits> bm_;$/;"	m	struct:boost::xpressive::detail::boyer_moore_finder	access:private
boost::xpressive::detail::boyer_moore_finder::boyer_moore_finder	xpressive/detail/core/finder.hpp	/^    boyer_moore_finder(boyer_moore_finder const &);$/;"	p	struct:boost::xpressive::detail::boyer_moore_finder	access:private	signature:(boyer_moore_finder const &)
boost::xpressive::detail::boyer_moore_finder::boyer_moore_finder	xpressive/detail/core/finder.hpp	/^    boyer_moore_finder(char_type const *begin, char_type const *end, Traits const &tr, bool icase)$/;"	f	struct:boost::xpressive::detail::boyer_moore_finder	access:public	signature:(char_type const *begin, char_type const *end, Traits const &tr, bool icase)
boost::xpressive::detail::boyer_moore_finder::char_type	xpressive/detail/core/finder.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::boyer_moore_finder	access:public
boost::xpressive::detail::boyer_moore_finder::ok_for_partial_matches	xpressive/detail/core/finder.hpp	/^    bool ok_for_partial_matches() const$/;"	f	struct:boost::xpressive::detail::boyer_moore_finder	access:public	signature:() const
boost::xpressive::detail::boyer_moore_finder::operator ()	xpressive/detail/core/finder.hpp	/^    bool operator ()(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::boyer_moore_finder	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::boyer_moore_finder::operator =	xpressive/detail/core/finder.hpp	/^    boyer_moore_finder &operator =(boyer_moore_finder const &);$/;"	p	struct:boost::xpressive::detail::boyer_moore_finder	access:private	signature:(boyer_moore_finder const &)
boost::xpressive::detail::by_ref_transform	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct by_ref_transform : proto::transform<by_ref_transform>$/;"	s	namespace:boost::xpressive::detail	inherits:proto::transform
boost::xpressive::detail::by_ref_transform::impl	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::detail::by_ref_transform	inherits:proto::transform_impl	access:public
boost::xpressive::detail::by_ref_transform::impl::operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::detail::by_ref_transform::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param ) const
boost::xpressive::detail::by_ref_transform::impl::reference	xpressive/detail/core/matcher/action_matcher.hpp	/^            reference;$/;"	t	struct:boost::xpressive::detail::by_ref_transform::impl	access:public
boost::xpressive::detail::by_ref_transform::impl::result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::detail::by_ref_transform::impl	access:public
boost::xpressive::detail::c_regex_traits_base	xpressive/traits/c_regex_traits.hpp	/^    struct c_regex_traits_base$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::c_regex_traits_base	xpressive/traits/c_regex_traits.hpp	/^    struct c_regex_traits_base<Char, 1>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::c_regex_traits_base	xpressive/traits/c_regex_traits.hpp	/^    struct c_regex_traits_base<wchar_t, SizeOfChar>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::c_regex_traits_base::imbue	xpressive/traits/c_regex_traits.hpp	/^        static void imbue(Traits const &)$/;"	f	struct:boost::xpressive::detail::c_regex_traits_base	access:protected	signature:(Traits const &)
boost::xpressive::detail::c_regex_traits_base::imbue	xpressive/traits/c_regex_traits.hpp	/^        void imbue(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::c_regex_traits_base	access:protected	signature:(Traits const &tr)
boost::xpressive::detail::c_tolower	xpressive/traits/c_regex_traits.hpp	/^    Char c_tolower(Char);$/;"	p	namespace:boost::xpressive::detail	signature:(Char)
boost::xpressive::detail::c_tolower	xpressive/traits/c_regex_traits.hpp	/^    inline char c_tolower(char ch)$/;"	f	namespace:boost::xpressive::detail	signature:(char ch)
boost::xpressive::detail::c_tolower	xpressive/traits/c_regex_traits.hpp	/^    inline wchar_t c_tolower(wchar_t ch)$/;"	f	namespace:boost::xpressive::detail	signature:(wchar_t ch)
boost::xpressive::detail::c_toupper	xpressive/traits/c_regex_traits.hpp	/^    Char c_toupper(Char);$/;"	p	namespace:boost::xpressive::detail	signature:(Char)
boost::xpressive::detail::c_toupper	xpressive/traits/c_regex_traits.hpp	/^    inline char c_toupper(char ch)$/;"	f	namespace:boost::xpressive::detail	signature:(char ch)
boost::xpressive::detail::c_toupper	xpressive/traits/c_regex_traits.hpp	/^    inline wchar_t c_toupper(wchar_t ch)$/;"	f	namespace:boost::xpressive::detail	signature:(wchar_t ch)
boost::xpressive::detail::case_converting_iterator	xpressive/match_results.hpp	/^struct case_converting_iterator$/;"	s	namespace:boost::xpressive::detail	inherits:std::iterator
boost::xpressive::detail::case_converting_iterator::base	xpressive/match_results.hpp	/^    OutputIterator base() const$/;"	f	struct:boost::xpressive::detail::case_converting_iterator	access:public	signature:() const
boost::xpressive::detail::case_converting_iterator::case_converting_iterator	xpressive/match_results.hpp	/^    case_converting_iterator(OutputIterator const &out, traits<Char> const *tr)$/;"	f	struct:boost::xpressive::detail::case_converting_iterator	access:public	signature:(OutputIterator const &out, traits<Char> const *tr)
boost::xpressive::detail::case_converting_iterator::next_	xpressive/match_results.hpp	/^    transform_op next_, rest_;$/;"	m	struct:boost::xpressive::detail::case_converting_iterator	access:private
boost::xpressive::detail::case_converting_iterator::operator *	xpressive/match_results.hpp	/^    case_converting_iterator &operator *()$/;"	f	struct:boost::xpressive::detail::case_converting_iterator	access:public	signature:()
boost::xpressive::detail::case_converting_iterator::operator ++	xpressive/match_results.hpp	/^    case_converting_iterator &operator ++()$/;"	f	struct:boost::xpressive::detail::case_converting_iterator	access:public	signature:()
boost::xpressive::detail::case_converting_iterator::operator ++	xpressive/match_results.hpp	/^    case_converting_iterator operator ++(int)$/;"	f	struct:boost::xpressive::detail::case_converting_iterator	access:public	signature:(int)
boost::xpressive::detail::case_converting_iterator::operator =	xpressive/match_results.hpp	/^    case_converting_iterator &operator =(Char ch)$/;"	f	struct:boost::xpressive::detail::case_converting_iterator	access:public	signature:(Char ch)
boost::xpressive::detail::case_converting_iterator::out_	xpressive/match_results.hpp	/^    OutputIterator out_;$/;"	m	struct:boost::xpressive::detail::case_converting_iterator	access:private
boost::xpressive::detail::case_converting_iterator::rest_	xpressive/match_results.hpp	/^    transform_op next_, rest_;$/;"	m	struct:boost::xpressive::detail::case_converting_iterator	access:private
boost::xpressive::detail::case_converting_iterator::set_transform	xpressive/match_results.hpp	/^    friend bool set_transform(case_converting_iterator &iter, transform_op trans, transform_scope scope)$/;"	f	struct:boost::xpressive::detail::case_converting_iterator	access:friend	signature:(case_converting_iterator &iter, transform_op trans, transform_scope scope)
boost::xpressive::detail::case_converting_iterator::traits_	xpressive/match_results.hpp	/^    traits<Char> const *traits_;$/;"	m	struct:boost::xpressive::detail::case_converting_iterator	access:private
boost::xpressive::detail::char_cast	xpressive/detail/utility/traits_utils.hpp	/^    char_cast(FromChar from, Traits const &, typename enable_if<is_same<ToChar, FromChar> >::type * = 0)$/;"	f	namespace:boost::xpressive::detail	signature:(FromChar from, Traits const &, typename enable_if<is_same<ToChar, FromChar> >::type * = 0)
boost::xpressive::detail::char_cast	xpressive/detail/utility/traits_utils.hpp	/^    char_cast(FromChar from, Traits const &tr, typename disable_if<is_same<ToChar, FromChar> >::type * = 0)$/;"	f	namespace:boost::xpressive::detail	signature:(FromChar from, Traits const &tr, typename disable_if<is_same<ToChar, FromChar> >::type * = 0)
boost::xpressive::detail::char_class_impl	xpressive/traits/detail/c_ctype.hpp	/^struct char_class_impl<char>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::char_class_impl	xpressive/traits/detail/c_ctype.hpp	/^struct char_class_impl<wchar_t>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_alpha         = 0x0002);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_alpha = 0x0002)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_blank         = 0x0004);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_blank = 0x0004)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_cntrl         = 0x0008);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_cntrl = 0x0008)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_digit         = 0x0010);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_digit = 0x0010)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_lower         = 0x0040);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_lower = 0x0040)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_newline       = 0x2000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_newline = 0x2000)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_newline = 01000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_newline = 01000)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_newline = 0x00020000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_newline = 0x00020000)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_newline = 0x2000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_newline = 0x2000)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_punct         = 0x0100);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_punct = 0x0100)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_space         = 0x0200);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_space = 0x0200)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_underscore    = 0x0800);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_underscore = 0x0800)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_underscore = 0400);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_underscore = 0400)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_underscore = 0x00010000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_underscore = 0x00010000)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_underscore = 0x1000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_underscore = 0x1000)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_upper         = 0x0400);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_upper = 0x0400)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(int, char_class_xdigit        = 0x1000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(int, char_class_xdigit = 0x1000)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(short, char_class_newline = 0x2000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(short, char_class_newline = 0x2000)
boost::xpressive::detail::char_class_impl::BOOST_STATIC_CONSTANT	xpressive/traits/detail/c_ctype.hpp	/^    BOOST_STATIC_CONSTANT(short, char_class_underscore = 0x1000);$/;"	p	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(short, char_class_underscore = 0x1000)
boost::xpressive::detail::char_class_impl::char_class_type	xpressive/traits/detail/c_ctype.hpp	/^    typedef int char_class_type;$/;"	t	struct:boost::xpressive::detail::char_class_impl	access:public
boost::xpressive::detail::char_class_impl::char_class_type	xpressive/traits/detail/c_ctype.hpp	/^    typedef short char_class_type;$/;"	t	struct:boost::xpressive::detail::char_class_impl	access:public
boost::xpressive::detail::char_class_impl::char_class_type	xpressive/traits/detail/c_ctype.hpp	/^    typedef wctype_t char_class_type;$/;"	t	struct:boost::xpressive::detail::char_class_impl	access:public
boost::xpressive::detail::char_class_impl::glibc_isctype	xpressive/traits/detail/c_ctype.hpp	/^    static bool glibc_isctype(char ch, char_class_type mask)$/;"	f	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(char ch, char_class_type mask)
boost::xpressive::detail::char_class_impl::isctype	xpressive/traits/detail/c_ctype.hpp	/^    static bool isctype(char ch, char_class_type mask)$/;"	f	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(char ch, char_class_type mask)
boost::xpressive::detail::char_class_impl::isctype	xpressive/traits/detail/c_ctype.hpp	/^    static bool isctype(wchar_t ch, char_class_type mask)$/;"	f	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(wchar_t ch, char_class_type mask)
boost::xpressive::detail::char_class_impl::lookup_classname	xpressive/traits/detail/c_ctype.hpp	/^    static char_class_type lookup_classname(FwdIter begin, FwdIter end, bool icase)$/;"	f	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(FwdIter begin, FwdIter end, bool icase)
boost::xpressive::detail::char_literal	xpressive/detail/utility/literals.hpp	/^struct char_literal<Char, Ch, Ch>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::char_literal::BOOST_STATIC_CONSTANT	xpressive/detail/utility/literals.hpp	/^    BOOST_STATIC_CONSTANT(boost::intmax_t, value = Ch);$/;"	p	struct:boost::xpressive::detail::char_literal	access:public	signature:(boost::intmax_t, value = Ch)
boost::xpressive::detail::char_overflow_handler	xpressive/detail/dynamic/parse_charset.hpp	/^struct char_overflow_handler$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::char_overflow_handler::operator ()	xpressive/detail/dynamic/parse_charset.hpp	/^    void operator ()(numeric::range_check_result result) const \/\/ throw(regex_error)$/;"	f	struct:boost::xpressive::detail::char_overflow_handler	access:public	signature:(numeric::range_check_result result) const
boost::xpressive::detail::char_overflow_handler_	xpressive/match_results.hpp	/^struct char_overflow_handler_$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::char_overflow_handler_::operator ()	xpressive/match_results.hpp	/^    void operator ()(numeric::range_check_result result) const \/\/ throw(regex_error)$/;"	f	struct:boost::xpressive::detail::char_overflow_handler_	access:public	signature:(numeric::range_check_result result) const
boost::xpressive::detail::char_sink	xpressive/detail/core/peeker.hpp	/^struct char_sink$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::char_sink::bset_	xpressive/detail/core/peeker.hpp	/^    hash_peek_bitset<char_type> &bset_;$/;"	m	struct:boost::xpressive::detail::char_sink	access:public
boost::xpressive::detail::char_sink::char_sink	xpressive/detail/core/peeker.hpp	/^    char_sink(hash_peek_bitset<char_type> &bset, Traits const &tr)$/;"	f	struct:boost::xpressive::detail::char_sink	access:public	signature:(hash_peek_bitset<char_type> &bset, Traits const &tr)
boost::xpressive::detail::char_sink::char_type	xpressive/detail/core/peeker.hpp	/^    typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::char_sink	access:public
boost::xpressive::detail::char_sink::operator ()	xpressive/detail/core/peeker.hpp	/^    void operator()(char_type ch) const$/;"	f	struct:boost::xpressive::detail::char_sink	access:public	signature:(char_type ch) const
boost::xpressive::detail::char_sink::operator =	xpressive/detail/core/peeker.hpp	/^    char_sink &operator =(char_sink const &);$/;"	p	struct:boost::xpressive::detail::char_sink	access:private	signature:(char_sink const &)
boost::xpressive::detail::char_sink::traits_	xpressive/detail/core/peeker.hpp	/^    Traits const &traits_;$/;"	m	struct:boost::xpressive::detail::char_sink	access:public
boost::xpressive::detail::char_translate	xpressive/detail/core/matcher/attr_matcher.hpp	/^    struct char_translate$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::char_translate	xpressive/detail/core/matcher/attr_matcher.hpp	/^    struct char_translate<Traits, true>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::char_translate::char_translate	xpressive/detail/core/matcher/attr_matcher.hpp	/^        explicit char_translate(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::char_translate	access:public	signature:(Traits const &tr)
boost::xpressive::detail::char_translate::char_type	xpressive/detail/core/matcher/attr_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::char_translate	access:public
boost::xpressive::detail::char_translate::operator ()	xpressive/detail/core/matcher/attr_matcher.hpp	/^        char_type operator ()(char_type ch1) const$/;"	f	struct:boost::xpressive::detail::char_translate	access:public	signature:(char_type ch1) const
boost::xpressive::detail::char_translate::operator =	xpressive/detail/core/matcher/attr_matcher.hpp	/^        char_translate &operator =(char_translate const &);$/;"	p	struct:boost::xpressive::detail::char_translate	access:private	signature:(char_translate const &)
boost::xpressive::detail::char_translate::traits_	xpressive/detail/core/matcher/attr_matcher.hpp	/^        Traits const &traits_;$/;"	m	struct:boost::xpressive::detail::char_translate	access:public
boost::xpressive::detail::charset_matcher	xpressive/detail/core/matcher/charset_matcher.hpp	/^    struct charset_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_fixed_width
boost::xpressive::detail::charset_matcher::char_type	xpressive/detail/core/matcher/charset_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::charset_matcher	access:public
boost::xpressive::detail::charset_matcher::charset_	xpressive/detail/core/matcher/charset_matcher.hpp	/^        CharSet charset_;$/;"	m	struct:boost::xpressive::detail::charset_matcher	access:public
boost::xpressive::detail::charset_matcher::charset_matcher	xpressive/detail/core/matcher/charset_matcher.hpp	/^        charset_matcher(CharSet const &charset = CharSet())$/;"	f	struct:boost::xpressive::detail::charset_matcher	access:public	signature:(CharSet const &charset = CharSet())
boost::xpressive::detail::charset_matcher::icase_type	xpressive/detail/core/matcher/charset_matcher.hpp	/^        typedef ICase icase_type;$/;"	t	struct:boost::xpressive::detail::charset_matcher	access:public
boost::xpressive::detail::charset_matcher::inverse	xpressive/detail/core/matcher/charset_matcher.hpp	/^        void inverse()$/;"	f	struct:boost::xpressive::detail::charset_matcher	access:public	signature:()
boost::xpressive::detail::charset_matcher::match	xpressive/detail/core/matcher/charset_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::charset_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::charset_matcher::traits_type	xpressive/detail/core/matcher/charset_matcher.hpp	/^        typedef Traits traits_type;$/;"	t	struct:boost::xpressive::detail::charset_matcher	access:public
boost::xpressive::detail::check_is_formatter	xpressive/match_results.hpp	/^binary_type check_is_formatter(T const &, U const &, ternary_type);$/;"	p	namespace:boost::xpressive::detail	signature:(T const &, U const &, ternary_type)
boost::xpressive::detail::check_is_formatter	xpressive/match_results.hpp	/^binary_type check_is_formatter(unary_type, T const &, ternary_type);$/;"	p	namespace:boost::xpressive::detail	signature:(unary_type, T const &, ternary_type)
boost::xpressive::detail::check_is_formatter	xpressive/match_results.hpp	/^no_type check_is_formatter(unary_type, binary_type, ternary_type);$/;"	p	namespace:boost::xpressive::detail	signature:(unary_type, binary_type, ternary_type)
boost::xpressive::detail::check_is_formatter	xpressive/match_results.hpp	/^ternary_type check_is_formatter(T const &, U const &, V const &);$/;"	p	namespace:boost::xpressive::detail	signature:(T const &, U const &, V const &)
boost::xpressive::detail::check_is_formatter	xpressive/match_results.hpp	/^ternary_type check_is_formatter(T const &, binary_type, U const &);$/;"	p	namespace:boost::xpressive::detail	signature:(T const &, binary_type, U const &)
boost::xpressive::detail::check_is_formatter	xpressive/match_results.hpp	/^ternary_type check_is_formatter(unary_type, T const &, U const &);$/;"	p	namespace:boost::xpressive::detail	signature:(unary_type, T const &, U const &)
boost::xpressive::detail::check_is_formatter	xpressive/match_results.hpp	/^ternary_type check_is_formatter(unary_type, binary_type, T const &);$/;"	p	namespace:boost::xpressive::detail	signature:(unary_type, binary_type, T const &)
boost::xpressive::detail::check_is_formatter	xpressive/match_results.hpp	/^unary_type check_is_formatter(T const &, binary_type, ternary_type);$/;"	p	namespace:boost::xpressive::detail	signature:(T const &, binary_type, ternary_type)
boost::xpressive::detail::check_tag	xpressive/regex_actions.hpp	/^        struct check_tag$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::child_	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct child_$/;"	s	namespace:boost::xpressive::detail	inherits:remove_reference
boost::xpressive::detail::classname_a	xpressive/traits/detail/c_ctype.hpp	/^inline std::string classname_a(FwdIter begin, FwdIter end)$/;"	f	namespace:boost::xpressive::detail	signature:(FwdIter begin, FwdIter end)
boost::xpressive::detail::classname_w	xpressive/traits/detail/c_ctype.hpp	/^inline std::wstring classname_w(FwdIter begin, FwdIter end)$/;"	f	namespace:boost::xpressive::detail	signature:(FwdIter begin, FwdIter end)
boost::xpressive::detail::common_compile	xpressive/detail/core/optimize.hpp	/^void common_compile$/;"	f	namespace:boost::xpressive::detail	signature:( intrusive_ptr<matchable_ex<BidiIter> const> const &regex , regex_impl<BidiIter> &impl , Traits const &tr )
boost::xpressive::detail::compound_charset	xpressive/detail/utility/chset/chset.hpp	/^struct compound_charset$/;"	s	namespace:boost::xpressive::detail	inherits:basic_chset
boost::xpressive::detail::compound_charset::base	xpressive/detail/utility/chset/chset.hpp	/^    basic_chset<char_type> const &base() const$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:() const
boost::xpressive::detail::compound_charset::base_type	xpressive/detail/utility/chset/chset.hpp	/^    typedef basic_chset<char_type> base_type;$/;"	t	struct:boost::xpressive::detail::compound_charset	access:public
boost::xpressive::detail::compound_charset::char_class_type	xpressive/detail/utility/chset/chset.hpp	/^    typedef typename Traits::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::detail::compound_charset	access:public
boost::xpressive::detail::compound_charset::char_type	xpressive/detail/utility/chset/chset.hpp	/^    typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::compound_charset	access:public
boost::xpressive::detail::compound_charset::complement_	xpressive/detail/utility/chset/chset.hpp	/^    bool complement_;$/;"	m	struct:boost::xpressive::detail::compound_charset	access:private
boost::xpressive::detail::compound_charset::compound_charset	xpressive/detail/utility/chset/chset.hpp	/^    compound_charset()$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:()
boost::xpressive::detail::compound_charset::has_posix_	xpressive/detail/utility/chset/chset.hpp	/^    bool has_posix_;$/;"	m	struct:boost::xpressive::detail::compound_charset	access:private
boost::xpressive::detail::compound_charset::inverse	xpressive/detail/utility/chset/chset.hpp	/^    void inverse()$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:()
boost::xpressive::detail::compound_charset::is_inverted	xpressive/detail/utility/chset/chset.hpp	/^    bool is_inverted() const$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:() const
boost::xpressive::detail::compound_charset::not_posix_pred	xpressive/detail/utility/chset/chset.hpp	/^    struct not_posix_pred$/;"	s	struct:boost::xpressive::detail::compound_charset	access:private
boost::xpressive::detail::compound_charset::not_posix_pred::ch_	xpressive/detail/utility/chset/chset.hpp	/^        char_type ch_;$/;"	m	struct:boost::xpressive::detail::compound_charset::not_posix_pred	access:public
boost::xpressive::detail::compound_charset::not_posix_pred::operator ()	xpressive/detail/utility/chset/chset.hpp	/^        bool operator ()(typename call_traits<char_class_type>::param_type m) const$/;"	f	struct:boost::xpressive::detail::compound_charset::not_posix_pred	access:public	signature:(typename call_traits<char_class_type>::param_type m) const
boost::xpressive::detail::compound_charset::not_posix_pred::traits_ptr_	xpressive/detail/utility/chset/chset.hpp	/^        Traits const *traits_ptr_;$/;"	m	struct:boost::xpressive::detail::compound_charset::not_posix_pred	access:public
boost::xpressive::detail::compound_charset::posix_no_	xpressive/detail/utility/chset/chset.hpp	/^    std::vector<char_class_type> posix_no_;$/;"	m	struct:boost::xpressive::detail::compound_charset	access:private
boost::xpressive::detail::compound_charset::posix_yes	xpressive/detail/utility/chset/chset.hpp	/^    char_class_type posix_yes() const$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:() const
boost::xpressive::detail::compound_charset::posix_yes_	xpressive/detail/utility/chset/chset.hpp	/^    char_class_type posix_yes_;$/;"	m	struct:boost::xpressive::detail::compound_charset	access:private
boost::xpressive::detail::compound_charset::set_char	xpressive/detail/utility/chset/chset.hpp	/^    void set_char(char_type ch, Traits const &tr, bool icase)$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:(char_type ch, Traits const &tr, bool icase)
boost::xpressive::detail::compound_charset::set_class	xpressive/detail/utility/chset/chset.hpp	/^    void set_class(char_class_type const &m, bool no)$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:(char_class_type const &m, bool no)
boost::xpressive::detail::compound_charset::set_range	xpressive/detail/utility/chset/chset.hpp	/^    void set_range(char_type from, char_type to, Traits const &tr, bool icase)$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:(char_type from, char_type to, Traits const &tr, bool icase)
boost::xpressive::detail::compound_charset::std::posix_no	xpressive/detail/utility/chset/chset.hpp	/^    std::vector<char_class_type> const &posix_no() const$/;"	f	class:boost::xpressive::detail::compound_charset::std	access:public	signature:() const
boost::xpressive::detail::compound_charset::test	xpressive/detail/utility/chset/chset.hpp	/^    bool test(char_type ch, Traits const &tr, ICase) const$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:(char_type ch, Traits const &tr, ICase) const
boost::xpressive::detail::compound_charset::test_posix	xpressive/detail/utility/chset/chset.hpp	/^    bool test_posix(char_type ch, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::compound_charset	access:private	signature:(char_type ch, Traits const &tr) const
boost::xpressive::detail::compound_charset::traits_type	xpressive/detail/utility/chset/chset.hpp	/^    typedef Traits traits_type;$/;"	t	struct:boost::xpressive::detail::compound_charset	access:public
boost::xpressive::detail::core_access	xpressive/detail/core/access.hpp	/^struct core_access$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::core_access::char_type	xpressive/detail/core/access.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::core_access	access:public
boost::xpressive::detail::core_access::get_action_args	xpressive/detail/core/access.hpp	/^    static action_args_type &get_action_args(match_results<BidiIter> &what)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what)
boost::xpressive::detail::core_access::get_base	xpressive/detail/core/access.hpp	/^    static BidiIter get_base(match_results<BidiIter> &what)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what)
boost::xpressive::detail::core_access::get_extras	xpressive/detail/core/access.hpp	/^    static results_extras<BidiIter> &get_extras(match_results<BidiIter> &what)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what)
boost::xpressive::detail::core_access::get_hidden_mark_count	xpressive/detail/core/access.hpp	/^    static std::size_t get_hidden_mark_count(basic_regex<BidiIter> const &rex)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(basic_regex<BidiIter> const &rex)
boost::xpressive::detail::core_access::get_nested_results	xpressive/detail/core/access.hpp	/^    static nested_results<BidiIter> &get_nested_results(match_results<BidiIter> &what)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what)
boost::xpressive::detail::core_access::get_regex_impl	xpressive/detail/core/access.hpp	/^    get_regex_impl(basic_regex<BidiIter> const &rex)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(basic_regex<BidiIter> const &rex)
boost::xpressive::detail::core_access::get_sub_match_vector	xpressive/detail/core/access.hpp	/^    static sub_match_vector<BidiIter> &get_sub_match_vector(match_results<BidiIter> &what)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what)
boost::xpressive::detail::core_access::get_sub_matches	xpressive/detail/core/access.hpp	/^    static sub_match_impl<BidiIter> *get_sub_matches(sub_match_vector<BidiIter> &subs)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(sub_match_vector<BidiIter> &subs)
boost::xpressive::detail::core_access::init_match_results	xpressive/detail/core/access.hpp	/^    static void init_match_results$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:( match_results<BidiIter> &what , regex_id_type regex_id , intrusive_ptr<traits<char_type> const> const &tr , sub_match_impl<BidiIter> *sub_matches , std::size_t size , std::vector<named_mark<char_type> > const &named_marks )
boost::xpressive::detail::core_access::init_sub_match_vector	xpressive/detail/core/access.hpp	/^    static void init_sub_match_vector$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:( sub_match_vector<BidiIter> &subs_vect , sub_match_impl<BidiIter> *subs_ptr , std::size_t size )
boost::xpressive::detail::core_access::init_sub_match_vector	xpressive/detail/core/access.hpp	/^    static void init_sub_match_vector$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:( sub_match_vector<BidiIter> &subs_vect , sub_match_impl<BidiIter> *subs_ptr , std::size_t size , sub_match_vector<BidiIter> const &that )
boost::xpressive::detail::core_access::match	xpressive/detail/core/access.hpp	/^    static bool match(basic_regex<BidiIter> const &rex, match_state<BidiIter> &state)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(basic_regex<BidiIter> const &rex, match_state<BidiIter> &state)
boost::xpressive::detail::core_access::reset	xpressive/detail/core/access.hpp	/^    static void reset(match_results<BidiIter> &what)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what)
boost::xpressive::detail::core_access::set_base	xpressive/detail/core/access.hpp	/^    static void set_base(match_results<BidiIter> &what, BidiIter base)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what, BidiIter base)
boost::xpressive::detail::core_access::set_prefix_suffix	xpressive/detail/core/access.hpp	/^    static void set_prefix_suffix(match_results<BidiIter> &what, BidiIter begin, BidiIter end)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what, BidiIter begin, BidiIter end)
boost::xpressive::detail::counted_base	xpressive/detail/utility/counted_base.hpp	/^    struct counted_base$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::counted_base::count_	xpressive/detail/utility/counted_base.hpp	/^        mutable boost::detail::atomic_count count_;$/;"	m	struct:boost::xpressive::detail::counted_base	access:private
boost::xpressive::detail::counted_base::counted_base	xpressive/detail/utility/counted_base.hpp	/^        counted_base()$/;"	f	struct:boost::xpressive::detail::counted_base	access:protected	signature:()
boost::xpressive::detail::counted_base::counted_base	xpressive/detail/utility/counted_base.hpp	/^        counted_base(counted_base<Derived> const &)$/;"	f	struct:boost::xpressive::detail::counted_base	access:protected	signature:(counted_base<Derived> const &)
boost::xpressive::detail::counted_base::operator =	xpressive/detail/utility/counted_base.hpp	/^        counted_base &operator =(counted_base<Derived> const &)$/;"	f	struct:boost::xpressive::detail::counted_base	access:protected	signature:(counted_base<Derived> const &)
boost::xpressive::detail::counted_base::use_count	xpressive/detail/utility/counted_base.hpp	/^        long use_count() const$/;"	f	struct:boost::xpressive::detail::counted_base	access:public	signature:() const
boost::xpressive::detail::counted_base_access	xpressive/detail/utility/counted_base.hpp	/^    struct counted_base_access$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::counted_base_access::add_ref	xpressive/detail/utility/counted_base.hpp	/^        static void add_ref(counted_base<Derived> const *that)$/;"	f	struct:boost::xpressive::detail::counted_base_access	access:public	signature:(counted_base<Derived> const *that)
boost::xpressive::detail::counted_base_access::release	xpressive/detail/utility/counted_base.hpp	/^        static void release(counted_base<Derived> const *that)$/;"	f	struct:boost::xpressive::detail::counted_base_access	access:public	signature:(counted_base<Derived> const *that)
boost::xpressive::detail::cpp_regex_traits_base	xpressive/traits/cpp_regex_traits.hpp	/^    struct cpp_regex_traits_base$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::cpp_regex_traits_base	xpressive/traits/cpp_regex_traits.hpp	/^    struct cpp_regex_traits_base<Char, 1>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::cpp_regex_traits_base::imbue	xpressive/traits/cpp_regex_traits.hpp	/^        void imbue(std::locale const &)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::locale const &)
boost::xpressive::detail::cpp_regex_traits_base::imbue	xpressive/traits/cpp_regex_traits.hpp	/^        void imbue(std::locale const &loc)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::locale const &loc)
boost::xpressive::detail::cpp_regex_traits_base::is	xpressive/traits/cpp_regex_traits.hpp	/^        bool is(std::ctype<Char> const &, Char ch, umaskex_t mask) const$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::ctype<Char> const &, Char ch, umaskex_t mask) const
boost::xpressive::detail::cpp_regex_traits_base::is	xpressive/traits/cpp_regex_traits.hpp	/^        static bool is(std::ctype<Char> const &ct, Char ch, umaskex_t mask)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::ctype<Char> const &ct, Char ch, umaskex_t mask)
boost::xpressive::detail::cpp_regex_traits_base::is_blank	xpressive/traits/cpp_regex_traits.hpp	/^        static bool is_blank(Char ch)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private	signature:(Char ch)
boost::xpressive::detail::cpp_regex_traits_base::is_newline	xpressive/traits/cpp_regex_traits.hpp	/^        static bool is_newline(Char ch)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private	signature:(Char ch)
boost::xpressive::detail::cpp_regex_traits_base::is_underscore	xpressive/traits/cpp_regex_traits.hpp	/^        static bool is_underscore(Char ch)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private	signature:(Char ch)
boost::xpressive::detail::cpp_regex_traits_base::masks_	xpressive/traits/cpp_regex_traits.hpp	/^        umaskex_t masks_[UCHAR_MAX + 1];$/;"	m	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private
boost::xpressive::detail::data_begin	xpressive/detail/utility/algorithm.hpp	/^Char const *data_begin(Char const *const &sz)$/;"	f	namespace:boost::xpressive::detail	signature:(Char const *const &sz)
boost::xpressive::detail::data_begin	xpressive/detail/utility/algorithm.hpp	/^Char const *data_begin(std::basic_string<Char, Traits, Alloc> const &str)$/;"	f	namespace:boost::xpressive::detail	signature:(std::basic_string<Char, Traits, Alloc> const &str)
boost::xpressive::detail::data_end	xpressive/detail/utility/algorithm.hpp	/^Char const *data_end(Char const *const &sz)$/;"	f	namespace:boost::xpressive::detail	signature:(Char const *const &sz)
boost::xpressive::detail::data_end	xpressive/detail/utility/algorithm.hpp	/^Char const *data_end(std::basic_string<Char, Traits, Alloc> const &str)$/;"	f	namespace:boost::xpressive::detail	signature:(std::basic_string<Char, Traits, Alloc> const &str)
boost::xpressive::detail::default_regex_traits	xpressive/xpressive_fwd.hpp	/^        struct default_regex_traits$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::default_regex_traits::type	xpressive/xpressive_fwd.hpp	/^            typedef c_regex_traits<Char> type;$/;"	t	struct:boost::xpressive::detail::default_regex_traits	access:public
boost::xpressive::detail::default_transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct default_transmogrify$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::default_transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct default_transmogrify<BidiIter, ICase, Traits, Matcher, typename Matcher::is_boost_xpressive_xpression_>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::default_transmogrify::call	xpressive/detail/static/transmogrify.hpp	/^        static Matcher2 const &call(Matcher2 const &m, dont_care)$/;"	f	struct:boost::xpressive::detail::default_transmogrify	access:public	signature:(Matcher2 const &m, dont_care)
boost::xpressive::detail::default_transmogrify::call	xpressive/detail/static/transmogrify.hpp	/^        static type call(Matcher2 const &m, Visitor &visitor)$/;"	f	struct:boost::xpressive::detail::default_transmogrify	access:public	signature:(Matcher2 const &m, Visitor &visitor)
boost::xpressive::detail::default_transmogrify::call_	xpressive/detail/static/transmogrify.hpp	/^        static type call_(Matcher2 const &m, Visitor &visitor, mpl::false_)$/;"	f	struct:boost::xpressive::detail::default_transmogrify	access:public	signature:(Matcher2 const &m, Visitor &visitor, mpl::false_)
boost::xpressive::detail::default_transmogrify::call_	xpressive/detail/static/transmogrify.hpp	/^        static type call_(Matcher2 const &m, Visitor &visitor, mpl::true_)$/;"	f	struct:boost::xpressive::detail::default_transmogrify	access:public	signature:(Matcher2 const &m, Visitor &visitor, mpl::true_)
boost::xpressive::detail::default_transmogrify::char_type	xpressive/detail/static/transmogrify.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::default_transmogrify	access:public
boost::xpressive::detail::default_transmogrify::string_type	xpressive/detail/static/transmogrify.hpp	/^        typedef typename Traits::string_type string_type;$/;"	t	struct:boost::xpressive::detail::default_transmogrify	access:public
boost::xpressive::detail::default_transmogrify::type	xpressive/detail/static/transmogrify.hpp	/^        >::type type;$/;"	t	struct:boost::xpressive::detail::default_transmogrify	access:public
boost::xpressive::detail::default_transmogrify::type	xpressive/detail/static/transmogrify.hpp	/^        typedef Matcher type;$/;"	t	struct:boost::xpressive::detail::default_transmogrify	access:public
boost::xpressive::detail::dont_care	xpressive/detail/utility/dont_care.hpp	/^    struct dont_care$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::dont_care::dont_care	xpressive/detail/utility/dont_care.hpp	/^        dont_care() {}$/;"	f	struct:boost::xpressive::detail::dont_care	access:public	signature:()
boost::xpressive::detail::dont_care::dont_care	xpressive/detail/utility/dont_care.hpp	/^        dont_care(T const &) {}$/;"	f	struct:boost::xpressive::detail::dont_care	access:public	signature:(T const &)
boost::xpressive::detail::dynamic_xpression	xpressive/detail/dynamic/dynamic.hpp	/^struct dynamic_xpression$/;"	s	namespace:boost::xpressive::detail	inherits:Matcher,matchable_ex
boost::xpressive::detail::dynamic_xpression::char_type	xpressive/detail/dynamic/dynamic.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::dynamic_xpression	access:public
boost::xpressive::detail::dynamic_xpression::dynamic_xpression	xpressive/detail/dynamic/dynamic.hpp	/^    dynamic_xpression(Matcher const &matcher = Matcher())$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:public	signature:(Matcher const &matcher = Matcher())
boost::xpressive::detail::dynamic_xpression::link	xpressive/detail/dynamic/dynamic.hpp	/^    virtual void link(xpression_linker<char_type> &linker) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:public	signature:(xpression_linker<char_type> &linker) const
boost::xpressive::detail::dynamic_xpression::match	xpressive/detail/dynamic/dynamic.hpp	/^    virtual bool match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::dynamic_xpression::next_	xpressive/detail/dynamic/dynamic.hpp	/^    shared_matchable<BidiIter> next_;$/;"	m	struct:boost::xpressive::detail::dynamic_xpression	access:private
boost::xpressive::detail::dynamic_xpression::peek	xpressive/detail/dynamic/dynamic.hpp	/^    virtual void peek(xpression_peeker<char_type> &peeker) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:public	signature:(xpression_peeker<char_type> &peeker) const
boost::xpressive::detail::dynamic_xpression::peek_next_	xpressive/detail/dynamic/dynamic.hpp	/^    void peek_next_(mpl::false_, xpression_peeker<char_type> &) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:private	signature:(mpl::false_, xpression_peeker<char_type> &) const
boost::xpressive::detail::dynamic_xpression::peek_next_	xpressive/detail/dynamic/dynamic.hpp	/^    void peek_next_(mpl::true_, xpression_peeker<char_type> &peeker) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:private	signature:(mpl::true_, xpression_peeker<char_type> &peeker) const
boost::xpressive::detail::dynamic_xpression::repeat	xpressive/detail/dynamic/dynamic.hpp	/^    virtual void repeat(quant_spec const &spec, sequence<BidiIter> &seq) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:public	signature:(quant_spec const &spec, sequence<BidiIter> &seq) const
boost::xpressive::detail::dynamic_xpression::repeat_	xpressive/detail/dynamic/dynamic.hpp	/^    void repeat_(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_fixed_width>, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:private	signature:(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_fixed_width>, mpl::false_) const
boost::xpressive::detail::dynamic_xpression::repeat_	xpressive/detail/dynamic/dynamic.hpp	/^    void repeat_(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_fixed_width>, mpl::true_) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:private	signature:(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_fixed_width>, mpl::true_) const
boost::xpressive::detail::dynamic_xpression::repeat_	xpressive/detail/dynamic/dynamic.hpp	/^    void repeat_(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_none>, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:private	signature:(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_none>, mpl::false_) const
boost::xpressive::detail::dynamic_xpression::repeat_	xpressive/detail/dynamic/dynamic.hpp	/^    void repeat_(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_variable_width>, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:private	signature:(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_variable_width>, mpl::false_) const
boost::xpressive::detail::empty_locale	xpressive/traits/c_regex_traits.hpp	/^    struct empty_locale$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::enable_reference_tracking	xpressive/detail/utility/tracking_ptr.hpp	/^struct enable_reference_tracking$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::enable_reference_tracking::add_ref	xpressive/detail/utility/tracking_ptr.hpp	/^    void add_ref()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:public	signature:()
boost::xpressive::detail::enable_reference_tracking::cnt_	xpressive/detail/utility/tracking_ptr.hpp	/^    boost::detail::atomic_count cnt_;$/;"	m	struct:boost::xpressive::detail::enable_reference_tracking	access:private
boost::xpressive::detail::enable_reference_tracking::dependents_type	xpressive/detail/utility/tracking_ptr.hpp	/^    typedef std::set<weak_ptr<Derived> > dependents_type;$/;"	t	struct:boost::xpressive::detail::enable_reference_tracking	access:public
boost::xpressive::detail::enable_reference_tracking::deps_	xpressive/detail/utility/tracking_ptr.hpp	/^    dependents_type deps_;$/;"	m	struct:boost::xpressive::detail::enable_reference_tracking	access:private
boost::xpressive::detail::enable_reference_tracking::derived_	xpressive/detail/utility/tracking_ptr.hpp	/^    Derived &derived_()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:()
boost::xpressive::detail::enable_reference_tracking::dump_	xpressive/detail/utility/tracking_ptr.hpp	/^    void dump_(std::ostream &sout) const;$/;"	p	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:(std::ostream &sout) const
boost::xpressive::detail::enable_reference_tracking::dump_	xpressive/detail/utility/tracking_ptr.hpp	/^inline void enable_reference_tracking<Derived>::dump_(std::ostream &sout) const$/;"	f	class:boost::xpressive::detail::enable_reference_tracking	signature:(std::ostream &sout) const
boost::xpressive::detail::enable_reference_tracking::enable_reference_tracking	xpressive/detail/utility/tracking_ptr.hpp	/^    enable_reference_tracking()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:protected	signature:()
boost::xpressive::detail::enable_reference_tracking::enable_reference_tracking	xpressive/detail/utility/tracking_ptr.hpp	/^    enable_reference_tracking(enable_reference_tracking<Derived> const &that)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:protected	signature:(enable_reference_tracking<Derived> const &that)
boost::xpressive::detail::enable_reference_tracking::has_deps_	xpressive/detail/utility/tracking_ptr.hpp	/^    bool has_deps_() const$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:() const
boost::xpressive::detail::enable_reference_tracking::operator <<	xpressive/detail/utility/tracking_ptr.hpp	/^    friend std::ostream &operator <<(std::ostream &sout, enable_reference_tracking<Derived> const &that)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:friend	signature:(std::ostream &sout, enable_reference_tracking<Derived> const &that)
boost::xpressive::detail::enable_reference_tracking::operator =	xpressive/detail/utility/tracking_ptr.hpp	/^    enable_reference_tracking<Derived> &operator =(enable_reference_tracking<Derived> const &that)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:protected	signature:(enable_reference_tracking<Derived> const &that)
boost::xpressive::detail::enable_reference_tracking::purge_stale_deps_	xpressive/detail/utility/tracking_ptr.hpp	/^    void purge_stale_deps_()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:()
boost::xpressive::detail::enable_reference_tracking::raw_copy_	xpressive/detail/utility/tracking_ptr.hpp	/^    void raw_copy_(Derived that)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:(Derived that)
boost::xpressive::detail::enable_reference_tracking::references_type	xpressive/detail/utility/tracking_ptr.hpp	/^    typedef std::set<shared_ptr<Derived> > references_type;$/;"	t	struct:boost::xpressive::detail::enable_reference_tracking	access:public
boost::xpressive::detail::enable_reference_tracking::refs_	xpressive/detail/utility/tracking_ptr.hpp	/^    references_type refs_;$/;"	m	struct:boost::xpressive::detail::enable_reference_tracking	access:private
boost::xpressive::detail::enable_reference_tracking::release	xpressive/detail/utility/tracking_ptr.hpp	/^    void release()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:public	signature:()
boost::xpressive::detail::enable_reference_tracking::self_	xpressive/detail/utility/tracking_ptr.hpp	/^    shared_ptr<Derived> self_;$/;"	m	struct:boost::xpressive::detail::enable_reference_tracking	access:private
boost::xpressive::detail::enable_reference_tracking::swap	xpressive/detail/utility/tracking_ptr.hpp	/^    void swap(enable_reference_tracking<Derived> &that)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:protected	signature:(enable_reference_tracking<Derived> &that)
boost::xpressive::detail::enable_reference_tracking::track_dependency_	xpressive/detail/utility/tracking_ptr.hpp	/^    void track_dependency_(enable_reference_tracking<Derived> &dep)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:(enable_reference_tracking<Derived> &dep)
boost::xpressive::detail::enable_reference_tracking::track_reference	xpressive/detail/utility/tracking_ptr.hpp	/^    void track_reference(enable_reference_tracking<Derived> &that)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:public	signature:(enable_reference_tracking<Derived> &that)
boost::xpressive::detail::enable_reference_tracking::tracking_clear	xpressive/detail/utility/tracking_ptr.hpp	/^    void tracking_clear()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:public	signature:()
boost::xpressive::detail::enable_reference_tracking::tracking_copy	xpressive/detail/utility/tracking_ptr.hpp	/^    void tracking_copy(Derived const &that)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:public	signature:(Derived const &that)
boost::xpressive::detail::enable_reference_tracking::tracking_update	xpressive/detail/utility/tracking_ptr.hpp	/^    void tracking_update()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:public	signature:()
boost::xpressive::detail::enable_reference_tracking::update_dependents_	xpressive/detail/utility/tracking_ptr.hpp	/^    void update_dependents_()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:()
boost::xpressive::detail::enable_reference_tracking::update_references_	xpressive/detail/utility/tracking_ptr.hpp	/^    void update_references_()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:()
boost::xpressive::detail::enable_reference_tracking::use_count	xpressive/detail/utility/tracking_ptr.hpp	/^    long use_count() const$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:public	signature:() const
boost::xpressive::detail::end	xpressive/regex_algorithms.hpp	/^      , BOOST_XPR_NONDEDUCED_TYPE_(BidiIter) end$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::end_matcher	xpressive/detail/core/matcher/end_matcher.hpp	/^    struct end_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_assertion
boost::xpressive::detail::end_matcher::match	xpressive/detail/core/matcher/end_matcher.hpp	/^        static bool match(match_state<BidiIter> &state, Next const &)$/;"	f	struct:boost::xpressive::detail::end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &)
boost::xpressive::detail::end_xpression	xpressive/detail/detail_fwd.hpp	/^    typedef static_xpression<end_matcher, no_next> end_xpression;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::ensure_	xpressive/regex_error.hpp	/^    inline bool ensure_($/;"	f	namespace:boost::xpressive::detail	signature:( bool cond , regex_constants::error_type code , char const *msg , char const *fun , char const *file , unsigned long line )
boost::xpressive::detail::epsilon_matcher	xpressive/detail/core/matcher/epsilon_matcher.hpp	/^    struct epsilon_matcher$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::epsilon_matcher::match	xpressive/detail/core/matcher/epsilon_matcher.hpp	/^        static bool match(match_state<BidiIter> &state, Next const &next)$/;"	f	struct:boost::xpressive::detail::epsilon_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next)
boost::xpressive::detail::escape_char	xpressive/detail/dynamic/parse_charset.hpp	/^    escape_char$/;"	e	enum:boost::xpressive::detail::escape_type
boost::xpressive::detail::escape_class	xpressive/detail/dynamic/parse_charset.hpp	/^  , escape_class$/;"	e	enum:boost::xpressive::detail::escape_type
boost::xpressive::detail::escape_mark	xpressive/detail/dynamic/parse_charset.hpp	/^  , escape_mark$/;"	e	enum:boost::xpressive::detail::escape_type
boost::xpressive::detail::escape_type	xpressive/detail/dynamic/parse_charset.hpp	/^enum escape_type$/;"	g	namespace:boost::xpressive::detail
boost::xpressive::detail::escape_value	xpressive/detail/dynamic/parse_charset.hpp	/^struct escape_value$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::escape_value::ch_	xpressive/detail/dynamic/parse_charset.hpp	/^    Char ch_;$/;"	m	struct:boost::xpressive::detail::escape_value	access:public
boost::xpressive::detail::escape_value::class_	xpressive/detail/dynamic/parse_charset.hpp	/^    Class class_;$/;"	m	struct:boost::xpressive::detail::escape_value	access:public
boost::xpressive::detail::escape_value::mark_nbr_	xpressive/detail/dynamic/parse_charset.hpp	/^    int mark_nbr_;$/;"	m	struct:boost::xpressive::detail::escape_value	access:public
boost::xpressive::detail::escape_value::type_	xpressive/detail/dynamic/parse_charset.hpp	/^    escape_type type_;$/;"	m	struct:boost::xpressive::detail::escape_value	access:public
boost::xpressive::detail::fill	xpressive/detail/utility/sequence_stack.hpp	/^struct fill_t {} const fill = {};$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::fill_t	xpressive/detail/utility/sequence_stack.hpp	/^struct fill_t {} const fill = {};$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::filter_self	xpressive/detail/utility/tracking_ptr.hpp	/^struct filter_self$/;"	s	namespace:boost::xpressive::detail	inherits:std::unary_function
boost::xpressive::detail::filter_self::filter_self	xpressive/detail/utility/tracking_ptr.hpp	/^    filter_self(enable_reference_tracking<Derived> *self)$/;"	f	struct:boost::xpressive::detail::filter_self	access:public	signature:(enable_reference_tracking<Derived> *self)
boost::xpressive::detail::filter_self::operator ()	xpressive/detail/utility/tracking_ptr.hpp	/^    bool operator ()(shared_ptr<Derived> const &that) const$/;"	f	struct:boost::xpressive::detail::filter_self	access:public	signature:(shared_ptr<Derived> const &that) const
boost::xpressive::detail::filter_self::self_	xpressive/detail/utility/tracking_ptr.hpp	/^    enable_reference_tracking<Derived> *self_;$/;"	m	struct:boost::xpressive::detail::filter_self	access:private
boost::xpressive::detail::find_nth_if	xpressive/detail/utility/algorithm.hpp	/^FwdIter find_nth_if(FwdIter begin, FwdIter end, Diff count, Pred pred)$/;"	f	namespace:boost::xpressive::detail	signature:(FwdIter begin, FwdIter end, Diff count, Pred pred)
boost::xpressive::detail::finder	xpressive/detail/core/regex_impl.hpp	/^struct finder$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
boost::xpressive::detail::finder::ok_for_partial_matches	xpressive/detail/core/regex_impl.hpp	/^    virtual bool ok_for_partial_matches() const { return true; }$/;"	f	struct:boost::xpressive::detail::finder	access:public	signature:() const
boost::xpressive::detail::finder::operator ()	xpressive/detail/core/regex_impl.hpp	/^    virtual bool operator ()(match_state<BidiIter> &state) const = 0;$/;"	p	struct:boost::xpressive::detail::finder	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::finder::~finder	xpressive/detail/core/regex_impl.hpp	/^    virtual ~finder() {}$/;"	f	struct:boost::xpressive::detail::finder	access:public	signature:()
boost::xpressive::detail::formatter_arity	xpressive/match_results.hpp	/^struct formatter_arity$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::formatter_arity	xpressive/match_results.hpp	/^struct formatter_arity<Formatter, What, Out, typename Formatter::proto_is_expr_>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
boost::xpressive::detail::formatter_arity::BOOST_STATIC_CONSTANT	xpressive/match_results.hpp	/^    BOOST_STATIC_CONSTANT($/;"	p	struct:boost::xpressive::detail::formatter_arity	access:public	signature:( std::size_t , value = sizeof( check_is_formatter( formatter(what) , formatter(what, out) , formatter(what, out, regex_constants::format_default) ) ) - 1 )
boost::xpressive::detail::formatter_arity::formatter	xpressive/match_results.hpp	/^    static formatter_wrapper<Formatter> &formatter;$/;"	m	struct:boost::xpressive::detail::formatter_arity	access:public
boost::xpressive::detail::formatter_arity::out	xpressive/match_results.hpp	/^    static Out &out;$/;"	m	struct:boost::xpressive::detail::formatter_arity	access:public
boost::xpressive::detail::formatter_arity::type	xpressive/match_results.hpp	/^    typedef mpl::size_t<value> type;$/;"	t	struct:boost::xpressive::detail::formatter_arity	access:public
boost::xpressive::detail::formatter_arity::what	xpressive/match_results.hpp	/^    static What &what;$/;"	m	struct:boost::xpressive::detail::formatter_arity	access:public
boost::xpressive::detail::formatter_wrapper	xpressive/match_results.hpp	/^struct formatter_wrapper$/;"	s	namespace:boost::xpressive::detail	inherits:Formatter,unary_binary_ternary
boost::xpressive::detail::formatter_wrapper	xpressive/match_results.hpp	/^struct formatter_wrapper<Formatter *, false>$/;"	s	namespace:boost::xpressive::detail	inherits:unary_binary_ternary
boost::xpressive::detail::formatter_wrapper	xpressive/match_results.hpp	/^struct formatter_wrapper<Formatter, true>$/;"	s	namespace:boost::xpressive::detail	inherits:unary_binary_ternary
boost::xpressive::detail::formatter_wrapper::formatter_wrapper	xpressive/match_results.hpp	/^    formatter_wrapper();$/;"	p	struct:boost::xpressive::detail::formatter_wrapper	access:public	signature:()
boost::xpressive::detail::formatter_wrapper::operator Formatter *	xpressive/match_results.hpp	/^    operator Formatter *();$/;"	p	struct:boost::xpressive::detail::formatter_wrapper	access:public	signature:()
boost::xpressive::detail::generic_quant_tag	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct generic_quant_tag$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::generic_quant_tag::max_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^        typedef mpl::integral_c<uint_t, Max> max_type;$/;"	t	struct:boost::xpressive::detail::generic_quant_tag	access:public
boost::xpressive::detail::generic_quant_tag::min_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^        typedef mpl::integral_c<uint_t, Min> min_type;$/;"	t	struct:boost::xpressive::detail::generic_quant_tag	access:public
boost::xpressive::detail::get_invalid_xpression	xpressive/detail/dynamic/dynamic.hpp	/^inline shared_matchable<BidiIter> const &get_invalid_xpression()$/;"	f	namespace:boost::xpressive::detail	signature:()
boost::xpressive::detail::get_mark_number	xpressive/detail/detail_fwd.hpp	/^    int get_mark_number(basic_mark_tag const &);$/;"	p	namespace:boost::xpressive::detail	signature:(basic_mark_tag const &)
boost::xpressive::detail::get_mark_number	xpressive/detail/static/static.hpp	/^inline int get_mark_number(basic_mark_tag const &mark)$/;"	f	namespace:boost::xpressive::detail	signature:(basic_mark_tag const &mark)
boost::xpressive::detail::get_mark_number	xpressive/regex_token_iterator.hpp	/^inline int get_mark_number(int i)$/;"	f	namespace:boost::xpressive::detail	signature:(int i)
boost::xpressive::detail::greedy_fast_tag	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    struct greedy_fast_tag {};$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::greedy_slow_tag	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    struct greedy_slow_tag {};$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::hash_peek_bitset	xpressive/detail/utility/hash_peek_bitset.hpp	/^struct hash_peek_bitset$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::hash_peek_bitset::bset_	xpressive/detail/utility/hash_peek_bitset.hpp	/^    std::bitset<256> bset_;$/;"	m	struct:boost::xpressive::detail::hash_peek_bitset	access:private
boost::xpressive::detail::hash_peek_bitset::char_type	xpressive/detail/utility/hash_peek_bitset.hpp	/^    typedef Char char_type;$/;"	t	struct:boost::xpressive::detail::hash_peek_bitset	access:public
boost::xpressive::detail::hash_peek_bitset::count	xpressive/detail/utility/hash_peek_bitset.hpp	/^    std::size_t count() const$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:() const
boost::xpressive::detail::hash_peek_bitset::hash_peek_bitset	xpressive/detail/utility/hash_peek_bitset.hpp	/^    hash_peek_bitset()$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:()
boost::xpressive::detail::hash_peek_bitset::icase	xpressive/detail/utility/hash_peek_bitset.hpp	/^    bool icase() const$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:() const
boost::xpressive::detail::hash_peek_bitset::icase_	xpressive/detail/utility/hash_peek_bitset.hpp	/^    bool icase_;$/;"	m	struct:boost::xpressive::detail::hash_peek_bitset	access:private
boost::xpressive::detail::hash_peek_bitset::int_type	xpressive/detail/utility/hash_peek_bitset.hpp	/^    typedef typename std::char_traits<char_type>::int_type int_type;$/;"	t	struct:boost::xpressive::detail::hash_peek_bitset	access:public
boost::xpressive::detail::hash_peek_bitset::set_all	xpressive/detail/utility/hash_peek_bitset.hpp	/^    void set_all()$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:()
boost::xpressive::detail::hash_peek_bitset::set_bitset	xpressive/detail/utility/hash_peek_bitset.hpp	/^    void set_bitset(hash_peek_bitset<Char> const &that)$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(hash_peek_bitset<Char> const &that)
boost::xpressive::detail::hash_peek_bitset::set_char	xpressive/detail/utility/hash_peek_bitset.hpp	/^    void set_char(char_type ch, bool icase, Traits const &tr)$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(char_type ch, bool icase, Traits const &tr)
boost::xpressive::detail::hash_peek_bitset::set_charset	xpressive/detail/utility/hash_peek_bitset.hpp	/^    void set_charset(basic_chset_8bit<Char> const &that, bool icase)$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(basic_chset_8bit<Char> const &that, bool icase)
boost::xpressive::detail::hash_peek_bitset::set_class	xpressive/detail/utility/hash_peek_bitset.hpp	/^    void set_class(typename Traits::char_class_type char_class, bool no, Traits const &tr)$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(typename Traits::char_class_type char_class, bool no, Traits const &tr)
boost::xpressive::detail::hash_peek_bitset::set_range	xpressive/detail/utility/hash_peek_bitset.hpp	/^    void set_range(char_type from, char_type to, bool no, bool icase, Traits const &tr)$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(char_type from, char_type to, bool no, bool icase, Traits const &tr)
boost::xpressive::detail::hash_peek_bitset::test	xpressive/detail/utility/hash_peek_bitset.hpp	/^    bool test(char_type ch, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(char_type ch, Traits const &tr) const
boost::xpressive::detail::hash_peek_bitset::test	xpressive/detail/utility/hash_peek_bitset.hpp	/^    bool test(char_type ch, Traits const &tr, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(char_type ch, Traits const &tr, mpl::false_) const
boost::xpressive::detail::hash_peek_bitset::test	xpressive/detail/utility/hash_peek_bitset.hpp	/^    bool test(char_type ch, Traits const &tr, mpl::true_) const$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(char_type ch, Traits const &tr, mpl::true_) const
boost::xpressive::detail::hash_peek_bitset::test_icase_	xpressive/detail/utility/hash_peek_bitset.hpp	/^    bool test_icase_(bool icase)$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:private	signature:(bool icase)
boost::xpressive::detail::hash_peek_finder	xpressive/detail/core/finder.hpp	/^struct hash_peek_finder$/;"	s	namespace:boost::xpressive::detail	inherits:finder
boost::xpressive::detail::hash_peek_finder::bset_	xpressive/detail/core/finder.hpp	/^    hash_peek_bitset<char_type> bset_;$/;"	m	struct:boost::xpressive::detail::hash_peek_finder	access:private
boost::xpressive::detail::hash_peek_finder::char_type	xpressive/detail/core/finder.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::hash_peek_finder	access:public
boost::xpressive::detail::hash_peek_finder::find_	xpressive/detail/core/finder.hpp	/^    BidiIter find_(BidiIter begin, BidiIter end, Traits const &tr, ICase) const$/;"	f	struct:boost::xpressive::detail::hash_peek_finder	access:private	signature:(BidiIter begin, BidiIter end, Traits const &tr, ICase) const
boost::xpressive::detail::hash_peek_finder::hash_peek_finder	xpressive/detail/core/finder.hpp	/^    hash_peek_finder(hash_peek_bitset<char_type> const &bset)$/;"	f	struct:boost::xpressive::detail::hash_peek_finder	access:public	signature:(hash_peek_bitset<char_type> const &bset)
boost::xpressive::detail::hash_peek_finder::hash_peek_finder	xpressive/detail/core/finder.hpp	/^    hash_peek_finder(hash_peek_finder const &);$/;"	p	struct:boost::xpressive::detail::hash_peek_finder	access:private	signature:(hash_peek_finder const &)
boost::xpressive::detail::hash_peek_finder::operator ()	xpressive/detail/core/finder.hpp	/^    bool operator ()(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::hash_peek_finder	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::hash_peek_finder::operator =	xpressive/detail/core/finder.hpp	/^    hash_peek_finder &operator =(hash_peek_finder const &);$/;"	p	struct:boost::xpressive::detail::hash_peek_finder	access:private	signature:(hash_peek_finder const &)
boost::xpressive::detail::highest_bit	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const highest_bit = static_cast<umaskex_t>(1) << (sizeof(umaskex_t) * CHAR_BIT - 1);$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::icase_modifier	xpressive/detail/core/linker.hpp	/^struct icase_modifier$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::icase_modifier::apply	xpressive/detail/core/linker.hpp	/^    struct apply {};$/;"	s	struct:boost::xpressive::detail::icase_modifier	access:public
boost::xpressive::detail::icase_modifier::apply	xpressive/detail/core/linker.hpp	/^    struct apply<xpression_visitor<BidiIter, ICase, Traits> >$/;"	s	struct:boost::xpressive::detail::icase_modifier	access:public
boost::xpressive::detail::icase_modifier::apply::type	xpressive/detail/core/linker.hpp	/^        typedef xpression_visitor<BidiIter, mpl::true_, Traits> type;$/;"	t	struct:boost::xpressive::detail::icase_modifier::apply	access:public
boost::xpressive::detail::icase_modifier::call	xpressive/detail/core/linker.hpp	/^    call(Visitor &visitor)$/;"	f	struct:boost::xpressive::detail::icase_modifier	access:public	signature:(Visitor &visitor)
boost::xpressive::detail::ignore_unused_icase	xpressive/detail/core/icase.hpp	/^    inline void ignore_unused_icase()$/;"	f	namespace:boost::xpressive::detail	signature:()
boost::xpressive::detail::ignore_unused_regex_actions	xpressive/regex_actions.hpp	/^        inline void ignore_unused_regex_actions()$/;"	f	namespace:boost::xpressive::detail	signature:()
boost::xpressive::detail::ignore_unused_regex_primitives	xpressive/regex_primitives.hpp	/^    inline void ignore_unused_regex_primitives()$/;"	f	namespace:boost::xpressive::detail	signature:()
boost::xpressive::detail::imbue	xpressive/regex_primitives.hpp	/^imbue(Locale const &loc)$/;"	f	class:boost::xpressive::detail	signature:(Locale const &loc)
boost::xpressive::detail::independent_end_matcher	xpressive/detail/core/matcher/end_matcher.hpp	/^    struct independent_end_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_assertion
boost::xpressive::detail::independent_end_matcher::match	xpressive/detail/core/matcher/end_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &) const$/;"	f	struct:boost::xpressive::detail::independent_end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &) const
boost::xpressive::detail::independent_end_xpression	xpressive/detail/detail_fwd.hpp	/^    typedef static_xpression<independent_end_matcher, no_next> independent_end_xpression;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::intrusive_ptr_add_ref	xpressive/detail/utility/counted_base.hpp	/^    inline void intrusive_ptr_add_ref(counted_base<Derived> const *that)$/;"	f	namespace:boost::xpressive::detail	signature:(counted_base<Derived> const *that)
boost::xpressive::detail::intrusive_ptr_add_ref	xpressive/detail/utility/tracking_ptr.hpp	/^inline void intrusive_ptr_add_ref(enable_reference_tracking<Derived> *p)$/;"	f	namespace:boost::xpressive::detail	signature:(enable_reference_tracking<Derived> *p)
boost::xpressive::detail::intrusive_ptr_release	xpressive/detail/utility/counted_base.hpp	/^    inline void intrusive_ptr_release(counted_base<Derived> const *that)$/;"	f	namespace:boost::xpressive::detail	signature:(counted_base<Derived> const *that)
boost::xpressive::detail::intrusive_ptr_release	xpressive/detail/utility/tracking_ptr.hpp	/^inline void intrusive_ptr_release(enable_reference_tracking<Derived> *p)$/;"	f	namespace:boost::xpressive::detail	signature:(enable_reference_tracking<Derived> *p)
boost::xpressive::detail::invalid_xpression	xpressive/detail/dynamic/dynamic.hpp	/^struct invalid_xpression$/;"	s	namespace:boost::xpressive::detail	inherits:matchable_ex
boost::xpressive::detail::invalid_xpression::invalid_xpression	xpressive/detail/dynamic/dynamic.hpp	/^    invalid_xpression()$/;"	f	struct:boost::xpressive::detail::invalid_xpression	access:public	signature:()
boost::xpressive::detail::invalid_xpression::match	xpressive/detail/dynamic/dynamic.hpp	/^    bool match(match_state<BidiIter> &) const$/;"	f	struct:boost::xpressive::detail::invalid_xpression	access:public	signature:(match_state<BidiIter> &) const
boost::xpressive::detail::is_char	xpressive/detail/static/type_traits.hpp	/^struct is_char$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::is_char	xpressive/detail/static/type_traits.hpp	/^struct is_char<char>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
boost::xpressive::detail::is_char	xpressive/detail/static/type_traits.hpp	/^struct is_char<wchar_t>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
boost::xpressive::detail::is_char_literal	xpressive/detail/static/transmogrify.hpp	/^    struct is_char_literal$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::or_
boost::xpressive::detail::is_char_ptr	xpressive/match_results.hpp	/^struct is_char_ptr$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::is_char_ptr	xpressive/match_results.hpp	/^struct is_char_ptr<T *>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::not_
boost::xpressive::detail::is_narrow_char	xpressive/detail/utility/chset/basic_chset.hpp	/^struct is_narrow_char$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::is_narrow_char	xpressive/detail/utility/chset/basic_chset.hpp	/^struct is_narrow_char<char>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
boost::xpressive::detail::is_narrow_char	xpressive/detail/utility/chset/basic_chset.hpp	/^struct is_narrow_char<signed char>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
boost::xpressive::detail::is_narrow_char	xpressive/detail/utility/chset/basic_chset.hpp	/^struct is_narrow_char<unsigned char>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
boost::xpressive::detail::is_null_terminated	xpressive/detail/utility/algorithm.hpp	/^inline std::ptrdiff_t is_null_terminated(char const *) { return 1; }$/;"	f	namespace:boost::xpressive::detail	signature:(char const *)
boost::xpressive::detail::is_null_terminated	xpressive/detail/utility/algorithm.hpp	/^inline std::ptrdiff_t is_null_terminated(wchar_t const *) { return 1; }$/;"	f	namespace:boost::xpressive::detail	signature:(wchar_t const *)
boost::xpressive::detail::is_null_terminated	xpressive/detail/utility/algorithm.hpp	/^template<typename T> std::ptrdiff_t is_null_terminated(T const &) { return 0; }$/;"	f	namespace:boost::xpressive::detail	signature:(T const &)
boost::xpressive::detail::is_random	xpressive/detail/static/type_traits.hpp	/^struct is_random$/;"	s	namespace:boost::xpressive::detail	inherits:is_convertible
boost::xpressive::detail::is_static_xpression	xpressive/detail/static/type_traits.hpp	/^struct is_static_xpression$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::is_static_xpression	xpressive/detail/static/type_traits.hpp	/^struct is_static_xpression<stacked_xpression<Top, Next> >$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
boost::xpressive::detail::is_static_xpression	xpressive/detail/static/type_traits.hpp	/^struct is_static_xpression<static_xpression<Matcher, Next> >$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
boost::xpressive::detail::is_string_iterator	xpressive/detail/static/type_traits.hpp	/^struct is_string_iterator$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::is_string_iterator	xpressive/detail/static/type_traits.hpp	/^struct is_string_iterator<std::string::const_iterator>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
boost::xpressive::detail::is_string_iterator	xpressive/detail/static/type_traits.hpp	/^struct is_string_iterator<std::string::iterator>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
boost::xpressive::detail::is_string_iterator	xpressive/detail/static/type_traits.hpp	/^struct is_string_iterator<std::wstring::const_iterator>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
boost::xpressive::detail::is_string_iterator	xpressive/detail/static/type_traits.hpp	/^struct is_string_iterator<std::wstring::iterator>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
boost::xpressive::detail::is_unknown	xpressive/detail/utility/width.hpp	/^bool is_unknown(width const &that);$/;"	p	namespace:boost::xpressive::detail	signature:(width const &that)
boost::xpressive::detail::is_unknown	xpressive/detail/utility/width.hpp	/^inline bool is_unknown(width const &that)$/;"	f	namespace:boost::xpressive::detail	signature:(width const &that)
boost::xpressive::detail::is_xpr	xpressive/detail/core/quant_style.hpp	/^struct is_xpr$/;"	s	namespace:boost::xpressive::detail	inherits:has_is_boost_xpressive_xpression_
boost::xpressive::detail::isnewline	xpressive/traits/detail/c_ctype.hpp	/^inline bool isnewline(char ch)$/;"	f	namespace:boost::xpressive::detail	signature:(char ch)
boost::xpressive::detail::iswnewline	xpressive/traits/detail/c_ctype.hpp	/^inline bool iswnewline(wchar_t ch)$/;"	f	namespace:boost::xpressive::detail	signature:(wchar_t ch)
boost::xpressive::detail::keeper_matcher	xpressive/detail/core/matcher/keeper_matcher.hpp	/^    struct keeper_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::keeper_matcher::keeper_matcher	xpressive/detail/core/matcher/keeper_matcher.hpp	/^        keeper_matcher(Xpr const &xpr, bool pure = Xpr::pure)$/;"	f	struct:boost::xpressive::detail::keeper_matcher	access:public	signature:(Xpr const &xpr, bool pure = Xpr::pure)
boost::xpressive::detail::keeper_matcher::match	xpressive/detail/core/matcher/keeper_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::keeper_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::keeper_matcher::match_	xpressive/detail/core/matcher/keeper_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::keeper_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::false_) const
boost::xpressive::detail::keeper_matcher::match_	xpressive/detail/core/matcher/keeper_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::true_) const$/;"	f	struct:boost::xpressive::detail::keeper_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::true_) const
boost::xpressive::detail::keeper_matcher::pure_	xpressive/detail/core/matcher/keeper_matcher.hpp	/^        bool pure_; \/\/ false if matching xpr_ could modify the sub-matches$/;"	m	struct:boost::xpressive::detail::keeper_matcher	access:public
boost::xpressive::detail::keeper_matcher::xpr_	xpressive/detail/core/matcher/keeper_matcher.hpp	/^        Xpr xpr_;$/;"	m	struct:boost::xpressive::detail::keeper_matcher	access:public
boost::xpressive::detail::keeper_tag	xpressive/detail/static/transforms/as_independent.hpp	/^    struct keeper_tag$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::leading_simple_repeat_finder	xpressive/detail/core/finder.hpp	/^struct leading_simple_repeat_finder$/;"	s	namespace:boost::xpressive::detail	inherits:finder
boost::xpressive::detail::leading_simple_repeat_finder::leading_simple_repeat_finder	xpressive/detail/core/finder.hpp	/^    leading_simple_repeat_finder()$/;"	f	struct:boost::xpressive::detail::leading_simple_repeat_finder	access:public	signature:()
boost::xpressive::detail::leading_simple_repeat_finder::leading_simple_repeat_finder	xpressive/detail/core/finder.hpp	/^    leading_simple_repeat_finder(leading_simple_repeat_finder const &);$/;"	p	struct:boost::xpressive::detail::leading_simple_repeat_finder	access:private	signature:(leading_simple_repeat_finder const &)
boost::xpressive::detail::leading_simple_repeat_finder::operator ()	xpressive/detail/core/finder.hpp	/^    bool operator ()(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::leading_simple_repeat_finder	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::leading_simple_repeat_finder::operator =	xpressive/detail/core/finder.hpp	/^    leading_simple_repeat_finder &operator =(leading_simple_repeat_finder const &);$/;"	p	struct:boost::xpressive::detail::leading_simple_repeat_finder	access:private	signature:(leading_simple_repeat_finder const &)
boost::xpressive::detail::let	xpressive/regex_actions.hpp	/^    detail::let_<proto::terminal<detail::let_tag>::type> const let = {{{}}};$/;"	m	class:boost::xpressive::detail
boost::xpressive::detail::let_	xpressive/regex_actions.hpp	/^        struct let_$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::let_domain	xpressive/regex_actions.hpp	/^        struct let_domain$/;"	s	namespace:boost::xpressive::detail	inherits:boost::proto::domain
boost::xpressive::detail::let_tag	xpressive/regex_actions.hpp	/^        struct let_tag$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::line_start_finder	xpressive/detail/core/finder.hpp	/^struct line_start_finder$/;"	s	namespace:boost::xpressive::detail	inherits:finder
boost::xpressive::detail::line_start_finder	xpressive/detail/core/finder.hpp	/^struct line_start_finder<BidiIter, Traits, 1u>$/;"	s	namespace:boost::xpressive::detail	inherits:finder
boost::xpressive::detail::line_start_finder::bits_	xpressive/detail/core/finder.hpp	/^    bool bits_[256];$/;"	m	struct:boost::xpressive::detail::line_start_finder	access:private
boost::xpressive::detail::line_start_finder::char_class_type	xpressive/detail/core/finder.hpp	/^    typedef typename Traits::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::detail::line_start_finder	access:public
boost::xpressive::detail::line_start_finder::char_type	xpressive/detail/core/finder.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::line_start_finder	access:public
boost::xpressive::detail::line_start_finder::diff_type	xpressive/detail/core/finder.hpp	/^    typedef typename iterator_difference<BidiIter>::type diff_type;$/;"	t	struct:boost::xpressive::detail::line_start_finder	access:public
boost::xpressive::detail::line_start_finder::line_start_finder	xpressive/detail/core/finder.hpp	/^    line_start_finder(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::line_start_finder	access:public	signature:(Traits const &tr)
boost::xpressive::detail::line_start_finder::line_start_finder	xpressive/detail/core/finder.hpp	/^    line_start_finder(line_start_finder const &);$/;"	p	struct:boost::xpressive::detail::line_start_finder	access:private	signature:(line_start_finder const &)
boost::xpressive::detail::line_start_finder::newline_	xpressive/detail/core/finder.hpp	/^    char_class_type newline_;$/;"	m	struct:boost::xpressive::detail::line_start_finder	access:private
boost::xpressive::detail::line_start_finder::operator ()	xpressive/detail/core/finder.hpp	/^    bool operator ()(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::line_start_finder	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::line_start_finder::operator =	xpressive/detail/core/finder.hpp	/^    line_start_finder &operator =(line_start_finder const &);$/;"	p	struct:boost::xpressive::detail::line_start_finder	access:private	signature:(line_start_finder const &)
boost::xpressive::detail::list	xpressive/detail/core/list.hpp	/^    struct list$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::list::_sentry	xpressive/detail/core/list.hpp	/^        node_base _sentry;$/;"	m	struct:boost::xpressive::detail::list	access:private
boost::xpressive::detail::list::back	xpressive/detail/core/list.hpp	/^        const_reference back() const$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:() const
boost::xpressive::detail::list::back	xpressive/detail/core/list.hpp	/^        reference back()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
boost::xpressive::detail::list::begin	xpressive/detail/core/list.hpp	/^        const_iterator begin() const$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:() const
boost::xpressive::detail::list::begin	xpressive/detail/core/list.hpp	/^        iterator begin()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
boost::xpressive::detail::list::clear	xpressive/detail/core/list.hpp	/^        void clear()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
boost::xpressive::detail::list::const_iterator	xpressive/detail/core/list.hpp	/^        typedef list_iterator<T const &> const_iterator;$/;"	t	struct:boost::xpressive::detail::list	access:public
boost::xpressive::detail::list::const_pointer	xpressive/detail/core/list.hpp	/^        typedef T const *const_pointer;$/;"	t	struct:boost::xpressive::detail::list	access:public
boost::xpressive::detail::list::const_reference	xpressive/detail/core/list.hpp	/^        typedef T const &const_reference;$/;"	t	struct:boost::xpressive::detail::list	access:public
boost::xpressive::detail::list::empty	xpressive/detail/core/list.hpp	/^        bool empty() const$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:() const
boost::xpressive::detail::list::end	xpressive/detail/core/list.hpp	/^        const_iterator end() const$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:() const
boost::xpressive::detail::list::end	xpressive/detail/core/list.hpp	/^        iterator end()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
boost::xpressive::detail::list::front	xpressive/detail/core/list.hpp	/^        const_reference front() const$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:() const
boost::xpressive::detail::list::front	xpressive/detail/core/list.hpp	/^        reference front()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
boost::xpressive::detail::list::iterator	xpressive/detail/core/list.hpp	/^        typedef list_iterator<> iterator;$/;"	t	struct:boost::xpressive::detail::list	access:public
boost::xpressive::detail::list::list	xpressive/detail/core/list.hpp	/^        list()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
boost::xpressive::detail::list::list	xpressive/detail/core/list.hpp	/^        list(list const &that)$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:(list const &that)
boost::xpressive::detail::list::list_iterator	xpressive/detail/core/list.hpp	/^        struct list_iterator$/;"	s	struct:boost::xpressive::detail::list	inherits:boost::iterator_facade	access:private
boost::xpressive::detail::list::list_iterator::_node	xpressive/detail/core/list.hpp	/^            node_base *_node;$/;"	m	struct:boost::xpressive::detail::list::list_iterator	access:private
boost::xpressive::detail::list::list_iterator::decrement	xpressive/detail/core/list.hpp	/^            void decrement() { _node = _node->_prev; }$/;"	f	struct:boost::xpressive::detail::list::list_iterator	access:private	signature:()
boost::xpressive::detail::list::list_iterator::dereference	xpressive/detail/core/list.hpp	/^            Ref dereference() const { return static_cast<node *>(_node)->_value; }$/;"	f	struct:boost::xpressive::detail::list::list_iterator	access:private	signature:() const
boost::xpressive::detail::list::list_iterator::equal	xpressive/detail/core/list.hpp	/^            bool equal(list_iterator const &it) const { return _node == it._node; }$/;"	f	struct:boost::xpressive::detail::list::list_iterator	access:private	signature:(list_iterator const &it) const
boost::xpressive::detail::list::list_iterator::increment	xpressive/detail/core/list.hpp	/^            void increment() { _node = _node->_next; }$/;"	f	struct:boost::xpressive::detail::list::list_iterator	access:private	signature:()
boost::xpressive::detail::list::list_iterator::list_iterator	xpressive/detail/core/list.hpp	/^            explicit list_iterator(node_base *n = 0) : _node(n) {}$/;"	f	struct:boost::xpressive::detail::list::list_iterator	access:public	signature:(node_base *n = 0)
boost::xpressive::detail::list::list_iterator::list_iterator	xpressive/detail/core/list.hpp	/^            list_iterator(list_iterator<> const &it) : _node(it._node) {}$/;"	f	struct:boost::xpressive::detail::list::list_iterator	access:public	signature:(list_iterator< const &it)
boost::xpressive::detail::list::node	xpressive/detail/core/list.hpp	/^        struct node : node_base$/;"	s	struct:boost::xpressive::detail::list	inherits:node_base	access:private
boost::xpressive::detail::list::node::_value	xpressive/detail/core/list.hpp	/^            T _value;$/;"	m	struct:boost::xpressive::detail::list::node	access:public
boost::xpressive::detail::list::node::node	xpressive/detail/core/list.hpp	/^            explicit node(T const &value)$/;"	f	struct:boost::xpressive::detail::list::node	access:public	signature:(T const &value)
boost::xpressive::detail::list::node_base	xpressive/detail/core/list.hpp	/^        struct node_base$/;"	s	struct:boost::xpressive::detail::list	access:private
boost::xpressive::detail::list::node_base::_next	xpressive/detail/core/list.hpp	/^            node_base *_next;$/;"	m	struct:boost::xpressive::detail::list::node_base	access:public
boost::xpressive::detail::list::node_base::_prev	xpressive/detail/core/list.hpp	/^            node_base *_prev;$/;"	m	struct:boost::xpressive::detail::list::node_base	access:public
boost::xpressive::detail::list::operator =	xpressive/detail/core/list.hpp	/^        list &operator =(list const &that)$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:(list const &that)
boost::xpressive::detail::list::pointer	xpressive/detail/core/list.hpp	/^        typedef T *pointer;$/;"	t	struct:boost::xpressive::detail::list	access:public
boost::xpressive::detail::list::pop_back	xpressive/detail/core/list.hpp	/^        void pop_back()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
boost::xpressive::detail::list::pop_front	xpressive/detail/core/list.hpp	/^        void pop_front()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
boost::xpressive::detail::list::push_back	xpressive/detail/core/list.hpp	/^        void push_back(T const &t)$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:(T const &t)
boost::xpressive::detail::list::push_front	xpressive/detail/core/list.hpp	/^        void push_front(T const &t)$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:(T const &t)
boost::xpressive::detail::list::reference	xpressive/detail/core/list.hpp	/^        typedef T &reference;$/;"	t	struct:boost::xpressive::detail::list	access:public
boost::xpressive::detail::list::size	xpressive/detail/core/list.hpp	/^        size_type size() const$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:() const
boost::xpressive::detail::list::size_type	xpressive/detail/core/list.hpp	/^        typedef std::size_t size_type;$/;"	t	struct:boost::xpressive::detail::list	access:public
boost::xpressive::detail::list::splice	xpressive/detail/core/list.hpp	/^        void splice(iterator it, list &, iterator xit)$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:(iterator it, list &, iterator xit)
boost::xpressive::detail::list::splice	xpressive/detail/core/list.hpp	/^        void splice(iterator it, list &x)$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:(iterator it, list &x)
boost::xpressive::detail::list::swap	xpressive/detail/core/list.hpp	/^        void swap(list &that) \/\/ throw()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:(list &that)
boost::xpressive::detail::list::~list	xpressive/detail/core/list.hpp	/^        ~list()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
boost::xpressive::detail::literal_matcher	xpressive/detail/core/matcher/literal_matcher.hpp	/^    struct literal_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_fixed_width
boost::xpressive::detail::literal_matcher::ch_	xpressive/detail/core/matcher/literal_matcher.hpp	/^        char_type ch_;$/;"	m	struct:boost::xpressive::detail::literal_matcher	access:public
boost::xpressive::detail::literal_matcher::char_type	xpressive/detail/core/matcher/literal_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::literal_matcher	access:public
boost::xpressive::detail::literal_matcher::icase_type	xpressive/detail/core/matcher/literal_matcher.hpp	/^        typedef ICase icase_type;$/;"	t	struct:boost::xpressive::detail::literal_matcher	access:public
boost::xpressive::detail::literal_matcher::literal_matcher	xpressive/detail/core/matcher/literal_matcher.hpp	/^        explicit literal_matcher(char_type ch)$/;"	f	struct:boost::xpressive::detail::literal_matcher	access:public	signature:(char_type ch)
boost::xpressive::detail::literal_matcher::literal_matcher	xpressive/detail/core/matcher/literal_matcher.hpp	/^        literal_matcher(char_type ch, Traits const &tr)$/;"	f	struct:boost::xpressive::detail::literal_matcher	access:public	signature:(char_type ch, Traits const &tr)
boost::xpressive::detail::literal_matcher::match	xpressive/detail/core/matcher/literal_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::literal_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::literal_matcher::not_type	xpressive/detail/core/matcher/literal_matcher.hpp	/^        typedef Not not_type;$/;"	t	struct:boost::xpressive::detail::literal_matcher	access:public
boost::xpressive::detail::locale_modifier	xpressive/detail/core/linker.hpp	/^struct locale_modifier$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::locale_modifier::apply	xpressive/detail/core/linker.hpp	/^    struct apply {};$/;"	s	struct:boost::xpressive::detail::locale_modifier	access:public
boost::xpressive::detail::locale_modifier::apply	xpressive/detail/core/linker.hpp	/^    struct apply<xpression_visitor<BidiIter, ICase, OtherTraits> >$/;"	s	struct:boost::xpressive::detail::locale_modifier	access:public
boost::xpressive::detail::locale_modifier::apply::traits_type	xpressive/detail/core/linker.hpp	/^        typedef typename regex_traits_type<Locale, BidiIter>::type traits_type;$/;"	t	struct:boost::xpressive::detail::locale_modifier::apply	access:public
boost::xpressive::detail::locale_modifier::apply::type	xpressive/detail/core/linker.hpp	/^        typedef xpression_visitor<BidiIter, ICase, traits_type> type;$/;"	t	struct:boost::xpressive::detail::locale_modifier::apply	access:public
boost::xpressive::detail::locale_modifier::call	xpressive/detail/core/linker.hpp	/^    call(Visitor &visitor) const$/;"	f	struct:boost::xpressive::detail::locale_modifier	access:public	signature:(Visitor &visitor) const
boost::xpressive::detail::locale_modifier::getloc	xpressive/detail/core/linker.hpp	/^    Locale getloc() const$/;"	f	struct:boost::xpressive::detail::locale_modifier	access:public	signature:() const
boost::xpressive::detail::locale_modifier::loc_	xpressive/detail/core/linker.hpp	/^    Locale loc_;$/;"	m	struct:boost::xpressive::detail::locale_modifier	access:private
boost::xpressive::detail::locale_modifier::locale_modifier	xpressive/detail/core/linker.hpp	/^    locale_modifier(Locale const &loc)$/;"	f	struct:boost::xpressive::detail::locale_modifier	access:public	signature:(Locale const &loc)
boost::xpressive::detail::locale_modifier::locale_type	xpressive/detail/core/linker.hpp	/^    typedef Locale locale_type;$/;"	t	struct:boost::xpressive::detail::locale_modifier	access:public
boost::xpressive::detail::logical_newline_matcher	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^    struct logical_newline_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_variable_width
boost::xpressive::detail::logical_newline_matcher::char_class_type	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        typedef typename Traits::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::detail::logical_newline_matcher	access:public
boost::xpressive::detail::logical_newline_matcher::char_type	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::logical_newline_matcher	access:public
boost::xpressive::detail::logical_newline_matcher::cr_	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        char_type nl_, cr_;$/;"	m	struct:boost::xpressive::detail::logical_newline_matcher	access:private
boost::xpressive::detail::logical_newline_matcher::logical_newline_matcher	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        logical_newline_matcher(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::logical_newline_matcher	access:public	signature:(Traits const &tr)
boost::xpressive::detail::logical_newline_matcher::match	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::logical_newline_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::logical_newline_matcher::newline	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        char_class_type newline() const$/;"	f	struct:boost::xpressive::detail::logical_newline_matcher	access:public	signature:() const
boost::xpressive::detail::logical_newline_matcher::newline_	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        char_class_type newline_;$/;"	m	struct:boost::xpressive::detail::logical_newline_matcher	access:private
boost::xpressive::detail::logical_newline_matcher::nl_	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        char_type nl_, cr_;$/;"	m	struct:boost::xpressive::detail::logical_newline_matcher	access:private
boost::xpressive::detail::logical_newline_placeholder	xpressive/detail/static/placeholders.hpp	/^struct logical_newline_placeholder$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::logical_newline_xpression	xpressive/detail/detail_fwd.hpp	/^    typedef proto::expr<proto::tag::terminal, proto::term<logical_newline_placeholder>, 0> logical_newline_xpression;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::lookahead_matcher	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^    struct lookahead_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::lookahead_matcher::inverse	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        void inverse()$/;"	f	struct:boost::xpressive::detail::lookahead_matcher	access:public	signature:()
boost::xpressive::detail::lookahead_matcher::lookahead_matcher	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        lookahead_matcher(Xpr const &xpr, bool no, bool pure = Xpr::pure)$/;"	f	struct:boost::xpressive::detail::lookahead_matcher	access:public	signature:(Xpr const &xpr, bool no, bool pure = Xpr::pure)
boost::xpressive::detail::lookahead_matcher::match	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::lookahead_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::lookahead_matcher::match_	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::lookahead_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::false_) const
boost::xpressive::detail::lookahead_matcher::match_	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::true_) const$/;"	f	struct:boost::xpressive::detail::lookahead_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::true_) const
boost::xpressive::detail::lookahead_matcher::not_	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        bool not_;$/;"	m	struct:boost::xpressive::detail::lookahead_matcher	access:public
boost::xpressive::detail::lookahead_matcher::pure_	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        bool pure_; \/\/ false if matching xpr_ could modify the sub-matches$/;"	m	struct:boost::xpressive::detail::lookahead_matcher	access:public
boost::xpressive::detail::lookahead_matcher::xpr_	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        Xpr xpr_;$/;"	m	struct:boost::xpressive::detail::lookahead_matcher	access:public
boost::xpressive::detail::lookahead_tag	xpressive/detail/static/transforms/as_independent.hpp	/^    struct lookahead_tag$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::lookbehind_matcher	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^    struct lookbehind_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::lookbehind_matcher::inverse	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        void inverse()$/;"	f	struct:boost::xpressive::detail::lookbehind_matcher	access:public	signature:()
boost::xpressive::detail::lookbehind_matcher::lookbehind_matcher	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        lookbehind_matcher(Xpr const &xpr, std::size_t wid, bool no, bool pure = Xpr::pure)$/;"	f	struct:boost::xpressive::detail::lookbehind_matcher	access:public	signature:(Xpr const &xpr, std::size_t wid, bool no, bool pure = Xpr::pure)
boost::xpressive::detail::lookbehind_matcher::match	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::lookbehind_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::lookbehind_matcher::match_	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::lookbehind_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::false_) const
boost::xpressive::detail::lookbehind_matcher::match_	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::true_) const$/;"	f	struct:boost::xpressive::detail::lookbehind_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::true_) const
boost::xpressive::detail::lookbehind_matcher::not_	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        bool not_;$/;"	m	struct:boost::xpressive::detail::lookbehind_matcher	access:public
boost::xpressive::detail::lookbehind_matcher::pure_	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        bool pure_; \/\/ false if matching xpr_ could modify the sub-matches$/;"	m	struct:boost::xpressive::detail::lookbehind_matcher	access:public
boost::xpressive::detail::lookbehind_matcher::width_	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        std::size_t width_;$/;"	m	struct:boost::xpressive::detail::lookbehind_matcher	access:public
boost::xpressive::detail::lookbehind_matcher::xpr_	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        Xpr xpr_;$/;"	m	struct:boost::xpressive::detail::lookbehind_matcher	access:public
boost::xpressive::detail::lookbehind_tag	xpressive/detail/static/transforms/as_independent.hpp	/^    struct lookbehind_tag$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::make_adaptor	xpressive/detail/core/adaptor.hpp	/^inline intrusive_ptr<Base const> make_adaptor(Xpr const &xpr)$/;"	f	namespace:boost::xpressive::detail	signature:(Xpr const &xpr)
boost::xpressive::detail::make_any_xpression	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_any_xpression$/;"	f	namespace:boost::xpressive::detail	signature:( regex_constants::syntax_option_type flags , Traits const &tr )
boost::xpressive::detail::make_assert_begin_line	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_assert_begin_line$/;"	f	namespace:boost::xpressive::detail	signature:( regex_constants::syntax_option_type flags , Traits const &tr )
boost::xpressive::detail::make_assert_end_line	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_assert_end_line$/;"	f	namespace:boost::xpressive::detail	signature:( regex_constants::syntax_option_type flags , Traits const &tr )
boost::xpressive::detail::make_assert_word	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_assert_word(Cond, Traits const &tr)$/;"	f	namespace:boost::xpressive::detail	signature:(Cond, Traits const &tr)
boost::xpressive::detail::make_backref_xpression	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_backref_xpression$/;"	f	namespace:boost::xpressive::detail	signature:( int mark_nbr , regex_constants::syntax_option_type flags , Traits const &tr )
boost::xpressive::detail::make_char_xpression	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_char_xpression$/;"	f	namespace:boost::xpressive::detail	signature:( Char ch , regex_constants::syntax_option_type flags , Traits const &tr )
boost::xpressive::detail::make_charset_xpression	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_charset_xpression$/;"	f	namespace:boost::xpressive::detail	signature:( compound_charset<Traits> &chset , Traits const &tr , regex_constants::syntax_option_type flags )
boost::xpressive::detail::make_dynamic	xpressive/detail/detail_fwd.hpp	/^    sequence<BidiIter> make_dynamic(Matcher const &matcher);$/;"	p	namespace:boost::xpressive::detail	signature:(Matcher const &matcher)
boost::xpressive::detail::make_dynamic	xpressive/detail/dynamic/dynamic.hpp	/^inline sequence<BidiIter> make_dynamic(Matcher const &matcher)$/;"	f	namespace:boost::xpressive::detail	signature:(Matcher const &matcher)
boost::xpressive::detail::make_function	xpressive/regex_actions.hpp	/^        typedef boost::proto::functional::make_expr<proto::tag::function, proto::default_domain> make_function;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::make_function::impl::as	xpressive/regex_actions.hpp	/^    as(A const &a)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A const &a)
boost::xpressive::detail::make_function::impl::const_cast_	xpressive/regex_actions.hpp	/^    const_cast_(A const &a)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A const &a)
boost::xpressive::detail::make_function::impl::dynamic_cast_	xpressive/regex_actions.hpp	/^    dynamic_cast_(A const &a)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A const &a)
boost::xpressive::detail::make_function::impl::static_cast_	xpressive/regex_actions.hpp	/^    static_cast_(A const &a)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A const &a)
boost::xpressive::detail::make_independent_end_xpression	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_independent_end_xpression(bool pure)$/;"	f	namespace:boost::xpressive::detail	signature:(bool pure)
boost::xpressive::detail::make_literal_xpression	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_literal_xpression$/;"	f	namespace:boost::xpressive::detail	signature:( typename Traits::string_type const &literal , regex_constants::syntax_option_type flags , Traits const &tr )
boost::xpressive::detail::make_optional	xpressive/detail/detail_fwd.hpp	/^    void make_optional(quant_spec const &spec, sequence<BidiIter> &seq);$/;"	p	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq)
boost::xpressive::detail::make_optional	xpressive/detail/detail_fwd.hpp	/^    void make_optional(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr);$/;"	p	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr)
boost::xpressive::detail::make_optional	xpressive/detail/dynamic/dynamic.hpp	/^make_optional(quant_spec const &spec, sequence<BidiIter> &seq)$/;"	f	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq)
boost::xpressive::detail::make_optional	xpressive/detail/dynamic/dynamic.hpp	/^make_optional(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr)$/;"	f	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr)
boost::xpressive::detail::make_posix_charset_xpression	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_posix_charset_xpression$/;"	f	namespace:boost::xpressive::detail	signature:( typename Traits::char_class_type m , bool no , regex_constants::syntax_option_type , Traits const & )
boost::xpressive::detail::make_repeat	xpressive/detail/detail_fwd.hpp	/^    void make_repeat(quant_spec const &spec, sequence<BidiIter> &seq);$/;"	p	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq)
boost::xpressive::detail::make_repeat	xpressive/detail/detail_fwd.hpp	/^    void make_repeat(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr);$/;"	p	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr)
boost::xpressive::detail::make_repeat	xpressive/detail/dynamic/dynamic.hpp	/^make_repeat(quant_spec const &spec, sequence<BidiIter> &seq)$/;"	f	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq)
boost::xpressive::detail::make_repeat	xpressive/detail/dynamic/dynamic.hpp	/^make_repeat(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr)$/;"	f	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr)
boost::xpressive::detail::make_simple_repeat	xpressive/detail/detail_fwd.hpp	/^    void make_simple_repeat(quant_spec const &spec, sequence<BidiIter> &seq);$/;"	p	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq)
boost::xpressive::detail::make_simple_repeat	xpressive/detail/detail_fwd.hpp	/^    void make_simple_repeat(quant_spec const &spec, sequence<BidiIter> &seq, Xpr const &xpr);$/;"	p	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq, Xpr const &xpr)
boost::xpressive::detail::make_simple_repeat	xpressive/detail/dynamic/dynamic.hpp	/^make_simple_repeat(quant_spec const &spec, sequence<BidiIter> &seq)$/;"	f	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq)
boost::xpressive::detail::make_simple_repeat	xpressive/detail/dynamic/dynamic.hpp	/^make_simple_repeat(quant_spec const &spec, sequence<BidiIter> &seq, Xpr const &xpr)$/;"	f	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq, Xpr const &xpr)
boost::xpressive::detail::make_static	xpressive/detail/detail_fwd.hpp	/^    make_static(Matcher const &matcher);$/;"	p	namespace:boost::xpressive::detail	signature:(Matcher const &matcher)
boost::xpressive::detail::make_static	xpressive/detail/detail_fwd.hpp	/^    make_static(Matcher const &matcher, Next const &next);$/;"	p	namespace:boost::xpressive::detail	signature:(Matcher const &matcher, Next const &next)
boost::xpressive::detail::make_static	xpressive/detail/static/static.hpp	/^make_static(Matcher const &matcher)$/;"	f	namespace:boost::xpressive::detail	signature:(Matcher const &matcher)
boost::xpressive::detail::make_static	xpressive/detail/static/static.hpp	/^make_static(Matcher const &matcher, Next const &next)$/;"	f	namespace:boost::xpressive::detail	signature:(Matcher const &matcher, Next const &next)
boost::xpressive::detail::mark_begin_matcher	xpressive/detail/core/matcher/mark_begin_matcher.hpp	/^    struct mark_begin_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::mark_begin_matcher::mark_begin_matcher	xpressive/detail/core/matcher/mark_begin_matcher.hpp	/^        mark_begin_matcher(int mark_number)$/;"	f	struct:boost::xpressive::detail::mark_begin_matcher	access:public	signature:(int mark_number)
boost::xpressive::detail::mark_begin_matcher::mark_number_	xpressive/detail/core/matcher/mark_begin_matcher.hpp	/^        int mark_number_; \/\/ signed because it could be negative$/;"	m	struct:boost::xpressive::detail::mark_begin_matcher	access:public
boost::xpressive::detail::mark_begin_matcher::match	xpressive/detail/core/matcher/mark_begin_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::mark_begin_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::mark_end_matcher	xpressive/detail/core/matcher/mark_end_matcher.hpp	/^    struct mark_end_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::mark_end_matcher::mark_end_matcher	xpressive/detail/core/matcher/mark_end_matcher.hpp	/^        mark_end_matcher(int mark_number)$/;"	f	struct:boost::xpressive::detail::mark_end_matcher	access:public	signature:(int mark_number)
boost::xpressive::detail::mark_end_matcher::mark_number_	xpressive/detail/core/matcher/mark_end_matcher.hpp	/^        int mark_number_;$/;"	m	struct:boost::xpressive::detail::mark_end_matcher	access:public
boost::xpressive::detail::mark_end_matcher::match	xpressive/detail/core/matcher/mark_end_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::mark_end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::mark_matcher	xpressive/detail/core/matcher/mark_matcher.hpp	/^    struct mark_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_variable_width
boost::xpressive::detail::mark_matcher::icase_type	xpressive/detail/core/matcher/mark_matcher.hpp	/^        typedef ICase icase_type;$/;"	t	struct:boost::xpressive::detail::mark_matcher	access:public
boost::xpressive::detail::mark_matcher::mark_matcher	xpressive/detail/core/matcher/mark_matcher.hpp	/^        mark_matcher(int mark_number, Traits const &)$/;"	f	struct:boost::xpressive::detail::mark_matcher	access:public	signature:(int mark_number, Traits const &)
boost::xpressive::detail::mark_matcher::mark_number_	xpressive/detail/core/matcher/mark_matcher.hpp	/^        int mark_number_;$/;"	m	struct:boost::xpressive::detail::mark_matcher	access:public
boost::xpressive::detail::mark_matcher::match	xpressive/detail/core/matcher/mark_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::mark_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::mark_nbr	xpressive/regex_actions.hpp	/^        struct mark_nbr$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::mark_nbr::operator ()	xpressive/regex_actions.hpp	/^            int operator()(mark_placeholder m) const$/;"	f	struct:boost::xpressive::detail::mark_nbr	access:public	signature:(mark_placeholder m) const
boost::xpressive::detail::mark_nbr::result_type	xpressive/regex_actions.hpp	/^            typedef int result_type;$/;"	t	struct:boost::xpressive::detail::mark_nbr	access:public
boost::xpressive::detail::mark_number	xpressive/regex_primitives.hpp	/^    struct mark_number : proto::callable$/;"	s	namespace:boost::xpressive::detail	inherits:proto::callable
boost::xpressive::detail::mark_number::operator ()	xpressive/regex_primitives.hpp	/^        int operator ()(Expr const &expr) const$/;"	f	struct:boost::xpressive::detail::mark_number	access:public	signature:(Expr const &expr) const
boost::xpressive::detail::mark_number::result_type	xpressive/regex_primitives.hpp	/^        typedef int result_type;$/;"	t	struct:boost::xpressive::detail::mark_number	access:public
boost::xpressive::detail::mark_placeholder	xpressive/detail/static/placeholders.hpp	/^struct mark_placeholder$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::mark_placeholder::mark_number_	xpressive/detail/static/placeholders.hpp	/^    int mark_number_;$/;"	m	struct:boost::xpressive::detail::mark_placeholder	access:public
boost::xpressive::detail::mark_transform	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct mark_transform : proto::transform<mark_transform>$/;"	s	namespace:boost::xpressive::detail	inherits:proto::transform
boost::xpressive::detail::mark_transform::impl	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::detail::mark_transform	inherits:proto::transform_impl	access:public
boost::xpressive::detail::mark_transform::impl::operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::detail::mark_transform::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param ) const
boost::xpressive::detail::mark_transform::impl::result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::detail::mark_transform::impl	access:public
boost::xpressive::detail::mark_transform::impl::state_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            typedef typename impl::state state_type;$/;"	t	struct:boost::xpressive::detail::mark_transform::impl	access:public
boost::xpressive::detail::mask_cast	xpressive/traits/cpp_regex_traits.hpp	/^    struct mask_cast$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::mask_cast	xpressive/traits/cpp_regex_traits.hpp	/^    struct mask_cast<std::ctype_base::print>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::mask_cast::BOOST_STATIC_CONSTANT	xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = 0227);$/;"	p	struct:boost::xpressive::detail::mask_cast	access:public	signature:(umaskex_t, value = 0227)
boost::xpressive::detail::mask_cast::BOOST_STATIC_CONSTANT	xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = static_cast<umask_t>(Mask));$/;"	p	struct:boost::xpressive::detail::mask_cast	access:public	signature:(umaskex_t, value = static_cast<umask_t>(Mask))
boost::xpressive::detail::mask_cast::value	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const mask_cast<Mask>::value;$/;"	m	class:boost::xpressive::detail::mask_cast
boost::xpressive::detail::match_context	xpressive/detail/core/state.hpp	/^struct match_context$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::match_context::char_type	xpressive/detail/core/state.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::match_context	access:public
boost::xpressive::detail::match_context::detail::traits_	xpressive/detail/core/state.hpp	/^    detail::traits<char_type> const *traits_;$/;"	m	class:boost::xpressive::detail::match_context::detail	access:public
boost::xpressive::detail::match_context::match_context	xpressive/detail/core/state.hpp	/^    match_context()$/;"	f	struct:boost::xpressive::detail::match_context	access:public	signature:()
boost::xpressive::detail::match_context::next_ptr_	xpressive/detail/core/state.hpp	/^    matchable<BidiIter> const *next_ptr_;$/;"	m	struct:boost::xpressive::detail::match_context	access:public
boost::xpressive::detail::match_context::prev_context_	xpressive/detail/core/state.hpp	/^    match_context<BidiIter> *prev_context_;$/;"	m	struct:boost::xpressive::detail::match_context	access:public
boost::xpressive::detail::match_context::results_ptr_	xpressive/detail/core/state.hpp	/^    match_results<BidiIter> *results_ptr_;$/;"	m	struct:boost::xpressive::detail::match_context	access:public
boost::xpressive::detail::match_flags	xpressive/detail/core/state.hpp	/^struct match_flags$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::match_flags::match_all_	xpressive/detail/core/state.hpp	/^    bool match_all_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
boost::xpressive::detail::match_flags::match_bol_	xpressive/detail/core/state.hpp	/^    bool match_bol_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
boost::xpressive::detail::match_flags::match_continuous_	xpressive/detail/core/state.hpp	/^    bool match_continuous_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
boost::xpressive::detail::match_flags::match_eol_	xpressive/detail/core/state.hpp	/^    bool match_eol_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
boost::xpressive::detail::match_flags::match_flags	xpressive/detail/core/state.hpp	/^    explicit match_flags(regex_constants::match_flag_type flags)$/;"	f	struct:boost::xpressive::detail::match_flags	access:public	signature:(regex_constants::match_flag_type flags)
boost::xpressive::detail::match_flags::match_not_bow_	xpressive/detail/core/state.hpp	/^    bool match_not_bow_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
boost::xpressive::detail::match_flags::match_not_eow_	xpressive/detail/core/state.hpp	/^    bool match_not_eow_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
boost::xpressive::detail::match_flags::match_not_null_	xpressive/detail/core/state.hpp	/^    bool match_not_null_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
boost::xpressive::detail::match_flags::match_partial_	xpressive/detail/core/state.hpp	/^    bool match_partial_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
boost::xpressive::detail::match_flags::match_prev_avail_	xpressive/detail/core/state.hpp	/^    bool match_prev_avail_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
boost::xpressive::detail::match_next	xpressive/detail/core/matcher/optional_matcher.hpp	/^    inline bool match_next(match_state<BidiIter> &state, Next const &next, int mark_number)$/;"	f	namespace:boost::xpressive::detail	signature:(match_state<BidiIter> &state, Next const &next, int mark_number)
boost::xpressive::detail::match_state	xpressive/detail/core/state.hpp	/^struct match_state$/;"	s	namespace:boost::xpressive::detail	inherits:noncopyable
boost::xpressive::detail::match_state::access	xpressive/detail/core/state.hpp	/^    typedef core_access<BidiIter> access;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::action_args_	xpressive/detail/core/state.hpp	/^    action_args_type *action_args_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::action_list_	xpressive/detail/core/state.hpp	/^    actionable action_list_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::action_list_tail_	xpressive/detail/core/state.hpp	/^    actionable const **action_list_tail_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::actionable	xpressive/detail/core/state.hpp	/^    typedef detail::actionable actionable;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::attr_context_	xpressive/detail/core/state.hpp	/^    attr_context attr_context_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::begin_	xpressive/detail/core/state.hpp	/^    BidiIter begin_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::bos	xpressive/detail/core/state.hpp	/^    bool bos() const$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:() const
boost::xpressive::detail::match_state::context_	xpressive/detail/core/state.hpp	/^    match_context context_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::cur_	xpressive/detail/core/state.hpp	/^    BidiIter cur_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::end_	xpressive/detail/core/state.hpp	/^    BidiIter end_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::eos	xpressive/detail/core/state.hpp	/^    bool eos()$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:()
boost::xpressive::detail::match_state::extras_	xpressive/detail/core/state.hpp	/^    results_extras *extras_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::flags_	xpressive/detail/core/state.hpp	/^    match_flags flags_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::found_partial_match	xpressive/detail/core/state.hpp	/^    bool found_partial_match()$/;"	f	struct:boost::xpressive::detail::match_state	access:private	signature:()
boost::xpressive::detail::match_state::found_partial_match_	xpressive/detail/core/state.hpp	/^    bool found_partial_match_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::get_traits	xpressive/detail/core/state.hpp	/^    Traits const &get_traits() const$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:() const
boost::xpressive::detail::match_state::init_	xpressive/detail/core/state.hpp	/^    void init_(regex_impl const &impl, match_results &what)$/;"	f	struct:boost::xpressive::detail::match_state	access:private	signature:(regex_impl const &impl, match_results &what)
boost::xpressive::detail::match_state::is_active_regex	xpressive/detail/core/state.hpp	/^    bool is_active_regex(regex_impl const &impl) const$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:(regex_impl const &impl) const
boost::xpressive::detail::match_state::iterator	xpressive/detail/core/state.hpp	/^    typedef BidiIter iterator;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::mark_count_	xpressive/detail/core/state.hpp	/^    std::size_t mark_count_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::match_context	xpressive/detail/core/state.hpp	/^    typedef detail::match_context<BidiIter> match_context;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::match_results	xpressive/detail/core/state.hpp	/^    typedef xpressive::match_results<BidiIter> match_results;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::match_state	xpressive/detail/core/state.hpp	/^    match_state$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:( BidiIter begin , BidiIter end , match_results &what , regex_impl const &impl , regex_constants::match_flag_type flags )
boost::xpressive::detail::match_state::matchable	xpressive/detail/core/state.hpp	/^    typedef detail::matchable<BidiIter> matchable;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::next_search_	xpressive/detail/core/state.hpp	/^    BidiIter next_search_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::pop_context	xpressive/detail/core/state.hpp	/^    bool pop_context(regex_impl const &impl, bool success)$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:(regex_impl const &impl, bool success)
boost::xpressive::detail::match_state::push_context	xpressive/detail/core/state.hpp	/^    match_context push_context(regex_impl const &impl, matchable const &next, match_context &prev)$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:(regex_impl const &impl, matchable const &next, match_context &prev)
boost::xpressive::detail::match_state::regex_impl	xpressive/detail/core/state.hpp	/^    typedef detail::regex_impl<BidiIter> regex_impl;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::reset	xpressive/detail/core/state.hpp	/^    void reset(match_results &what, regex_impl const &impl)$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:(match_results &what, regex_impl const &impl)
boost::xpressive::detail::match_state::results_extras	xpressive/detail/core/state.hpp	/^    typedef detail::results_extras<BidiIter> results_extras;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::set_partial_match	xpressive/detail/core/state.hpp	/^    void set_partial_match()$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:()
boost::xpressive::detail::match_state::sub_match	xpressive/detail/core/state.hpp	/^    sub_match_impl &sub_match(int n)$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:(int n)
boost::xpressive::detail::match_state::sub_match_impl	xpressive/detail/core/state.hpp	/^    typedef detail::sub_match_impl<BidiIter> sub_match_impl;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::sub_matches_	xpressive/detail/core/state.hpp	/^    sub_match_impl *sub_matches_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
boost::xpressive::detail::match_state::swap_context	xpressive/detail/core/state.hpp	/^    void swap_context(match_context &context)$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:(match_context &context)
boost::xpressive::detail::match_state::uninit_	xpressive/detail/core/state.hpp	/^    void uninit_(regex_impl const &impl, match_results &)$/;"	f	struct:boost::xpressive::detail::match_state	access:private	signature:(regex_impl const &impl, match_results &)
boost::xpressive::detail::matchable	xpressive/detail/dynamic/matchable.hpp	/^struct matchable$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::matchable::char_type	xpressive/detail/dynamic/matchable.hpp	/^    typedef typename iterator_value<iterator_type>::type char_type;$/;"	t	struct:boost::xpressive::detail::matchable	access:public
boost::xpressive::detail::matchable::iterator_type	xpressive/detail/dynamic/matchable.hpp	/^    typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::detail::matchable	access:public
boost::xpressive::detail::matchable::match	xpressive/detail/dynamic/matchable.hpp	/^    virtual bool match(match_state<BidiIter> &state) const = 0;$/;"	p	struct:boost::xpressive::detail::matchable	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::matchable::~matchable	xpressive/detail/dynamic/matchable.hpp	/^    virtual ~matchable() {}$/;"	f	struct:boost::xpressive::detail::matchable	access:public	signature:()
boost::xpressive::detail::matchable_ex	xpressive/detail/dynamic/matchable.hpp	/^struct matchable_ex$/;"	s	namespace:boost::xpressive::detail	inherits:matchable,counted_base
boost::xpressive::detail::matchable_ex::char_type	xpressive/detail/dynamic/matchable.hpp	/^    typedef typename iterator_value<iterator_type>::type char_type;$/;"	t	struct:boost::xpressive::detail::matchable_ex	access:public
boost::xpressive::detail::matchable_ex::iterator_type	xpressive/detail/dynamic/matchable.hpp	/^    typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::detail::matchable_ex	access:public
boost::xpressive::detail::matchable_ex::link	xpressive/detail/dynamic/matchable.hpp	/^    virtual void link(xpression_linker<char_type> &) const$/;"	f	struct:boost::xpressive::detail::matchable_ex	access:public	signature:(xpression_linker<char_type> &) const
boost::xpressive::detail::matchable_ex::peek	xpressive/detail/dynamic/matchable.hpp	/^    virtual void peek(xpression_peeker<char_type> &peeker) const$/;"	f	struct:boost::xpressive::detail::matchable_ex	access:public	signature:(xpression_peeker<char_type> &peeker) const
boost::xpressive::detail::matchable_ex::pop_match	xpressive/detail/dynamic/matchable.hpp	/^    static bool pop_match(match_state<BidiIter> &state, void const *top)$/;"	f	struct:boost::xpressive::detail::matchable_ex	access:public	signature:(match_state<BidiIter> &state, void const *top)
boost::xpressive::detail::matchable_ex::push_match	xpressive/detail/dynamic/matchable.hpp	/^    bool push_match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::matchable_ex	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::matchable_ex::repeat	xpressive/detail/dynamic/matchable.hpp	/^    virtual void repeat(quant_spec const &, sequence<BidiIter> &) const$/;"	f	struct:boost::xpressive::detail::matchable_ex	access:public	signature:(quant_spec const &, sequence<BidiIter> &) const
boost::xpressive::detail::matchable_ex::skip_match	xpressive/detail/dynamic/matchable.hpp	/^    bool skip_match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::matchable_ex	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::matchable_ex::top_match	xpressive/detail/dynamic/matchable.hpp	/^    static bool top_match(match_state<BidiIter> &state, void const *top)$/;"	f	struct:boost::xpressive::detail::matchable_ex	access:public	signature:(match_state<BidiIter> &state, void const *top)
boost::xpressive::detail::matcher_wrapper	xpressive/detail/dynamic/dynamic.hpp	/^struct matcher_wrapper$/;"	s	namespace:boost::xpressive::detail	inherits:Matcher
boost::xpressive::detail::matcher_wrapper::link	xpressive/detail/dynamic/dynamic.hpp	/^    void link(xpression_linker<Char> &linker) const$/;"	f	struct:boost::xpressive::detail::matcher_wrapper	access:public	signature:(xpression_linker<Char> &linker) const
boost::xpressive::detail::matcher_wrapper::match	xpressive/detail/dynamic/dynamic.hpp	/^    bool match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::matcher_wrapper	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::matcher_wrapper::matcher_wrapper	xpressive/detail/dynamic/dynamic.hpp	/^    matcher_wrapper(Matcher const &matcher = Matcher())$/;"	f	struct:boost::xpressive::detail::matcher_wrapper	access:public	signature:(Matcher const &matcher = Matcher())
boost::xpressive::detail::matcher_wrapper::peek	xpressive/detail/dynamic/dynamic.hpp	/^    void peek(xpression_peeker<Char> &peeker) const$/;"	f	struct:boost::xpressive::detail::matcher_wrapper	access:public	signature:(xpression_peeker<Char> &peeker) const
boost::xpressive::detail::mem_ptr_eval	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct mem_ptr_eval$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::mem_ptr_eval	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct mem_ptr_eval<Expr, Context, true>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::mem_ptr_eval::evaluated_args	xpressive/detail/core/matcher/action_matcher.hpp	/^        evaluated_args;$/;"	t	struct:boost::xpressive::detail::mem_ptr_eval	access:public
boost::xpressive::detail::mem_ptr_eval::function_type	xpressive/detail/core/matcher/action_matcher.hpp	/^        function_type;$/;"	t	struct:boost::xpressive::detail::mem_ptr_eval	access:public
boost::xpressive::detail::mem_ptr_eval::left_type	xpressive/detail/core/matcher/action_matcher.hpp	/^        typedef typename child_<Expr, 0>::type left_type;$/;"	t	struct:boost::xpressive::detail::mem_ptr_eval	access:public
boost::xpressive::detail::mem_ptr_eval::operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^        result_type operator()(Expr &expr, Context &ctx) const$/;"	f	struct:boost::xpressive::detail::mem_ptr_eval	access:public	signature:(Expr &expr, Context &ctx) const
boost::xpressive::detail::mem_ptr_eval::result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^        >::type result_type;$/;"	t	struct:boost::xpressive::detail::mem_ptr_eval	access:public
boost::xpressive::detail::mem_ptr_eval::result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^        result_type;$/;"	t	struct:boost::xpressive::detail::mem_ptr_eval	access:public
boost::xpressive::detail::mem_ptr_eval::right_type	xpressive/detail/core/matcher/action_matcher.hpp	/^        typedef typename child_<Expr, 1>::type right_type;$/;"	t	struct:boost::xpressive::detail::mem_ptr_eval	access:public
boost::xpressive::detail::memento	xpressive/detail/core/state.hpp	/^struct memento$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::memento::action_list_head_	xpressive/detail/core/state.hpp	/^    actionable const *action_list_head_;$/;"	m	struct:boost::xpressive::detail::memento	access:public
boost::xpressive::detail::memento::action_list_tail_	xpressive/detail/core/state.hpp	/^    actionable const **action_list_tail_;$/;"	m	struct:boost::xpressive::detail::memento	access:public
boost::xpressive::detail::memento::attr_context_	xpressive/detail/core/state.hpp	/^    attr_context attr_context_;$/;"	m	struct:boost::xpressive::detail::memento	access:public
boost::xpressive::detail::memento::nested_results_count_	xpressive/detail/core/state.hpp	/^    std::size_t nested_results_count_;$/;"	m	struct:boost::xpressive::detail::memento	access:public
boost::xpressive::detail::memento::old_sub_matches_	xpressive/detail/core/state.hpp	/^    sub_match_impl<BidiIter> *old_sub_matches_;$/;"	m	struct:boost::xpressive::detail::memento	access:public
boost::xpressive::detail::merge_charset	xpressive/detail/dynamic/parser.hpp	/^inline void merge_charset$/;"	f	namespace:boost::xpressive::detail	signature:( basic_chset<Char> &basic , compound_charset<Traits> const &compound , Traits const &tr )
boost::xpressive::detail::minus_one	xpressive/regex_primitives.hpp	/^    typedef mpl::int_<-1> minus_one;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::modifier_op	xpressive/detail/static/modifier.hpp	/^    struct modifier_op$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::modifier_op::apply	xpressive/detail/static/modifier.hpp	/^        struct apply$/;"	s	struct:boost::xpressive::detail::modifier_op	access:public
boost::xpressive::detail::modifier_op::apply::operator ()	xpressive/detail/static/modifier.hpp	/^        operator ()(Expr const &expr) const$/;"	f	class:boost::xpressive::detail::modifier_op::apply	access:public	signature:(Expr const &expr) const
boost::xpressive::detail::modifier_op::apply::type	xpressive/detail/static/modifier.hpp	/^            >::type type;$/;"	t	struct:boost::xpressive::detail::modifier_op::apply	access:public
boost::xpressive::detail::modifier_op::mod_	xpressive/detail/static/modifier.hpp	/^        Modifier mod_;$/;"	m	struct:boost::xpressive::detail::modifier_op	access:public
boost::xpressive::detail::modifier_op::operator opt_type	xpressive/detail/static/modifier.hpp	/^        operator opt_type() const$/;"	f	struct:boost::xpressive::detail::modifier_op	access:public	signature:() const
boost::xpressive::detail::modifier_op::opt_	xpressive/detail/static/modifier.hpp	/^        opt_type opt_;$/;"	m	struct:boost::xpressive::detail::modifier_op	access:public
boost::xpressive::detail::modifier_op::opt_type	xpressive/detail/static/modifier.hpp	/^        typedef regex_constants::syntax_option_type opt_type;$/;"	t	struct:boost::xpressive::detail::modifier_op	access:public
boost::xpressive::detail::modifier_tag	xpressive/detail/static/transforms/as_modifier.hpp	/^    struct modifier_tag$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::mylog2	xpressive/traits/cpp_regex_traits.hpp	/^    inline int mylog2(umaskex_t i)$/;"	f	namespace:boost::xpressive::detail	signature:(umaskex_t i)
boost::xpressive::detail::named_mark	xpressive/detail/core/regex_impl.hpp	/^struct named_mark$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::named_mark::mark_nbr_	xpressive/detail/core/regex_impl.hpp	/^    std::size_t mark_nbr_;$/;"	m	struct:boost::xpressive::detail::named_mark	access:public
boost::xpressive::detail::named_mark::name_	xpressive/detail/core/regex_impl.hpp	/^    string_type name_;$/;"	m	struct:boost::xpressive::detail::named_mark	access:public
boost::xpressive::detail::named_mark::named_mark	xpressive/detail/core/regex_impl.hpp	/^    named_mark(string_type name, std::size_t mark_nbr)$/;"	f	struct:boost::xpressive::detail::named_mark	access:public	signature:(string_type name, std::size_t mark_nbr)
boost::xpressive::detail::named_mark::string_type	xpressive/detail/core/regex_impl.hpp	/^    typedef typename detail::string_type<Char>::type string_type;$/;"	t	struct:boost::xpressive::detail::named_mark	access:public
boost::xpressive::detail::nested_results	xpressive/detail/core/results_cache.hpp	/^    struct nested_results$/;"	s	namespace:boost::xpressive::detail	inherits:detail::list
boost::xpressive::detail::never_true	xpressive/detail/utility/never_true.hpp	/^    struct never_true$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::no_next	xpressive/detail/static/static.hpp	/^struct no_next$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::no_next::BOOST_STATIC_CONSTANT	xpressive/detail/static/static.hpp	/^    BOOST_STATIC_CONSTANT(bool, pure = true);$/;"	p	struct:boost::xpressive::detail::no_next	access:public	signature:(bool, pure = true)
boost::xpressive::detail::no_next::BOOST_STATIC_CONSTANT	xpressive/detail/static/static.hpp	/^    BOOST_STATIC_CONSTANT(std::size_t, width = 0);$/;"	p	struct:boost::xpressive::detail::no_next	access:public	signature:(std::size_t, width = 0)
boost::xpressive::detail::no_next::get_width	xpressive/detail/static/static.hpp	/^    detail::width get_width() const$/;"	f	struct:boost::xpressive::detail::no_next	access:public	signature:() const
boost::xpressive::detail::no_next::link	xpressive/detail/static/static.hpp	/^    void link(xpression_linker<Char> &) const$/;"	f	struct:boost::xpressive::detail::no_next	access:public	signature:(xpression_linker<Char> &) const
boost::xpressive::detail::no_next::peek	xpressive/detail/static/static.hpp	/^    void peek(xpression_peeker<Char> &peeker) const$/;"	f	struct:boost::xpressive::detail::no_next	access:public	signature:(xpression_peeker<Char> &peeker) const
boost::xpressive::detail::no_type	xpressive/match_results.hpp	/^typedef char no_type;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::non_greedy_tag	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    struct non_greedy_tag {};$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::non_std_ctype_blank	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_blank = 1 << 12;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::non_std_ctype_blank	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_blank = unused_mask<all_ctype_masks | non_std_ctype_underscore>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::non_std_ctype_masks	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_masks = non_std_ctype_underscore | non_std_ctype_blank | non_std_ctype_newline;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::non_std_ctype_newline	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_newline = 1 << 13;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::non_std_ctype_newline	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_newline = unused_mask<all_ctype_masks | non_std_ctype_underscore | non_std_ctype_blank>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::non_std_ctype_underscore	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_underscore = 1 << 11;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::non_std_ctype_underscore	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_underscore = unused_mask<all_ctype_masks>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::noop_output_iterator	xpressive/match_results.hpp	/^struct noop_output_iterator$/;"	s	namespace:boost::xpressive::detail	inherits:std::iterator
boost::xpressive::detail::noop_output_iterator::operator *	xpressive/match_results.hpp	/^    noop_output_iterator &operator *()$/;"	f	struct:boost::xpressive::detail::noop_output_iterator	access:public	signature:()
boost::xpressive::detail::noop_output_iterator::operator ++	xpressive/match_results.hpp	/^    noop_output_iterator &operator ++()$/;"	f	struct:boost::xpressive::detail::noop_output_iterator	access:public	signature:()
boost::xpressive::detail::noop_output_iterator::operator ++	xpressive/match_results.hpp	/^    noop_output_iterator &operator ++(int)$/;"	f	struct:boost::xpressive::detail::noop_output_iterator	access:public	signature:(int)
boost::xpressive::detail::noop_output_iterator::operator =	xpressive/match_results.hpp	/^    noop_output_iterator &operator =(Char const &)$/;"	f	struct:boost::xpressive::detail::noop_output_iterator	access:public	signature:(Char const &)
boost::xpressive::detail::not_a_locale	xpressive/traits/null_regex_traits.hpp	/^    struct not_a_locale {};$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::op_lower	xpressive/match_results.hpp	/^enum transform_op { op_none = 0, op_upper = 1, op_lower = 2 };$/;"	e	enum:boost::xpressive::detail::transform_op
boost::xpressive::detail::op_none	xpressive/match_results.hpp	/^enum transform_op { op_none = 0, op_upper = 1, op_lower = 2 };$/;"	e	enum:boost::xpressive::detail::transform_op
boost::xpressive::detail::op_upper	xpressive/match_results.hpp	/^enum transform_op { op_none = 0, op_upper = 1, op_lower = 2 };$/;"	e	enum:boost::xpressive::detail::transform_op
boost::xpressive::detail::operator !=	xpressive/detail/utility/width.hpp	/^inline bool operator !=(width const &left, width const &right)$/;"	f	namespace:boost::xpressive::detail	signature:(width const &left, width const &right)
boost::xpressive::detail::operator +	xpressive/detail/dynamic/sequence.hpp	/^inline sequence<BidiIter> operator +(sequence<BidiIter> left, sequence<BidiIter> const &right)$/;"	f	namespace:boost::xpressive::detail	signature:(sequence<BidiIter> left, sequence<BidiIter> const &right)
boost::xpressive::detail::operator +	xpressive/detail/utility/width.hpp	/^inline width operator +(width left, width const &right)$/;"	f	namespace:boost::xpressive::detail	signature:(width left, width const &right)
boost::xpressive::detail::operator ==	xpressive/detail/utility/width.hpp	/^inline bool operator ==(width const &left, width const &right)$/;"	f	namespace:boost::xpressive::detail	signature:(width const &left, width const &right)
boost::xpressive::detail::operator |	xpressive/detail/dynamic/sequence.hpp	/^inline sequence<BidiIter> operator |(sequence<BidiIter> left, sequence<BidiIter> const &right)$/;"	f	namespace:boost::xpressive::detail	signature:(sequence<BidiIter> left, sequence<BidiIter> const &right)
boost::xpressive::detail::operator |	xpressive/detail/utility/width.hpp	/^inline width operator |(width left, width const &right)$/;"	f	namespace:boost::xpressive::detail	signature:(width left, width const &right)
boost::xpressive::detail::opt	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct opt$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::opt::operator reference	xpressive/detail/core/matcher/action_matcher.hpp	/^        operator reference() const$/;"	f	struct:boost::xpressive::detail::opt	access:public	signature:() const
boost::xpressive::detail::opt::opt	xpressive/detail/core/matcher/action_matcher.hpp	/^        opt(T const *t)$/;"	f	struct:boost::xpressive::detail::opt	access:public	signature:(T const *t)
boost::xpressive::detail::opt::reference	xpressive/detail/core/matcher/action_matcher.hpp	/^        typedef T const &reference;$/;"	t	struct:boost::xpressive::detail::opt	access:public
boost::xpressive::detail::opt::t_	xpressive/detail/core/matcher/action_matcher.hpp	/^        T const *t_;$/;"	m	struct:boost::xpressive::detail::opt	access:public
boost::xpressive::detail::opt::type	xpressive/detail/core/matcher/action_matcher.hpp	/^        typedef T type;$/;"	t	struct:boost::xpressive::detail::opt	access:public
boost::xpressive::detail::optimize_regex	xpressive/detail/core/optimize.hpp	/^intrusive_ptr<finder<BidiIter> > optimize_regex$/;"	f	namespace:boost::xpressive::detail	signature:( xpression_peeker<typename iterator_value<BidiIter>::type> const &peeker , Traits const &tr , mpl::false_ )
boost::xpressive::detail::optimize_regex	xpressive/detail/core/optimize.hpp	/^intrusive_ptr<finder<BidiIter> > optimize_regex$/;"	f	namespace:boost::xpressive::detail	signature:( xpression_peeker<typename iterator_value<BidiIter>::type> const &peeker , Traits const &tr , mpl::true_ )
boost::xpressive::detail::optional_mark_matcher	xpressive/detail/core/matcher/optional_matcher.hpp	/^    struct optional_mark_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::optional_mark_matcher::mark_number_	xpressive/detail/core/matcher/optional_matcher.hpp	/^        int mark_number_;$/;"	m	struct:boost::xpressive::detail::optional_mark_matcher	access:public
boost::xpressive::detail::optional_mark_matcher::match	xpressive/detail/core/matcher/optional_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::optional_mark_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::optional_mark_matcher::match_	xpressive/detail/core/matcher/optional_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::false_) const \/\/ Non-greedy$/;"	f	struct:boost::xpressive::detail::optional_mark_matcher	access:private	signature:(match_state<BidiIter> &state, Next const &next, mpl::false_) const
boost::xpressive::detail::optional_mark_matcher::match_	xpressive/detail/core/matcher/optional_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::true_) const \/\/ Greedy$/;"	f	struct:boost::xpressive::detail::optional_mark_matcher	access:private	signature:(match_state<BidiIter> &state, Next const &next, mpl::true_) const
boost::xpressive::detail::optional_mark_matcher::operator =	xpressive/detail/core/matcher/optional_matcher.hpp	/^        optional_mark_matcher &operator =(optional_mark_matcher const &);$/;"	p	struct:boost::xpressive::detail::optional_mark_matcher	access:private	signature:(optional_mark_matcher const &)
boost::xpressive::detail::optional_mark_matcher::optional_mark_matcher	xpressive/detail/core/matcher/optional_matcher.hpp	/^        explicit optional_mark_matcher(Xpr const &xpr, int mark_number)$/;"	f	struct:boost::xpressive::detail::optional_mark_matcher	access:public	signature:(Xpr const &xpr, int mark_number)
boost::xpressive::detail::optional_mark_matcher::xpr_	xpressive/detail/core/matcher/optional_matcher.hpp	/^        Xpr xpr_;$/;"	m	struct:boost::xpressive::detail::optional_mark_matcher	access:public
boost::xpressive::detail::optional_matcher	xpressive/detail/core/matcher/optional_matcher.hpp	/^    struct optional_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::optional_matcher::match	xpressive/detail/core/matcher/optional_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::optional_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::optional_matcher::match_	xpressive/detail/core/matcher/optional_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::false_) const \/\/ Non-greedy$/;"	f	struct:boost::xpressive::detail::optional_matcher	access:private	signature:(match_state<BidiIter> &state, Next const &next, mpl::false_) const
boost::xpressive::detail::optional_matcher::match_	xpressive/detail/core/matcher/optional_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::true_) const \/\/ Greedy$/;"	f	struct:boost::xpressive::detail::optional_matcher	access:private	signature:(match_state<BidiIter> &state, Next const &next, mpl::true_) const
boost::xpressive::detail::optional_matcher::operator =	xpressive/detail/core/matcher/optional_matcher.hpp	/^        optional_matcher &operator =(optional_matcher const &);$/;"	p	struct:boost::xpressive::detail::optional_matcher	access:private	signature:(optional_matcher const &)
boost::xpressive::detail::optional_matcher::optional_matcher	xpressive/detail/core/matcher/optional_matcher.hpp	/^        explicit optional_matcher(Xpr const &xpr)$/;"	f	struct:boost::xpressive::detail::optional_matcher	access:public	signature:(Xpr const &xpr)
boost::xpressive::detail::optional_matcher::xpr_	xpressive/detail/core/matcher/optional_matcher.hpp	/^        Xpr xpr_;$/;"	m	struct:boost::xpressive::detail::optional_matcher	access:public
boost::xpressive::detail::or_widths	xpressive/detail/static/width_of.hpp	/^    struct or_widths$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
boost::xpressive::detail::or_widths	xpressive/detail/static/width_of.hpp	/^    struct or_widths<N, N>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
boost::xpressive::detail::parse_charset	xpressive/detail/dynamic/parse_charset.hpp	/^inline void parse_charset$/;"	f	namespace:boost::xpressive::detail	signature:( FwdIter &begin , FwdIter end , compound_charset<RegexTraits> &chset , CompilerTraits &tr )
boost::xpressive::detail::parse_escape	xpressive/detail/dynamic/parse_charset.hpp	/^parse_escape(FwdIter &begin, FwdIter end, CompilerTraits &tr)$/;"	f	namespace:boost::xpressive::detail	signature:(FwdIter &begin, FwdIter end, CompilerTraits &tr)
boost::xpressive::detail::peeker_string	xpressive/detail/core/peeker.hpp	/^struct peeker_string$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::peeker_string::begin_	xpressive/detail/core/peeker.hpp	/^    Char const *begin_;$/;"	m	struct:boost::xpressive::detail::peeker_string	access:public
boost::xpressive::detail::peeker_string::end_	xpressive/detail/core/peeker.hpp	/^    Char const *end_;$/;"	m	struct:boost::xpressive::detail::peeker_string	access:public
boost::xpressive::detail::peeker_string::icase_	xpressive/detail/core/peeker.hpp	/^    bool icase_;$/;"	m	struct:boost::xpressive::detail::peeker_string	access:public
boost::xpressive::detail::pop_context_match	xpressive/detail/core/flow_control.hpp	/^inline bool pop_context_match(match_state<BidiIter> &state)$/;"	f	namespace:boost::xpressive::detail	signature:(match_state<BidiIter> &state)
boost::xpressive::detail::posix_charset_matcher	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^    struct posix_charset_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_fixed_width
boost::xpressive::detail::posix_charset_matcher::char_class_type	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^        typedef typename Traits::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::detail::posix_charset_matcher	access:public
boost::xpressive::detail::posix_charset_matcher::inverse	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^        void inverse()$/;"	f	struct:boost::xpressive::detail::posix_charset_matcher	access:public	signature:()
boost::xpressive::detail::posix_charset_matcher::mask_	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^        char_class_type mask_;$/;"	m	struct:boost::xpressive::detail::posix_charset_matcher	access:public
boost::xpressive::detail::posix_charset_matcher::match	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::posix_charset_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::posix_charset_matcher::not_	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^        bool not_;$/;"	m	struct:boost::xpressive::detail::posix_charset_matcher	access:public
boost::xpressive::detail::posix_charset_matcher::posix_charset_matcher	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^        posix_charset_matcher(char_class_type m, bool no)$/;"	f	struct:boost::xpressive::detail::posix_charset_matcher	access:public	signature:(char_class_type m, bool no)
boost::xpressive::detail::posix_charset_matcher::traits_type	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^        typedef Traits traits_type;$/;"	t	struct:boost::xpressive::detail::posix_charset_matcher	access:public
boost::xpressive::detail::posix_charset_placeholder	xpressive/detail/static/placeholders.hpp	/^struct posix_charset_placeholder$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::posix_charset_placeholder::name_	xpressive/detail/static/placeholders.hpp	/^    char const *name_;$/;"	m	struct:boost::xpressive::detail::posix_charset_placeholder	access:public
boost::xpressive::detail::posix_charset_placeholder::not_	xpressive/detail/static/placeholders.hpp	/^    bool not_;$/;"	m	struct:boost::xpressive::detail::posix_charset_placeholder	access:public
boost::xpressive::detail::predicate_context	xpressive/detail/core/matcher/predicate_matcher.hpp	/^    struct predicate_context$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::predicate_context::action_args_	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        action_args_type *action_args_;$/;"	m	struct:boost::xpressive::detail::predicate_context	access:public
boost::xpressive::detail::predicate_context::args	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        action_args_type const &args() const$/;"	f	struct:boost::xpressive::detail::predicate_context	access:public	signature:() const
boost::xpressive::detail::predicate_context::eval	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval$/;"	s	struct:boost::xpressive::detail::predicate_context	inherits:proto::default_eval	access:public
boost::xpressive::detail::predicate_context::eval	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval<Expr, proto::tag::mem_ptr>$/;"	s	struct:boost::xpressive::detail::predicate_context	inherits:mem_ptr_eval	access:public
boost::xpressive::detail::predicate_context::eval	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval<Expr, proto::tag::terminal>$/;"	s	struct:boost::xpressive::detail::predicate_context	inherits:eval_terminal	access:public
boost::xpressive::detail::predicate_context::eval_terminal	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval_terminal$/;"	s	struct:boost::xpressive::detail::predicate_context	inherits:proto::default_eval	access:public
boost::xpressive::detail::predicate_context::eval_terminal	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval_terminal<Expr, action_arg<Type, Int> >$/;"	s	struct:boost::xpressive::detail::predicate_context	access:public
boost::xpressive::detail::predicate_context::eval_terminal	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval_terminal<Expr, any_matcher>$/;"	s	struct:boost::xpressive::detail::predicate_context	access:public
boost::xpressive::detail::predicate_context::eval_terminal	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval_terminal<Expr, mark_placeholder>$/;"	s	struct:boost::xpressive::detail::predicate_context	access:public
boost::xpressive::detail::predicate_context::eval_terminal	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval_terminal<Expr, reference_wrapper<Arg> >$/;"	s	struct:boost::xpressive::detail::predicate_context	access:public
boost::xpressive::detail::predicate_context::eval_terminal::operator ()	xpressive/detail/core/matcher/predicate_matcher.hpp	/^            result_type operator()(Expr &, predicate_context const &ctx) const$/;"	f	struct:boost::xpressive::detail::predicate_context::eval_terminal	access:public	signature:(Expr &, predicate_context const &ctx) const
boost::xpressive::detail::predicate_context::eval_terminal::operator ()	xpressive/detail/core/matcher/predicate_matcher.hpp	/^            result_type operator()(Expr &expr, predicate_context const &) const$/;"	f	struct:boost::xpressive::detail::predicate_context::eval_terminal	access:public	signature:(Expr &expr, predicate_context const &) const
boost::xpressive::detail::predicate_context::eval_terminal::operator ()	xpressive/detail/core/matcher/predicate_matcher.hpp	/^            result_type operator()(Expr &expr, predicate_context const &ctx) const$/;"	f	struct:boost::xpressive::detail::predicate_context::eval_terminal	access:public	signature:(Expr &expr, predicate_context const &ctx) const
boost::xpressive::detail::predicate_context::eval_terminal::result_type	xpressive/detail/core/matcher/predicate_matcher.hpp	/^            typedef Arg &result_type;$/;"	t	struct:boost::xpressive::detail::predicate_context::eval_terminal	access:public
boost::xpressive::detail::predicate_context::eval_terminal::result_type	xpressive/detail/core/matcher/predicate_matcher.hpp	/^            typedef sub_match<BidiIter> const &result_type;$/;"	t	struct:boost::xpressive::detail::predicate_context::eval_terminal	access:public
boost::xpressive::detail::predicate_context::eval_terminal::result_type	xpressive/detail/core/matcher/predicate_matcher.hpp	/^            typedef typename action_arg<Type, Int>::reference result_type;$/;"	t	struct:boost::xpressive::detail::predicate_context::eval_terminal	access:public
boost::xpressive::detail::predicate_context::predicate_context	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        explicit predicate_context(int sub, sub_match_impl<BidiIter> const *sub_matches, action_args_type *action_args)$/;"	f	struct:boost::xpressive::detail::predicate_context	access:public	signature:(int sub, sub_match_impl<BidiIter> const *sub_matches, action_args_type *action_args)
boost::xpressive::detail::predicate_context::sub_	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        int sub_;$/;"	m	struct:boost::xpressive::detail::predicate_context	access:public
boost::xpressive::detail::predicate_context::sub_matches_	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        sub_match_impl<BidiIter> const *sub_matches_;$/;"	m	struct:boost::xpressive::detail::predicate_context	access:public
boost::xpressive::detail::predicate_matcher	xpressive/detail/core/matcher/predicate_matcher.hpp	/^    struct predicate_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_assertion
boost::xpressive::detail::predicate_matcher::match	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::predicate_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::predicate_matcher::match_	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::predicate_matcher	access:private	signature:(match_state<BidiIter> &state, Next const &next, mpl::false_) const
boost::xpressive::detail::predicate_matcher::match_	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::true_) const$/;"	f	struct:boost::xpressive::detail::predicate_matcher	access:private	signature:(match_state<BidiIter> &state, Next const &next, mpl::true_) const
boost::xpressive::detail::predicate_matcher::predicate_	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        Predicate predicate_;$/;"	m	struct:boost::xpressive::detail::predicate_matcher	access:public
boost::xpressive::detail::predicate_matcher::predicate_matcher	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        predicate_matcher(Predicate const &pred, int sub)$/;"	f	struct:boost::xpressive::detail::predicate_matcher	access:public	signature:(Predicate const &pred, int sub)
boost::xpressive::detail::predicate_matcher::sub_	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        int sub_;$/;"	m	struct:boost::xpressive::detail::predicate_matcher	access:public
boost::xpressive::detail::push_back	xpressive/regex_primitives.hpp	/^    struct push_back : proto::callable$/;"	s	namespace:boost::xpressive::detail	inherits:proto::callable
boost::xpressive::detail::push_back::operator ()	xpressive/regex_primitives.hpp	/^        int operator ()(Subs &subs, int i) const$/;"	f	struct:boost::xpressive::detail::push_back	access:public	signature:(Subs &subs, int i) const
boost::xpressive::detail::push_back::result_type	xpressive/regex_primitives.hpp	/^        typedef int result_type;$/;"	t	struct:boost::xpressive::detail::push_back	access:public
boost::xpressive::detail::push_context_match	xpressive/detail/core/flow_control.hpp	/^inline bool push_context_match$/;"	f	namespace:boost::xpressive::detail	signature:( regex_impl<BidiIter> const &impl , match_state<BidiIter> &state , matchable<BidiIter> const &next )
boost::xpressive::detail::quant_enum	xpressive/detail/core/quant_style.hpp	/^enum quant_enum$/;"	g	namespace:boost::xpressive::detail
boost::xpressive::detail::quant_fixed_width	xpressive/detail/core/quant_style.hpp	/^    quant_fixed_width,$/;"	e	enum:boost::xpressive::detail::quant_enum
boost::xpressive::detail::quant_none	xpressive/detail/core/quant_style.hpp	/^    quant_none,$/;"	e	enum:boost::xpressive::detail::quant_enum
boost::xpressive::detail::quant_spec	xpressive/detail/dynamic/matchable.hpp	/^struct quant_spec$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::quant_spec::greedy_	xpressive/detail/dynamic/matchable.hpp	/^    bool greedy_;$/;"	m	struct:boost::xpressive::detail::quant_spec	access:public
boost::xpressive::detail::quant_spec::hidden_mark_count_	xpressive/detail/dynamic/matchable.hpp	/^    std::size_t *hidden_mark_count_;$/;"	m	struct:boost::xpressive::detail::quant_spec	access:public
boost::xpressive::detail::quant_spec::max_	xpressive/detail/dynamic/matchable.hpp	/^    unsigned int max_;$/;"	m	struct:boost::xpressive::detail::quant_spec	access:public
boost::xpressive::detail::quant_spec::min_	xpressive/detail/dynamic/matchable.hpp	/^    unsigned int min_;$/;"	m	struct:boost::xpressive::detail::quant_spec	access:public
boost::xpressive::detail::quant_style	xpressive/detail/core/quant_style.hpp	/^struct quant_style$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::quant_style::BOOST_STATIC_CONSTANT	xpressive/detail/core/quant_style.hpp	/^    BOOST_STATIC_CONSTANT(bool, pure = Pure);$/;"	p	struct:boost::xpressive::detail::quant_style	access:public	signature:(bool, pure = Pure)
boost::xpressive::detail::quant_style::BOOST_STATIC_CONSTANT	xpressive/detail/core/quant_style.hpp	/^    BOOST_STATIC_CONSTANT(int, quant = QuantStyle);$/;"	p	struct:boost::xpressive::detail::quant_style	access:public	signature:(int, quant = QuantStyle)
boost::xpressive::detail::quant_style::BOOST_STATIC_CONSTANT	xpressive/detail/core/quant_style.hpp	/^    BOOST_STATIC_CONSTANT(std::size_t, width = Width);$/;"	p	struct:boost::xpressive::detail::quant_style	access:public	signature:(std::size_t, width = Width)
boost::xpressive::detail::quant_style::get_width	xpressive/detail/core/quant_style.hpp	/^    static detail::width get_width()$/;"	f	struct:boost::xpressive::detail::quant_style	access:public	signature:()
boost::xpressive::detail::quant_style::is_boost_xpressive_xpression_	xpressive/detail/core/quant_style.hpp	/^    typedef void is_boost_xpressive_xpression_;$/;"	t	struct:boost::xpressive::detail::quant_style	access:public
boost::xpressive::detail::quant_style_assertion	xpressive/detail/core/quant_style.hpp	/^struct quant_style_assertion$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::quant_style_fixed_unknown_width	xpressive/detail/core/quant_style.hpp	/^typedef quant_style<quant_fixed_width> quant_style_fixed_unknown_width;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::quant_style_fixed_width	xpressive/detail/core/quant_style.hpp	/^struct quant_style_fixed_width$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::quant_style_none	xpressive/detail/core/quant_style.hpp	/^typedef quant_style<quant_none> quant_style_none;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::quant_style_variable_width	xpressive/detail/core/quant_style.hpp	/^typedef quant_style<quant_variable_width> quant_style_variable_width;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::quant_type	xpressive/detail/core/quant_style.hpp	/^struct quant_type$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::int_
boost::xpressive::detail::quant_variable_width	xpressive/detail/core/quant_style.hpp	/^    quant_variable_width$/;"	e	enum:boost::xpressive::detail::quant_enum
boost::xpressive::detail::range	xpressive/detail/utility/chset/range_run.hpp	/^struct range$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::range::first_	xpressive/detail/utility/chset/range_run.hpp	/^    Char first_;$/;"	m	struct:boost::xpressive::detail::range	access:public
boost::xpressive::detail::range::includes	xpressive/detail/utility/chset/range_run.hpp	/^    bool includes(Char v) const;$/;"	p	struct:boost::xpressive::detail::range	access:public	signature:(Char v) const
boost::xpressive::detail::range::includes	xpressive/detail/utility/chset/range_run.hpp	/^    bool includes(range const &r) const;$/;"	p	struct:boost::xpressive::detail::range	access:public	signature:(range const &r) const
boost::xpressive::detail::range::is_valid	xpressive/detail/utility/chset/range_run.hpp	/^    bool is_valid() const;$/;"	p	struct:boost::xpressive::detail::range	access:public	signature:() const
boost::xpressive::detail::range::last_	xpressive/detail/utility/chset/range_run.hpp	/^    Char last_;$/;"	m	struct:boost::xpressive::detail::range	access:public
boost::xpressive::detail::range::merge	xpressive/detail/utility/chset/range_run.hpp	/^    void merge(range const &r);$/;"	p	struct:boost::xpressive::detail::range	access:public	signature:(range const &r)
boost::xpressive::detail::range::overlaps	xpressive/detail/utility/chset/range_run.hpp	/^    bool overlaps(range const &r) const;$/;"	p	struct:boost::xpressive::detail::range	access:public	signature:(range const &r) const
boost::xpressive::detail::range::range	xpressive/detail/utility/chset/range_run.hpp	/^    range(Char first, Char last);$/;"	p	struct:boost::xpressive::detail::range	access:public	signature:(Char first, Char last)
boost::xpressive::detail::range_compare	xpressive/detail/utility/chset/range_run.hpp	/^struct range_compare$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::range_compare::operator ()	xpressive/detail/utility/chset/range_run.hpp	/^    bool operator()(range<Char> const &x, range<Char> const &y) const$/;"	f	struct:boost::xpressive::detail::range_compare	access:public	signature:(range<Char> const &x, range<Char> const &y) const
boost::xpressive::detail::range_data	xpressive/detail/utility/algorithm.hpp	/^struct range_data$/;"	s	namespace:boost::xpressive::detail	inherits:range_value
boost::xpressive::detail::range_data	xpressive/detail/utility/algorithm.hpp	/^struct range_data<T *>$/;"	s	namespace:boost::xpressive::detail	inherits:remove_const
boost::xpressive::detail::range_data::data_begin	xpressive/detail/utility/algorithm.hpp	/^typename range_data<Cont>::type const *data_begin(Cont const &cont)$/;"	f	class:boost::xpressive::detail::range_data	signature:(Cont const &cont)
boost::xpressive::detail::range_data::data_end	xpressive/detail/utility/algorithm.hpp	/^typename range_data<Cont>::type const *data_end(Cont const &cont)$/;"	f	class:boost::xpressive::detail::range_data	signature:(Cont const &cont)
boost::xpressive::detail::range_matcher	xpressive/detail/core/matcher/range_matcher.hpp	/^    struct range_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_fixed_width
boost::xpressive::detail::range_matcher::ch_max_	xpressive/detail/core/matcher/range_matcher.hpp	/^        char_type ch_max_;$/;"	m	struct:boost::xpressive::detail::range_matcher	access:public
boost::xpressive::detail::range_matcher::ch_min_	xpressive/detail/core/matcher/range_matcher.hpp	/^        char_type ch_min_;$/;"	m	struct:boost::xpressive::detail::range_matcher	access:public
boost::xpressive::detail::range_matcher::char_type	xpressive/detail/core/matcher/range_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::range_matcher	access:public
boost::xpressive::detail::range_matcher::icase_type	xpressive/detail/core/matcher/range_matcher.hpp	/^        typedef ICase icase_type;$/;"	t	struct:boost::xpressive::detail::range_matcher	access:public
boost::xpressive::detail::range_matcher::in_range	xpressive/detail/core/matcher/range_matcher.hpp	/^        bool in_range(Traits const &tr, char_type ch, mpl::false_) const \/\/ case-sensitive$/;"	f	struct:boost::xpressive::detail::range_matcher	access:public	signature:(Traits const &tr, char_type ch, mpl::false_) const
boost::xpressive::detail::range_matcher::in_range	xpressive/detail/core/matcher/range_matcher.hpp	/^        bool in_range(Traits const &tr, char_type ch, mpl::true_) const \/\/ case-insensitive$/;"	f	struct:boost::xpressive::detail::range_matcher	access:public	signature:(Traits const &tr, char_type ch, mpl::true_) const
boost::xpressive::detail::range_matcher::inverse	xpressive/detail/core/matcher/range_matcher.hpp	/^        void inverse()$/;"	f	struct:boost::xpressive::detail::range_matcher	access:public	signature:()
boost::xpressive::detail::range_matcher::match	xpressive/detail/core/matcher/range_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::range_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::range_matcher::not_	xpressive/detail/core/matcher/range_matcher.hpp	/^        bool not_;$/;"	m	struct:boost::xpressive::detail::range_matcher	access:public
boost::xpressive::detail::range_matcher::range_matcher	xpressive/detail/core/matcher/range_matcher.hpp	/^        range_matcher(char_type ch_min, char_type ch_max, bool no, Traits const &)$/;"	f	struct:boost::xpressive::detail::range_matcher	access:public	signature:(char_type ch_min, char_type ch_max, bool no, Traits const &)
boost::xpressive::detail::range_placeholder	xpressive/detail/static/placeholders.hpp	/^struct range_placeholder$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::range_placeholder::ch_max_	xpressive/detail/static/placeholders.hpp	/^    Char ch_max_;$/;"	m	struct:boost::xpressive::detail::range_placeholder	access:public
boost::xpressive::detail::range_placeholder::ch_min_	xpressive/detail/static/placeholders.hpp	/^    Char ch_min_;$/;"	m	struct:boost::xpressive::detail::range_placeholder	access:public
boost::xpressive::detail::range_placeholder::not_	xpressive/detail/static/placeholders.hpp	/^    bool not_;$/;"	m	struct:boost::xpressive::detail::range_placeholder	access:public
boost::xpressive::detail::range_run	xpressive/detail/utility/chset/range_run.hpp	/^struct range_run$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::range_run::begin	xpressive/detail/utility/chset/range_run.hpp	/^    const_iterator begin() const;$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:() const
boost::xpressive::detail::range_run::clear	xpressive/detail/utility/chset/range_run.hpp	/^    void clear();$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:()
boost::xpressive::detail::range_run::clear	xpressive/detail/utility/chset/range_run.hpp	/^    void clear(range_type const &r);$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:(range_type const &r)
boost::xpressive::detail::range_run::const_iterator	xpressive/detail/utility/chset/range_run.hpp	/^    typedef typename run_type::const_iterator const_iterator;$/;"	t	struct:boost::xpressive::detail::range_run	access:public
boost::xpressive::detail::range_run::empty	xpressive/detail/utility/chset/range_run.hpp	/^    bool empty() const;$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:() const
boost::xpressive::detail::range_run::end	xpressive/detail/utility/chset/range_run.hpp	/^    const_iterator end() const;$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:() const
boost::xpressive::detail::range_run::iterator	xpressive/detail/utility/chset/range_run.hpp	/^    typedef typename run_type::iterator iterator;$/;"	t	struct:boost::xpressive::detail::range_run	access:public
boost::xpressive::detail::range_run::merge	xpressive/detail/utility/chset/range_run.hpp	/^    void merge(iterator iter, range_type const &r);$/;"	p	struct:boost::xpressive::detail::range_run	access:private	signature:(iterator iter, range_type const &r)
boost::xpressive::detail::range_run::range_type	xpressive/detail/utility/chset/range_run.hpp	/^    typedef range<Char> range_type;$/;"	t	struct:boost::xpressive::detail::range_run	access:public
boost::xpressive::detail::range_run::run_	xpressive/detail/utility/chset/range_run.hpp	/^    run_type run_;$/;"	m	struct:boost::xpressive::detail::range_run	access:private
boost::xpressive::detail::range_run::run_type	xpressive/detail/utility/chset/range_run.hpp	/^    typedef std::vector<range_type> run_type;$/;"	t	struct:boost::xpressive::detail::range_run	access:public
boost::xpressive::detail::range_run::set	xpressive/detail/utility/chset/range_run.hpp	/^    void set(range_type const &r);$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:(range_type const &r)
boost::xpressive::detail::range_run::swap	xpressive/detail/utility/chset/range_run.hpp	/^    void swap(range_run& rr);$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:(range_run& rr)
boost::xpressive::detail::range_run::test	xpressive/detail/utility/chset/range_run.hpp	/^    bool test(Char v) const;$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:(Char v) const
boost::xpressive::detail::range_run::test	xpressive/detail/utility/chset/range_run.hpp	/^    bool test(Char v, Traits const &tr) const;$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:(Char v, Traits const &tr) const
boost::xpressive::detail::re	xpressive/regex_algorithms.hpp	/^      , basic_regex<BidiIter> const &re$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::read_attr	xpressive/detail/static/transforms/as_action.hpp	/^    struct read_attr$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::read_attr	xpressive/detail/static/transforms/as_action.hpp	/^    struct read_attr<Nbr, Matcher &>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::read_attr::matcher_type	xpressive/detail/static/transforms/as_action.hpp	/^        typedef Matcher matcher_type;$/;"	t	struct:boost::xpressive::detail::read_attr	access:public
boost::xpressive::detail::read_attr::nbr	xpressive/detail/static/transforms/as_action.hpp	/^        static Nbr nbr() { return Nbr(); }$/;"	f	struct:boost::xpressive::detail::read_attr	access:public	signature:()
boost::xpressive::detail::read_attr::nbr_type	xpressive/detail/static/transforms/as_action.hpp	/^        typedef Nbr nbr_type;$/;"	t	struct:boost::xpressive::detail::read_attr	access:public
boost::xpressive::detail::reclaim_sub_matches	xpressive/detail/core/state.hpp	/^inline void reclaim_sub_matches(memento<BidiIter> const &mem, match_state<BidiIter> &state, bool success)$/;"	f	namespace:boost::xpressive::detail	signature:(memento<BidiIter> const &mem, match_state<BidiIter> &state, bool success)
boost::xpressive::detail::regex_byref_matcher	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^    struct regex_byref_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::regex_byref_matcher::match	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::regex_byref_matcher::pimpl_	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        regex_impl<BidiIter> const *pimpl_;$/;"	m	struct:boost::xpressive::detail::regex_byref_matcher	access:public
boost::xpressive::detail::regex_byref_matcher::regex_byref_matcher	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        regex_byref_matcher(shared_ptr<regex_impl<BidiIter> > const &impl)$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:public	signature:(shared_ptr<regex_impl<BidiIter> > const &impl)
boost::xpressive::detail::regex_byref_matcher::wimpl_	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        weak_ptr<regex_impl<BidiIter> > wimpl_;$/;"	m	struct:boost::xpressive::detail::regex_byref_matcher	access:public
boost::xpressive::detail::regex_byref_matcher::wrap_	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        static Next const &wrap_(Next const &next, mpl::false_)$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:private	signature:(Next const &next, mpl::false_)
boost::xpressive::detail::regex_byref_matcher::wrap_	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        static xpression_adaptor<reference_wrapper<Next const>, matchable<BidiIter> > wrap_(Next const &next, mpl::true_)$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:private	signature:(Next const &next, mpl::true_)
boost::xpressive::detail::regex_domain	xpressive/detail/core/regex_domain.hpp	/^    struct regex_domain$/;"	s	namespace:boost::xpressive::detail	inherits:proto::domain
boost::xpressive::detail::regex_impl	xpressive/detail/core/regex_impl.hpp	/^struct regex_impl$/;"	s	namespace:boost::xpressive::detail	inherits:enable_reference_tracking
boost::xpressive::detail::regex_impl::char_type	xpressive/detail/core/regex_impl.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::finder_	xpressive/detail/core/regex_impl.hpp	/^    intrusive_ptr<finder<BidiIter> > finder_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::hidden_mark_count_	xpressive/detail/core/regex_impl.hpp	/^    std::size_t hidden_mark_count_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::instances	xpressive/detail/core/regex_impl.hpp	/^    static int instances;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::instances	xpressive/detail/core/regex_impl.hpp	/^int regex_impl<BidiIter>::instances = 0;$/;"	m	class:boost::xpressive::detail::regex_impl
boost::xpressive::detail::regex_impl::mark_count_	xpressive/detail/core/regex_impl.hpp	/^    std::size_t mark_count_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::named_marks_	xpressive/detail/core/regex_impl.hpp	/^    std::vector<named_mark<char_type> > named_marks_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::operator =	xpressive/detail/core/regex_impl.hpp	/^    regex_impl &operator =(regex_impl const &);$/;"	p	struct:boost::xpressive::detail::regex_impl	access:private	signature:(regex_impl const &)
boost::xpressive::detail::regex_impl::regex_impl	xpressive/detail/core/regex_impl.hpp	/^    regex_impl()$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:()
boost::xpressive::detail::regex_impl::regex_impl	xpressive/detail/core/regex_impl.hpp	/^    regex_impl(regex_impl<BidiIter> const &that)$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:(regex_impl<BidiIter> const &that)
boost::xpressive::detail::regex_impl::swap	xpressive/detail/core/regex_impl.hpp	/^    void swap(regex_impl<BidiIter> &that)$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:(regex_impl<BidiIter> &that)
boost::xpressive::detail::regex_impl::traits_	xpressive/detail/core/regex_impl.hpp	/^    intrusive_ptr<traits<char_type> const> traits_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::xpr_	xpressive/detail/core/regex_impl.hpp	/^    intrusive_ptr<matchable_ex<BidiIter> const> xpr_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
boost::xpressive::detail::regex_impl::~regex_impl	xpressive/detail/core/regex_impl.hpp	/^    ~regex_impl()$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:()
boost::xpressive::detail::regex_iterator_impl	xpressive/regex_iterator.hpp	/^struct regex_iterator_impl$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
boost::xpressive::detail::regex_iterator_impl::access	xpressive/regex_iterator.hpp	/^    typedef detail::core_access<BidiIter> access;$/;"	t	struct:boost::xpressive::detail::regex_iterator_impl	access:public
boost::xpressive::detail::regex_iterator_impl::equal_to	xpressive/regex_iterator.hpp	/^    bool equal_to(regex_iterator_impl<BidiIter> const &that) const$/;"	f	struct:boost::xpressive::detail::regex_iterator_impl	access:public	signature:(regex_iterator_impl<BidiIter> const &that) const
boost::xpressive::detail::regex_iterator_impl::next	xpressive/regex_iterator.hpp	/^    bool next()$/;"	f	struct:boost::xpressive::detail::regex_iterator_impl	access:public	signature:()
boost::xpressive::detail::regex_iterator_impl::not_null_	xpressive/regex_iterator.hpp	/^    bool not_null_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
boost::xpressive::detail::regex_iterator_impl::regex_constants::flags_	xpressive/regex_iterator.hpp	/^    regex_constants::match_flag_type const flags_;$/;"	m	class:boost::xpressive::detail::regex_iterator_impl::regex_constants	access:public
boost::xpressive::detail::regex_iterator_impl::regex_iterator_impl	xpressive/regex_iterator.hpp	/^    regex_iterator_impl$/;"	f	struct:boost::xpressive::detail::regex_iterator_impl	access:public	signature:( BidiIter begin , BidiIter cur , BidiIter end , BidiIter next_search , basic_regex<BidiIter> const &rex , regex_constants::match_flag_type flags , bool not_null = false )
boost::xpressive::detail::regex_iterator_impl::rex_	xpressive/regex_iterator.hpp	/^    basic_regex<BidiIter> rex_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
boost::xpressive::detail::regex_iterator_impl::state_	xpressive/regex_iterator.hpp	/^    match_state<BidiIter> state_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
boost::xpressive::detail::regex_iterator_impl::what_	xpressive/regex_iterator.hpp	/^    match_results<BidiIter> what_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
boost::xpressive::detail::regex_matcher	xpressive/detail/core/matcher/regex_matcher.hpp	/^    struct regex_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::regex_matcher::impl_	xpressive/detail/core/matcher/regex_matcher.hpp	/^        regex_impl<BidiIter> impl_;$/;"	m	struct:boost::xpressive::detail::regex_matcher	access:public
boost::xpressive::detail::regex_matcher::match	xpressive/detail/core/matcher/regex_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::regex_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::regex_matcher::regex_matcher	xpressive/detail/core/matcher/regex_matcher.hpp	/^        regex_matcher(shared_ptr<regex_impl<BidiIter> > const &impl)$/;"	f	struct:boost::xpressive::detail::regex_matcher	access:public	signature:(shared_ptr<regex_impl<BidiIter> > const &impl)
boost::xpressive::detail::regex_token_iterator_impl	xpressive/regex_token_iterator.hpp	/^struct regex_token_iterator_impl$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
boost::xpressive::detail::regex_token_iterator_impl::equal_to	xpressive/regex_token_iterator.hpp	/^    bool equal_to(regex_token_iterator_impl<BidiIter> const &that) const$/;"	f	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public	signature:(regex_token_iterator_impl<BidiIter> const &that) const
boost::xpressive::detail::regex_token_iterator_impl::iter_	xpressive/regex_token_iterator.hpp	/^    regex_iterator_impl<BidiIter> iter_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
boost::xpressive::detail::regex_token_iterator_impl::n_	xpressive/regex_token_iterator.hpp	/^    int n_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
boost::xpressive::detail::regex_token_iterator_impl::next	xpressive/regex_token_iterator.hpp	/^    bool next()$/;"	f	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public	signature:()
boost::xpressive::detail::regex_token_iterator_impl::regex_token_iterator_impl	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator_impl$/;"	f	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public	signature:( BidiIter begin , BidiIter cur , BidiIter end , BidiIter next_search , basic_regex<BidiIter> const &rex , regex_constants::match_flag_type flags = regex_constants::match_default , std::vector<int> subs = std::vector<int>(1, 0) , int n = -2 , bool not_null = false )
boost::xpressive::detail::regex_token_iterator_impl::result_	xpressive/regex_token_iterator.hpp	/^    value_type result_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
boost::xpressive::detail::regex_token_iterator_impl::subs_	xpressive/regex_token_iterator.hpp	/^    std::vector<int> subs_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
boost::xpressive::detail::regex_token_iterator_impl::value_type	xpressive/regex_token_iterator.hpp	/^    typedef sub_match<BidiIter> value_type;$/;"	t	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
boost::xpressive::detail::regex_traits_type	xpressive/detail/core/linker.hpp	/^struct regex_traits_type$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::regex_traits_type::char_type	xpressive/detail/core/linker.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::regex_traits_type	access:public
boost::xpressive::detail::regex_traits_type::type	xpressive/detail/core/linker.hpp	/^    >::type type;$/;"	t	struct:boost::xpressive::detail::regex_traits_type	access:public
boost::xpressive::detail::repeat_begin_matcher	xpressive/detail/core/matcher/repeat_begin_matcher.hpp	/^    struct repeat_begin_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::repeat_begin_matcher::mark_number_	xpressive/detail/core/matcher/repeat_begin_matcher.hpp	/^        int mark_number_;$/;"	m	struct:boost::xpressive::detail::repeat_begin_matcher	access:public
boost::xpressive::detail::repeat_begin_matcher::match	xpressive/detail/core/matcher/repeat_begin_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::repeat_begin_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::repeat_begin_matcher::repeat_begin_matcher	xpressive/detail/core/matcher/repeat_begin_matcher.hpp	/^        repeat_begin_matcher(int mark_number)$/;"	f	struct:boost::xpressive::detail::repeat_begin_matcher	access:public	signature:(int mark_number)
boost::xpressive::detail::repeat_end_matcher	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^    struct repeat_end_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
boost::xpressive::detail::repeat_end_matcher::back_	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        mutable void const *back_;$/;"	m	struct:boost::xpressive::detail::repeat_end_matcher	access:public
boost::xpressive::detail::repeat_end_matcher::greedy_type	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        typedef Greedy greedy_type;$/;"	t	struct:boost::xpressive::detail::repeat_end_matcher	access:public
boost::xpressive::detail::repeat_end_matcher::mark_number_	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        int mark_number_;$/;"	m	struct:boost::xpressive::detail::repeat_end_matcher	access:public
boost::xpressive::detail::repeat_end_matcher::match	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::repeat_end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::repeat_end_matcher::match_	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::repeat_end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::false_) const
boost::xpressive::detail::repeat_end_matcher::match_	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::true_) const$/;"	f	struct:boost::xpressive::detail::repeat_end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::true_) const
boost::xpressive::detail::repeat_end_matcher::max_	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        unsigned int min_, max_;$/;"	m	struct:boost::xpressive::detail::repeat_end_matcher	access:public
boost::xpressive::detail::repeat_end_matcher::min_	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        unsigned int min_, max_;$/;"	m	struct:boost::xpressive::detail::repeat_end_matcher	access:public
boost::xpressive::detail::repeat_end_matcher::repeat_end_matcher	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        repeat_end_matcher(int mark_nbr, unsigned int min, unsigned int max)$/;"	f	struct:boost::xpressive::detail::repeat_end_matcher	access:public	signature:(int mark_nbr, unsigned int min, unsigned int max)
boost::xpressive::detail::restore_action_queue	xpressive/detail/core/state.hpp	/^inline void restore_action_queue(memento<BidiIter> const &mem, match_state<BidiIter> &state)$/;"	f	namespace:boost::xpressive::detail	signature:(memento<BidiIter> const &mem, match_state<BidiIter> &state)
boost::xpressive::detail::restore_sub_matches	xpressive/detail/core/state.hpp	/^inline void restore_sub_matches(memento<BidiIter> const &mem, match_state<BidiIter> &state)$/;"	f	namespace:boost::xpressive::detail	signature:(memento<BidiIter> const &mem, match_state<BidiIter> &state)
boost::xpressive::detail::results_cache	xpressive/detail/core/results_cache.hpp	/^    struct results_cache$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::results_cache::access	xpressive/detail/core/results_cache.hpp	/^        typedef core_access<BidiIter> access;$/;"	t	struct:boost::xpressive::detail::results_cache	access:public
boost::xpressive::detail::results_cache::append_new	xpressive/detail/core/results_cache.hpp	/^        match_results<BidiIter> &append_new(nested_results<BidiIter> &out)$/;"	f	struct:boost::xpressive::detail::results_cache	access:public	signature:(nested_results<BidiIter> &out)
boost::xpressive::detail::results_cache::cache_	xpressive/detail/core/results_cache.hpp	/^        nested_results<BidiIter> cache_;$/;"	m	struct:boost::xpressive::detail::results_cache	access:private
boost::xpressive::detail::results_cache::reclaim_all	xpressive/detail/core/results_cache.hpp	/^        void reclaim_all(nested_results<BidiIter> &out)$/;"	f	struct:boost::xpressive::detail::results_cache	access:public	signature:(nested_results<BidiIter> &out)
boost::xpressive::detail::results_cache::reclaim_last	xpressive/detail/core/results_cache.hpp	/^        void reclaim_last(nested_results<BidiIter> &out)$/;"	f	struct:boost::xpressive::detail::results_cache	access:public	signature:(nested_results<BidiIter> &out)
boost::xpressive::detail::results_cache::reclaim_last_n	xpressive/detail/core/results_cache.hpp	/^        void reclaim_last_n(nested_results<BidiIter> &out, std::size_t count)$/;"	f	struct:boost::xpressive::detail::results_cache	access:public	signature:(nested_results<BidiIter> &out, std::size_t count)
boost::xpressive::detail::results_extras	xpressive/match_results.hpp	/^struct results_extras$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
boost::xpressive::detail::results_extras::results_cache_	xpressive/match_results.hpp	/^    results_cache<BidiIter> results_cache_;$/;"	m	struct:boost::xpressive::detail::results_extras	access:public
boost::xpressive::detail::results_extras::sub_match_stack_	xpressive/match_results.hpp	/^    sequence_stack<sub_match_impl<BidiIter> > sub_match_stack_;$/;"	m	struct:boost::xpressive::detail::results_extras	access:public
boost::xpressive::detail::save_restore	xpressive/detail/utility/save_restore.hpp	/^    struct save_restore$/;"	s	namespace:boost::xpressive::detail	inherits:noncopyable
boost::xpressive::detail::save_restore::ref	xpressive/detail/utility/save_restore.hpp	/^        T &ref;$/;"	m	struct:boost::xpressive::detail::save_restore	access:private
boost::xpressive::detail::save_restore::restore	xpressive/detail/utility/save_restore.hpp	/^        void restore()$/;"	f	struct:boost::xpressive::detail::save_restore	access:public	signature:()
boost::xpressive::detail::save_restore::save_restore	xpressive/detail/utility/save_restore.hpp	/^        explicit save_restore(T &t)$/;"	f	struct:boost::xpressive::detail::save_restore	access:public	signature:(T &t)
boost::xpressive::detail::save_restore::save_restore	xpressive/detail/utility/save_restore.hpp	/^        save_restore(T &t, T const &n)$/;"	f	struct:boost::xpressive::detail::save_restore	access:public	signature:(T &t, T const &n)
boost::xpressive::detail::save_restore::val	xpressive/detail/utility/save_restore.hpp	/^        T const val;$/;"	m	struct:boost::xpressive::detail::save_restore	access:private
boost::xpressive::detail::save_restore::~save_restore	xpressive/detail/utility/save_restore.hpp	/^        ~save_restore()$/;"	f	struct:boost::xpressive::detail::save_restore	access:public	signature:()
boost::xpressive::detail::save_sub_matches	xpressive/detail/core/state.hpp	/^inline memento<BidiIter> save_sub_matches(match_state<BidiIter> &state)$/;"	f	namespace:boost::xpressive::detail	signature:(match_state<BidiIter> &state)
boost::xpressive::detail::scope_next	xpressive/match_results.hpp	/^enum transform_scope { scope_next = 0, scope_rest = 1 };$/;"	e	enum:boost::xpressive::detail::transform_scope
boost::xpressive::detail::scope_rest	xpressive/match_results.hpp	/^enum transform_scope { scope_next = 0, scope_rest = 1 };$/;"	e	enum:boost::xpressive::detail::transform_scope
boost::xpressive::detail::self_placeholder	xpressive/detail/static/placeholders.hpp	/^struct self_placeholder$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::sequence	xpressive/detail/dynamic/sequence.hpp	/^struct sequence$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::sequence::alt_end_xpr_	xpressive/detail/dynamic/sequence.hpp	/^    intrusive_ptr<alt_end_xpr_type> alt_end_xpr_;$/;"	m	struct:boost::xpressive::detail::sequence	access:private
boost::xpressive::detail::sequence::alt_end_xpr_type	xpressive/detail/dynamic/sequence.hpp	/^    typedef dynamic_xpression<alternate_end_matcher, BidiIter> alt_end_xpr_type;$/;"	t	struct:boost::xpressive::detail::sequence	access:private
boost::xpressive::detail::sequence::alternates_	xpressive/detail/dynamic/sequence.hpp	/^    alternates_vector<BidiIter> *alternates_;$/;"	m	struct:boost::xpressive::detail::sequence	access:private
boost::xpressive::detail::sequence::empty	xpressive/detail/dynamic/sequence.hpp	/^    bool empty() const$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:() const
boost::xpressive::detail::sequence::head_	xpressive/detail/dynamic/sequence.hpp	/^    shared_matchable<BidiIter> head_;$/;"	m	struct:boost::xpressive::detail::sequence	access:private
boost::xpressive::detail::sequence::operator +=	xpressive/detail/dynamic/sequence.hpp	/^    sequence<BidiIter> &operator +=(sequence<BidiIter> const &that)$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:(sequence<BidiIter> const &that)
boost::xpressive::detail::sequence::operator |=	xpressive/detail/dynamic/sequence.hpp	/^    sequence<BidiIter> &operator |=(sequence<BidiIter> that)$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:(sequence<BidiIter> that)
boost::xpressive::detail::sequence::pure	xpressive/detail/dynamic/sequence.hpp	/^    bool pure() const$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:() const
boost::xpressive::detail::sequence::pure_	xpressive/detail/dynamic/sequence.hpp	/^    bool pure_;$/;"	m	struct:boost::xpressive::detail::sequence	access:private
boost::xpressive::detail::sequence::quant	xpressive/detail/dynamic/sequence.hpp	/^    quant_enum quant() const$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:() const
boost::xpressive::detail::sequence::quant_	xpressive/detail/dynamic/sequence.hpp	/^    quant_enum quant_;$/;"	m	struct:boost::xpressive::detail::sequence	access:private
boost::xpressive::detail::sequence::repeat	xpressive/detail/dynamic/sequence.hpp	/^    void repeat(quant_spec const &spec)$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:(quant_spec const &spec)
boost::xpressive::detail::sequence::sequence	xpressive/detail/dynamic/sequence.hpp	/^    sequence()$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:()
boost::xpressive::detail::sequence::sequence	xpressive/detail/dynamic/sequence.hpp	/^    sequence(intrusive_ptr<dynamic_xpression<Matcher, BidiIter> > const &xpr)$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:(intrusive_ptr<dynamic_xpression<Matcher, BidiIter> > const &xpr)
boost::xpressive::detail::sequence::sequence	xpressive/detail/dynamic/sequence.hpp	/^    sequence(intrusive_ptr<dynamic_xpression<alternate_matcher<alternates_vector<BidiIter>, Traits>, BidiIter> > const &xpr)$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:(intrusive_ptr<dynamic_xpression<alternate_matcher<alternates_vector<BidiIter>, Traits>, BidiIter> > const &xpr)
boost::xpressive::detail::sequence::set_quant_	xpressive/detail/dynamic/sequence.hpp	/^    void set_quant_()$/;"	f	struct:boost::xpressive::detail::sequence	access:private	signature:()
boost::xpressive::detail::sequence::tail_	xpressive/detail/dynamic/sequence.hpp	/^    shared_matchable<BidiIter> *tail_;$/;"	m	struct:boost::xpressive::detail::sequence	access:private
boost::xpressive::detail::sequence::width	xpressive/detail/dynamic/sequence.hpp	/^    detail::width width() const$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:() const
boost::xpressive::detail::sequence::width_	xpressive/detail/dynamic/sequence.hpp	/^    detail::width width_;$/;"	m	struct:boost::xpressive::detail::sequence	access:private
boost::xpressive::detail::sequence::xpr	xpressive/detail/dynamic/sequence.hpp	/^    shared_matchable<BidiIter> const &xpr() const$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:() const
boost::xpressive::detail::sequence_stack	xpressive/detail/utility/sequence_stack.hpp	/^struct sequence_stack$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::sequence_stack::allocate	xpressive/detail/utility/sequence_stack.hpp	/^    static T *allocate(std::size_t size, T const &t)$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:private	signature:(std::size_t size, T const &t)
boost::xpressive::detail::sequence_stack::allocate_guard_t	xpressive/detail/utility/sequence_stack.hpp	/^    struct allocate_guard_t$/;"	s	struct:boost::xpressive::detail::sequence_stack	access:public
boost::xpressive::detail::sequence_stack::allocate_guard_t::dismissed	xpressive/detail/utility/sequence_stack.hpp	/^        bool dismissed;$/;"	m	struct:boost::xpressive::detail::sequence_stack::allocate_guard_t	access:public
boost::xpressive::detail::sequence_stack::allocate_guard_t::i	xpressive/detail/utility/sequence_stack.hpp	/^        std::size_t i;$/;"	m	struct:boost::xpressive::detail::sequence_stack::allocate_guard_t	access:public
boost::xpressive::detail::sequence_stack::allocate_guard_t::p	xpressive/detail/utility/sequence_stack.hpp	/^        T *p;$/;"	m	struct:boost::xpressive::detail::sequence_stack::allocate_guard_t	access:public
boost::xpressive::detail::sequence_stack::allocate_guard_t::~allocate_guard_t	xpressive/detail/utility/sequence_stack.hpp	/^        ~allocate_guard_t()$/;"	f	struct:boost::xpressive::detail::sequence_stack::allocate_guard_t	access:public	signature:()
boost::xpressive::detail::sequence_stack::begin_	xpressive/detail/utility/sequence_stack.hpp	/^    T *begin_;$/;"	m	struct:boost::xpressive::detail::sequence_stack	access:private
boost::xpressive::detail::sequence_stack::chunk	xpressive/detail/utility/sequence_stack.hpp	/^    struct chunk$/;"	s	struct:boost::xpressive::detail::sequence_stack	access:private
boost::xpressive::detail::sequence_stack::chunk::back_	xpressive/detail/utility/sequence_stack.hpp	/^        chunk *back_, *next_;$/;"	m	struct:boost::xpressive::detail::sequence_stack::chunk	access:public
boost::xpressive::detail::sequence_stack::chunk::begin_	xpressive/detail/utility/sequence_stack.hpp	/^        T *const begin_, *curr_, *const end_;$/;"	m	struct:boost::xpressive::detail::sequence_stack::chunk	access:public
boost::xpressive::detail::sequence_stack::chunk::chunk	xpressive/detail/utility/sequence_stack.hpp	/^        chunk(std::size_t size, T const &t, std::size_t count, chunk *back, chunk *next)$/;"	f	struct:boost::xpressive::detail::sequence_stack::chunk	access:public	signature:(std::size_t size, T const &t, std::size_t count, chunk *back, chunk *next)
boost::xpressive::detail::sequence_stack::chunk::curr_	xpressive/detail/utility/sequence_stack.hpp	/^        T *const begin_, *curr_, *const end_;$/;"	m	struct:boost::xpressive::detail::sequence_stack::chunk	access:public
boost::xpressive::detail::sequence_stack::chunk::end_	xpressive/detail/utility/sequence_stack.hpp	/^        T *const begin_, *curr_, *const end_;$/;"	m	struct:boost::xpressive::detail::sequence_stack::chunk	access:public
boost::xpressive::detail::sequence_stack::chunk::next_	xpressive/detail/utility/sequence_stack.hpp	/^        chunk *back_, *next_;$/;"	m	struct:boost::xpressive::detail::sequence_stack::chunk	access:public
boost::xpressive::detail::sequence_stack::chunk::operator =	xpressive/detail/utility/sequence_stack.hpp	/^        chunk &operator =(chunk const &);$/;"	p	struct:boost::xpressive::detail::sequence_stack::chunk	access:private	signature:(chunk const &)
boost::xpressive::detail::sequence_stack::chunk::size	xpressive/detail/utility/sequence_stack.hpp	/^        std::size_t size() const$/;"	f	struct:boost::xpressive::detail::sequence_stack::chunk	access:public	signature:() const
boost::xpressive::detail::sequence_stack::chunk::~chunk	xpressive/detail/utility/sequence_stack.hpp	/^        ~chunk()$/;"	f	struct:boost::xpressive::detail::sequence_stack::chunk	access:public	signature:()
boost::xpressive::detail::sequence_stack::clear	xpressive/detail/utility/sequence_stack.hpp	/^    void clear()$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:()
boost::xpressive::detail::sequence_stack::conserve	xpressive/detail/utility/sequence_stack.hpp	/^    void conserve()$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:()
boost::xpressive::detail::sequence_stack::curr_	xpressive/detail/utility/sequence_stack.hpp	/^    T *curr_;$/;"	m	struct:boost::xpressive::detail::sequence_stack	access:private
boost::xpressive::detail::sequence_stack::current_chunk_	xpressive/detail/utility/sequence_stack.hpp	/^    chunk *current_chunk_;$/;"	m	struct:boost::xpressive::detail::sequence_stack	access:private
boost::xpressive::detail::sequence_stack::deallocate	xpressive/detail/utility/sequence_stack.hpp	/^    static void deallocate(T *p, std::size_t i)$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:private	signature:(T *p, std::size_t i)
boost::xpressive::detail::sequence_stack::end_	xpressive/detail/utility/sequence_stack.hpp	/^    T *end_;$/;"	m	struct:boost::xpressive::detail::sequence_stack	access:private
boost::xpressive::detail::sequence_stack::grow_	xpressive/detail/utility/sequence_stack.hpp	/^    T *grow_(std::size_t count, T const &t)$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:private	signature:(std::size_t count, T const &t)
boost::xpressive::detail::sequence_stack::in_current_chunk	xpressive/detail/utility/sequence_stack.hpp	/^    bool in_current_chunk(T *ptr) const$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:private	signature:(T *ptr) const
boost::xpressive::detail::sequence_stack::push_sequence	xpressive/detail/utility/sequence_stack.hpp	/^    T *push_sequence(std::size_t count, T const &t)$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:(std::size_t count, T const &t)
boost::xpressive::detail::sequence_stack::push_sequence	xpressive/detail/utility/sequence_stack.hpp	/^    T *push_sequence(std::size_t count, T const &t, fill_t)$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:(std::size_t count, T const &t, fill_t)
boost::xpressive::detail::sequence_stack::sequence_stack	xpressive/detail/utility/sequence_stack.hpp	/^    sequence_stack()$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:()
boost::xpressive::detail::sequence_stack::unwind	xpressive/detail/utility/sequence_stack.hpp	/^    void unwind()$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:()
boost::xpressive::detail::sequence_stack::unwind_chunk_	xpressive/detail/utility/sequence_stack.hpp	/^    void unwind_chunk_()$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:private	signature:()
boost::xpressive::detail::sequence_stack::unwind_to	xpressive/detail/utility/sequence_stack.hpp	/^    void unwind_to(T *ptr)$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:(T *ptr)
boost::xpressive::detail::sequence_stack::~sequence_stack	xpressive/detail/utility/sequence_stack.hpp	/^    ~sequence_stack()$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:()
boost::xpressive::detail::set	xpressive/regex_primitives.hpp	/^detail::set_initializer_type const set = {{}};$/;"	m	class:boost::xpressive::detail
boost::xpressive::detail::set_char	xpressive/detail/detail_fwd.hpp	/^    void set_char(basic_chset<Char> &chset, Char ch, Traits const &tr, bool icase);$/;"	p	namespace:boost::xpressive::detail	signature:(basic_chset<Char> &chset, Char ch, Traits const &tr, bool icase)
boost::xpressive::detail::set_char	xpressive/detail/detail_fwd.hpp	/^    void set_char(compound_charset<Traits> &chset, Char ch, Traits const &tr, bool icase);$/;"	p	namespace:boost::xpressive::detail	signature:(compound_charset<Traits> &chset, Char ch, Traits const &tr, bool icase)
boost::xpressive::detail::set_char	xpressive/detail/utility/chset/basic_chset.hpp	/^void set_char(basic_chset<Char> &chset, Char ch, Traits const &tr, bool icase);$/;"	p	namespace:boost::xpressive::detail	signature:(basic_chset<Char> &chset, Char ch, Traits const &tr, bool icase)
boost::xpressive::detail::set_char	xpressive/detail/utility/chset/chset.hpp	/^inline void set_char(compound_charset<Traits> &chset, Char ch, Traits const &tr, bool icase)$/;"	f	namespace:boost::xpressive::detail	signature:(compound_charset<Traits> &chset, Char ch, Traits const &tr, bool icase)
boost::xpressive::detail::set_class	xpressive/detail/detail_fwd.hpp	/^    void set_class(basic_chset<Char> &chset, typename Traits::char_class_type char_class, bool no, Traits const &tr);$/;"	p	namespace:boost::xpressive::detail	signature:(basic_chset<Char> &chset, typename Traits::char_class_type char_class, bool no, Traits const &tr)
boost::xpressive::detail::set_class	xpressive/detail/detail_fwd.hpp	/^    void set_class(compound_charset<Traits> &chset, typename Traits::char_class_type char_class, bool no, Traits const &tr);$/;"	p	namespace:boost::xpressive::detail	signature:(compound_charset<Traits> &chset, typename Traits::char_class_type char_class, bool no, Traits const &tr)
boost::xpressive::detail::set_class	xpressive/detail/utility/chset/basic_chset.hpp	/^void set_class(basic_chset<Char> &chset, typename Traits::char_class_type char_class, bool no, Traits const &tr);$/;"	p	namespace:boost::xpressive::detail	signature:(basic_chset<Char> &chset, typename Traits::char_class_type char_class, bool no, Traits const &tr)
boost::xpressive::detail::set_class	xpressive/detail/utility/chset/chset.hpp	/^inline void set_class(compound_charset<Traits> &chset, typename Traits::char_class_type char_class, bool no, Traits const &)$/;"	f	namespace:boost::xpressive::detail	signature:(compound_charset<Traits> &chset, typename Traits::char_class_type char_class, bool no, Traits const &)
boost::xpressive::detail::set_initializer	xpressive/detail/core/matcher/set_matcher.hpp	/^struct set_initializer$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::set_initializer_type	xpressive/detail/detail_fwd.hpp	/^    typedef proto::expr<proto::tag::terminal, proto::term<set_initializer>, 0> set_initializer_type;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::set_matcher	xpressive/detail/core/matcher/set_matcher.hpp	/^struct set_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_fixed_width
boost::xpressive::detail::set_matcher::char_type	xpressive/detail/core/matcher/set_matcher.hpp	/^    typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::set_matcher	access:public
boost::xpressive::detail::set_matcher::icase_	xpressive/detail/core/matcher/set_matcher.hpp	/^    bool icase_;$/;"	m	struct:boost::xpressive::detail::set_matcher	access:public
boost::xpressive::detail::set_matcher::in_set	xpressive/detail/core/matcher/set_matcher.hpp	/^    bool in_set(Traits const &tr, char_type ch) const$/;"	f	struct:boost::xpressive::detail::set_matcher	access:public	signature:(Traits const &tr, char_type ch) const
boost::xpressive::detail::set_matcher::inverse	xpressive/detail/core/matcher/set_matcher.hpp	/^    void inverse()$/;"	f	struct:boost::xpressive::detail::set_matcher	access:public	signature:()
boost::xpressive::detail::set_matcher::match	xpressive/detail/core/matcher/set_matcher.hpp	/^    bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::set_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::set_matcher::nocase	xpressive/detail/core/matcher/set_matcher.hpp	/^    void nocase(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::set_matcher	access:public	signature:(Traits const &tr)
boost::xpressive::detail::set_matcher::not_	xpressive/detail/core/matcher/set_matcher.hpp	/^    bool not_;$/;"	m	struct:boost::xpressive::detail::set_matcher	access:public
boost::xpressive::detail::set_matcher::set_	xpressive/detail/core/matcher/set_matcher.hpp	/^    char_type set_[ Size::value ];$/;"	m	struct:boost::xpressive::detail::set_matcher	access:public
boost::xpressive::detail::set_matcher::set_matcher	xpressive/detail/core/matcher/set_matcher.hpp	/^    set_matcher()$/;"	f	struct:boost::xpressive::detail::set_matcher	access:public	signature:()
boost::xpressive::detail::set_range	xpressive/detail/detail_fwd.hpp	/^    void set_range(basic_chset<Char> &chset, Char from, Char to, Traits const &tr, bool icase);$/;"	p	namespace:boost::xpressive::detail	signature:(basic_chset<Char> &chset, Char from, Char to, Traits const &tr, bool icase)
boost::xpressive::detail::set_range	xpressive/detail/detail_fwd.hpp	/^    void set_range(compound_charset<Traits> &chset, Char from, Char to, Traits const &tr, bool icase);$/;"	p	namespace:boost::xpressive::detail	signature:(compound_charset<Traits> &chset, Char from, Char to, Traits const &tr, bool icase)
boost::xpressive::detail::set_range	xpressive/detail/utility/chset/basic_chset.hpp	/^void set_range(basic_chset<Char> &chset, Char from, Char to, Traits const &tr, bool icase);$/;"	p	namespace:boost::xpressive::detail	signature:(basic_chset<Char> &chset, Char from, Char to, Traits const &tr, bool icase)
boost::xpressive::detail::set_range	xpressive/detail/utility/chset/chset.hpp	/^inline void set_range(compound_charset<Traits> &chset, Char from, Char to, Traits const &tr, bool icase)$/;"	f	namespace:boost::xpressive::detail	signature:(compound_charset<Traits> &chset, Char from, Char to, Traits const &tr, bool icase)
boost::xpressive::detail::set_transform	xpressive/match_results.hpp	/^inline bool set_transform(Iterator &, transform_op, transform_scope)$/;"	f	namespace:boost::xpressive::detail	signature:(Iterator &, transform_op, transform_scope)
boost::xpressive::detail::shared_matchable	xpressive/detail/dynamic/matchable.hpp	/^struct shared_matchable$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::shared_matchable::BOOST_STATIC_CONSTANT	xpressive/detail/dynamic/matchable.hpp	/^    BOOST_STATIC_CONSTANT(bool, pure = false);$/;"	p	struct:boost::xpressive::detail::shared_matchable	access:public	signature:(bool, pure = false)
boost::xpressive::detail::shared_matchable::BOOST_STATIC_CONSTANT	xpressive/detail/dynamic/matchable.hpp	/^    BOOST_STATIC_CONSTANT(std::size_t, width = unknown_width::value);$/;"	p	struct:boost::xpressive::detail::shared_matchable	access:public	signature:(std::size_t, width = unknown_width::value)
boost::xpressive::detail::shared_matchable::char_type	xpressive/detail/dynamic/matchable.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::shared_matchable	access:public
boost::xpressive::detail::shared_matchable::iterator_type	xpressive/detail/dynamic/matchable.hpp	/^    typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::detail::shared_matchable	access:public
boost::xpressive::detail::shared_matchable::link	xpressive/detail/dynamic/matchable.hpp	/^    void link(xpression_linker<char_type> &linker) const$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:public	signature:(xpression_linker<char_type> &linker) const
boost::xpressive::detail::shared_matchable::match	xpressive/detail/dynamic/matchable.hpp	/^    bool match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::shared_matchable::matchable	xpressive/detail/dynamic/matchable.hpp	/^    matchable_ptr const &matchable() const$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:public	signature:() const
boost::xpressive::detail::shared_matchable::matchable_ptr	xpressive/detail/dynamic/matchable.hpp	/^    typedef intrusive_ptr<matchable_ex<BidiIter> const> matchable_ptr;$/;"	t	struct:boost::xpressive::detail::shared_matchable	access:public
boost::xpressive::detail::shared_matchable::operator !	xpressive/detail/dynamic/matchable.hpp	/^    bool operator !() const$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:public	signature:() const
boost::xpressive::detail::shared_matchable::operator !=	xpressive/detail/dynamic/matchable.hpp	/^    friend bool operator !=(shared_matchable<BidiIter> const &left, shared_matchable<BidiIter> const &right)$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:friend	signature:(shared_matchable<BidiIter> const &left, shared_matchable<BidiIter> const &right)
boost::xpressive::detail::shared_matchable::operator ==	xpressive/detail/dynamic/matchable.hpp	/^    friend bool operator ==(shared_matchable<BidiIter> const &left, shared_matchable<BidiIter> const &right)$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:friend	signature:(shared_matchable<BidiIter> const &left, shared_matchable<BidiIter> const &right)
boost::xpressive::detail::shared_matchable::peek	xpressive/detail/dynamic/matchable.hpp	/^    void peek(xpression_peeker<char_type> &peeker) const$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:public	signature:(xpression_peeker<char_type> &peeker) const
boost::xpressive::detail::shared_matchable::push_match	xpressive/detail/dynamic/matchable.hpp	/^    bool push_match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::shared_matchable::shared_matchable	xpressive/detail/dynamic/matchable.hpp	/^    shared_matchable(matchable_ptr const &xpr = matchable_ptr())$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:public	signature:(matchable_ptr const &xpr = matchable_ptr())
boost::xpressive::detail::shared_matchable::xpr_	xpressive/detail/dynamic/matchable.hpp	/^    matchable_ptr xpr_;$/;"	m	struct:boost::xpressive::detail::shared_matchable	access:private
boost::xpressive::detail::simple_repeat_matcher	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    struct simple_repeat_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_variable_width
boost::xpressive::detail::simple_repeat_matcher::get_width	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        detail::width get_width() const$/;"	f	struct:boost::xpressive::detail::simple_repeat_matcher	access:public	signature:() const
boost::xpressive::detail::simple_repeat_matcher::greedy_type	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        typedef Greedy greedy_type;$/;"	t	struct:boost::xpressive::detail::simple_repeat_matcher	access:public
boost::xpressive::detail::simple_repeat_matcher::leading_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        mutable bool leading_;$/;"	m	struct:boost::xpressive::detail::simple_repeat_matcher	access:public
boost::xpressive::detail::simple_repeat_matcher::match	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::simple_repeat_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::simple_repeat_matcher::match_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, greedy_fast_tag) const$/;"	f	struct:boost::xpressive::detail::simple_repeat_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, greedy_fast_tag) const
boost::xpressive::detail::simple_repeat_matcher::match_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, greedy_slow_tag) const$/;"	f	struct:boost::xpressive::detail::simple_repeat_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, greedy_slow_tag) const
boost::xpressive::detail::simple_repeat_matcher::match_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, non_greedy_tag) const$/;"	f	struct:boost::xpressive::detail::simple_repeat_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, non_greedy_tag) const
boost::xpressive::detail::simple_repeat_matcher::max_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        unsigned int min_, max_;$/;"	m	struct:boost::xpressive::detail::simple_repeat_matcher	access:public
boost::xpressive::detail::simple_repeat_matcher::min_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        unsigned int min_, max_;$/;"	m	struct:boost::xpressive::detail::simple_repeat_matcher	access:public
boost::xpressive::detail::simple_repeat_matcher::operator =	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        simple_repeat_matcher &operator =(simple_repeat_matcher const &);$/;"	p	struct:boost::xpressive::detail::simple_repeat_matcher	access:private	signature:(simple_repeat_matcher const &)
boost::xpressive::detail::simple_repeat_matcher::simple_repeat_matcher	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        simple_repeat_matcher(Xpr const &xpr, unsigned int min, unsigned int max, std::size_t width)$/;"	f	struct:boost::xpressive::detail::simple_repeat_matcher	access:public	signature:(Xpr const &xpr, unsigned int min, unsigned int max, std::size_t width)
boost::xpressive::detail::simple_repeat_matcher::width_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        std::size_t width_;$/;"	m	struct:boost::xpressive::detail::simple_repeat_matcher	access:public
boost::xpressive::detail::simple_repeat_matcher::xpr_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        Xpr xpr_;$/;"	m	struct:boost::xpressive::detail::simple_repeat_matcher	access:public
boost::xpressive::detail::simple_repeat_matcher::xpr_type	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        typedef Xpr xpr_type;$/;"	t	struct:boost::xpressive::detail::simple_repeat_matcher	access:public
boost::xpressive::detail::simple_repeat_traits	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    struct simple_repeat_traits$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::simple_repeat_traits	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    struct simple_repeat_traits<any_dxpr, mpl::true_, mpl::true_>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::simple_repeat_traits	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    struct simple_repeat_traits<any_sxpr, mpl::true_, mpl::true_>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::simple_repeat_traits::tag_type	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        typedef greedy_fast_tag tag_type;$/;"	t	struct:boost::xpressive::detail::simple_repeat_traits	access:public
boost::xpressive::detail::simple_repeat_traits::tag_type	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        typedef typename mpl::if_c<Greedy::value, greedy_slow_tag, non_greedy_tag>::type tag_type;$/;"	t	struct:boost::xpressive::detail::simple_repeat_traits	access:public
boost::xpressive::detail::sizeof	xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(std::ctype_base::mask), ==, sizeof(umask_t));$/;"	p	namespace:boost::xpressive::detail	signature:(std::ctype_base::mask)
boost::xpressive::detail::sizeof	xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(std::ctype_base::mask), ==, sizeof(umask_t));$/;"	p	namespace:boost::xpressive::detail	signature:(umask_t)
boost::xpressive::detail::sizeof	xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(umask_t), <=, sizeof(umaskex_t));$/;"	p	namespace:boost::xpressive::detail	signature:(umask_t)
boost::xpressive::detail::sizeof	xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(umask_t), <=, sizeof(umaskex_t));$/;"	p	namespace:boost::xpressive::detail	signature:(umaskex_t)
boost::xpressive::detail::skip_directive	xpressive/regex_primitives.hpp	/^    struct skip_directive$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::skip_directive::operator ()	xpressive/regex_primitives.hpp	/^        operator ()(Expr const &expr) const$/;"	f	struct:boost::xpressive::detail::skip_directive	access:public	signature:(Expr const &expr) const
boost::xpressive::detail::skip_directive::result	xpressive/regex_primitives.hpp	/^        struct result {};$/;"	s	struct:boost::xpressive::detail::skip_directive	access:public
boost::xpressive::detail::skip_directive::result	xpressive/regex_primitives.hpp	/^        struct result<This(Expr)>$/;"	s	struct:boost::xpressive::detail::skip_directive	access:public
boost::xpressive::detail::skip_directive::result::skip_transform	xpressive/regex_primitives.hpp	/^            skip_transform;$/;"	t	struct:boost::xpressive::detail::skip_directive::result	access:public
boost::xpressive::detail::skip_directive::result::type	xpressive/regex_primitives.hpp	/^            type;$/;"	t	struct:boost::xpressive::detail::skip_directive::result	access:public
boost::xpressive::detail::skip_directive::skip_	xpressive/regex_primitives.hpp	/^        skip_type skip_;$/;"	m	struct:boost::xpressive::detail::skip_directive	access:private
boost::xpressive::detail::skip_directive::skip_directive	xpressive/regex_primitives.hpp	/^        skip_directive(Skip const &skip)$/;"	f	struct:boost::xpressive::detail::skip_directive	access:public	signature:(Skip const &skip)
boost::xpressive::detail::skip_directive::skip_type	xpressive/regex_primitives.hpp	/^        typedef typename proto::result_of::as_expr<Skip>::type skip_type;$/;"	t	struct:boost::xpressive::detail::skip_directive	access:public
boost::xpressive::detail::skip_primitives	xpressive/regex_primitives.hpp	/^    struct skip_primitives : proto::transform<skip_primitives>$/;"	s	namespace:boost::xpressive::detail	inherits:proto::transform
boost::xpressive::detail::skip_primitives::impl	xpressive/regex_primitives.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::detail::skip_primitives	inherits:proto::transform_impl	access:public
boost::xpressive::detail::skip_primitives::impl::operator ()	xpressive/regex_primitives.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::detail::skip_primitives::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param ) const
boost::xpressive::detail::skip_primitives::impl::result_type	xpressive/regex_primitives.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::detail::skip_primitives::impl	access:public
boost::xpressive::detail::stacked_xpression	xpressive/detail/static/static.hpp	/^struct stacked_xpression$/;"	s	namespace:boost::xpressive::detail	inherits:Next
boost::xpressive::detail::stacked_xpression::match	xpressive/detail/static/static.hpp	/^    bool match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::stacked_xpression	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::stacked_xpression::pop_match	xpressive/detail/static/static.hpp	/^    static bool pop_match(match_state<BidiIter> &state, void const *top)$/;"	f	struct:boost::xpressive::detail::stacked_xpression	access:public	signature:(match_state<BidiIter> &state, void const *top)
boost::xpressive::detail::stacked_xpression::skip_impl	xpressive/detail/static/static.hpp	/^    static bool skip_impl(That const &that, match_state<BidiIter> &state)$/;"	f	struct:boost::xpressive::detail::stacked_xpression	access:public	signature:(That const &that, match_state<BidiIter> &state)
boost::xpressive::detail::stacked_xpression::skip_match	xpressive/detail/static/static.hpp	/^    bool skip_match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::stacked_xpression	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::stacked_xpression::top_match	xpressive/detail/static/static.hpp	/^    static bool top_match(match_state<BidiIter> &state, void const *top)$/;"	f	struct:boost::xpressive::detail::stacked_xpression	access:public	signature:(match_state<BidiIter> &state, void const *top)
boost::xpressive::detail::stacked_xpression_cast	xpressive/detail/static/static.hpp	/^inline stacked_xpression<Top, Next> const &stacked_xpression_cast(Next const &next)$/;"	f	namespace:boost::xpressive::detail	signature:(Next const &next)
boost::xpressive::detail::static_compile	xpressive/detail/detail_fwd.hpp	/^    void static_compile(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl);$/;"	p	namespace:boost::xpressive::detail	signature:(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl)
boost::xpressive::detail::static_compile	xpressive/detail/static/compile.hpp	/^    void static_compile(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl)$/;"	f	namespace:boost::xpressive::detail	signature:(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl)
boost::xpressive::detail::static_compile_impl1	xpressive/detail/static/compile.hpp	/^    static_compile_impl1(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl)$/;"	f	namespace:boost::xpressive::detail	signature:(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl)
boost::xpressive::detail::static_compile_impl2	xpressive/detail/static/compile.hpp	/^    void static_compile_impl2(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl, Traits const &tr)$/;"	f	namespace:boost::xpressive::detail	signature:(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl, Traits const &tr)
boost::xpressive::detail::static_xpression	xpressive/detail/static/static.hpp	/^struct static_xpression$/;"	s	namespace:boost::xpressive::detail	inherits:Matcher
boost::xpressive::detail::static_xpression::BOOST_STATIC_CONSTANT	xpressive/detail/static/static.hpp	/^    BOOST_STATIC_CONSTANT($/;"	p	struct:boost::xpressive::detail::static_xpression	access:public	signature:( std::size_t , width = Matcher::width != unknown_width::value && Next::width != unknown_width::value ? Matcher::width + Next::width : unknown_width::value )
boost::xpressive::detail::static_xpression::BOOST_STATIC_CONSTANT	xpressive/detail/static/static.hpp	/^    BOOST_STATIC_CONSTANT(bool, pure = Matcher::pure && Next::pure);$/;"	p	struct:boost::xpressive::detail::static_xpression	access:public	signature:(bool, pure = Matcher::pure && Next::pure)
boost::xpressive::detail::static_xpression::get_width	xpressive/detail/static/static.hpp	/^    detail::width get_width() const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:public	signature:() const
boost::xpressive::detail::static_xpression::get_width_	xpressive/detail/static/static.hpp	/^    detail::width get_width_(mpl::size_t<Width>) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:private	signature:(mpl::size_t<Width>) const
boost::xpressive::detail::static_xpression::get_width_	xpressive/detail/static/static.hpp	/^    detail::width get_width_(unknown_width) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:private	signature:(unknown_width) const
boost::xpressive::detail::static_xpression::link	xpressive/detail/static/static.hpp	/^    void link(xpression_linker<Char> &linker) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:public	signature:(xpression_linker<Char> &linker) const
boost::xpressive::detail::static_xpression::match	xpressive/detail/static/static.hpp	/^    bool match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::static_xpression::next_	xpressive/detail/static/static.hpp	/^    Next next_;$/;"	m	struct:boost::xpressive::detail::static_xpression	access:public
boost::xpressive::detail::static_xpression::operator =	xpressive/detail/static/static.hpp	/^    static_xpression &operator =(static_xpression const &);$/;"	p	struct:boost::xpressive::detail::static_xpression	access:private	signature:(static_xpression const &)
boost::xpressive::detail::static_xpression::peek	xpressive/detail/static/static.hpp	/^    void peek(xpression_peeker<Char> &peeker) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:public	signature:(xpression_peeker<Char> &peeker) const
boost::xpressive::detail::static_xpression::peek_next_	xpressive/detail/static/static.hpp	/^    void peek_next_(mpl::false_, xpression_peeker<Char> &) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:private	signature:(mpl::false_, xpression_peeker<Char> &) const
boost::xpressive::detail::static_xpression::peek_next_	xpressive/detail/static/static.hpp	/^    void peek_next_(mpl::true_, xpression_peeker<Char> &peeker) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:private	signature:(mpl::true_, xpression_peeker<Char> &peeker) const
boost::xpressive::detail::static_xpression::push_match	xpressive/detail/static/static.hpp	/^    bool push_match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:public	signature:(match_state<BidiIter> &state) const
boost::xpressive::detail::static_xpression::skip_impl	xpressive/detail/static/static.hpp	/^    static bool skip_impl(That const &that, match_state<BidiIter> &state)$/;"	f	struct:boost::xpressive::detail::static_xpression	access:public	signature:(That const &that, match_state<BidiIter> &state)
boost::xpressive::detail::static_xpression::static_xpression	xpressive/detail/static/static.hpp	/^    static_xpression(Matcher const &matcher = Matcher(), Next const &next = Next())$/;"	f	struct:boost::xpressive::detail::static_xpression	access:public	signature:(Matcher const &matcher = Matcher(), Next const &next = Next())
boost::xpressive::detail::std::to_vector	xpressive/regex_token_iterator.hpp	/^inline std::vector<int> const &to_vector(std::vector<int> const &subs)$/;"	f	class:boost::xpressive::detail::std	signature:(std::vector<int> const &subs)
boost::xpressive::detail::std_ctype_alnum	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alnum = 1 << 0;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_alnum	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alnum = mask_cast<std::ctype_base::alnum>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_alpha	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alpha = 1 << 1;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_alpha	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alpha = mask_cast<std::ctype_base::alpha>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_cntrl	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_cntrl = 1 << 2;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_cntrl	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_cntrl = mask_cast<std::ctype_base::cntrl>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_digit	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_digit = 1 << 3;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_digit	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_digit = mask_cast<std::ctype_base::digit>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_graph	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_graph = 1 << 4;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_graph	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_graph = mask_cast<std::ctype_base::graph>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_lower	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_lower = 1 << 5;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_lower	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_lower = mask_cast<std::ctype_base::lower>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_print	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_print = 1 << 6;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_print	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_print = mask_cast<std::ctype_base::print>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_punct	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_punct = 1 << 7;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_punct	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_punct = mask_cast<std::ctype_base::punct>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_reserved	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_reserved = 0;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_reserved	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_reserved = 0x8000;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_reserved	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_reserved = 0x8200;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_space	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_space = 1 << 8;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_space	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_space = mask_cast<std::ctype_base::space>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_upper	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_upper = 1 << 9;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_upper	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_upper = mask_cast<std::ctype_base::upper>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_xdigit	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_xdigit = 1 << 10;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_ctype_xdigit	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_xdigit = mask_cast<std::ctype_base::xdigit>::value;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::std_masks	xpressive/traits/cpp_regex_traits.hpp	/^    static umaskex_t const std_masks[] =$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::string_cast	xpressive/detail/utility/traits_utils.hpp	/^    string_cast(From const &from, Traits const &tr)$/;"	f	namespace:boost::xpressive::detail	signature:(From const &from, Traits const &tr)
boost::xpressive::detail::string_cast_	xpressive/detail/utility/traits_utils.hpp	/^    struct string_cast_$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::string_cast_	xpressive/detail/utility/traits_utils.hpp	/^    struct string_cast_<From, From, Char, Char>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::string_cast_	xpressive/detail/utility/traits_utils.hpp	/^    struct string_cast_<To, From, Char, Char>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::string_cast_::BOOST_MPL_ASSERT	xpressive/detail/utility/traits_utils.hpp	/^        BOOST_MPL_ASSERT((is_same<FromChar, char>));$/;"	p	struct:boost::xpressive::detail::string_cast_	access:public	signature:(is_same<FromChar, char>)
boost::xpressive::detail::string_cast_::operator ()	xpressive/detail/utility/traits_utils.hpp	/^        result_type operator()(From const &from, Traits const &) const$/;"	f	struct:boost::xpressive::detail::string_cast_	access:public	signature:(From const &from, Traits const &) const
boost::xpressive::detail::string_cast_::operator ()	xpressive/detail/utility/traits_utils.hpp	/^        result_type operator()(From const &from, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::string_cast_	access:public	signature:(From const &from, Traits const &tr) const
boost::xpressive::detail::string_cast_::result_type	xpressive/detail/utility/traits_utils.hpp	/^        typedef From const &result_type;$/;"	t	struct:boost::xpressive::detail::string_cast_	access:public
boost::xpressive::detail::string_cast_::result_type	xpressive/detail/utility/traits_utils.hpp	/^        typedef To const result_type;$/;"	t	struct:boost::xpressive::detail::string_cast_	access:public
boost::xpressive::detail::string_literal	xpressive/detail/utility/literals.hpp	/^struct string_literal<char>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::string_literal	xpressive/detail/utility/literals.hpp	/^struct string_literal<wchar_t>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::string_literal::pick	xpressive/detail/utility/literals.hpp	/^    static BOOST_CONSTEXPR char const *pick(char const *cstr, wchar_t const *)$/;"	f	struct:boost::xpressive::detail::string_literal	access:public	signature:(char const *cstr, wchar_t const *)
boost::xpressive::detail::string_literal::pick	xpressive/detail/utility/literals.hpp	/^    static BOOST_CONSTEXPR char pick(char ch, wchar_t)$/;"	f	struct:boost::xpressive::detail::string_literal	access:public	signature:(char ch, wchar_t)
boost::xpressive::detail::string_literal::pick	xpressive/detail/utility/literals.hpp	/^    static BOOST_CONSTEXPR wchar_t const *pick(char const *, wchar_t const *cstr)$/;"	f	struct:boost::xpressive::detail::string_literal	access:public	signature:(char const *, wchar_t const *cstr)
boost::xpressive::detail::string_literal::pick	xpressive/detail/utility/literals.hpp	/^    static BOOST_CONSTEXPR wchar_t pick(char, wchar_t ch)$/;"	f	struct:boost::xpressive::detail::string_literal	access:public	signature:(char, wchar_t ch)
boost::xpressive::detail::string_matcher	xpressive/detail/core/matcher/string_matcher.hpp	/^    struct string_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_fixed_unknown_width
boost::xpressive::detail::string_matcher::char_type	xpressive/detail/core/matcher/string_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::string_matcher	access:public
boost::xpressive::detail::string_matcher::end_	xpressive/detail/core/matcher/string_matcher.hpp	/^        char_type const *end_;$/;"	m	struct:boost::xpressive::detail::string_matcher	access:public
boost::xpressive::detail::string_matcher::get_width	xpressive/detail/core/matcher/string_matcher.hpp	/^        detail::width get_width() const$/;"	f	struct:boost::xpressive::detail::string_matcher	access:public	signature:() const
boost::xpressive::detail::string_matcher::icase_type	xpressive/detail/core/matcher/string_matcher.hpp	/^        typedef ICase icase_type;$/;"	t	struct:boost::xpressive::detail::string_matcher	access:public
boost::xpressive::detail::string_matcher::match	xpressive/detail/core/matcher/string_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::string_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
boost::xpressive::detail::string_matcher::str_	xpressive/detail/core/matcher/string_matcher.hpp	/^        string_type str_;$/;"	m	struct:boost::xpressive::detail::string_matcher	access:public
boost::xpressive::detail::string_matcher::string_matcher	xpressive/detail/core/matcher/string_matcher.hpp	/^        string_matcher(string_matcher<Traits, ICase> const &that)$/;"	f	struct:boost::xpressive::detail::string_matcher	access:public	signature:(string_matcher<Traits, ICase> const &that)
boost::xpressive::detail::string_matcher::string_matcher	xpressive/detail/core/matcher/string_matcher.hpp	/^        string_matcher(string_type const &str, Traits const &tr)$/;"	f	struct:boost::xpressive::detail::string_matcher	access:public	signature:(string_type const &str, Traits const &tr)
boost::xpressive::detail::string_matcher::string_type	xpressive/detail/core/matcher/string_matcher.hpp	/^        typedef typename Traits::string_type string_type;$/;"	t	struct:boost::xpressive::detail::string_matcher	access:public
boost::xpressive::detail::string_type	xpressive/detail/detail_fwd.hpp	/^    struct string_type$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::string_type	xpressive/detail/detail_fwd.hpp	/^    struct string_type<char>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::string_type	xpressive/detail/detail_fwd.hpp	/^    struct string_type<wchar_t>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::string_type::type	xpressive/detail/detail_fwd.hpp	/^        typedef std::string type;$/;"	t	struct:boost::xpressive::detail::string_type	access:public
boost::xpressive::detail::string_type::type	xpressive/detail/detail_fwd.hpp	/^        typedef std::vector<Char> type;$/;"	t	struct:boost::xpressive::detail::string_type	access:public
boost::xpressive::detail::string_type::type	xpressive/detail/detail_fwd.hpp	/^        typedef std::wstring type;$/;"	t	struct:boost::xpressive::detail::string_type	access:public
boost::xpressive::detail::sub_match_impl	xpressive/detail/core/sub_match_impl.hpp	/^struct sub_match_impl$/;"	s	namespace:boost::xpressive::detail	inherits:sub_match
boost::xpressive::detail::sub_match_impl::begin_	xpressive/detail/core/sub_match_impl.hpp	/^    BidiIter begin_;$/;"	m	struct:boost::xpressive::detail::sub_match_impl	access:public
boost::xpressive::detail::sub_match_impl::repeat_count_	xpressive/detail/core/sub_match_impl.hpp	/^    unsigned int repeat_count_;$/;"	m	struct:boost::xpressive::detail::sub_match_impl	access:public
boost::xpressive::detail::sub_match_impl::sub_match_impl	xpressive/detail/core/sub_match_impl.hpp	/^    sub_match_impl(BidiIter const &begin)$/;"	f	struct:boost::xpressive::detail::sub_match_impl	access:public	signature:(BidiIter const &begin)
boost::xpressive::detail::sub_match_impl::zero_width_	xpressive/detail/core/sub_match_impl.hpp	/^    bool zero_width_;$/;"	m	struct:boost::xpressive::detail::sub_match_impl	access:public
boost::xpressive::detail::sub_match_iterator	xpressive/detail/core/sub_match_vector.hpp	/^struct sub_match_iterator$/;"	s	namespace:boost::xpressive::detail	inherits:iterator_adaptor
boost::xpressive::detail::sub_match_iterator::base_t	xpressive/detail/core/sub_match_vector.hpp	/^    > base_t;$/;"	t	struct:boost::xpressive::detail::sub_match_iterator	access:public
boost::xpressive::detail::sub_match_iterator::sub_match_iterator	xpressive/detail/core/sub_match_vector.hpp	/^    sub_match_iterator(MainIter baseiter)$/;"	f	struct:boost::xpressive::detail::sub_match_iterator	access:public	signature:(MainIter baseiter)
boost::xpressive::detail::sub_match_vector	xpressive/detail/core/sub_match_vector.hpp	/^struct sub_match_vector$/;"	s	namespace:boost::xpressive::detail	inherits:noncopyable
boost::xpressive::detail::sub_match_vector::begin	xpressive/detail/core/sub_match_vector.hpp	/^    const_iterator begin() const$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:() const
boost::xpressive::detail::sub_match_vector::char_type	xpressive/detail/core/sub_match_vector.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
boost::xpressive::detail::sub_match_vector::const_iterator	xpressive/detail/core/sub_match_vector.hpp	/^    > const_iterator;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
boost::xpressive::detail::sub_match_vector::const_reference	xpressive/detail/core/sub_match_vector.hpp	/^    typedef value_type const &const_reference;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
boost::xpressive::detail::sub_match_vector::difference_type	xpressive/detail/core/sub_match_vector.hpp	/^    typedef typename iterator_difference<BidiIter>::type difference_type;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
boost::xpressive::detail::sub_match_vector::dummy	xpressive/detail/core/sub_match_vector.hpp	/^    struct dummy { int i_; };$/;"	s	struct:boost::xpressive::detail::sub_match_vector	access:private
boost::xpressive::detail::sub_match_vector::dummy::bool_type	xpressive/detail/core/sub_match_vector.hpp	/^    typedef int dummy::*bool_type;$/;"	t	class:boost::xpressive::detail::sub_match_vector::dummy	access:private
boost::xpressive::detail::sub_match_vector::dummy::i_	xpressive/detail/core/sub_match_vector.hpp	/^    struct dummy { int i_; };$/;"	m	struct:boost::xpressive::detail::sub_match_vector::dummy	access:public
boost::xpressive::detail::sub_match_vector::empty	xpressive/detail/core/sub_match_vector.hpp	/^    bool empty() const$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:() const
boost::xpressive::detail::sub_match_vector::end	xpressive/detail/core/sub_match_vector.hpp	/^    const_iterator end() const$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:() const
boost::xpressive::detail::sub_match_vector::init_	xpressive/detail/core/sub_match_vector.hpp	/^    void init_(sub_match_impl<BidiIter> *sub_matches, size_type size)$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:private	signature:(sub_match_impl<BidiIter> *sub_matches, size_type size)
boost::xpressive::detail::sub_match_vector::init_	xpressive/detail/core/sub_match_vector.hpp	/^    void init_(sub_match_impl<BidiIter> *sub_matches, size_type size, sub_match_vector<BidiIter> const &that)$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:private	signature:(sub_match_impl<BidiIter> *sub_matches, size_type size, sub_match_vector<BidiIter> const &that)
boost::xpressive::detail::sub_match_vector::iterator	xpressive/detail/core/sub_match_vector.hpp	/^    typedef const_iterator iterator;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
boost::xpressive::detail::sub_match_vector::operator !	xpressive/detail/core/sub_match_vector.hpp	/^    bool operator !() const$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:() const
boost::xpressive::detail::sub_match_vector::operator []	xpressive/detail/core/sub_match_vector.hpp	/^    const_reference operator [](size_type index) const$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:(size_type index) const
boost::xpressive::detail::sub_match_vector::operator bool_type	xpressive/detail/core/sub_match_vector.hpp	/^    operator bool_type() const$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:() const
boost::xpressive::detail::sub_match_vector::reference	xpressive/detail/core/sub_match_vector.hpp	/^    typedef const_reference reference;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
boost::xpressive::detail::sub_match_vector::size	xpressive/detail/core/sub_match_vector.hpp	/^    size_type size() const$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:() const
boost::xpressive::detail::sub_match_vector::size_	xpressive/detail/core/sub_match_vector.hpp	/^    size_type size_;$/;"	m	struct:boost::xpressive::detail::sub_match_vector	access:private
boost::xpressive::detail::sub_match_vector::size_type	xpressive/detail/core/sub_match_vector.hpp	/^    typedef std::size_t size_type;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
boost::xpressive::detail::sub_match_vector::string_type	xpressive/detail/core/sub_match_vector.hpp	/^    typedef typename sub_match<BidiIter>::string_type string_type;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
boost::xpressive::detail::sub_match_vector::sub_match_vector	xpressive/detail/core/sub_match_vector.hpp	/^    sub_match_vector()$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:()
boost::xpressive::detail::sub_match_vector::sub_matches_	xpressive/detail/core/sub_match_vector.hpp	/^    sub_match_impl<BidiIter> *sub_matches_;$/;"	m	struct:boost::xpressive::detail::sub_match_vector	access:private
boost::xpressive::detail::sub_match_vector::swap	xpressive/detail/core/sub_match_vector.hpp	/^    void swap(sub_match_vector<BidiIter> &that)$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:(sub_match_vector<BidiIter> &that)
boost::xpressive::detail::sub_match_vector::value_type	xpressive/detail/core/sub_match_vector.hpp	/^    typedef sub_match<BidiIter> value_type;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
boost::xpressive::detail::subreg_transform	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct subreg_transform : proto::transform<subreg_transform>$/;"	s	namespace:boost::xpressive::detail	inherits:proto::transform
boost::xpressive::detail::subreg_transform::impl	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::detail::subreg_transform	inherits:proto::transform_impl	access:public
boost::xpressive::detail::subreg_transform::impl::operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::detail::subreg_transform::impl	access:public	signature:( typename impl::expr_param , typename impl::state_param state , typename impl::data_param data ) const
boost::xpressive::detail::subreg_transform::impl::result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::detail::subreg_transform::impl	access:public
boost::xpressive::detail::subreg_transform::impl::state_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            typedef typename impl::state state_type;$/;"	t	struct:boost::xpressive::detail::subreg_transform::impl	access:public
boost::xpressive::detail::swap	xpressive/detail/core/list.hpp	/^    void swap(list<T> &lhs, list<T> &rhs)$/;"	f	namespace:boost::xpressive::detail	signature:(list<T> &lhs, list<T> &rhs)
boost::xpressive::detail::swap	xpressive/detail/core/regex_impl.hpp	/^void swap(regex_impl<BidiIter> &left, regex_impl<BidiIter> &right)$/;"	f	namespace:boost::xpressive::detail	signature:(regex_impl<BidiIter> &left, regex_impl<BidiIter> &right)
boost::xpressive::detail::symbols	xpressive/detail/utility/symbols.hpp	/^    struct symbols$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::symbols::char_type	xpressive/detail/utility/symbols.hpp	/^        typedef typename range_value<key_type>::type char_type;$/;"	t	struct:boost::xpressive::detail::symbols	access:public
boost::xpressive::detail::symbols::cond_rotation	xpressive/detail/utility/symbols.hpp	/^        bool cond_rotation(bool left, node* const i, node* const j) const$/;"	f	struct:boost::xpressive::detail::symbols	access:private	signature:(bool left, node* const i, node* const j) const
boost::xpressive::detail::symbols::insert	xpressive/detail/utility/symbols.hpp	/^        node* insert(node* p, key_iterator &begin, key_iterator end, result_type r, Trans trans) const$/;"	f	struct:boost::xpressive::detail::symbols	access:private	signature:(node* p, key_iterator &begin, key_iterator end, result_type r, Trans trans) const
boost::xpressive::detail::symbols::iterator	xpressive/detail/utility/symbols.hpp	/^        typedef typename range_const_iterator<Map>::type iterator;$/;"	t	struct:boost::xpressive::detail::symbols	access:public
boost::xpressive::detail::symbols::key_iterator	xpressive/detail/utility/symbols.hpp	/^        typedef typename range_const_iterator<key_type>::type key_iterator;$/;"	t	struct:boost::xpressive::detail::symbols	access:public
boost::xpressive::detail::symbols::key_type	xpressive/detail/utility/symbols.hpp	/^        typedef typename range_value<Map>::type::first_type key_type;$/;"	t	struct:boost::xpressive::detail::symbols	access:public
boost::xpressive::detail::symbols::load	xpressive/detail/utility/symbols.hpp	/^        void load(Map const &map, Trans trans)$/;"	f	struct:boost::xpressive::detail::symbols	access:public	signature:(Map const &map, Trans trans)
boost::xpressive::detail::symbols::node	xpressive/detail/utility/symbols.hpp	/^        struct node$/;"	s	struct:boost::xpressive::detail::symbols	inherits:boost::noncopyable	access:private
boost::xpressive::detail::symbols::node::__anon1::eq	xpressive/detail/utility/symbols.hpp	/^                node* eq;$/;"	m	union:boost::xpressive::detail::symbols::node::__anon1	access:public
boost::xpressive::detail::symbols::node::__anon1::result	xpressive/detail/utility/symbols.hpp	/^                result_type result;$/;"	m	union:boost::xpressive::detail::symbols::node::__anon1	access:public
boost::xpressive::detail::symbols::node::ch	xpressive/detail/utility/symbols.hpp	/^            char_type ch;$/;"	m	struct:boost::xpressive::detail::symbols::node	access:public
boost::xpressive::detail::symbols::node::hi	xpressive/detail/utility/symbols.hpp	/^            node* hi;$/;"	m	struct:boost::xpressive::detail::symbols::node	access:public
boost::xpressive::detail::symbols::node::lo	xpressive/detail/utility/symbols.hpp	/^            node* lo;$/;"	m	struct:boost::xpressive::detail::symbols::node	access:public
boost::xpressive::detail::symbols::node::node	xpressive/detail/utility/symbols.hpp	/^            node(char_type c)$/;"	f	struct:boost::xpressive::detail::symbols::node	access:public	signature:(char_type c)
boost::xpressive::detail::symbols::node::swap	xpressive/detail/utility/symbols.hpp	/^            void swap(node& that)$/;"	f	struct:boost::xpressive::detail::symbols::node	access:public	signature:(node& that)
boost::xpressive::detail::symbols::node::tau	xpressive/detail/utility/symbols.hpp	/^            long tau;$/;"	m	struct:boost::xpressive::detail::symbols::node	access:public
boost::xpressive::detail::symbols::node::~node	xpressive/detail/utility/symbols.hpp	/^            ~node()$/;"	f	struct:boost::xpressive::detail::symbols::node	access:public	signature:()
boost::xpressive::detail::symbols::operator ()	xpressive/detail/utility/symbols.hpp	/^        result_type operator ()(BidiIter &begin, BidiIter end, Trans trans) const$/;"	f	struct:boost::xpressive::detail::symbols	access:public	signature:(BidiIter &begin, BidiIter end, Trans trans) const
boost::xpressive::detail::symbols::peek	xpressive/detail/utility/symbols.hpp	/^        void peek(Sink const &sink) const$/;"	f	struct:boost::xpressive::detail::symbols	access:public	signature:(Sink const &sink) const
boost::xpressive::detail::symbols::peek_	xpressive/detail/utility/symbols.hpp	/^        void peek_(node const *const &p, Sink const &sink) const$/;"	f	struct:boost::xpressive::detail::symbols	access:private	signature:(node const *const &p, Sink const &sink) const
boost::xpressive::detail::symbols::result_type	xpressive/detail/utility/symbols.hpp	/^        typedef value_type const *result_type;$/;"	t	struct:boost::xpressive::detail::symbols	access:public
boost::xpressive::detail::symbols::root	xpressive/detail/utility/symbols.hpp	/^        boost::shared_ptr<node> root;$/;"	m	struct:boost::xpressive::detail::symbols	access:private
boost::xpressive::detail::symbols::search	xpressive/detail/utility/symbols.hpp	/^        result_type search(BidiIter &begin, BidiIter end, Trans trans, node* p) const$/;"	f	struct:boost::xpressive::detail::symbols	access:private	signature:(BidiIter &begin, BidiIter end, Trans trans, node* p) const
boost::xpressive::detail::symbols::value_type	xpressive/detail/utility/symbols.hpp	/^        typedef typename range_value<Map>::type::second_type value_type;$/;"	t	struct:boost::xpressive::detail::symbols	access:public
boost::xpressive::detail::ternary_type	xpressive/match_results.hpp	/^typedef char (&ternary_type)[4];$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::throw_on_stack_error	xpressive/basic_regex.hpp	/^    inline void throw_on_stack_error(bool stack_error)$/;"	f	namespace:boost::xpressive::detail	signature:(bool stack_error)
boost::xpressive::detail::to_vector	xpressive/regex_primitives.hpp	/^    to_vector(Subs const &subs)$/;"	f	namespace:boost::xpressive::detail	signature:(Subs const &subs)
boost::xpressive::detail::to_vector	xpressive/regex_token_iterator.hpp	/^inline std::vector<int> to_vector(Int const (&sub_matches)[ Size ])$/;"	f	namespace:boost::xpressive::detail	signature:(Int const (&sub_matches)[ Size ])
boost::xpressive::detail::to_vector	xpressive/regex_token_iterator.hpp	/^inline std::vector<int> to_vector(int subs)$/;"	f	namespace:boost::xpressive::detail	signature:(int subs)
boost::xpressive::detail::to_vector	xpressive/regex_token_iterator.hpp	/^inline std::vector<int> to_vector(std::vector<Int> const &sub_matches)$/;"	f	namespace:boost::xpressive::detail	signature:(std::vector<Int> const &sub_matches)
boost::xpressive::detail::toi	xpressive/detail/utility/algorithm.hpp	/^int toi(InIter &begin, InIter end, Traits const &tr, int radix = 10, int max = INT_MAX)$/;"	f	namespace:boost::xpressive::detail	signature:(InIter &begin, InIter end, Traits const &tr, int radix = 10, int max = INT_MAX)
boost::xpressive::detail::tracking_ptr	xpressive/detail/utility/tracking_ptr.hpp	/^struct tracking_ptr$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::tracking_ptr::BOOST_MPL_ASSERT	xpressive/detail/utility/tracking_ptr.hpp	/^    BOOST_MPL_ASSERT((is_base_and_derived<enable_reference_tracking<Type>, Type>));$/;"	p	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:(is_base_and_derived<enable_reference_tracking<Type>, Type>)
boost::xpressive::detail::tracking_ptr::element_type	xpressive/detail/utility/tracking_ptr.hpp	/^    typedef Type element_type;$/;"	t	struct:boost::xpressive::detail::tracking_ptr	access:public
boost::xpressive::detail::tracking_ptr::fork_	xpressive/detail/utility/tracking_ptr.hpp	/^    intrusive_ptr<element_type> fork_() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:private	signature:() const
boost::xpressive::detail::tracking_ptr::get	xpressive/detail/utility/tracking_ptr.hpp	/^    shared_ptr<element_type> const &get() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:() const
boost::xpressive::detail::tracking_ptr::has_deps_	xpressive/detail/utility/tracking_ptr.hpp	/^    bool has_deps_() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:private	signature:() const
boost::xpressive::detail::tracking_ptr::impl_	xpressive/detail/utility/tracking_ptr.hpp	/^    mutable intrusive_ptr<element_type> impl_;$/;"	m	struct:boost::xpressive::detail::tracking_ptr	access:private
boost::xpressive::detail::tracking_ptr::operator !	xpressive/detail/utility/tracking_ptr.hpp	/^    bool operator !() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:() const
boost::xpressive::detail::tracking_ptr::operator *	xpressive/detail/utility/tracking_ptr.hpp	/^    element_type const &operator *() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:() const
boost::xpressive::detail::tracking_ptr::operator ->	xpressive/detail/utility/tracking_ptr.hpp	/^    element_type const *operator ->() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:() const
boost::xpressive::detail::tracking_ptr::operator =	xpressive/detail/utility/tracking_ptr.hpp	/^    tracking_ptr<element_type> &operator =(tracking_ptr<element_type> const &that)$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:(tracking_ptr<element_type> const &that)
boost::xpressive::detail::tracking_ptr::operator bool	xpressive/detail/utility/tracking_ptr.hpp	/^    operator bool() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:() const
boost::xpressive::detail::tracking_ptr::operator unspecified_bool_type	xpressive/detail/utility/tracking_ptr.hpp	/^    operator unspecified_bool_type() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:() const
boost::xpressive::detail::tracking_ptr::swap	xpressive/detail/utility/tracking_ptr.hpp	/^    void swap(tracking_ptr<element_type> &that) \/\/ throw()$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:(tracking_ptr<element_type> &that)
boost::xpressive::detail::tracking_ptr::tracking_ptr	xpressive/detail/utility/tracking_ptr.hpp	/^    tracking_ptr()$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:()
boost::xpressive::detail::tracking_ptr::tracking_ptr	xpressive/detail/utility/tracking_ptr.hpp	/^    tracking_ptr(tracking_ptr<element_type> const &that)$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:(tracking_ptr<element_type> const &that)
boost::xpressive::detail::tracking_ptr::tracking_ptr::unspecified_bool_type	xpressive/detail/utility/tracking_ptr.hpp	/^    typedef intrusive_ptr<element_type> tracking_ptr::* unspecified_bool_type;$/;"	t	class:boost::xpressive::detail::tracking_ptr::tracking_ptr	access:public
boost::xpressive::detail::traits	xpressive/detail/core/regex_impl.hpp	/^struct traits$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
boost::xpressive::detail::traits::in_range	xpressive/detail/core/regex_impl.hpp	/^    virtual bool in_range(Char from, Char to, Char ch) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char from, Char to, Char ch) const
boost::xpressive::detail::traits::tolower	xpressive/detail/core/regex_impl.hpp	/^    virtual Char tolower(Char ch) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char ch) const
boost::xpressive::detail::traits::toupper	xpressive/detail/core/regex_impl.hpp	/^    virtual Char toupper(Char ch) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char ch) const
boost::xpressive::detail::traits::value	xpressive/detail/core/regex_impl.hpp	/^    virtual int value(Char ch, int radix) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char ch, int radix) const
boost::xpressive::detail::traits::~traits	xpressive/detail/core/regex_impl.hpp	/^    virtual ~traits() {}$/;"	f	struct:boost::xpressive::detail::traits	access:public	signature:()
boost::xpressive::detail::traits_cast	xpressive/detail/core/state.hpp	/^inline Traits const &traits_cast(match_state<BidiIter> const &state)$/;"	f	namespace:boost::xpressive::detail	signature:(match_state<BidiIter> const &state)
boost::xpressive::detail::traits_cast	xpressive/detail/detail_fwd.hpp	/^    Traits const &traits_cast(match_state<BidiIter> const &state);$/;"	p	namespace:boost::xpressive::detail	signature:(match_state<BidiIter> const &state)
boost::xpressive::detail::traits_holder	xpressive/detail/core/regex_impl.hpp	/^struct traits_holder$/;"	s	namespace:boost::xpressive::detail	inherits:traits
boost::xpressive::detail::traits_holder::char_type	xpressive/detail/core/regex_impl.hpp	/^    typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::traits_holder	access:public
boost::xpressive::detail::traits_holder::in_range	xpressive/detail/core/regex_impl.hpp	/^    bool in_range(char_type from, char_type to, char_type ch) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type from, char_type to, char_type ch) const
boost::xpressive::detail::traits_holder::tolower	xpressive/detail/core/regex_impl.hpp	/^    char_type tolower(char_type ch) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type ch) const
boost::xpressive::detail::traits_holder::tolower_	xpressive/detail/core/regex_impl.hpp	/^    char_type tolower_(char_type ch, regex_traits_version_1_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_1_tag) const
boost::xpressive::detail::traits_holder::tolower_	xpressive/detail/core/regex_impl.hpp	/^    char_type tolower_(char_type ch, regex_traits_version_2_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_2_tag) const
boost::xpressive::detail::traits_holder::toupper	xpressive/detail/core/regex_impl.hpp	/^    char_type toupper(char_type ch) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type ch) const
boost::xpressive::detail::traits_holder::toupper_	xpressive/detail/core/regex_impl.hpp	/^    char_type toupper_(char_type ch, regex_traits_version_1_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_1_tag) const
boost::xpressive::detail::traits_holder::toupper_	xpressive/detail/core/regex_impl.hpp	/^    char_type toupper_(char_type ch, regex_traits_version_2_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_2_tag) const
boost::xpressive::detail::traits_holder::traits	xpressive/detail/core/regex_impl.hpp	/^    Traits const &traits() const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:() const
boost::xpressive::detail::traits_holder::traits_	xpressive/detail/core/regex_impl.hpp	/^    Traits traits_;$/;"	m	struct:boost::xpressive::detail::traits_holder	access:private
boost::xpressive::detail::traits_holder::traits_holder	xpressive/detail/core/regex_impl.hpp	/^    explicit traits_holder(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(Traits const &tr)
boost::xpressive::detail::traits_holder::value	xpressive/detail/core/regex_impl.hpp	/^    int value(char_type ch, int radix) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type ch, int radix) const
boost::xpressive::detail::transform_op	xpressive/match_results.hpp	/^enum transform_op { op_none = 0, op_upper = 1, op_lower = 2 };$/;"	g	namespace:boost::xpressive::detail
boost::xpressive::detail::transform_scope	xpressive/match_results.hpp	/^enum transform_scope { scope_next = 0, scope_rest = 1 };$/;"	g	namespace:boost::xpressive::detail
boost::xpressive::detail::translate	xpressive/detail/utility/traits_utils.hpp	/^    inline Char translate(Char ch, Traits const &tr, mpl::false_) \/\/ case-sensitive$/;"	f	namespace:boost::xpressive::detail	signature:(Char ch, Traits const &tr, mpl::false_)
boost::xpressive::detail::translate	xpressive/detail/utility/traits_utils.hpp	/^    inline Char translate(Char ch, Traits const &tr, mpl::true_) \/\/ case-insensitive$/;"	f	namespace:boost::xpressive::detail	signature:(Char ch, Traits const &tr, mpl::true_)
boost::xpressive::detail::transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify$/;"	s	namespace:boost::xpressive::detail	inherits:default_transmogrify
boost::xpressive::detail::transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, assert_bol_placeholder >$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, assert_eol_placeholder >$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, assert_word_placeholder<Cond> >$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, logical_newline_placeholder >$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, mark_placeholder >$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, posix_charset_placeholder >$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, range_placeholder<Char> >$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, reference_wrapper<basic_regex<BidiIter> > >$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, reference_wrapper<basic_regex<BidiIter> const> >$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, self_placeholder >$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, tracking_ptr<regex_impl<BidiIter> > >$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, mpl::true_, Traits, set_matcher<Traits, Size> >$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::transmogrify::BOOST_MPL_ASSERT	xpressive/detail/static/transmogrify.hpp	/^        BOOST_MPL_ASSERT((is_same<Char, char_type>));$/;"	p	struct:boost::xpressive::detail::transmogrify	access:public	signature:(is_same<Char, char_type>)
boost::xpressive::detail::transmogrify::call	xpressive/detail/static/transmogrify.hpp	/^        static type call(Matcher2 const &m, Visitor &visitor)$/;"	f	struct:boost::xpressive::detail::transmogrify	access:public	signature:(Matcher2 const &m, Visitor &visitor)
boost::xpressive::detail::transmogrify::call	xpressive/detail/static/transmogrify.hpp	/^        static type call(Matcher2 const &m, dont_care)$/;"	f	struct:boost::xpressive::detail::transmogrify	access:public	signature:(Matcher2 const &m, dont_care)
boost::xpressive::detail::transmogrify::call	xpressive/detail/static/transmogrify.hpp	/^        static type call(Matcher2 m, Visitor &visitor)$/;"	f	struct:boost::xpressive::detail::transmogrify	access:public	signature:(Matcher2 m, Visitor &visitor)
boost::xpressive::detail::transmogrify::call	xpressive/detail/static/transmogrify.hpp	/^        static type call(Matcher2, Visitor &visitor)$/;"	f	struct:boost::xpressive::detail::transmogrify	access:public	signature:(Matcher2, Visitor &visitor)
boost::xpressive::detail::transmogrify::call	xpressive/detail/static/transmogrify.hpp	/^        static type call(dont_care, Visitor &visitor)$/;"	f	struct:boost::xpressive::detail::transmogrify	access:public	signature:(dont_care, Visitor &visitor)
boost::xpressive::detail::transmogrify::char_type	xpressive/detail/static/transmogrify.hpp	/^        typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
boost::xpressive::detail::transmogrify::type	xpressive/detail/static/transmogrify.hpp	/^        typedef assert_bol_matcher<Traits> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
boost::xpressive::detail::transmogrify::type	xpressive/detail/static/transmogrify.hpp	/^        typedef assert_eol_matcher<Traits> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
boost::xpressive::detail::transmogrify::type	xpressive/detail/static/transmogrify.hpp	/^        typedef assert_word_matcher<Cond, Traits> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
boost::xpressive::detail::transmogrify::type	xpressive/detail/static/transmogrify.hpp	/^        typedef logical_newline_matcher<Traits> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
boost::xpressive::detail::transmogrify::type	xpressive/detail/static/transmogrify.hpp	/^        typedef mark_matcher<Traits, ICase> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
boost::xpressive::detail::transmogrify::type	xpressive/detail/static/transmogrify.hpp	/^        typedef posix_charset_matcher<Traits> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
boost::xpressive::detail::transmogrify::type	xpressive/detail/static/transmogrify.hpp	/^        typedef range_matcher<Traits, ICase> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
boost::xpressive::detail::transmogrify::type	xpressive/detail/static/transmogrify.hpp	/^        typedef regex_byref_matcher<BidiIter> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
boost::xpressive::detail::transmogrify::type	xpressive/detail/static/transmogrify.hpp	/^        typedef regex_matcher<BidiIter> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
boost::xpressive::detail::transmogrify::type	xpressive/detail/static/transmogrify.hpp	/^        typedef set_matcher<Traits, Size> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
boost::xpressive::detail::true_matcher	xpressive/detail/core/matcher/true_matcher.hpp	/^    struct true_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_assertion
boost::xpressive::detail::true_matcher::match	xpressive/detail/core/matcher/true_matcher.hpp	/^        static bool match(match_state<BidiIter> &, Next const &)$/;"	f	struct:boost::xpressive::detail::true_matcher	access:public	signature:(match_state<BidiIter> &, Next const &)
boost::xpressive::detail::true_xpression	xpressive/detail/detail_fwd.hpp	/^    typedef static_xpression<true_matcher, no_next> true_xpression;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::type_info_less	xpressive/match_results.hpp	/^struct type_info_less$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::type_info_less::operator ()	xpressive/match_results.hpp	/^    bool operator()(std::type_info const *left, std::type_info const *right) const$/;"	f	struct:boost::xpressive::detail::type_info_less	access:public	signature:(std::type_info const *left, std::type_info const *right) const
boost::xpressive::detail::uint_t	xpressive/detail/detail_fwd.hpp	/^    typedef unsigned int uint_t;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::umask_t	xpressive/traits/cpp_regex_traits.hpp	/^    typedef boost::uint_t<sizeof(std::ctype_base::mask) * CHAR_BIT>::least umask_t;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::umaskex_bits	xpressive/traits/cpp_regex_traits.hpp	/^    int const umaskex_bits = (14 > (sizeof(umask_t) * CHAR_BIT)) ? 14 : sizeof(umask_t) * CHAR_BIT;$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::umaskex_t	xpressive/traits/cpp_regex_traits.hpp	/^    typedef boost::uint_t<umaskex_bits>::fast umaskex_t;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::unary_binary_ternary	xpressive/match_results.hpp	/^struct unary_binary_ternary$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::unary_binary_ternary::binary_fun	xpressive/match_results.hpp	/^    typedef binary_type (*binary_fun)(any_type, any_type);$/;"	t	struct:boost::xpressive::detail::unary_binary_ternary	access:public
boost::xpressive::detail::unary_binary_ternary::operator binary_fun	xpressive/match_results.hpp	/^    operator binary_fun();$/;"	p	struct:boost::xpressive::detail::unary_binary_ternary	access:public	signature:()
boost::xpressive::detail::unary_binary_ternary::operator ternary_fun	xpressive/match_results.hpp	/^    operator ternary_fun();$/;"	p	struct:boost::xpressive::detail::unary_binary_ternary	access:public	signature:()
boost::xpressive::detail::unary_binary_ternary::operator unary_fun	xpressive/match_results.hpp	/^    operator unary_fun();$/;"	p	struct:boost::xpressive::detail::unary_binary_ternary	access:public	signature:()
boost::xpressive::detail::unary_binary_ternary::ternary_fun	xpressive/match_results.hpp	/^    typedef ternary_type (*ternary_fun)(any_type, any_type, any_type);$/;"	t	struct:boost::xpressive::detail::unary_binary_ternary	access:public
boost::xpressive::detail::unary_binary_ternary::unary_fun	xpressive/match_results.hpp	/^    typedef unary_type (*unary_fun)(any_type);$/;"	t	struct:boost::xpressive::detail::unary_binary_ternary	access:public
boost::xpressive::detail::unary_type	xpressive/match_results.hpp	/^typedef char (&unary_type)[2];$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::unknown_width	xpressive/detail/detail_fwd.hpp	/^    typedef mpl::size_t<INT_MAX \/ 2 - 1> unknown_width;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::unknown_width	xpressive/detail/utility/width.hpp	/^typedef mpl::size_t<INT_MAX \/ 2 - 1> unknown_width;$/;"	t	namespace:boost::xpressive::detail
boost::xpressive::detail::unused_mask	xpressive/traits/cpp_regex_traits.hpp	/^    struct unused_mask$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::unused_mask	xpressive/traits/cpp_regex_traits.hpp	/^    struct unused_mask<In, Out, true>$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::unused_mask::BOOST_STATIC_CONSTANT	xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = (unused_mask<In, (Out >> 1)>::value));$/;"	p	struct:boost::xpressive::detail::unused_mask	access:public	signature:(umaskex_t, value = (unused_mask<In, (Out >> 1)>::value))
boost::xpressive::detail::unused_mask::BOOST_STATIC_CONSTANT	xpressive/traits/cpp_regex_traits.hpp	/^        BOOST_STATIC_CONSTANT(umaskex_t, value = Out);$/;"	p	struct:boost::xpressive::detail::unused_mask	access:public	signature:(umaskex_t, value = Out)
boost::xpressive::detail::unused_mask::value	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const unused_mask<In, Out, Done>::value;$/;"	m	class:boost::xpressive::detail::unused_mask
boost::xpressive::detail::use_simple_repeat	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_
boost::xpressive::detail::use_simple_repeat	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat<Expr &, Char>$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, generic_quant_tag<Count, Count> >$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, generic_quant_tag<Min, Max> >$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, keeper_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, lookahead_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, lookbehind_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, modifier_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::assign>$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_assign
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::bitwise_or>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::and_
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::comma>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::complement>$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::dereference>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::logical_not>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::negate>$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::shift_right>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::and_
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::subscript>$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_subscript
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::terminal>$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_terminal
boost::xpressive::detail::use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::unary_plus>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::use_simple_repeat_assign	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_assign$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::use_simple_repeat_assign	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_assign<attribute_placeholder<Nbr> >$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::use_simple_repeat_assign	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_assign<mark_placeholder>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::use_simple_repeat_assign	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_assign<set_initializer>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
boost::xpressive::detail::use_simple_repeat_subscript	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_subscript$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::use_simple_repeat_subscript	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_subscript<Expr, Char, set_initializer_type>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
boost::xpressive::detail::use_simple_repeat_terminal	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_terminal$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::bool_
boost::xpressive::detail::use_simple_repeat_terminal	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_terminal<Expr, Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
boost::xpressive::detail::use_simple_repeat_terminal	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_terminal<reference_wrapper<basic_regex<BidiIter> >, Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::use_simple_repeat_terminal	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_terminal<reference_wrapper<basic_regex<BidiIter> const>, Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::use_simple_repeat_terminal	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_terminal<tracking_ptr<regex_impl<BidiIter> >, Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
boost::xpressive::detail::value_wrapper	xpressive/regex_actions.hpp	/^        struct value_wrapper$/;"	s	namespace:boost::xpressive::detail	inherits:noncopyable
boost::xpressive::detail::value_wrapper::value	xpressive/regex_actions.hpp	/^            T value;$/;"	m	struct:boost::xpressive::detail::value_wrapper	access:public
boost::xpressive::detail::value_wrapper::value_wrapper	xpressive/regex_actions.hpp	/^            value_wrapper()$/;"	f	struct:boost::xpressive::detail::value_wrapper	access:public	signature:()
boost::xpressive::detail::value_wrapper::value_wrapper	xpressive/regex_actions.hpp	/^            value_wrapper(T const &t)$/;"	f	struct:boost::xpressive::detail::value_wrapper	access:public	signature:(T const &t)
boost::xpressive::detail::weak_iterator	xpressive/detail/utility/tracking_ptr.hpp	/^struct weak_iterator$/;"	s	namespace:boost::xpressive::detail	inherits:iterator_facade
boost::xpressive::detail::weak_iterator::base_iterator	xpressive/detail/utility/tracking_ptr.hpp	/^    typedef typename set_type::iterator base_iterator;$/;"	t	struct:boost::xpressive::detail::weak_iterator	access:public
boost::xpressive::detail::weak_iterator::cur_	xpressive/detail/utility/tracking_ptr.hpp	/^    shared_ptr<Derived> cur_;$/;"	m	struct:boost::xpressive::detail::weak_iterator	access:private
boost::xpressive::detail::weak_iterator::dereference	xpressive/detail/utility/tracking_ptr.hpp	/^    shared_ptr<Derived> const &dereference() const$/;"	f	struct:boost::xpressive::detail::weak_iterator	access:private	signature:() const
boost::xpressive::detail::weak_iterator::equal	xpressive/detail/utility/tracking_ptr.hpp	/^    bool equal(weak_iterator<Derived> const &that) const$/;"	f	struct:boost::xpressive::detail::weak_iterator	access:private	signature:(weak_iterator<Derived> const &that) const
boost::xpressive::detail::weak_iterator::increment	xpressive/detail/utility/tracking_ptr.hpp	/^    void increment()$/;"	f	struct:boost::xpressive::detail::weak_iterator	access:private	signature:()
boost::xpressive::detail::weak_iterator::iter_	xpressive/detail/utility/tracking_ptr.hpp	/^    base_iterator iter_;$/;"	m	struct:boost::xpressive::detail::weak_iterator	access:private
boost::xpressive::detail::weak_iterator::satisfy_	xpressive/detail/utility/tracking_ptr.hpp	/^    void satisfy_()$/;"	f	struct:boost::xpressive::detail::weak_iterator	access:private	signature:()
boost::xpressive::detail::weak_iterator::set_	xpressive/detail/utility/tracking_ptr.hpp	/^    set_type *set_;$/;"	m	struct:boost::xpressive::detail::weak_iterator	access:private
boost::xpressive::detail::weak_iterator::set_type	xpressive/detail/utility/tracking_ptr.hpp	/^    typedef std::set<weak_ptr<Derived> > set_type;$/;"	t	struct:boost::xpressive::detail::weak_iterator	access:public
boost::xpressive::detail::weak_iterator::weak_iterator	xpressive/detail/utility/tracking_ptr.hpp	/^    weak_iterator()$/;"	f	struct:boost::xpressive::detail::weak_iterator	access:public	signature:()
boost::xpressive::detail::weak_iterator::weak_iterator	xpressive/detail/utility/tracking_ptr.hpp	/^    weak_iterator(base_iterator iter, set_type *set)$/;"	f	struct:boost::xpressive::detail::weak_iterator	access:public	signature:(base_iterator iter, set_type *set)
boost::xpressive::detail::what	xpressive/regex_algorithms.hpp	/^      , match_results<BidiIter> &what$/;"	m	namespace:boost::xpressive::detail
boost::xpressive::detail::widen_fun	xpressive/detail/utility/traits_utils.hpp	/^    struct widen_fun$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::widen_fun::operator ()	xpressive/detail/utility/traits_utils.hpp	/^        result_type operator()(char ch) const$/;"	f	struct:boost::xpressive::detail::widen_fun	access:public	signature:(char ch) const
boost::xpressive::detail::widen_fun::result_type	xpressive/detail/utility/traits_utils.hpp	/^        typedef typename Traits::char_type result_type;$/;"	t	struct:boost::xpressive::detail::widen_fun	access:public
boost::xpressive::detail::widen_fun::traits_	xpressive/detail/utility/traits_utils.hpp	/^        Traits const &traits_;$/;"	m	struct:boost::xpressive::detail::widen_fun	access:public
boost::xpressive::detail::widen_fun::widen_fun	xpressive/detail/utility/traits_utils.hpp	/^        explicit widen_fun(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::widen_fun	access:public	signature:(Traits const &tr)
boost::xpressive::detail::width	xpressive/detail/utility/width.hpp	/^struct width$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::width::operator !	xpressive/detail/utility/width.hpp	/^    bool operator !() const$/;"	f	struct:boost::xpressive::detail::width	access:public	signature:() const
boost::xpressive::detail::width::operator +=	xpressive/detail/utility/width.hpp	/^    width &operator +=(width const &that)$/;"	f	struct:boost::xpressive::detail::width	access:public	signature:(width const &that)
boost::xpressive::detail::width::operator |=	xpressive/detail/utility/width.hpp	/^    width &operator |=(width const &that)$/;"	f	struct:boost::xpressive::detail::width	access:public	signature:(width const &that)
boost::xpressive::detail::width::value	xpressive/detail/utility/width.hpp	/^    std::size_t value() const$/;"	f	struct:boost::xpressive::detail::width	access:public	signature:() const
boost::xpressive::detail::width::value_	xpressive/detail/utility/width.hpp	/^    std::size_t value_;$/;"	m	struct:boost::xpressive::detail::width	access:private
boost::xpressive::detail::width::width	xpressive/detail/utility/width.hpp	/^    width(std::size_t val = 0)$/;"	f	struct:boost::xpressive::detail::width	access:public	signature:(std::size_t val = 0)
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, generic_quant_tag<Count, Count> >$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::if_c::type
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, generic_quant_tag<Min, Max> >$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, keeper_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, lookahead_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, lookbehind_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, modifier_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:width_of
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::assign>$/;"	s	namespace:boost::xpressive::detail	inherits:width_of_assign
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::bitwise_or>$/;"	s	namespace:boost::xpressive::detail	inherits:or_widths
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::comma>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::complement>$/;"	s	namespace:boost::xpressive::detail	inherits:width_of
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::dereference>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::logical_not>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::negate>$/;"	s	namespace:boost::xpressive::detail	inherits:width_of
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::shift_right>$/;"	s	namespace:boost::xpressive::detail	inherits:add_widths
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::subscript>$/;"	s	namespace:boost::xpressive::detail	inherits:width_of_subscript
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::terminal>$/;"	s	namespace:boost::xpressive::detail	inherits:width_of_terminal
boost::xpressive::detail::width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::unary_plus>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
boost::xpressive::detail::width_of_assign	xpressive/detail/static/width_of.hpp	/^    struct width_of_assign$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::width_of_assign	xpressive/detail/static/width_of.hpp	/^    struct width_of_assign<Expr, Char, attribute_placeholder<Nbr> >$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
boost::xpressive::detail::width_of_assign	xpressive/detail/static/width_of.hpp	/^    struct width_of_assign<Expr, Char, mark_placeholder>$/;"	s	namespace:boost::xpressive::detail	inherits:width_of
boost::xpressive::detail::width_of_assign	xpressive/detail/static/width_of.hpp	/^    struct width_of_assign<Expr, Char, set_initializer>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
boost::xpressive::detail::width_of_subscript	xpressive/detail/static/width_of.hpp	/^    struct width_of_subscript$/;"	s	namespace:boost::xpressive::detail	inherits:width_of
boost::xpressive::detail::width_of_subscript	xpressive/detail/static/width_of.hpp	/^    struct width_of_subscript<Expr, Char, set_initializer_type>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
boost::xpressive::detail::width_of_terminal	xpressive/detail/static/width_of.hpp	/^    struct width_of_terminal$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
boost::xpressive::detail::width_of_terminal	xpressive/detail/static/width_of.hpp	/^    struct width_of_terminal<Char, Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
boost::xpressive::detail::width_of_terminal	xpressive/detail/static/width_of.hpp	/^    struct width_of_terminal<Elem (&) [N], Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
boost::xpressive::detail::width_of_terminal	xpressive/detail/static/width_of.hpp	/^    struct width_of_terminal<Elem const (&) [N], Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
boost::xpressive::detail::width_of_terminal	xpressive/detail/static/width_of.hpp	/^    struct width_of_terminal<Expr, Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
boost::xpressive::detail::width_of_terminal	xpressive/detail/static/width_of.hpp	/^    struct width_of_terminal<char, Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
boost::xpressive::detail::width_of_terminal	xpressive/detail/static/width_of.hpp	/^    struct width_of_terminal<char, char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
boost::xpressive::detail::word_begin	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^    struct word_begin$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::word_begin::eval	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        static bool eval(bool prevword, bool thisword, match_state<BidiIter> &state)$/;"	f	struct:boost::xpressive::detail::word_begin	access:public	signature:(bool prevword, bool thisword, match_state<BidiIter> &state)
boost::xpressive::detail::word_boundary	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^    struct word_boundary$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::word_boundary::eval	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        static bool eval(bool prevword, bool thisword, match_state<BidiIter> &state)$/;"	f	struct:boost::xpressive::detail::word_boundary	access:public	signature:(bool prevword, bool thisword, match_state<BidiIter> &state)
boost::xpressive::detail::word_end	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^    struct word_end$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::word_end::eval	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        static bool eval(bool prevword, bool thisword, match_state<BidiIter> &state)$/;"	f	struct:boost::xpressive::detail::word_end	access:public	signature:(bool prevword, bool thisword, match_state<BidiIter> &state)
boost::xpressive::detail::xpression_adaptor	xpressive/detail/core/adaptor.hpp	/^struct xpression_adaptor$/;"	s	namespace:boost::xpressive::detail	inherits:Base
boost::xpressive::detail::xpression_adaptor::char_type	xpressive/detail/core/adaptor.hpp	/^    typedef typename iterator_value<iterator_type>::type char_type;$/;"	t	struct:boost::xpressive::detail::xpression_adaptor	access:public
boost::xpressive::detail::xpression_adaptor::iterator_type	xpressive/detail/core/adaptor.hpp	/^    typedef typename Base::iterator_type iterator_type;$/;"	t	struct:boost::xpressive::detail::xpression_adaptor	access:public
boost::xpressive::detail::xpression_adaptor::link	xpressive/detail/core/adaptor.hpp	/^    void link(xpression_linker<char_type> &linker) const$/;"	f	struct:boost::xpressive::detail::xpression_adaptor	access:public	signature:(xpression_linker<char_type> &linker) const
boost::xpressive::detail::xpression_adaptor::match	xpressive/detail/core/adaptor.hpp	/^    virtual bool match(match_state<iterator_type> &state) const$/;"	f	struct:boost::xpressive::detail::xpression_adaptor	access:public	signature:(match_state<iterator_type> &state) const
boost::xpressive::detail::xpression_adaptor::operator =	xpressive/detail/core/adaptor.hpp	/^    xpression_adaptor &operator =(xpression_adaptor const &);$/;"	p	struct:boost::xpressive::detail::xpression_adaptor	access:private	signature:(xpression_adaptor const &)
boost::xpressive::detail::xpression_adaptor::peek	xpressive/detail/core/adaptor.hpp	/^    void peek(xpression_peeker<char_type> &peeker) const$/;"	f	struct:boost::xpressive::detail::xpression_adaptor	access:public	signature:(xpression_peeker<char_type> &peeker) const
boost::xpressive::detail::xpression_adaptor::xpr_	xpressive/detail/core/adaptor.hpp	/^    Xpr xpr_;$/;"	m	struct:boost::xpressive::detail::xpression_adaptor	access:public
boost::xpressive::detail::xpression_adaptor::xpression_adaptor	xpressive/detail/core/adaptor.hpp	/^    xpression_adaptor(Xpr const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_adaptor	access:public	signature:(Xpr const &xpr)
boost::xpressive::detail::xpression_linker	xpressive/detail/core/linker.hpp	/^struct xpression_linker$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::xpression_linker::accept	xpressive/detail/core/linker.hpp	/^    void accept(Matcher const &, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(Matcher const &, void const *)
boost::xpressive::detail::xpression_linker::accept	xpressive/detail/core/linker.hpp	/^    void accept(action_matcher<Action> const &, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(action_matcher<Action> const &, void const *)
boost::xpressive::detail::xpression_linker::accept	xpressive/detail/core/linker.hpp	/^    void accept(alternate_end_matcher const &matcher, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(alternate_end_matcher const &matcher, void const *)
boost::xpressive::detail::xpression_linker::accept	xpressive/detail/core/linker.hpp	/^    void accept(alternate_matcher<Alternates, Traits> const &matcher, void const *next)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(alternate_matcher<Alternates, Traits> const &matcher, void const *next)
boost::xpressive::detail::xpression_linker::accept	xpressive/detail/core/linker.hpp	/^    void accept(keeper_matcher<Xpr> const &matcher, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(keeper_matcher<Xpr> const &matcher, void const *)
boost::xpressive::detail::xpression_linker::accept	xpressive/detail/core/linker.hpp	/^    void accept(lookahead_matcher<Xpr> const &matcher, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(lookahead_matcher<Xpr> const &matcher, void const *)
boost::xpressive::detail::xpression_linker::accept	xpressive/detail/core/linker.hpp	/^    void accept(lookbehind_matcher<Xpr> const &matcher, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(lookbehind_matcher<Xpr> const &matcher, void const *)
boost::xpressive::detail::xpression_linker::accept	xpressive/detail/core/linker.hpp	/^    void accept(mark_matcher<Traits, ICase> const &, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(mark_matcher<Traits, ICase> const &, void const *)
boost::xpressive::detail::xpression_linker::accept	xpressive/detail/core/linker.hpp	/^    void accept(optional_mark_matcher<Xpr, Greedy> const &matcher, void const *next)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(optional_mark_matcher<Xpr, Greedy> const &matcher, void const *next)
boost::xpressive::detail::xpression_linker::accept	xpressive/detail/core/linker.hpp	/^    void accept(optional_matcher<Xpr, Greedy> const &matcher, void const *next)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(optional_matcher<Xpr, Greedy> const &matcher, void const *next)
boost::xpressive::detail::xpression_linker::accept	xpressive/detail/core/linker.hpp	/^    void accept(predicate_matcher<Predicate> const &, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(predicate_matcher<Predicate> const &, void const *)
boost::xpressive::detail::xpression_linker::accept	xpressive/detail/core/linker.hpp	/^    void accept(repeat_begin_matcher const &, void const *next)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(repeat_begin_matcher const &, void const *next)
boost::xpressive::detail::xpression_linker::accept	xpressive/detail/core/linker.hpp	/^    void accept(repeat_end_matcher<Greedy> const &matcher, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(repeat_end_matcher<Greedy> const &matcher, void const *)
boost::xpressive::detail::xpression_linker::accept	xpressive/detail/core/linker.hpp	/^    void accept(simple_repeat_matcher<Xpr, Greedy> const &matcher, void const *)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(simple_repeat_matcher<Xpr, Greedy> const &matcher, void const *)
boost::xpressive::detail::xpression_linker::alt_branch_link	xpressive/detail/core/linker.hpp	/^    void alt_branch_link(Xpr const &xpr, void const *next, xpression_peeker<Char> *peeker)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(Xpr const &xpr, void const *next, xpression_peeker<Char> *peeker)
boost::xpressive::detail::xpression_linker::alt_link	xpressive/detail/core/linker.hpp	/^    void alt_link$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:private	signature:( alternates_vector<BidiIter> const &alternates , void const *next , xpression_peeker<Char> *peeker )
boost::xpressive::detail::xpression_linker::alt_link	xpressive/detail/core/linker.hpp	/^    void alt_link$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:private	signature:( fusion::sequence_base<Alternates> const &alternates , void const *next , xpression_peeker<Char> *peeker )
boost::xpressive::detail::xpression_linker::alt_link_pred	xpressive/detail/core/linker.hpp	/^    struct alt_link_pred$/;"	s	struct:boost::xpressive::detail::xpression_linker	access:private
boost::xpressive::detail::xpression_linker::alt_link_pred::alt_link_pred	xpressive/detail/core/linker.hpp	/^        alt_link_pred$/;"	f	struct:boost::xpressive::detail::xpression_linker::alt_link_pred	access:public	signature:( xpression_linker<Char> *linker , xpression_peeker<Char> *peeker , void const *next )
boost::xpressive::detail::xpression_linker::alt_link_pred::linker_	xpressive/detail/core/linker.hpp	/^        xpression_linker<Char> *linker_;$/;"	m	struct:boost::xpressive::detail::xpression_linker::alt_link_pred	access:public
boost::xpressive::detail::xpression_linker::alt_link_pred::next_	xpressive/detail/core/linker.hpp	/^        void const *next_;$/;"	m	struct:boost::xpressive::detail::xpression_linker::alt_link_pred	access:public
boost::xpressive::detail::xpression_linker::alt_link_pred::operator ()	xpressive/detail/core/linker.hpp	/^        void operator ()(Xpr const &xpr) const$/;"	f	struct:boost::xpressive::detail::xpression_linker::alt_link_pred	access:public	signature:(Xpr const &xpr) const
boost::xpressive::detail::xpression_linker::alt_link_pred::peeker_	xpressive/detail/core/linker.hpp	/^        xpression_peeker<Char> *peeker_;$/;"	m	struct:boost::xpressive::detail::xpression_linker::alt_link_pred	access:public
boost::xpressive::detail::xpression_linker::back_stack_	xpressive/detail/core/linker.hpp	/^    std::stack<void const *> back_stack_;$/;"	m	struct:boost::xpressive::detail::xpression_linker	access:private
boost::xpressive::detail::xpression_linker::get_traits	xpressive/detail/core/linker.hpp	/^    Traits const &get_traits() const$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:private	signature:() const
boost::xpressive::detail::xpression_linker::has_backrefs	xpressive/detail/core/linker.hpp	/^    bool has_backrefs() const$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:() const
boost::xpressive::detail::xpression_linker::has_backrefs_	xpressive/detail/core/linker.hpp	/^    bool has_backrefs_;$/;"	m	struct:boost::xpressive::detail::xpression_linker	access:private
boost::xpressive::detail::xpression_linker::std::traits_type_	xpressive/detail/core/linker.hpp	/^    std::type_info const *traits_type_;$/;"	m	class:boost::xpressive::detail::xpression_linker::std	access:private
boost::xpressive::detail::xpression_linker::traits_	xpressive/detail/core/linker.hpp	/^    void const *traits_;$/;"	m	struct:boost::xpressive::detail::xpression_linker	access:private
boost::xpressive::detail::xpression_linker::xpression_linker	xpressive/detail/core/linker.hpp	/^    explicit xpression_linker(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(Traits const &tr)
boost::xpressive::detail::xpression_peeker	xpressive/detail/core/peeker.hpp	/^struct xpression_peeker$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::xpression_peeker::accept	xpressive/detail/core/peeker.hpp	/^    accept(charset_matcher<Traits, ICase, basic_chset<Char> > const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(charset_matcher<Traits, ICase, basic_chset<Char> > const &xpr)
boost::xpressive::detail::xpression_peeker::accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(Matcher const &)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(Matcher const &)
boost::xpressive::detail::xpression_peeker::accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(alternate_matcher<Alternates, Traits> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(alternate_matcher<Alternates, Traits> const &xpr)
boost::xpressive::detail::xpression_peeker::accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(attr_matcher<Matcher, Traits, ICase> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(attr_matcher<Matcher, Traits, ICase> const &xpr)
boost::xpressive::detail::xpression_peeker::accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(keeper_matcher<Xpr> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(keeper_matcher<Xpr> const &xpr)
boost::xpressive::detail::xpression_peeker::accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(literal_matcher<Traits, ICase, mpl::false_> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(literal_matcher<Traits, ICase, mpl::false_> const &xpr)
boost::xpressive::detail::xpression_peeker::accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(optional_mark_matcher<Xpr, Greedy> const &)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(optional_mark_matcher<Xpr, Greedy> const &)
boost::xpressive::detail::xpression_peeker::accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(optional_matcher<Xpr, Greedy> const &)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(optional_matcher<Xpr, Greedy> const &)
boost::xpressive::detail::xpression_peeker::accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(posix_charset_matcher<Traits> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(posix_charset_matcher<Traits> const &xpr)
boost::xpressive::detail::xpression_peeker::accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(range_matcher<Traits, ICase> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(range_matcher<Traits, ICase> const &xpr)
boost::xpressive::detail::xpression_peeker::accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(simple_repeat_matcher<Xpr, Greedy> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(simple_repeat_matcher<Xpr, Greedy> const &xpr)
boost::xpressive::detail::xpression_peeker::accept	xpressive/detail/core/peeker.hpp	/^    mpl::false_ accept(string_matcher<Traits, ICase> const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(string_matcher<Traits, ICase> const &xpr)
boost::xpressive::detail::xpression_peeker::accept	xpressive/detail/core/peeker.hpp	/^    mpl::true_ accept(assert_bol_matcher<Traits> const &)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(assert_bol_matcher<Traits> const &)
boost::xpressive::detail::xpression_peeker::accept	xpressive/detail/core/peeker.hpp	/^    mpl::true_ accept(mark_begin_matcher const &)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(mark_begin_matcher const &)
boost::xpressive::detail::xpression_peeker::accept	xpressive/detail/core/peeker.hpp	/^    mpl::true_ accept(repeat_begin_matcher const &)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(repeat_begin_matcher const &)
boost::xpressive::detail::xpression_peeker::bitset	xpressive/detail/core/peeker.hpp	/^    hash_peek_bitset<Char> const &bitset() const$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:() const
boost::xpressive::detail::xpression_peeker::bset_	xpressive/detail/core/peeker.hpp	/^    hash_peek_bitset<Char> &bset_;$/;"	m	struct:boost::xpressive::detail::xpression_peeker	access:private
boost::xpressive::detail::xpression_peeker::fail	xpressive/detail/core/peeker.hpp	/^    void fail()$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:()
boost::xpressive::detail::xpression_peeker::get_string	xpressive/detail/core/peeker.hpp	/^    peeker_string<Char> const &get_string() const$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:() const
boost::xpressive::detail::xpression_peeker::get_traits_	xpressive/detail/core/peeker.hpp	/^    Traits const &get_traits_() const$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:private	signature:() const
boost::xpressive::detail::xpression_peeker::has_backrefs_	xpressive/detail/core/peeker.hpp	/^    bool has_backrefs_;$/;"	m	struct:boost::xpressive::detail::xpression_peeker	access:private
boost::xpressive::detail::xpression_peeker::leading_simple_repeat	xpressive/detail/core/peeker.hpp	/^    bool leading_simple_repeat() const$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:() const
boost::xpressive::detail::xpression_peeker::leading_simple_repeat_	xpressive/detail/core/peeker.hpp	/^    int leading_simple_repeat_;$/;"	m	struct:boost::xpressive::detail::xpression_peeker	access:private
boost::xpressive::detail::xpression_peeker::line_start	xpressive/detail/core/peeker.hpp	/^    bool line_start() const$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:() const
boost::xpressive::detail::xpression_peeker::line_start_	xpressive/detail/core/peeker.hpp	/^    bool line_start_;$/;"	m	struct:boost::xpressive::detail::xpression_peeker	access:private
boost::xpressive::detail::xpression_peeker::operator =	xpressive/detail/core/peeker.hpp	/^    xpression_peeker &operator =(xpression_peeker const &);$/;"	p	struct:boost::xpressive::detail::xpression_peeker	access:private	signature:(xpression_peeker const &)
boost::xpressive::detail::xpression_peeker::set_traits	xpressive/detail/core/peeker.hpp	/^    void set_traits(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(Traits const &tr)
boost::xpressive::detail::xpression_peeker::std::traits_type_	xpressive/detail/core/peeker.hpp	/^    std::type_info const *traits_type_;$/;"	m	class:boost::xpressive::detail::xpression_peeker::std	access:private
boost::xpressive::detail::xpression_peeker::str_	xpressive/detail/core/peeker.hpp	/^    peeker_string<Char> str_;$/;"	m	struct:boost::xpressive::detail::xpression_peeker	access:private
boost::xpressive::detail::xpression_peeker::str_icase_	xpressive/detail/core/peeker.hpp	/^    bool str_icase_;$/;"	m	struct:boost::xpressive::detail::xpression_peeker	access:private
boost::xpressive::detail::xpression_peeker::traits_	xpressive/detail/core/peeker.hpp	/^    void const *traits_;$/;"	m	struct:boost::xpressive::detail::xpression_peeker	access:private
boost::xpressive::detail::xpression_peeker::xpression_peeker	xpressive/detail/core/peeker.hpp	/^    xpression_peeker(hash_peek_bitset<Char> &bset, Traits const &tr, bool has_backrefs = false)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(hash_peek_bitset<Char> &bset, Traits const &tr, bool has_backrefs = false)
boost::xpressive::detail::xpression_peeker::xpression_peeker	xpressive/detail/core/peeker.hpp	/^    xpression_peeker(xpression_peeker const &);$/;"	p	struct:boost::xpressive::detail::xpression_peeker	access:private	signature:(xpression_peeker const &)
boost::xpressive::detail::xpression_visitor	xpressive/detail/static/visitor.hpp	/^    struct xpression_visitor$/;"	s	namespace:boost::xpressive::detail	inherits:xpression_visitor_base
boost::xpressive::detail::xpression_visitor::apply	xpressive/detail/static/visitor.hpp	/^        struct apply$/;"	s	struct:boost::xpressive::detail::xpression_visitor	access:public
boost::xpressive::detail::xpression_visitor::apply::type	xpressive/detail/static/visitor.hpp	/^            typedef typename transmogrify<BidiIter, ICase, Traits, Matcher>::type type;$/;"	t	struct:boost::xpressive::detail::xpression_visitor::apply	access:public
boost::xpressive::detail::xpression_visitor::call	xpressive/detail/static/visitor.hpp	/^        call(Matcher const &matcher)$/;"	f	struct:boost::xpressive::detail::xpression_visitor	access:public	signature:(Matcher const &matcher)
boost::xpressive::detail::xpression_visitor::char_type	xpressive/detail/static/visitor.hpp	/^        typedef typename boost::iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::xpression_visitor	access:public
boost::xpressive::detail::xpression_visitor::icase_type	xpressive/detail/static/visitor.hpp	/^        typedef ICase icase_type;$/;"	t	struct:boost::xpressive::detail::xpression_visitor	access:public
boost::xpressive::detail::xpression_visitor::iterator_type	xpressive/detail/static/visitor.hpp	/^        typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::detail::xpression_visitor	access:public
boost::xpressive::detail::xpression_visitor::traits	xpressive/detail/static/visitor.hpp	/^        Traits const &traits() const$/;"	f	struct:boost::xpressive::detail::xpression_visitor	access:public	signature:() const
boost::xpressive::detail::xpression_visitor::traits_	xpressive/detail/static/visitor.hpp	/^        Traits traits_;$/;"	m	struct:boost::xpressive::detail::xpression_visitor	access:private
boost::xpressive::detail::xpression_visitor::traits_type	xpressive/detail/static/visitor.hpp	/^        typedef Traits traits_type;$/;"	t	struct:boost::xpressive::detail::xpression_visitor	access:public
boost::xpressive::detail::xpression_visitor::xpression_visitor	xpressive/detail/static/visitor.hpp	/^        explicit xpression_visitor(Traits const &tr, shared_ptr<regex_impl<BidiIter> > const &self)$/;"	f	struct:boost::xpressive::detail::xpression_visitor	access:public	signature:(Traits const &tr, shared_ptr<regex_impl<BidiIter> > const &self)
boost::xpressive::detail::xpression_visitor_base	xpressive/detail/static/visitor.hpp	/^    struct xpression_visitor_base$/;"	s	namespace:boost::xpressive::detail
boost::xpressive::detail::xpression_visitor_base::get_hidden_mark	xpressive/detail/static/visitor.hpp	/^        int get_hidden_mark()$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:public	signature:()
boost::xpressive::detail::xpression_visitor_base::mark_number	xpressive/detail/static/visitor.hpp	/^        void mark_number(int mark_nbr)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:public	signature:(int mark_nbr)
boost::xpressive::detail::xpression_visitor_base::self	xpressive/detail/static/visitor.hpp	/^        shared_ptr<regex_impl<BidiIter> > &self()$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:public	signature:()
boost::xpressive::detail::xpression_visitor_base::self_	xpressive/detail/static/visitor.hpp	/^        shared_ptr<regex_impl<BidiIter> > self_;$/;"	m	struct:boost::xpressive::detail::xpression_visitor_base	access:private
boost::xpressive::detail::xpression_visitor_base::swap	xpressive/detail/static/visitor.hpp	/^        void swap(xpression_visitor_base<BidiIter> &that)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:public	signature:(xpression_visitor_base<BidiIter> &that)
boost::xpressive::detail::xpression_visitor_base::visit_	xpressive/detail/static/visitor.hpp	/^        void visit_(Matcher const &)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:protected	signature:(Matcher const &)
boost::xpressive::detail::xpression_visitor_base::visit_	xpressive/detail/static/visitor.hpp	/^        void visit_(mark_begin_matcher const &mark_begin)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:protected	signature:(mark_begin_matcher const &mark_begin)
boost::xpressive::detail::xpression_visitor_base::visit_	xpressive/detail/static/visitor.hpp	/^        void visit_(mark_placeholder const &backref)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:protected	signature:(mark_placeholder const &backref)
boost::xpressive::detail::xpression_visitor_base::visit_	xpressive/detail/static/visitor.hpp	/^        void visit_(reference_wrapper<basic_regex<BidiIter> > const &rex)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:protected	signature:(reference_wrapper<basic_regex<BidiIter> > const &rex)
boost::xpressive::detail::xpression_visitor_base::visit_	xpressive/detail/static/visitor.hpp	/^        void visit_(reference_wrapper<basic_regex<BidiIter> const> const &rex)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:protected	signature:(reference_wrapper<basic_regex<BidiIter> const> const &rex)
boost::xpressive::detail::xpression_visitor_base::visit_	xpressive/detail/static/visitor.hpp	/^        void visit_(tracking_ptr<regex_impl<BidiIter> > const &rex)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:protected	signature:(tracking_ptr<regex_impl<BidiIter> > const &rex)
boost::xpressive::detail::xpression_visitor_base::xpression_visitor_base	xpressive/detail/static/visitor.hpp	/^        explicit xpression_visitor_base(shared_ptr<regex_impl<BidiIter> > const &self)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:public	signature:(shared_ptr<regex_impl<BidiIter> > const &self)
boost::xpressive::function	xpressive/regex_actions.hpp	/^    struct function$/;"	s	namespace:boost::xpressive
boost::xpressive::function::at	xpressive/regex_actions.hpp	/^    function<op::at>::type const at = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::back	xpressive/regex_actions.hpp	/^    function<op::back>::type const back = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::first	xpressive/regex_actions.hpp	/^    function<op::first>::type const first = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::front	xpressive/regex_actions.hpp	/^    function<op::front>::type const front = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::insert	xpressive/regex_actions.hpp	/^    function<op::insert>::type const insert = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::length	xpressive/regex_actions.hpp	/^    function<op::length>::type const length = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::make_pair	xpressive/regex_actions.hpp	/^    function<op::make_pair>::type const make_pair = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::matched	xpressive/regex_actions.hpp	/^    function<op::matched>::type const matched = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::pop	xpressive/regex_actions.hpp	/^    function<op::pop>::type const pop = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::pop_back	xpressive/regex_actions.hpp	/^    function<op::pop_back>::type const pop_back = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::pop_front	xpressive/regex_actions.hpp	/^    function<op::pop_front>::type const pop_front = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::push	xpressive/regex_actions.hpp	/^    function<op::push>::type const push = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::push_back	xpressive/regex_actions.hpp	/^    function<op::push_back>::type const push_back = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::push_front	xpressive/regex_actions.hpp	/^    function<op::push_front>::type const push_front = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::second	xpressive/regex_actions.hpp	/^    function<op::second>::type const second = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::str	xpressive/regex_actions.hpp	/^    function<op::str>::type const str = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::top	xpressive/regex_actions.hpp	/^    function<op::top>::type const top = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::function::type	xpressive/regex_actions.hpp	/^        typedef typename proto::terminal<PolymorphicFunctionObject>::type type;$/;"	t	struct:boost::xpressive::function	access:public
boost::xpressive::function::unwrap_reference	xpressive/regex_actions.hpp	/^    function<op::unwrap_reference>::type const unwrap_reference = {{}};$/;"	m	class:boost::xpressive::function
boost::xpressive::grammar_detail	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
boost::xpressive::grammar_detail	xpressive/detail/static/grammar.hpp	/^    namespace grammar_detail$/;"	n	namespace:boost::xpressive
boost::xpressive::grammar_detail	xpressive/detail/static/transforms/as_action.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
boost::xpressive::grammar_detail	xpressive/detail/static/transforms/as_alternate.hpp	/^    namespace grammar_detail$/;"	n	namespace:boost::xpressive
boost::xpressive::grammar_detail	xpressive/detail/static/transforms/as_independent.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
boost::xpressive::grammar_detail	xpressive/detail/static/transforms/as_inverse.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
boost::xpressive::grammar_detail	xpressive/detail/static/transforms/as_marker.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
boost::xpressive::grammar_detail	xpressive/detail/static/transforms/as_matcher.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
boost::xpressive::grammar_detail	xpressive/detail/static/transforms/as_modifier.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
boost::xpressive::grammar_detail	xpressive/detail/static/transforms/as_quantifier.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
boost::xpressive::grammar_detail	xpressive/detail/static/transforms/as_sequence.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
boost::xpressive::grammar_detail	xpressive/detail/static/transforms/as_set.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
boost::xpressive::grammar_detail::ActionableCases	xpressive/detail/static/grammar.hpp	/^        struct ActionableCases$/;"	s	namespace:boost::xpressive::grammar_detail
boost::xpressive::grammar_detail::ActionableCases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_$/;"	s	struct:boost::xpressive::grammar_detail::ActionableCases	inherits:Cases::,case_	access:public
boost::xpressive::grammar_detail::ActionableCases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<proto::tag::assign, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::ActionableCases	inherits:or_	access:public
boost::xpressive::grammar_detail::Cases	xpressive/detail/static/grammar.hpp	/^        struct Cases$/;"	s	namespace:boost::xpressive::grammar_detail
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:not_	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::generic_quant_tag<Min, Max>, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::keeper_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::lookahead_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::lookbehind_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::modifier_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<optional_tag<Greedy> , Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::assign, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:or_	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::bitwise_or, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::comma, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::complement, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::dereference, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::logical_not, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::negate, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::shift_right, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::subscript, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:or_	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::terminal, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
boost::xpressive::grammar_detail::Cases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::unary_plus, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
boost::xpressive::grammar_detail::CharLiteral	xpressive/detail/static/transforms/as_set.hpp	/^    struct CharLiteral$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
boost::xpressive::grammar_detail::CharLiteral	xpressive/detail/static/transforms/as_set.hpp	/^    struct CharLiteral<char>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:terminal
boost::xpressive::grammar_detail::CheckAssertion	xpressive/detail/static/transforms/as_action.hpp	/^    struct CheckAssertion$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::function
boost::xpressive::grammar_detail::DeepCopy	xpressive/detail/static/transforms/as_action.hpp	/^    struct DeepCopy$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
boost::xpressive::grammar_detail::FindAttr	xpressive/detail/static/transforms/as_action.hpp	/^    struct FindAttr$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
boost::xpressive::grammar_detail::IndependentEndXpression	xpressive/detail/static/transforms/as_independent.hpp	/^    struct IndependentEndXpression$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
boost::xpressive::grammar_detail::InsertAttrs	xpressive/detail/static/transforms/as_action.hpp	/^    struct InsertAttrs$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:if_
boost::xpressive::grammar_detail::InsertMark	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct InsertMark$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
boost::xpressive::grammar_detail::InvertibleCases	xpressive/detail/static/grammar.hpp	/^        struct InvertibleCases$/;"	s	namespace:boost::xpressive::grammar_detail
boost::xpressive::grammar_detail::InvertibleCases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_$/;"	s	struct:boost::xpressive::grammar_detail::InvertibleCases	inherits:not_	access:public
boost::xpressive::grammar_detail::InvertibleCases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::lookahead_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::InvertibleCases	inherits:when	access:public
boost::xpressive::grammar_detail::InvertibleCases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::lookbehind_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::InvertibleCases	inherits:when	access:public
boost::xpressive::grammar_detail::InvertibleCases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::assign, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::InvertibleCases	inherits:when	access:public
boost::xpressive::grammar_detail::InvertibleCases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::comma, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::InvertibleCases	inherits:when	access:public
boost::xpressive::grammar_detail::InvertibleCases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::subscript, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::InvertibleCases	inherits:when	access:public
boost::xpressive::grammar_detail::InvertibleCases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::terminal, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::InvertibleCases	inherits:when	access:public
boost::xpressive::grammar_detail::IsMarkerOrRepeater	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct IsMarkerOrRepeater$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
boost::xpressive::grammar_detail::ListSet	xpressive/detail/static/transforms/as_set.hpp	/^    struct ListSet$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
boost::xpressive::grammar_detail::MaxAttr	xpressive/detail/static/transforms/as_action.hpp	/^    struct MaxAttr$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
boost::xpressive::grammar_detail::NonGreedyRepeatCases	xpressive/detail/static/grammar.hpp	/^        struct NonGreedyRepeatCases$/;"	s	namespace:boost::xpressive::grammar_detail
boost::xpressive::grammar_detail::NonGreedyRepeatCases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_$/;"	s	struct:boost::xpressive::grammar_detail::NonGreedyRepeatCases	inherits:not_	access:public
boost::xpressive::grammar_detail::NonGreedyRepeatCases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::generic_quant_tag<Min, Max>, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NonGreedyRepeatCases	inherits:unary_expr	access:public
boost::xpressive::grammar_detail::NonGreedyRepeatCases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::dereference, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NonGreedyRepeatCases	inherits:dereference	access:public
boost::xpressive::grammar_detail::NonGreedyRepeatCases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::logical_not, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NonGreedyRepeatCases	inherits:logical_not	access:public
boost::xpressive::grammar_detail::NonGreedyRepeatCases::case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::unary_plus, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NonGreedyRepeatCases	inherits:unary_plus	access:public
boost::xpressive::grammar_detail::NotHasAction	xpressive/detail/static/transforms/as_independent.hpp	/^    struct NotHasAction$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::switch_
boost::xpressive::grammar_detail::NotHasActionCases	xpressive/detail/static/transforms/as_independent.hpp	/^    struct NotHasActionCases$/;"	s	namespace:boost::xpressive::grammar_detail
boost::xpressive::grammar_detail::NotHasActionCases::case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:proto::nary_expr	access:public
boost::xpressive::grammar_detail::NotHasActionCases::case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_<detail::keeper_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:proto::_	access:public
boost::xpressive::grammar_detail::NotHasActionCases::case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_<detail::lookahead_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:proto::_	access:public
boost::xpressive::grammar_detail::NotHasActionCases::case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_<detail::lookbehind_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:proto::_	access:public
boost::xpressive::grammar_detail::NotHasActionCases::case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_<proto::tag::comma, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:proto::_	access:public
boost::xpressive::grammar_detail::NotHasActionCases::case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_<proto::tag::complement, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:proto::_	access:public
boost::xpressive::grammar_detail::NotHasActionCases::case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_<proto::tag::subscript, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:proto::subscript	access:public
boost::xpressive::grammar_detail::NotHasActionCases::case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_<proto::tag::terminal, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:not_	access:public
boost::xpressive::grammar_detail::add_attrs	xpressive/detail/static/transforms/as_action.hpp	/^    struct add_attrs : proto::transform<add_attrs>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::add_attrs::impl	xpressive/detail/static/transforms/as_action.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::add_attrs	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::add_attrs::impl::begin_type	xpressive/detail/static/transforms/as_action.hpp	/^            begin_type;$/;"	t	struct:boost::xpressive::grammar_detail::add_attrs::impl	access:public
boost::xpressive::grammar_detail::add_attrs::impl::expr_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::add_attrs::impl	access:public
boost::xpressive::grammar_detail::add_attrs::impl::operator ()	xpressive/detail/static/transforms/as_action.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::add_attrs::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param ) const
boost::xpressive::grammar_detail::add_attrs::impl::result_type	xpressive/detail/static/transforms/as_action.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::add_attrs::impl	access:public
boost::xpressive::grammar_detail::add_hidden_mark	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct add_hidden_mark : proto::transform<add_hidden_mark>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::add_hidden_mark::impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::add_hidden_mark	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::add_hidden_mark::impl::expr_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::add_hidden_mark::impl	access:public
boost::xpressive::grammar_detail::add_hidden_mark::impl::operator ()	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::add_hidden_mark::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
boost::xpressive::grammar_detail::add_hidden_mark::impl::result_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::add_hidden_mark::impl	access:public
boost::xpressive::grammar_detail::as_action	xpressive/detail/static/transforms/as_action.hpp	/^    struct as_action : proto::transform<as_action>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_action::impl	xpressive/detail/static/transforms/as_action.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_action	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_action::impl::action_copy_type	xpressive/detail/static/transforms/as_action.hpp	/^            action_copy_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_action::impl	access:public
boost::xpressive::grammar_detail::as_action::impl::action_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename proto::result_of::right<Expr>::type action_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_action::impl	access:public
boost::xpressive::grammar_detail::as_action::impl::expr_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename proto::result_of::left<Expr>::type expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_action::impl	access:public
boost::xpressive::grammar_detail::as_action::impl::marked_expr_type	xpressive/detail/static/transforms/as_action.hpp	/^            marked_expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_action::impl	access:public
boost::xpressive::grammar_detail::as_action::impl::matcher_type	xpressive/detail/static/transforms/as_action.hpp	/^            matcher_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_action::impl	access:public
boost::xpressive::grammar_detail::as_action::impl::no_attr_type	xpressive/detail/static/transforms/as_action.hpp	/^            no_attr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_action::impl	access:public
boost::xpressive::grammar_detail::as_action::impl::operator ()	xpressive/detail/static/transforms/as_action.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_action::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
boost::xpressive::grammar_detail::as_action::impl::result_type	xpressive/detail/static/transforms/as_action.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_action::impl	access:public
boost::xpressive::grammar_detail::as_alternate_matcher	xpressive/detail/static/transforms/as_alternate.hpp	/^        struct as_alternate_matcher : proto::transform<as_alternate_matcher<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_alternate_matcher::impl	xpressive/detail/static/transforms/as_alternate.hpp	/^            struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_alternate_matcher	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_alternate_matcher::impl::data_type	xpressive/detail/static/transforms/as_alternate.hpp	/^                typedef typename impl::data data_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_alternate_matcher::impl	access:public
boost::xpressive::grammar_detail::as_alternate_matcher::impl::operator ()	xpressive/detail/static/transforms/as_alternate.hpp	/^                result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_alternate_matcher::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
boost::xpressive::grammar_detail::as_alternate_matcher::impl::result_type	xpressive/detail/static/transforms/as_alternate.hpp	/^                result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_alternate_matcher::impl	access:public
boost::xpressive::grammar_detail::as_attr_matcher	xpressive/detail/static/transforms/as_action.hpp	/^    struct as_attr_matcher : proto::transform<as_attr_matcher>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_attr_matcher::impl	xpressive/detail/static/transforms/as_action.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_attr_matcher	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_attr_matcher::impl::data_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename impl::data data_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_attr_matcher::impl	access:public
boost::xpressive::grammar_detail::as_attr_matcher::impl::expr_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_attr_matcher::impl	access:public
boost::xpressive::grammar_detail::as_attr_matcher::impl::operator ()	xpressive/detail/static/transforms/as_action.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_attr_matcher::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
boost::xpressive::grammar_detail::as_attr_matcher::impl::result_type	xpressive/detail/static/transforms/as_action.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_attr_matcher::impl	access:public
boost::xpressive::grammar_detail::as_default_optional	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_default_optional : proto::transform<as_default_optional<Grammar, Greedy, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_default_optional::impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_default_optional	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_default_optional::impl::end_xpr	xpressive/detail/static/transforms/as_quantifier.hpp	/^            end_xpr;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_optional::impl	access:public
boost::xpressive::grammar_detail::as_default_optional::impl::operator ()	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_default_optional::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
boost::xpressive::grammar_detail::as_default_optional::impl::result_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_optional::impl	access:public
boost::xpressive::grammar_detail::as_default_quantifier	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_default_quantifier : proto::transform<as_default_quantifier<Greedy, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_default_quantifier::impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_default_quantifier	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_default_quantifier::impl::expr_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_quantifier::impl	access:public
boost::xpressive::grammar_detail::as_default_quantifier::impl::operator ()	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_default_quantifier::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
boost::xpressive::grammar_detail::as_default_quantifier::impl::other	xpressive/detail/static/transforms/as_quantifier.hpp	/^            other;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_quantifier::impl	access:public
boost::xpressive::grammar_detail::as_default_quantifier::impl::result_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_quantifier::impl	access:public
boost::xpressive::grammar_detail::as_default_quantifier_impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_default_quantifier_impl : proto::transform<as_default_quantifier_impl<Greedy, Min, Max> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_default_quantifier_impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_default_quantifier_impl<Greedy, 0, 1>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:call
boost::xpressive::grammar_detail::as_default_quantifier_impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_default_quantifier_impl<Greedy, 0, Max>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:call
boost::xpressive::grammar_detail::as_default_quantifier_impl::impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_default_quantifier_impl	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_default_quantifier_impl::impl::marked_sub_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            marked_sub_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_quantifier_impl::impl	access:public
boost::xpressive::grammar_detail::as_default_quantifier_impl::impl::operator ()	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_default_quantifier_impl::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
boost::xpressive::grammar_detail::as_default_quantifier_impl::impl::result_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_quantifier_impl::impl	access:public
boost::xpressive::grammar_detail::as_default_quantifier_impl::impl::xpr_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_quantifier_impl::impl	access:public
boost::xpressive::grammar_detail::as_inverse	xpressive/detail/static/transforms/as_inverse.hpp	/^    struct as_inverse : proto::callable$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::callable
boost::xpressive::grammar_detail::as_inverse::operator ()	xpressive/detail/static/transforms/as_inverse.hpp	/^        typename inverter<Matcher>::type operator ()(Matcher const &matcher) const$/;"	f	struct:boost::xpressive::grammar_detail::as_inverse	access:public	signature:(Matcher const &matcher) const
boost::xpressive::grammar_detail::as_inverse::result	xpressive/detail/static/transforms/as_inverse.hpp	/^        struct result<This(Matcher)>$/;"	s	struct:boost::xpressive::grammar_detail::as_inverse	inherits:inverter	access:public
boost::xpressive::grammar_detail::as_keeper	xpressive/detail/static/transforms/as_independent.hpp	/^    struct as_keeper : proto::transform<as_keeper<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_keeper::impl	xpressive/detail/static/transforms/as_independent.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_keeper	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_keeper::impl::arg_type	xpressive/detail/static/transforms/as_independent.hpp	/^            typedef typename proto::result_of::child<Expr>::type arg_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_keeper::impl	access:public
boost::xpressive::grammar_detail::as_keeper::impl::end_xpr_type	xpressive/detail/static/transforms/as_independent.hpp	/^            end_xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_keeper::impl	access:public
boost::xpressive::grammar_detail::as_keeper::impl::operator ()	xpressive/detail/static/transforms/as_independent.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_keeper::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
boost::xpressive::grammar_detail::as_keeper::impl::result_type	xpressive/detail/static/transforms/as_independent.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_keeper::impl	access:public
boost::xpressive::grammar_detail::as_keeper::impl::xpr_type	xpressive/detail/static/transforms/as_independent.hpp	/^            xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_keeper::impl	access:public
boost::xpressive::grammar_detail::as_list_set_matcher	xpressive/detail/static/transforms/as_set.hpp	/^    struct as_list_set_matcher : proto::transform<as_list_set_matcher<Char, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_list_set_matcher::impl	xpressive/detail/static/transforms/as_set.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_list_set_matcher	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_list_set_matcher::impl::data_type	xpressive/detail/static/transforms/as_set.hpp	/^            typedef typename impl::data data_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_list_set_matcher::impl	access:public
boost::xpressive::grammar_detail::as_list_set_matcher::impl::operator ()	xpressive/detail/static/transforms/as_set.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_list_set_matcher::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
boost::xpressive::grammar_detail::as_list_set_matcher::impl::result_type	xpressive/detail/static/transforms/as_set.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_list_set_matcher::impl	access:public
boost::xpressive::grammar_detail::as_lookahead	xpressive/detail/static/transforms/as_independent.hpp	/^    struct as_lookahead : proto::transform<as_lookahead<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_lookahead::impl	xpressive/detail/static/transforms/as_independent.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_lookahead	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_lookahead::impl::arg_type	xpressive/detail/static/transforms/as_independent.hpp	/^            typedef typename proto::result_of::child<Expr>::type arg_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookahead::impl	access:public
boost::xpressive::grammar_detail::as_lookahead::impl::end_xpr_type	xpressive/detail/static/transforms/as_independent.hpp	/^            end_xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookahead::impl	access:public
boost::xpressive::grammar_detail::as_lookahead::impl::operator ()	xpressive/detail/static/transforms/as_independent.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_lookahead::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
boost::xpressive::grammar_detail::as_lookahead::impl::result_type	xpressive/detail/static/transforms/as_independent.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookahead::impl	access:public
boost::xpressive::grammar_detail::as_lookahead::impl::xpr_type	xpressive/detail/static/transforms/as_independent.hpp	/^            xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookahead::impl	access:public
boost::xpressive::grammar_detail::as_lookbehind	xpressive/detail/static/transforms/as_independent.hpp	/^    struct as_lookbehind : proto::transform<as_lookbehind<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_lookbehind::impl	xpressive/detail/static/transforms/as_independent.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_lookbehind	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_lookbehind::impl::arg_type	xpressive/detail/static/transforms/as_independent.hpp	/^            typedef typename proto::result_of::child<Expr>::type arg_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookbehind::impl	access:public
boost::xpressive::grammar_detail::as_lookbehind::impl::end_xpr_type	xpressive/detail/static/transforms/as_independent.hpp	/^            end_xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookbehind::impl	access:public
boost::xpressive::grammar_detail::as_lookbehind::impl::operator ()	xpressive/detail/static/transforms/as_independent.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_lookbehind::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
boost::xpressive::grammar_detail::as_lookbehind::impl::result_type	xpressive/detail/static/transforms/as_independent.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookbehind::impl	access:public
boost::xpressive::grammar_detail::as_lookbehind::impl::xpr_type	xpressive/detail/static/transforms/as_independent.hpp	/^            xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookbehind::impl	access:public
boost::xpressive::grammar_detail::as_mark_optional	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_mark_optional : proto::transform<as_mark_optional<Grammar, Greedy, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_mark_optional::impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_mark_optional	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_mark_optional::impl::end_xpr	xpressive/detail/static/transforms/as_quantifier.hpp	/^            end_xpr;$/;"	t	struct:boost::xpressive::grammar_detail::as_mark_optional::impl	access:public
boost::xpressive::grammar_detail::as_mark_optional::impl::operator ()	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_mark_optional::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
boost::xpressive::grammar_detail::as_mark_optional::impl::result_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_mark_optional::impl	access:public
boost::xpressive::grammar_detail::as_marker	xpressive/detail/static/transforms/as_marker.hpp	/^    struct as_marker : proto::transform<as_marker>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_marker::impl	xpressive/detail/static/transforms/as_marker.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_marker	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_marker::impl::operator ()	xpressive/detail/static/transforms/as_marker.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_marker::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param ) const
boost::xpressive::grammar_detail::as_marker::impl::result_type	xpressive/detail/static/transforms/as_marker.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_marker::impl	access:public
boost::xpressive::grammar_detail::as_matcher	xpressive/detail/static/transforms/as_matcher.hpp	/^    struct as_matcher : proto::transform<as_matcher>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_matcher::impl	xpressive/detail/static/transforms/as_matcher.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_matcher	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_matcher::impl::data_type	xpressive/detail/static/transforms/as_matcher.hpp	/^            typedef typename impl::data data_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_matcher::impl	access:public
boost::xpressive::grammar_detail::as_matcher::impl::operator ()	xpressive/detail/static/transforms/as_matcher.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_matcher::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
boost::xpressive::grammar_detail::as_matcher::impl::result_type	xpressive/detail/static/transforms/as_matcher.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_matcher::impl	access:public
boost::xpressive::grammar_detail::as_modifier	xpressive/detail/static/transforms/as_modifier.hpp	/^    struct as_modifier : proto::transform<as_modifier<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_modifier::impl	xpressive/detail/static/transforms/as_modifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_modifier	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_modifier::impl::expr_type	xpressive/detail/static/transforms/as_modifier.hpp	/^            expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_modifier::impl	access:public
boost::xpressive::grammar_detail::as_modifier::impl::modifier_type	xpressive/detail/static/transforms/as_modifier.hpp	/^            modifier_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_modifier::impl	access:public
boost::xpressive::grammar_detail::as_modifier::impl::operator ()	xpressive/detail/static/transforms/as_modifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_modifier::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
boost::xpressive::grammar_detail::as_modifier::impl::result_type	xpressive/detail/static/transforms/as_modifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_modifier::impl	access:public
boost::xpressive::grammar_detail::as_modifier::impl::visitor_type	xpressive/detail/static/transforms/as_modifier.hpp	/^            visitor_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_modifier::impl	access:public
boost::xpressive::grammar_detail::as_optional	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_optional$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:or_
boost::xpressive::grammar_detail::as_read_attr	xpressive/detail/static/transforms/as_action.hpp	/^    struct as_read_attr : proto::transform<as_read_attr>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_read_attr::impl	xpressive/detail/static/transforms/as_action.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_read_attr	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_read_attr::impl::attr_type	xpressive/detail/static/transforms/as_action.hpp	/^            attr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_read_attr::impl	access:public
boost::xpressive::grammar_detail::as_read_attr::impl::expr_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_read_attr::impl	access:public
boost::xpressive::grammar_detail::as_read_attr::impl::operator ()	xpressive/detail/static/transforms/as_action.hpp	/^            result_type operator ()(proto::ignore, proto::ignore, proto::ignore) const$/;"	f	struct:boost::xpressive::grammar_detail::as_read_attr::impl	access:public	signature:(proto::ignore, proto::ignore, proto::ignore) const
boost::xpressive::grammar_detail::as_read_attr::impl::result_type	xpressive/detail/static/transforms/as_action.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_read_attr::impl	access:public
boost::xpressive::grammar_detail::as_repeat	xpressive/detail/static/grammar.hpp	/^        struct as_repeat$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:if_
boost::xpressive::grammar_detail::as_set_matcher	xpressive/detail/static/transforms/as_set.hpp	/^    struct as_set_matcher : proto::transform<as_set_matcher<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_set_matcher::impl	xpressive/detail/static/transforms/as_set.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_set_matcher	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_set_matcher::impl::char_type	xpressive/detail/static/transforms/as_set.hpp	/^            typedef typename data_type::char_type char_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_set_matcher::impl	access:public
boost::xpressive::grammar_detail::as_set_matcher::impl::charset_type	xpressive/detail/static/transforms/as_set.hpp	/^            charset_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_set_matcher::impl	access:public
boost::xpressive::grammar_detail::as_set_matcher::impl::data_type	xpressive/detail/static/transforms/as_set.hpp	/^            typedef typename impl::data data_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_set_matcher::impl	access:public
boost::xpressive::grammar_detail::as_set_matcher::impl::operator ()	xpressive/detail/static/transforms/as_set.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_set_matcher::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
boost::xpressive::grammar_detail::as_set_matcher::impl::result_type	xpressive/detail/static/transforms/as_set.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_set_matcher::impl	access:public
boost::xpressive::grammar_detail::as_simple_quantifier	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct as_simple_quantifier : proto::transform<as_simple_quantifier<Grammar, Greedy, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::as_simple_quantifier::impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_simple_quantifier	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::as_simple_quantifier::impl::arg_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            arg_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_simple_quantifier::impl	access:public
boost::xpressive::grammar_detail::as_simple_quantifier::impl::matcher_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            matcher_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_simple_quantifier::impl	access:public
boost::xpressive::grammar_detail::as_simple_quantifier::impl::operator ()	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_simple_quantifier::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
boost::xpressive::grammar_detail::as_simple_quantifier::impl::result_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_simple_quantifier::impl	access:public
boost::xpressive::grammar_detail::as_simple_quantifier::impl::xpr_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_simple_quantifier::impl	access:public
boost::xpressive::grammar_detail::attr_nbr	xpressive/detail/static/transforms/as_action.hpp	/^    struct attr_nbr : proto::transform<attr_nbr>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::attr_nbr::impl	xpressive/detail/static/transforms/as_action.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::attr_nbr	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::attr_nbr::impl::expr_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::attr_nbr::impl	access:public
boost::xpressive::grammar_detail::attr_nbr::impl::result_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename expr_type::proto_child0::nbr_type::type result_type;$/;"	t	struct:boost::xpressive::grammar_detail::attr_nbr::impl	access:public
boost::xpressive::grammar_detail::fill_list_set	xpressive/detail/static/transforms/as_set.hpp	/^    void fill_list_set(Char *&, detail::set_initializer_type, Traits const &)$/;"	f	namespace:boost::xpressive::grammar_detail	signature:(Char *&, detail::set_initializer_type, Traits const &)
boost::xpressive::grammar_detail::fill_list_set	xpressive/detail/static/transforms/as_set.hpp	/^    void fill_list_set(Char *&buffer, Expr const &expr, Traits const &traits)$/;"	f	namespace:boost::xpressive::grammar_detail	signature:(Char *&buffer, Expr const &expr, Traits const &traits)
boost::xpressive::grammar_detail::in_alternate_list	xpressive/detail/static/transforms/as_alternate.hpp	/^        struct in_alternate_list : proto::transform<in_alternate_list<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::in_alternate_list::impl	xpressive/detail/static/transforms/as_alternate.hpp	/^            struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::in_alternate_list	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::in_alternate_list::impl::operator ()	xpressive/detail/static/transforms/as_alternate.hpp	/^                result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::in_alternate_list::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
boost::xpressive::grammar_detail::in_alternate_list::impl::result_type	xpressive/detail/static/transforms/as_alternate.hpp	/^                result_type;$/;"	t	struct:boost::xpressive::grammar_detail::in_alternate_list::impl	access:public
boost::xpressive::grammar_detail::in_sequence	xpressive/detail/static/transforms/as_sequence.hpp	/^    struct in_sequence : proto::transform<in_sequence<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::in_sequence::impl	xpressive/detail/static/transforms/as_sequence.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::in_sequence	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::in_sequence::impl::operator ()	xpressive/detail/static/transforms/as_sequence.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::in_sequence::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
boost::xpressive::grammar_detail::in_sequence::impl::result_type	xpressive/detail/static/transforms/as_sequence.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::in_sequence::impl	access:public
boost::xpressive::grammar_detail::inverter	xpressive/detail/static/transforms/as_inverse.hpp	/^    struct inverter$/;"	s	namespace:boost::xpressive::grammar_detail
boost::xpressive::grammar_detail::inverter	xpressive/detail/static/transforms/as_inverse.hpp	/^    struct inverter<detail::assert_word_matcher<detail::word_boundary<mpl::true_>, Traits> >$/;"	s	namespace:boost::xpressive::grammar_detail
boost::xpressive::grammar_detail::inverter	xpressive/detail/static/transforms/as_inverse.hpp	/^    struct inverter<detail::literal_matcher<Traits, ICase, Not> >$/;"	s	namespace:boost::xpressive::grammar_detail
boost::xpressive::grammar_detail::inverter	xpressive/detail/static/transforms/as_inverse.hpp	/^    struct inverter<detail::logical_newline_matcher<Traits> >$/;"	s	namespace:boost::xpressive::grammar_detail
boost::xpressive::grammar_detail::inverter::call	xpressive/detail/static/transforms/as_inverse.hpp	/^        static T call(T t)$/;"	f	struct:boost::xpressive::grammar_detail::inverter	access:public	signature:(T t)
boost::xpressive::grammar_detail::inverter::call	xpressive/detail/static/transforms/as_inverse.hpp	/^        static type call(detail::assert_word_matcher<detail::word_boundary<mpl::true_>, Traits> t)$/;"	f	struct:boost::xpressive::grammar_detail::inverter	access:public	signature:(detail::assert_word_matcher<detail::word_boundary<mpl::true_>, Traits> t)
boost::xpressive::grammar_detail::inverter::call	xpressive/detail/static/transforms/as_inverse.hpp	/^        static type call(detail::literal_matcher<Traits, ICase, Not> t)$/;"	f	struct:boost::xpressive::grammar_detail::inverter	access:public	signature:(detail::literal_matcher<Traits, ICase, Not> t)
boost::xpressive::grammar_detail::inverter::call	xpressive/detail/static/transforms/as_inverse.hpp	/^        static type call(detail::logical_newline_matcher<Traits> t)$/;"	f	struct:boost::xpressive::grammar_detail::inverter	access:public	signature:(detail::logical_newline_matcher<Traits> t)
boost::xpressive::grammar_detail::inverter::type	xpressive/detail/static/transforms/as_inverse.hpp	/^        typedef T type;$/;"	t	struct:boost::xpressive::grammar_detail::inverter	access:public
boost::xpressive::grammar_detail::inverter::type	xpressive/detail/static/transforms/as_inverse.hpp	/^        typedef detail::assert_word_matcher<detail::word_boundary<mpl::false_>, Traits> type;$/;"	t	struct:boost::xpressive::grammar_detail::inverter	access:public
boost::xpressive::grammar_detail::inverter::type	xpressive/detail/static/transforms/as_inverse.hpp	/^        typedef detail::literal_matcher<Traits, ICase, typename mpl::not_<Not>::type> type;$/;"	t	struct:boost::xpressive::grammar_detail::inverter	access:public
boost::xpressive::grammar_detail::inverter::type	xpressive/detail/static/transforms/as_inverse.hpp	/^        typedef detail::posix_charset_matcher<Traits> type;$/;"	t	struct:boost::xpressive::grammar_detail::inverter	access:public
boost::xpressive::grammar_detail::make_optional_	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct make_optional_ : proto::transform<make_optional_<Greedy, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::make_optional_::impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::make_optional_	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::make_optional_::impl::expr_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::make_optional_::impl	access:public
boost::xpressive::grammar_detail::make_optional_::impl::operator ()	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::make_optional_::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param ) const
boost::xpressive::grammar_detail::make_optional_::impl::result_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::make_optional_::impl	access:public
boost::xpressive::grammar_detail::max_attr	xpressive/detail/static/transforms/as_action.hpp	/^    struct max_attr : proto::transform<max_attr>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
boost::xpressive::grammar_detail::max_attr::impl	xpressive/detail/static/transforms/as_action.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::max_attr	inherits:proto::transform_impl	access:public
boost::xpressive::grammar_detail::max_attr::impl::result_type	xpressive/detail/static/transforms/as_action.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::max_attr::impl	access:public
boost::xpressive::grammar_detail::max_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct max_type : Tag::max_type {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:Tag::max_type
boost::xpressive::grammar_detail::max_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct max_type<proto::tag::dereference> : mpl::integral_c<uint_t, UINT_MAX-1> {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:mpl::integral_c
boost::xpressive::grammar_detail::max_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct max_type<proto::tag::logical_not> : mpl::integral_c<uint_t, 1> {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:mpl::integral_c
boost::xpressive::grammar_detail::max_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct max_type<proto::tag::unary_plus> : mpl::integral_c<uint_t, UINT_MAX-1> {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:mpl::integral_c
boost::xpressive::grammar_detail::merge_charset	xpressive/detail/static/transforms/as_set.hpp	/^    struct merge_charset$/;"	s	namespace:boost::xpressive::grammar_detail
boost::xpressive::grammar_detail::merge_charset::call_	xpressive/detail/static/transforms/as_set.hpp	/^        void call_(Expr const &expr, Tag) const$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:private	signature:(Expr const &expr, Tag) const
boost::xpressive::grammar_detail::merge_charset::call_	xpressive/detail/static/transforms/as_set.hpp	/^        void call_(Expr const &expr, tag::bitwise_or) const$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:private	signature:(Expr const &expr, tag::bitwise_or) const
boost::xpressive::grammar_detail::merge_charset::char_type	xpressive/detail/static/transforms/as_set.hpp	/^        typedef typename CharSet::char_type char_type;$/;"	t	struct:boost::xpressive::grammar_detail::merge_charset	access:public
boost::xpressive::grammar_detail::merge_charset::charset_	xpressive/detail/static/transforms/as_set.hpp	/^        CharSet &charset_;$/;"	m	struct:boost::xpressive::grammar_detail::merge_charset	access:private
boost::xpressive::grammar_detail::merge_charset::icase_type	xpressive/detail/static/transforms/as_set.hpp	/^        typedef typename CharSet::icase_type icase_type;$/;"	t	struct:boost::xpressive::grammar_detail::merge_charset	access:public
boost::xpressive::grammar_detail::merge_charset::merge_charset	xpressive/detail/static/transforms/as_set.hpp	/^        merge_charset(CharSet &charset, Data &data)$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:public	signature:(CharSet &charset, Data &data)
boost::xpressive::grammar_detail::merge_charset::operator ()	xpressive/detail/static/transforms/as_set.hpp	/^        void operator ()(Expr const &expr) const$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:public	signature:(Expr const &expr) const
boost::xpressive::grammar_detail::merge_charset::operator =	xpressive/detail/static/transforms/as_set.hpp	/^        merge_charset &operator =(merge_charset const &);$/;"	p	struct:boost::xpressive::grammar_detail::merge_charset	access:private	signature:(merge_charset const &)
boost::xpressive::grammar_detail::merge_charset::set_	xpressive/detail/static/transforms/as_set.hpp	/^        void set_(detail::literal_matcher<traits_type, icase_type, Not> const &ch) const$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:private	signature:(detail::literal_matcher<traits_type, icase_type, Not> const &ch) const
boost::xpressive::grammar_detail::merge_charset::set_	xpressive/detail/static/transforms/as_set.hpp	/^        void set_(detail::posix_charset_matcher<traits_type> const &posix) const$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:private	signature:(detail::posix_charset_matcher<traits_type> const &posix) const
boost::xpressive::grammar_detail::merge_charset::set_	xpressive/detail/static/transforms/as_set.hpp	/^        void set_(detail::range_matcher<traits_type, icase_type> const &rg) const$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:private	signature:(detail::range_matcher<traits_type, icase_type> const &rg) const
boost::xpressive::grammar_detail::merge_charset::set_	xpressive/detail/static/transforms/as_set.hpp	/^        void set_(detail::set_matcher<traits_type, Size> const &set_) const$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:private	signature:(detail::set_matcher<traits_type, Size> const &set_) const
boost::xpressive::grammar_detail::merge_charset::traits_type	xpressive/detail/static/transforms/as_set.hpp	/^        typedef typename Data::traits_type traits_type;$/;"	t	struct:boost::xpressive::grammar_detail::merge_charset	access:public
boost::xpressive::grammar_detail::merge_charset::visitor_	xpressive/detail/static/transforms/as_set.hpp	/^        Data &visitor_;$/;"	m	struct:boost::xpressive::grammar_detail::merge_charset	access:private
boost::xpressive::grammar_detail::min_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct min_type : Tag::min_type {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:Tag::min_type
boost::xpressive::grammar_detail::min_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct min_type<proto::tag::dereference> : mpl::integral_c<uint_t, 0> {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:mpl::integral_c
boost::xpressive::grammar_detail::min_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct min_type<proto::tag::logical_not> : mpl::integral_c<uint_t, 0> {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:mpl::integral_c
boost::xpressive::grammar_detail::min_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct min_type<proto::tag::unary_plus> : mpl::integral_c<uint_t, 1> {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:mpl::integral_c
boost::xpressive::grammar_detail::optional_tag	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct optional_tag$/;"	s	namespace:boost::xpressive::grammar_detail
boost::xpressive::has_fold_case	xpressive/regex_traits.hpp	/^struct has_fold_case$/;"	s	namespace:boost::xpressive	inherits:is_convertible
boost::xpressive::has_fold_case	xpressive/traits/c_regex_traits.hpp	/^struct has_fold_case<c_regex_traits<char> >$/;"	s	namespace:boost::xpressive	inherits:mpl::true_
boost::xpressive::has_fold_case	xpressive/traits/cpp_regex_traits.hpp	/^struct has_fold_case<cpp_regex_traits<char> >$/;"	s	namespace:boost::xpressive	inherits:mpl::true_
boost::xpressive::icase	xpressive/regex_primitives.hpp	/^template<typename Expr> detail::unspecified icase(Expr const &expr) { return 0; }$/;"	f	namespace:boost::xpressive	signature:(Expr const &expr)
boost::xpressive::inf	xpressive/regex_primitives.hpp	/^unsigned int const inf = UINT_MAX-1;$/;"	m	namespace:boost::xpressive
boost::xpressive::is_valid_regex	xpressive/detail/static/grammar.hpp	/^    struct is_valid_regex$/;"	s	namespace:boost::xpressive	inherits:proto::matches
boost::xpressive::let	xpressive/regex_actions.hpp	/^    detail::unspecified let(ArgBindings const &...args);$/;"	p	namespace:boost::xpressive	signature:(ArgBindings const &....args)
boost::xpressive::local	xpressive/regex_actions.hpp	/^    struct local$/;"	s	namespace:boost::xpressive	inherits:detail::value_wrapper,proto::terminal::type
boost::xpressive::local::base_type	xpressive/regex_actions.hpp	/^        typedef typename proto::terminal<reference_wrapper<T> >::type base_type;$/;"	t	struct:boost::xpressive::local	access:public
boost::xpressive::local::get	xpressive/regex_actions.hpp	/^        T &get()$/;"	f	struct:boost::xpressive::local	access:public	signature:()
boost::xpressive::local::get	xpressive/regex_actions.hpp	/^        T const &get() const$/;"	f	struct:boost::xpressive::local	access:public	signature:() const
boost::xpressive::local::local	xpressive/regex_actions.hpp	/^        explicit local(T const &t)$/;"	f	struct:boost::xpressive::local	access:public	signature:(T const &t)
boost::xpressive::local::local	xpressive/regex_actions.hpp	/^        local()$/;"	f	struct:boost::xpressive::local	access:public	signature:()
boost::xpressive::lookup_classname	xpressive/detail/detail_fwd.hpp	/^    lookup_classname(Traits const &traits, char const (&cname)[N], bool icase = false);$/;"	p	namespace:boost::xpressive	signature:(Traits const &traits, char const (&cname)[N], bool icase = false)
boost::xpressive::lookup_classname	xpressive/regex_traits.hpp	/^lookup_classname(Traits const &traits, char const (&cname)[N], bool icase)$/;"	f	namespace:boost::xpressive	signature:(Traits const &traits, char const (&cname)[N], bool icase)
boost::xpressive::mark_tag	xpressive/regex_primitives.hpp	/^struct mark_tag$/;"	s	namespace:boost::xpressive	inherits:proto::extends
boost::xpressive::mark_tag::base_type	xpressive/regex_primitives.hpp	/^    typedef proto::extends<detail::basic_mark_tag, mark_tag, detail::regex_domain> base_type;$/;"	t	struct:boost::xpressive::mark_tag	access:private
boost::xpressive::mark_tag::make_tag	xpressive/regex_primitives.hpp	/^    static detail::basic_mark_tag make_tag(int mark_nbr)$/;"	f	struct:boost::xpressive::mark_tag	access:private	signature:(int mark_nbr)
boost::xpressive::mark_tag::mark_tag	xpressive/regex_primitives.hpp	/^    mark_tag(int mark_nbr)$/;"	f	struct:boost::xpressive::mark_tag	access:public	signature:(int mark_nbr)
boost::xpressive::mark_tag::operator detail::basic_mark_tag const &	xpressive/regex_primitives.hpp	/^    operator detail::basic_mark_tag const &() const$/;"	f	struct:boost::xpressive::mark_tag	access:public	signature:() const
boost::xpressive::match_results	xpressive/match_results.hpp	/^struct match_results$/;"	s	namespace:boost::xpressive
boost::xpressive::match_results::args_	xpressive/match_results.hpp	/^    detail::action_args_type args_;$/;"	m	struct:boost::xpressive::match_results	access:private
boost::xpressive::match_results::at_	xpressive/match_results.hpp	/^    const_reference at_(char_type const *name) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(char_type const *name) const
boost::xpressive::match_results::at_	xpressive/match_results.hpp	/^    const_reference at_(detail::basic_mark_tag const &mark) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(detail::basic_mark_tag const &mark) const
boost::xpressive::match_results::at_	xpressive/match_results.hpp	/^    const_reference at_(size_type sub) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(size_type sub) const
boost::xpressive::match_results::at_	xpressive/match_results.hpp	/^    const_reference at_(string_type const &name) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(string_type const &name) const
boost::xpressive::match_results::base_	xpressive/match_results.hpp	/^    boost::optional<BidiIter> base_;$/;"	m	struct:boost::xpressive::match_results	access:private
boost::xpressive::match_results::begin	xpressive/match_results.hpp	/^    const_iterator begin() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
boost::xpressive::match_results::char_type	xpressive/match_results.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::match_results	access:public
boost::xpressive::match_results::const_iterator	xpressive/match_results.hpp	/^    typedef typename detail::sub_match_vector<BidiIter>::const_iterator const_iterator;$/;"	t	struct:boost::xpressive::match_results	access:public
boost::xpressive::match_results::const_reference	xpressive/match_results.hpp	/^    typedef value_type const &const_reference;$/;"	t	struct:boost::xpressive::match_results	access:public
boost::xpressive::match_results::difference_type	xpressive/match_results.hpp	/^    typedef typename iterator_difference<BidiIter>::type difference_type;$/;"	t	struct:boost::xpressive::match_results	access:public
boost::xpressive::match_results::dummy	xpressive/match_results.hpp	/^    struct dummy { int i_; };$/;"	s	struct:boost::xpressive::match_results	access:private
boost::xpressive::match_results::dummy::bool_type	xpressive/match_results.hpp	/^    typedef int dummy::*bool_type;$/;"	t	class:boost::xpressive::match_results::dummy	access:private
boost::xpressive::match_results::dummy::i_	xpressive/match_results.hpp	/^    struct dummy { int i_; };$/;"	m	struct:boost::xpressive::match_results::dummy	access:public
boost::xpressive::match_results::empty	xpressive/match_results.hpp	/^    bool empty() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
boost::xpressive::match_results::end	xpressive/match_results.hpp	/^    const_iterator end() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
boost::xpressive::match_results::extras_ptr_	xpressive/match_results.hpp	/^    intrusive_ptr<extras_type> extras_ptr_;$/;"	m	struct:boost::xpressive::match_results	access:private
boost::xpressive::match_results::extras_type	xpressive/match_results.hpp	/^    typedef detail::results_extras<BidiIter> extras_type;$/;"	t	struct:boost::xpressive::match_results	access:private
boost::xpressive::match_results::format	xpressive/match_results.hpp	/^    OutputIterator format$/;"	f	struct:boost::xpressive::match_results	access:public	signature:( OutputIterator out , Format const &fmt , regex_constants::match_flag_type flags = regex_constants::format_default , typename disable_if<detail::is_char_ptr<Format> >::type * = 0 ) const
boost::xpressive::match_results::format	xpressive/match_results.hpp	/^    OutputIterator format$/;"	f	struct:boost::xpressive::match_results	access:public	signature:( OutputIterator out , char_type const *fmt , regex_constants::match_flag_type flags = regex_constants::format_default ) const
boost::xpressive::match_results::format	xpressive/match_results.hpp	/^    string_type format$/;"	f	struct:boost::xpressive::match_results	access:public	signature:( Format const &fmt , regex_constants::match_flag_type flags = regex_constants::format_default , typename disable_if<detail::is_char_ptr<Format> >::type * = 0 ) const
boost::xpressive::match_results::format	xpressive/match_results.hpp	/^    string_type format$/;"	f	struct:boost::xpressive::match_results	access:public	signature:( char_type const *fmt , regex_constants::match_flag_type flags = regex_constants::format_default ) const
boost::xpressive::match_results::format2_	xpressive/match_results.hpp	/^    OutputIterator format2_(OutputIterator out, Char const *const &result) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(OutputIterator out, Char const *const &result) const
boost::xpressive::match_results::format2_	xpressive/match_results.hpp	/^    OutputIterator format2_(OutputIterator out, ForwardRange const &result) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(OutputIterator out, ForwardRange const &result) const
boost::xpressive::match_results::format_	xpressive/match_results.hpp	/^    OutputIterator format_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( OutputIterator out , Callable1 const &format , regex_constants::match_flag_type , mpl::size_t<1> ) const
boost::xpressive::match_results::format_	xpressive/match_results.hpp	/^    OutputIterator format_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( OutputIterator out , Callable2 const &format , regex_constants::match_flag_type , mpl::size_t<2> ) const
boost::xpressive::match_results::format_	xpressive/match_results.hpp	/^    OutputIterator format_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( OutputIterator out , Callable3 const &format , regex_constants::match_flag_type flags , mpl::size_t<3> ) const
boost::xpressive::match_results::format_	xpressive/match_results.hpp	/^    OutputIterator format_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( OutputIterator out , Expr const &format , regex_constants::match_flag_type , mpl::size_t<4> ) const
boost::xpressive::match_results::format_	xpressive/match_results.hpp	/^    OutputIterator format_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( OutputIterator out , ForwardRange const &format , regex_constants::match_flag_type flags , mpl::size_t<0> ) const
boost::xpressive::match_results::format_all_	xpressive/match_results.hpp	/^    OutputIterator format_all_(ForwardIterator cur, ForwardIterator end, OutputIterator out) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(ForwardIterator cur, ForwardIterator end, OutputIterator out) const
boost::xpressive::match_results::format_all_impl_	xpressive/match_results.hpp	/^    OutputIterator format_all_impl_(ForwardIterator &cur, ForwardIterator end, OutputIterator out, bool metacolon = false) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(ForwardIterator &cur, ForwardIterator end, OutputIterator out, bool metacolon = false) const
boost::xpressive::match_results::format_backref_	xpressive/match_results.hpp	/^    OutputIterator format_backref_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( ForwardIterator &cur , ForwardIterator end , OutputIterator out ) const
boost::xpressive::match_results::format_ecma_262_	xpressive/match_results.hpp	/^    OutputIterator format_ecma_262_(ForwardIterator cur, ForwardIterator end, OutputIterator out) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(ForwardIterator cur, ForwardIterator end, OutputIterator out) const
boost::xpressive::match_results::format_escape_	xpressive/match_results.hpp	/^    OutputIterator format_escape_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( ForwardIterator &cur , ForwardIterator end , OutputIterator out ) const
boost::xpressive::match_results::format_named_backref_	xpressive/match_results.hpp	/^    OutputIterator format_named_backref_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( ForwardIterator &cur , ForwardIterator end , OutputIterator out ) const
boost::xpressive::match_results::format_perl_	xpressive/match_results.hpp	/^    OutputIterator format_perl_(ForwardIterator cur, ForwardIterator end, OutputIterator out) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(ForwardIterator cur, ForwardIterator end, OutputIterator out) const
boost::xpressive::match_results::format_sed_	xpressive/match_results.hpp	/^    OutputIterator format_sed_(ForwardIterator cur, ForwardIterator end, OutputIterator out) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(ForwardIterator cur, ForwardIterator end, OutputIterator out) const
boost::xpressive::match_results::get_extras_	xpressive/match_results.hpp	/^    extras_type &get_extras_()$/;"	f	struct:boost::xpressive::match_results	access:private	signature:()
boost::xpressive::match_results::init_	xpressive/match_results.hpp	/^    void init_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( regex_id_type regex_id , intrusive_ptr<detail::traits<char_type> const> const &tr , detail::sub_match_impl<BidiIter> *sub_matches , size_type size , std::vector<detail::named_mark<char_type> > const &named_marks )
boost::xpressive::match_results::iterator	xpressive/match_results.hpp	/^    typedef typename detail::sub_match_vector<BidiIter>::iterator iterator;$/;"	t	struct:boost::xpressive::match_results	access:public
boost::xpressive::match_results::length	xpressive/match_results.hpp	/^    difference_type length(size_type sub = 0) const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(size_type sub = 0) const
boost::xpressive::match_results::let	xpressive/match_results.hpp	/^    match_results<BidiIter> &let(Arg const &arg)$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(Arg const &arg)
boost::xpressive::match_results::match_results	xpressive/match_results.hpp	/^    match_results()$/;"	f	struct:boost::xpressive::match_results	access:public	signature:()
boost::xpressive::match_results::match_results	xpressive/match_results.hpp	/^    match_results(match_results<BidiIter> const &that)$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(match_results<BidiIter> const &that)
boost::xpressive::match_results::named_marks_	xpressive/match_results.hpp	/^    std::vector<detail::named_mark<char_type> > named_marks_;$/;"	m	struct:boost::xpressive::match_results	access:private
boost::xpressive::match_results::nested_results	xpressive/match_results.hpp	/^    nested_results_type const &nested_results() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
boost::xpressive::match_results::nested_results_	xpressive/match_results.hpp	/^    nested_results_type nested_results_;$/;"	m	struct:boost::xpressive::match_results	access:private
boost::xpressive::match_results::nested_results_type	xpressive/match_results.hpp	/^    typedef typename detail::nested_results<BidiIter> nested_results_type;$/;"	t	struct:boost::xpressive::match_results	access:public
boost::xpressive::match_results::operator !	xpressive/match_results.hpp	/^    bool operator !() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
boost::xpressive::match_results::operator ()	xpressive/match_results.hpp	/^    match_results<BidiIter> const &operator ()(basic_regex<BidiIter> const &rex, std::size_t index = 0) const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(basic_regex<BidiIter> const &rex, std::size_t index = 0) const
boost::xpressive::match_results::operator ()	xpressive/match_results.hpp	/^    match_results<BidiIter> const &operator ()(regex_id_type regex_id, size_type index = 0) const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(regex_id_type regex_id, size_type index = 0) const
boost::xpressive::match_results::operator =	xpressive/match_results.hpp	/^    match_results<BidiIter> &operator =(match_results<BidiIter> const &that)$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(match_results<BidiIter> const &that)
boost::xpressive::match_results::operator []	xpressive/match_results.hpp	/^    const_reference operator [](Sub const &sub) const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(Sub const &sub) const
boost::xpressive::match_results::operator bool_type	xpressive/match_results.hpp	/^    operator bool_type() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
boost::xpressive::match_results::position	xpressive/match_results.hpp	/^    difference_type position(size_type sub = 0) const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(size_type sub = 0) const
boost::xpressive::match_results::prefix	xpressive/match_results.hpp	/^    const_reference prefix() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
boost::xpressive::match_results::prefix_	xpressive/match_results.hpp	/^    boost::optional<sub_match<BidiIter> > prefix_;$/;"	m	struct:boost::xpressive::match_results	access:private
boost::xpressive::match_results::reference	xpressive/match_results.hpp	/^    typedef value_type const &reference;$/;"	t	struct:boost::xpressive::match_results	access:public
boost::xpressive::match_results::regex_id	xpressive/match_results.hpp	/^    regex_id_type regex_id() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
boost::xpressive::match_results::regex_id_	xpressive/match_results.hpp	/^    regex_id_type regex_id_;$/;"	m	struct:boost::xpressive::match_results	access:private
boost::xpressive::match_results::reset_	xpressive/match_results.hpp	/^    void reset_()$/;"	f	struct:boost::xpressive::match_results	access:private	signature:()
boost::xpressive::match_results::set_base_	xpressive/match_results.hpp	/^    void set_base_(BidiIter base)$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(BidiIter base)
boost::xpressive::match_results::set_prefix_suffix_	xpressive/match_results.hpp	/^    void set_prefix_suffix_(BidiIter begin, BidiIter end)$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(BidiIter begin, BidiIter end)
boost::xpressive::match_results::size	xpressive/match_results.hpp	/^    size_type size() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
boost::xpressive::match_results::size_type	xpressive/match_results.hpp	/^    typedef std::size_t size_type;$/;"	t	struct:boost::xpressive::match_results	access:public
boost::xpressive::match_results::str	xpressive/match_results.hpp	/^    string_type str(size_type sub = 0) const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(size_type sub = 0) const
boost::xpressive::match_results::string_type	xpressive/match_results.hpp	/^    typedef typename detail::string_type<char_type>::type string_type;$/;"	t	struct:boost::xpressive::match_results	access:public
boost::xpressive::match_results::sub_matches_	xpressive/match_results.hpp	/^    detail::sub_match_vector<BidiIter> sub_matches_;$/;"	m	struct:boost::xpressive::match_results	access:private
boost::xpressive::match_results::suffix	xpressive/match_results.hpp	/^    const_reference suffix() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
boost::xpressive::match_results::suffix_	xpressive/match_results.hpp	/^    boost::optional<sub_match<BidiIter> > suffix_;$/;"	m	struct:boost::xpressive::match_results	access:private
boost::xpressive::match_results::swap	xpressive/match_results.hpp	/^    void swap(match_results<BidiIter> &that) \/\/ throw()$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(match_results<BidiIter> &that)
boost::xpressive::match_results::traits_	xpressive/match_results.hpp	/^    intrusive_ptr<detail::traits<char_type> const> traits_;$/;"	m	struct:boost::xpressive::match_results	access:private
boost::xpressive::match_results::value_type	xpressive/match_results.hpp	/^    typedef sub_match<BidiIter> value_type;$/;"	t	struct:boost::xpressive::match_results	access:public
boost::xpressive::match_results::~match_results	xpressive/match_results.hpp	/^    ~match_results()$/;"	f	struct:boost::xpressive::match_results	access:public	signature:()
boost::xpressive::null_regex_traits	xpressive/traits/null_regex_traits.hpp	/^struct null_regex_traits$/;"	s	namespace:boost::xpressive
boost::xpressive::null_regex_traits::char_class_type	xpressive/traits/null_regex_traits.hpp	/^    typedef int char_class_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
boost::xpressive::null_regex_traits::char_type	xpressive/traits/null_regex_traits.hpp	/^    typedef Elem char_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
boost::xpressive::null_regex_traits::getloc	xpressive/traits/null_regex_traits.hpp	/^    static locale_type getloc()$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:()
boost::xpressive::null_regex_traits::hash	xpressive/traits/null_regex_traits.hpp	/^    static unsigned char hash(char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::null_regex_traits::imbue	xpressive/traits/null_regex_traits.hpp	/^    static locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(locale_type loc)
boost::xpressive::null_regex_traits::in_range	xpressive/traits/null_regex_traits.hpp	/^    static bool in_range(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
boost::xpressive::null_regex_traits::in_range_nocase	xpressive/traits/null_regex_traits.hpp	/^    static bool in_range_nocase(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
boost::xpressive::null_regex_traits::isctype	xpressive/traits/null_regex_traits.hpp	/^    static bool isctype(char_type ch, char_class_type mask)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch, char_class_type mask)
boost::xpressive::null_regex_traits::locale_type	xpressive/traits/null_regex_traits.hpp	/^    typedef detail::not_a_locale locale_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
boost::xpressive::null_regex_traits::lookup_classname	xpressive/traits/null_regex_traits.hpp	/^    static char_class_type lookup_classname(FwdIter begin, FwdIter end, bool icase)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end, bool icase)
boost::xpressive::null_regex_traits::lookup_collatename	xpressive/traits/null_regex_traits.hpp	/^    static string_type lookup_collatename(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
boost::xpressive::null_regex_traits::null_regex_traits	xpressive/traits/null_regex_traits.hpp	/^    null_regex_traits(locale_type = locale_type())$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(locale_type = locale_type())
boost::xpressive::null_regex_traits::operator !=	xpressive/traits/null_regex_traits.hpp	/^    bool operator !=(null_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(null_regex_traits<char_type> const &that) const
boost::xpressive::null_regex_traits::operator ==	xpressive/traits/null_regex_traits.hpp	/^    bool operator ==(null_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(null_regex_traits<char_type> const &that) const
boost::xpressive::null_regex_traits::string_type	xpressive/traits/null_regex_traits.hpp	/^    typedef std::vector<char_type> string_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
boost::xpressive::null_regex_traits::transform	xpressive/traits/null_regex_traits.hpp	/^    static string_type transform(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
boost::xpressive::null_regex_traits::transform_primary	xpressive/traits/null_regex_traits.hpp	/^    static string_type transform_primary(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
boost::xpressive::null_regex_traits::translate	xpressive/traits/null_regex_traits.hpp	/^    static char_type translate(char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::null_regex_traits::translate_nocase	xpressive/traits/null_regex_traits.hpp	/^    static char_type translate_nocase(char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch)
boost::xpressive::null_regex_traits::value	xpressive/traits/null_regex_traits.hpp	/^    static int value(char_type ch, int radix)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch, int radix)
boost::xpressive::null_regex_traits::version_tag	xpressive/traits/null_regex_traits.hpp	/^    typedef regex_traits_version_1_tag version_tag;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
boost::xpressive::null_regex_traits::widen	xpressive/traits/null_regex_traits.hpp	/^    char_type widen(char ch) const$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char ch) const
boost::xpressive::op	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive { namespace op$/;"	n	namespace:boost::xpressive
boost::xpressive::op	xpressive/regex_actions.hpp	/^    namespace op$/;"	n	namespace:boost::xpressive
boost::xpressive::op	xpressive/xpressive_fwd.hpp	/^    namespace op$/;"	n	namespace:boost::xpressive
boost::xpressive::op::as	xpressive/regex_actions.hpp	/^        struct as$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::as::impl	xpressive/regex_actions.hpp	/^            T impl(sub_match<BidiIter> const &val, mpl::false_) const$/;"	f	struct:boost::xpressive::op::as	access:private	signature:(sub_match<BidiIter> const &val, mpl::false_) const
boost::xpressive::op::as::impl	xpressive/regex_actions.hpp	/^            T impl(sub_match<RandIter> const &val, mpl::true_) const$/;"	f	struct:boost::xpressive::op::as	access:private	signature:(sub_match<RandIter> const &val, mpl::true_) const
boost::xpressive::op::as::operator ()	xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(Value const &val) const
boost::xpressive::op::as::operator ()	xpressive/regex_actions.hpp	/^            T operator()(csub_match const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(csub_match const &val) const
boost::xpressive::op::as::operator ()	xpressive/regex_actions.hpp	/^            T operator()(sub_match<BidiIter> const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(sub_match<BidiIter> const &val) const
boost::xpressive::op::as::operator ()	xpressive/regex_actions.hpp	/^            T operator()(wcsub_match const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(wcsub_match const &val) const
boost::xpressive::op::as::result_type	xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::as	access:public
boost::xpressive::op::at	xpressive/regex_actions.hpp	/^        struct at$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::at::operator ()	xpressive/regex_actions.hpp	/^            typename Cont::const_reference operator()(Cont const &c, Idx idx) const$/;"	f	struct:boost::xpressive::op::at	access:public	signature:(Cont const &c, Idx idx) const
boost::xpressive::op::at::operator ()	xpressive/regex_actions.hpp	/^            typename Cont::reference operator()(Cont &c, Idx idx BOOST_PROTO_DISABLE_IF_IS_CONST(Cont)) const$/;"	f	struct:boost::xpressive::op::at	access:public	signature:(Cont &c, Idx idx BOOST_PROTO_DISABLE_IF_IS_CONST(Cont)) const
boost::xpressive::op::at::result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::at	access:public
boost::xpressive::op::at::result	xpressive/regex_actions.hpp	/^            struct result<This(Cont &, Idx)>$/;"	s	struct:boost::xpressive::op::at	access:public
boost::xpressive::op::at::result	xpressive/regex_actions.hpp	/^            struct result<This(Cont const &, Idx)>$/;"	s	struct:boost::xpressive::op::at	access:public
boost::xpressive::op::at::result	xpressive/regex_actions.hpp	/^            struct result<This(Cont, Idx)>$/;"	s	struct:boost::xpressive::op::at	access:public
boost::xpressive::op::at::result::type	xpressive/regex_actions.hpp	/^                typedef typename Cont::const_reference type;$/;"	t	struct:boost::xpressive::op::at::result	access:public
boost::xpressive::op::at::result::type	xpressive/regex_actions.hpp	/^                typedef typename Cont::reference type;$/;"	t	struct:boost::xpressive::op::at::result	access:public
boost::xpressive::op::back	xpressive/regex_actions.hpp	/^        struct back$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::back::operator ()	xpressive/regex_actions.hpp	/^            typename result<back(Sequence &)>::type operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::back	access:public	signature:(Sequence &seq) const
boost::xpressive::op::back::result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::back	access:public
boost::xpressive::op::back::result	xpressive/regex_actions.hpp	/^            struct result<This(Sequence)>$/;"	s	struct:boost::xpressive::op::back	access:public
boost::xpressive::op::back::result::sequence_type	xpressive/regex_actions.hpp	/^                typedef typename remove_reference<Sequence>::type sequence_type;$/;"	t	struct:boost::xpressive::op::back::result	access:public
boost::xpressive::op::back::result::type	xpressive/regex_actions.hpp	/^                type;$/;"	t	struct:boost::xpressive::op::back::result	access:public
boost::xpressive::op::const_cast_	xpressive/regex_actions.hpp	/^        struct const_cast_$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::const_cast_::operator ()	xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::const_cast_	access:public	signature:(Value const &val) const
boost::xpressive::op::const_cast_::result_type	xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::const_cast_	access:public
boost::xpressive::op::construct	xpressive/regex_actions.hpp	/^        struct construct$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::construct::operator ()	xpressive/regex_actions.hpp	/^            T operator()() const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:() const
boost::xpressive::op::construct::operator ()	xpressive/regex_actions.hpp	/^            T operator()(A0 const &a0) const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:(A0 const &a0) const
boost::xpressive::op::construct::operator ()	xpressive/regex_actions.hpp	/^            T operator()(A0 const &a0, A1 const &a1) const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:(A0 const &a0, A1 const &a1) const
boost::xpressive::op::construct::operator ()	xpressive/regex_actions.hpp	/^            T operator()(A0 const &a0, A1 const &a1, A2 const &a2) const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:(A0 const &a0, A1 const &a1, A2 const &a2) const
boost::xpressive::op::construct::result_type	xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::construct	access:public
boost::xpressive::op::dynamic_cast_	xpressive/regex_actions.hpp	/^        struct dynamic_cast_$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::dynamic_cast_::operator ()	xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::dynamic_cast_	access:public	signature:(Value const &val) const
boost::xpressive::op::dynamic_cast_::result_type	xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::dynamic_cast_	access:public
boost::xpressive::op::first	xpressive/regex_actions.hpp	/^        struct first$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::first::operator ()	xpressive/regex_actions.hpp	/^            typename Pair::first_type operator()(Pair const &p) const$/;"	f	struct:boost::xpressive::op::first	access:public	signature:(Pair const &p) const
boost::xpressive::op::first::result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::first	access:public
boost::xpressive::op::first::result	xpressive/regex_actions.hpp	/^            struct result<This(Pair)>$/;"	s	struct:boost::xpressive::op::first	access:public
boost::xpressive::op::first::result::type	xpressive/regex_actions.hpp	/^                typedef typename remove_reference<Pair>::type::first_type type;$/;"	t	struct:boost::xpressive::op::first::result	access:public
boost::xpressive::op::front	xpressive/regex_actions.hpp	/^        struct front$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::front::operator ()	xpressive/regex_actions.hpp	/^            typename result<front(Sequence &)>::type operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::front	access:public	signature:(Sequence &seq) const
boost::xpressive::op::front::result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::front	access:public
boost::xpressive::op::front::result	xpressive/regex_actions.hpp	/^            struct result<This(Sequence)>$/;"	s	struct:boost::xpressive::op::front	access:public
boost::xpressive::op::front::result::sequence_type	xpressive/regex_actions.hpp	/^                typedef typename remove_reference<Sequence>::type sequence_type;$/;"	t	struct:boost::xpressive::op::front::result	access:public
boost::xpressive::op::front::result::type	xpressive/regex_actions.hpp	/^                type;$/;"	t	struct:boost::xpressive::op::front::result	access:public
boost::xpressive::op::insert	xpressive/regex_actions.hpp	/^        struct insert$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::insert::detail	xpressive/regex_actions.hpp	/^            struct detail$/;"	s	struct:boost::xpressive::op::insert	access:public
boost::xpressive::op::insert::detail::result_detail	xpressive/regex_actions.hpp	/^                struct result_detail$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
boost::xpressive::op::insert::detail::result_detail	xpressive/regex_actions.hpp	/^                struct result_detail<This(Cont, It, It), void>$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
boost::xpressive::op::insert::detail::result_detail	xpressive/regex_actions.hpp	/^                struct result_detail<This(Cont, It, Size, Value),$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
boost::xpressive::op::insert::detail::result_detail	xpressive/regex_actions.hpp	/^                struct result_detail<This(Cont, It, Value),$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
boost::xpressive::op::insert::detail::result_detail	xpressive/regex_actions.hpp	/^                struct result_detail<This(Cont, Pos0, String, Pos1, Length)>$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
boost::xpressive::op::insert::detail::result_detail	xpressive/regex_actions.hpp	/^                struct result_detail<This(Cont, Size, A0, A1),$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
boost::xpressive::op::insert::detail::result_detail	xpressive/regex_actions.hpp	/^                struct result_detail<This(Cont, Size, T),$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
boost::xpressive::op::insert::detail::result_detail	xpressive/regex_actions.hpp	/^                struct result_detail<This(Cont, Value), void>$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
boost::xpressive::op::insert::detail::result_detail::BOOST_STATIC_CONSTANT	xpressive/regex_actions.hpp	/^                    BOOST_STATIC_CONSTANT(bool, is_iterator = (sizeof(yes_type) == sizeof(check_insert_return(scont_.insert(svalue_)))));$/;"	p	struct:boost::xpressive::op::insert::detail::result_detail	access:public	signature:(bool, is_iterator = (sizeof(yes_type) == sizeof(check_insert_return(scont_.insert(svalue_)))))
boost::xpressive::op::insert::detail::result_detail::check_insert_return	xpressive/regex_actions.hpp	/^                    static no_type check_insert_return(std::pair<typename cont_type::iterator, bool>);$/;"	p	struct:boost::xpressive::op::insert::detail::result_detail	access:public	signature:(std::pair<typename cont_type::iterator, bool>)
boost::xpressive::op::insert::detail::result_detail::check_insert_return	xpressive/regex_actions.hpp	/^                    static yes_type check_insert_return(typename cont_type::iterator);$/;"	p	struct:boost::xpressive::op::insert::detail::result_detail	access:public	signature:(typename cont_type::iterator)
boost::xpressive::op::insert::detail::result_detail::cont_type	xpressive/regex_actions.hpp	/^                    typedef typename remove_reference<Cont>::type cont_type;$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
boost::xpressive::op::insert::detail::result_detail::no_type	xpressive/regex_actions.hpp	/^                    typedef char (&no_type)[2];$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
boost::xpressive::op::insert::detail::result_detail::scont_	xpressive/regex_actions.hpp	/^                    static cont_type &scont_;$/;"	m	struct:boost::xpressive::op::insert::detail::result_detail	access:public
boost::xpressive::op::insert::detail::result_detail::svalue_	xpressive/regex_actions.hpp	/^                    static value_type &svalue_;$/;"	m	struct:boost::xpressive::op::insert::detail::result_detail	access:public
boost::xpressive::op::insert::detail::result_detail::type	xpressive/regex_actions.hpp	/^                    type;$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
boost::xpressive::op::insert::detail::result_detail::type	xpressive/regex_actions.hpp	/^                    typedef typename remove_reference<Cont>::type &type;$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
boost::xpressive::op::insert::detail::result_detail::type	xpressive/regex_actions.hpp	/^                    typedef typename remove_reference<Cont>::type::iterator type;$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
boost::xpressive::op::insert::detail::result_detail::type	xpressive/regex_actions.hpp	/^                    typedef void type;$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
boost::xpressive::op::insert::detail::result_detail::value_type	xpressive/regex_actions.hpp	/^                    typedef typename remove_reference<Value>::type value_type;$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
boost::xpressive::op::insert::detail::result_detail::yes_type	xpressive/regex_actions.hpp	/^                    typedef char yes_type;$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
boost::xpressive::op::insert::operator ()	xpressive/regex_actions.hpp	/^            operator()(Cont &cont, A0 const &a0) const$/;"	f	struct:boost::xpressive::op::insert	access:public	signature:(Cont &cont, A0 const &a0) const
boost::xpressive::op::insert::operator ()	xpressive/regex_actions.hpp	/^            operator()(Cont &cont, A0 const &a0, A1 const &a1) const$/;"	f	struct:boost::xpressive::op::insert	access:public	signature:(Cont &cont, A0 const &a0, A1 const &a1) const
boost::xpressive::op::insert::operator ()	xpressive/regex_actions.hpp	/^            operator()(Cont &cont, A0 const &a0, A1 const &a1, A2 const &a2) const$/;"	f	struct:boost::xpressive::op::insert	access:public	signature:(Cont &cont, A0 const &a0, A1 const &a1, A2 const &a2) const
boost::xpressive::op::insert::operator ()	xpressive/regex_actions.hpp	/^            operator()(Cont &cont, A0 const &a0, A1 const &a1, A2 const &a2, A3 const &a3) const$/;"	f	struct:boost::xpressive::op::insert	access:public	signature:(Cont &cont, A0 const &a0, A1 const &a1, A2 const &a2, A3 const &a3) const
boost::xpressive::op::insert::result	xpressive/regex_actions.hpp	/^            struct result$/;"	s	struct:boost::xpressive::op::insert	access:public
boost::xpressive::op::insert::result::type	xpressive/regex_actions.hpp	/^                typedef typename detail::result_detail<Sig>::type type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
boost::xpressive::op::length	xpressive/regex_actions.hpp	/^        struct length$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::length::operator ()	xpressive/regex_actions.hpp	/^            typename Sub::difference_type operator()(Sub const &sub) const$/;"	f	struct:boost::xpressive::op::length	access:public	signature:(Sub const &sub) const
boost::xpressive::op::length::result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::length	access:public
boost::xpressive::op::length::result	xpressive/regex_actions.hpp	/^            struct result<This(Sub)>$/;"	s	struct:boost::xpressive::op::length	access:public
boost::xpressive::op::length::result::type	xpressive/regex_actions.hpp	/^                typedef typename remove_reference<Sub>::type::difference_type type;$/;"	t	struct:boost::xpressive::op::length::result	access:public
boost::xpressive::op::make_pair	xpressive/regex_actions.hpp	/^        struct make_pair$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::make_pair::operator ()	xpressive/regex_actions.hpp	/^            std::pair<First, Second> operator()(First const &first, Second const &second) const$/;"	f	struct:boost::xpressive::op::make_pair	access:public	signature:(First const &first, Second const &second) const
boost::xpressive::op::make_pair::result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::make_pair	access:public
boost::xpressive::op::make_pair::result	xpressive/regex_actions.hpp	/^            struct result<This(First, Second)>$/;"	s	struct:boost::xpressive::op::make_pair	access:public
boost::xpressive::op::make_pair::result::first_type	xpressive/regex_actions.hpp	/^                typedef typename decay<First>::type first_type;$/;"	t	struct:boost::xpressive::op::make_pair::result	access:public
boost::xpressive::op::make_pair::result::second_type	xpressive/regex_actions.hpp	/^                typedef typename decay<Second>::type second_type;$/;"	t	struct:boost::xpressive::op::make_pair::result	access:public
boost::xpressive::op::make_pair::result::type	xpressive/regex_actions.hpp	/^                typedef std::pair<first_type, second_type> type;$/;"	t	struct:boost::xpressive::op::make_pair::result	access:public
boost::xpressive::op::matched	xpressive/regex_actions.hpp	/^        struct matched$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::matched::operator ()	xpressive/regex_actions.hpp	/^            bool operator()(Sub const &sub) const$/;"	f	struct:boost::xpressive::op::matched	access:public	signature:(Sub const &sub) const
boost::xpressive::op::matched::result_type	xpressive/regex_actions.hpp	/^            typedef bool result_type;$/;"	t	struct:boost::xpressive::op::matched	access:public
boost::xpressive::op::pop	xpressive/regex_actions.hpp	/^        struct pop$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::pop::operator ()	xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::pop	access:public	signature:(Sequence &seq) const
boost::xpressive::op::pop::result_type	xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::pop	access:public
boost::xpressive::op::pop_back	xpressive/regex_actions.hpp	/^        struct pop_back$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::pop_back::operator ()	xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::pop_back	access:public	signature:(Sequence &seq) const
boost::xpressive::op::pop_back::result_type	xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::pop_back	access:public
boost::xpressive::op::pop_front	xpressive/regex_actions.hpp	/^        struct pop_front$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::pop_front::operator ()	xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::pop_front	access:public	signature:(Sequence &seq) const
boost::xpressive::op::pop_front::result_type	xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::pop_front	access:public
boost::xpressive::op::push	xpressive/regex_actions.hpp	/^        struct push$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::push::operator ()	xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq, Value const &val) const$/;"	f	struct:boost::xpressive::op::push	access:public	signature:(Sequence &seq, Value const &val) const
boost::xpressive::op::push::result_type	xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::push	access:public
boost::xpressive::op::push_back	xpressive/regex_actions.hpp	/^        struct push_back$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::push_back::operator ()	xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq, Value const &val) const$/;"	f	struct:boost::xpressive::op::push_back	access:public	signature:(Sequence &seq, Value const &val) const
boost::xpressive::op::push_back::result_type	xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::push_back	access:public
boost::xpressive::op::push_front	xpressive/regex_actions.hpp	/^        struct push_front$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::push_front::operator ()	xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq, Value const &val) const$/;"	f	struct:boost::xpressive::op::push_front	access:public	signature:(Sequence &seq, Value const &val) const
boost::xpressive::op::push_front::result_type	xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::push_front	access:public
boost::xpressive::op::second	xpressive/regex_actions.hpp	/^        struct second$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::second::operator ()	xpressive/regex_actions.hpp	/^            typename Pair::second_type operator()(Pair const &p) const$/;"	f	struct:boost::xpressive::op::second	access:public	signature:(Pair const &p) const
boost::xpressive::op::second::result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::second	access:public
boost::xpressive::op::second::result	xpressive/regex_actions.hpp	/^            struct result<This(Pair)>$/;"	s	struct:boost::xpressive::op::second	access:public
boost::xpressive::op::second::result::type	xpressive/regex_actions.hpp	/^                typedef typename remove_reference<Pair>::type::second_type type;$/;"	t	struct:boost::xpressive::op::second::result	access:public
boost::xpressive::op::static_cast_	xpressive/regex_actions.hpp	/^        struct static_cast_$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::static_cast_::operator ()	xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::static_cast_	access:public	signature:(Value const &val) const
boost::xpressive::op::static_cast_::result_type	xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::static_cast_	access:public
boost::xpressive::op::str	xpressive/regex_actions.hpp	/^        struct str$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::str::operator ()	xpressive/regex_actions.hpp	/^            typename Sub::string_type operator()(Sub const &sub) const$/;"	f	struct:boost::xpressive::op::str	access:public	signature:(Sub const &sub) const
boost::xpressive::op::str::result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::str	access:public
boost::xpressive::op::str::result	xpressive/regex_actions.hpp	/^            struct result<This(Sub)>$/;"	s	struct:boost::xpressive::op::str	access:public
boost::xpressive::op::str::result::type	xpressive/regex_actions.hpp	/^                typedef typename remove_reference<Sub>::type::string_type type;$/;"	t	struct:boost::xpressive::op::str::result	access:public
boost::xpressive::op::throw_	xpressive/regex_actions.hpp	/^        struct throw_$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::throw_::operator ()	xpressive/regex_actions.hpp	/^            void operator()() const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:() const
boost::xpressive::op::throw_::operator ()	xpressive/regex_actions.hpp	/^            void operator()(A0 const &a0) const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:(A0 const &a0) const
boost::xpressive::op::throw_::operator ()	xpressive/regex_actions.hpp	/^            void operator()(A0 const &a0, A1 const &a1) const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:(A0 const &a0, A1 const &a1) const
boost::xpressive::op::throw_::operator ()	xpressive/regex_actions.hpp	/^            void operator()(A0 const &a0, A1 const &a1, A2 const &a2) const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:(A0 const &a0, A1 const &a1, A2 const &a2) const
boost::xpressive::op::throw_::result_type	xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::throw_	access:public
boost::xpressive::op::top	xpressive/regex_actions.hpp	/^        struct top$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::top::operator ()	xpressive/regex_actions.hpp	/^            typename result<top(Sequence &)>::type operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::top	access:public	signature:(Sequence &seq) const
boost::xpressive::op::top::result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::top	access:public
boost::xpressive::op::top::result	xpressive/regex_actions.hpp	/^            struct result<This(Sequence)>$/;"	s	struct:boost::xpressive::op::top	access:public
boost::xpressive::op::top::result::sequence_type	xpressive/regex_actions.hpp	/^                typedef typename remove_reference<Sequence>::type sequence_type;$/;"	t	struct:boost::xpressive::op::top::result	access:public
boost::xpressive::op::top::result::type	xpressive/regex_actions.hpp	/^                type;$/;"	t	struct:boost::xpressive::op::top::result	access:public
boost::xpressive::op::unwrap_reference	xpressive/regex_actions.hpp	/^        struct unwrap_reference$/;"	s	namespace:boost::xpressive::op
boost::xpressive::op::unwrap_reference::operator ()	xpressive/regex_actions.hpp	/^            T &operator()(boost::reference_wrapper<T> r) const$/;"	f	struct:boost::xpressive::op::unwrap_reference	access:public	signature:(boost::reference_wrapper<T> r) const
boost::xpressive::op::unwrap_reference::result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::unwrap_reference	access:public
boost::xpressive::op::unwrap_reference::result	xpressive/regex_actions.hpp	/^            struct result<This(Ref &)>$/;"	s	struct:boost::xpressive::op::unwrap_reference	access:public
boost::xpressive::op::unwrap_reference::result	xpressive/regex_actions.hpp	/^            struct result<This(Ref)>$/;"	s	struct:boost::xpressive::op::unwrap_reference	access:public
boost::xpressive::op::unwrap_reference::result::type	xpressive/regex_actions.hpp	/^                typedef typename boost::unwrap_reference<Ref>::type &type;$/;"	t	struct:boost::xpressive::op::unwrap_reference::result	access:public
boost::xpressive::operator !=	xpressive/sub_match.hpp	/^bool operator != (sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator !=	xpressive/sub_match.hpp	/^bool operator != (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)
boost::xpressive::operator !=	xpressive/sub_match.hpp	/^bool operator != (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)
boost::xpressive::operator !=	xpressive/sub_match.hpp	/^bool operator != (typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator !=	xpressive/sub_match.hpp	/^bool operator != (typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator +	xpressive/sub_match.hpp	/^operator + (sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator +	xpressive/sub_match.hpp	/^operator + (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)
boost::xpressive::operator +	xpressive/sub_match.hpp	/^operator + (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)
boost::xpressive::operator +	xpressive/sub_match.hpp	/^operator + (sub_match<BidiIter> const &lhs, typename sub_match<BidiIter>::string_type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename sub_match<BidiIter>::string_type const &rhs)
boost::xpressive::operator +	xpressive/sub_match.hpp	/^operator + (typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator +	xpressive/sub_match.hpp	/^operator + (typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator +	xpressive/sub_match.hpp	/^operator + (typename sub_match<BidiIter>::string_type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename sub_match<BidiIter>::string_type const &lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator <	xpressive/sub_match.hpp	/^bool operator < (sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator <	xpressive/sub_match.hpp	/^bool operator < (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)
boost::xpressive::operator <	xpressive/sub_match.hpp	/^bool operator < (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)
boost::xpressive::operator <	xpressive/sub_match.hpp	/^bool operator < (typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator <	xpressive/sub_match.hpp	/^bool operator < (typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator <<	xpressive/sub_match.hpp	/^inline std::basic_ostream<Char, Traits> &operator <<$/;"	f	namespace:boost::xpressive	signature:( std::basic_ostream<Char, Traits> &sout , sub_match<BidiIter> const &sub )
boost::xpressive::operator <=	xpressive/sub_match.hpp	/^bool operator <= (sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator <=	xpressive/sub_match.hpp	/^bool operator <= (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)
boost::xpressive::operator <=	xpressive/sub_match.hpp	/^bool operator <= (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)
boost::xpressive::operator <=	xpressive/sub_match.hpp	/^bool operator <= (typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator <=	xpressive/sub_match.hpp	/^bool operator <= (typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator ==	xpressive/sub_match.hpp	/^bool operator == (sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator ==	xpressive/sub_match.hpp	/^bool operator == (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)
boost::xpressive::operator ==	xpressive/sub_match.hpp	/^bool operator == (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)
boost::xpressive::operator ==	xpressive/sub_match.hpp	/^bool operator == (typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator ==	xpressive/sub_match.hpp	/^bool operator == (typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator >	xpressive/sub_match.hpp	/^bool operator > (sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator >	xpressive/sub_match.hpp	/^bool operator > (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)
boost::xpressive::operator >	xpressive/sub_match.hpp	/^bool operator > (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)
boost::xpressive::operator >	xpressive/sub_match.hpp	/^bool operator > (typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator >	xpressive/sub_match.hpp	/^bool operator > (typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator >=	xpressive/sub_match.hpp	/^bool operator >= (sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator >=	xpressive/sub_match.hpp	/^bool operator >= (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)
boost::xpressive::operator >=	xpressive/sub_match.hpp	/^bool operator >= (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)
boost::xpressive::operator >=	xpressive/sub_match.hpp	/^bool operator >= (typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::operator >=	xpressive/sub_match.hpp	/^bool operator >= (typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)
boost::xpressive::placeholder	xpressive/regex_actions.hpp	/^    struct placeholder$/;"	s	namespace:boost::xpressive
boost::xpressive::placeholder::action_arg_type	xpressive/regex_actions.hpp	/^        action_arg_type;$/;"	t	struct:boost::xpressive::placeholder	access:public
boost::xpressive::placeholder::operator =	xpressive/regex_actions.hpp	/^        detail::unspecified operator=(T &t) const;$/;"	p	struct:boost::xpressive::placeholder	access:public	signature:(T &t) const
boost::xpressive::placeholder::operator =	xpressive/regex_actions.hpp	/^        detail::unspecified operator=(T const &t) const;$/;"	p	struct:boost::xpressive::placeholder	access:public	signature:(T const &t) const
boost::xpressive::placeholder::this_type	xpressive/regex_actions.hpp	/^        typedef placeholder<T, I, Dummy> this_type;$/;"	t	struct:boost::xpressive::placeholder	access:public
boost::xpressive::proto::functional::as_xpr	xpressive/regex_primitives.hpp	/^proto::functional::as_expr<> const as_xpr = {};$/;"	m	class:boost::xpressive::proto::functional
boost::xpressive::proto::result_of::make_expr::after	xpressive/regex_primitives.hpp	/^after(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
boost::xpressive::proto::result_of::make_expr::before	xpressive/regex_primitives.hpp	/^before(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
boost::xpressive::proto::result_of::make_expr::keep	xpressive/regex_primitives.hpp	/^keep(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
boost::xpressive::proto::result_of::make_expr::optional	xpressive/regex_primitives.hpp	/^optional(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
boost::xpressive::proto::result_of::make_expr::repeat	xpressive/regex_primitives.hpp	/^repeat(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
boost::xpressive::proto::result_of::make_expr::repeat	xpressive/regex_primitives.hpp	/^repeat(Expr2 const &expr2)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr2 const &expr2)
boost::xpressive::proto::terminal::_	xpressive/regex_primitives.hpp	/^proto::terminal<detail::any_matcher>::type const _ = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::_b	xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_word_boundary>::type const _b = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::_d	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const _d = {{"d", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::_n	xpressive/regex_primitives.hpp	/^proto::terminal<char>::type const _n = {'\\n'};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::_s	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const _s = {{"s", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::_w	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const _w = {{"w", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a1	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<1> > >::type const a1 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a2	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<2> > >::type const a2 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a3	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<3> > >::type const a3 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a4	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<4> > >::type const a4 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a5	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<5> > >::type const a5 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a6	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<6> > >::type const a6 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a7	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<7> > >::type const a7 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a8	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<8> > >::type const a8 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::a9	xpressive/regex_primitives.hpp	/^proto::terminal<detail::attribute_placeholder<mpl::int_<9> > >::type const a9 = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::alnum	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const alnum = {{"alnum", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::alpha	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const alpha = {{"alpha", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::blank	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const blank = {{"blank", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::bol	xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_bol_placeholder>::type const bol = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::bos	xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_bos_matcher>::type const bos = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::bow	xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_word_begin>::type const bow = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::by_ref	xpressive/regex_primitives.hpp	/^by_ref(basic_regex<BidiIter> const &rex)$/;"	f	class:boost::xpressive::proto::terminal	signature:(basic_regex<BidiIter> const &rex)
boost::xpressive::proto::terminal::check	xpressive/regex_actions.hpp	/^    proto::terminal<detail::check_tag>::type const check = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::cntrl	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const cntrl = {{"cntrl", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::digit	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const digit = {{"digit", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::eol	xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_eol_placeholder>::type const eol = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::eos	xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_eos_matcher>::type const eos = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::eow	xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_word_end>::type const eow = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::epsilon	xpressive/regex_primitives.hpp	/^proto::terminal<detail::epsilon_matcher>::type const epsilon = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::graph	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const graph = {{"graph", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::lower	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const lower = {{"lower", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::nil	xpressive/regex_primitives.hpp	/^proto::terminal<detail::epsilon_matcher>::type const nil = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::print	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const print = {{"print", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::punct	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const punct = {{"punct", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::range	xpressive/regex_primitives.hpp	/^range(Char ch_min, Char ch_max)$/;"	f	class:boost::xpressive::proto::terminal	signature:(Char ch_min, Char ch_max)
boost::xpressive::proto::terminal::self	xpressive/regex_primitives.hpp	/^proto::terminal<detail::self_placeholder>::type const self = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::space	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const space = {{"space", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::upper	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const upper = {{"upper", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::proto::terminal::xdigit	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const xdigit = {{"xdigit", false}};$/;"	m	class:boost::xpressive::proto::terminal
boost::xpressive::range_begin	xpressive/sub_match.hpp	/^inline BidiIter range_begin(sub_match<BidiIter> &sub)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> &sub)
boost::xpressive::range_begin	xpressive/sub_match.hpp	/^inline BidiIter range_begin(sub_match<BidiIter> const &sub)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &sub)
boost::xpressive::range_end	xpressive/sub_match.hpp	/^inline BidiIter range_end(sub_match<BidiIter> &sub)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> &sub)
boost::xpressive::range_end	xpressive/sub_match.hpp	/^inline BidiIter range_end(sub_match<BidiIter> const &sub)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &sub)
boost::xpressive::ref	xpressive/regex_actions.hpp	/^    reference<T> const ref(T &t)$/;"	f	namespace:boost::xpressive	signature:(T &t)
boost::xpressive::reference	xpressive/regex_actions.hpp	/^    struct reference$/;"	s	namespace:boost::xpressive	inherits:proto::extends
boost::xpressive::reference::base_type	xpressive/regex_actions.hpp	/^        typedef proto::extends<typename proto::terminal<reference_wrapper<T> >::type, reference<T> > base_type;$/;"	t	struct:boost::xpressive::reference	access:public
boost::xpressive::reference::get	xpressive/regex_actions.hpp	/^        T &get() const$/;"	f	struct:boost::xpressive::reference	access:public	signature:() const
boost::xpressive::reference::reference	xpressive/regex_actions.hpp	/^        explicit reference(T &t)$/;"	f	struct:boost::xpressive::reference	access:public	signature:(T &t)
boost::xpressive::regex_compiler	xpressive/regex_compiler.hpp	/^struct regex_compiler$/;"	s	namespace:boost::xpressive
boost::xpressive::regex_compiler::alternate_matcher	xpressive/regex_compiler.hpp	/^    typedef detail::alternate_matcher<detail::alternates_vector<BidiIter>, RegexTraits> alternate_matcher;$/;"	t	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_compiler::char_class_type	xpressive/regex_compiler.hpp	/^    typedef typename traits_type::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
boost::xpressive::regex_compiler::char_type	xpressive/regex_compiler.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
boost::xpressive::regex_compiler::compile	xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> compile(char_type const *begin, std::size_t size, flag_type flags)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(char_type const *begin, std::size_t size, flag_type flags)
boost::xpressive::regex_compiler::compile	xpressive/regex_compiler.hpp	/^    compile(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)
boost::xpressive::regex_compiler::compile	xpressive/regex_compiler.hpp	/^    compile(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)
boost::xpressive::regex_compiler::compile	xpressive/regex_compiler.hpp	/^    compile(char_type const *begin, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(char_type const *begin, flag_type flags = regex_constants::ECMAScript)
boost::xpressive::regex_compiler::compile_	xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> compile_(FwdIter begin, FwdIter end, flag_type flags, std::forward_iterator_tag)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter begin, FwdIter end, flag_type flags, std::forward_iterator_tag)
boost::xpressive::regex_compiler::compile_	xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> compile_(InputIter begin, InputIter end, flag_type flags, std::input_iterator_tag)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(InputIter begin, InputIter end, flag_type flags, std::input_iterator_tag)
boost::xpressive::regex_compiler::escape_value	xpressive/regex_compiler.hpp	/^    typedef detail::escape_value<char_type, char_class_type> escape_value;$/;"	t	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_compiler::flag_type	xpressive/regex_compiler.hpp	/^    typedef regex_constants::syntax_option_type flag_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
boost::xpressive::regex_compiler::getloc	xpressive/regex_compiler.hpp	/^    locale_type getloc() const$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:() const
boost::xpressive::regex_compiler::hidden_mark_count_	xpressive/regex_compiler.hpp	/^    std::size_t hidden_mark_count_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_compiler::imbue	xpressive/regex_compiler.hpp	/^    locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(locale_type loc)
boost::xpressive::regex_compiler::is_upper_	xpressive/regex_compiler.hpp	/^    bool is_upper_(char_type ch) const$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(char_type ch) const
boost::xpressive::regex_compiler::iterator_type	xpressive/regex_compiler.hpp	/^    typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
boost::xpressive::regex_compiler::locale_type	xpressive/regex_compiler.hpp	/^    typedef typename traits_type::locale_type locale_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
boost::xpressive::regex_compiler::mark_count_	xpressive/regex_compiler.hpp	/^    std::size_t mark_count_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_compiler::operator []	xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> &operator [](string_type const &name)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(string_type const &name)
boost::xpressive::regex_compiler::operator []	xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> const &operator [](string_type const &name) const$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(string_type const &name) const
boost::xpressive::regex_compiler::parse_alternates	xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_alternates(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_atom	xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_atom(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_charset	xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_charset(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_escape	xpressive/regex_compiler.hpp	/^    escape_value parse_escape(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_group	xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_group(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_literal	xpressive/regex_compiler.hpp	/^    string_type parse_literal(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_quant	xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_quant(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_quote_meta	xpressive/regex_compiler.hpp	/^    string_type parse_quote_meta(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::parse_sequence	xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_sequence(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
boost::xpressive::regex_compiler::regex_compiler	xpressive/regex_compiler.hpp	/^    explicit regex_compiler(RegexTraits const &traits = RegexTraits())$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(RegexTraits const &traits = RegexTraits())
boost::xpressive::regex_compiler::reset	xpressive/regex_compiler.hpp	/^    void reset()$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:()
boost::xpressive::regex_compiler::rules_	xpressive/regex_compiler.hpp	/^    std::map<string_type, basic_regex<BidiIter> > rules_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_compiler::rxtraits	xpressive/regex_compiler.hpp	/^    traits_type &rxtraits()$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:()
boost::xpressive::regex_compiler::rxtraits	xpressive/regex_compiler.hpp	/^    traits_type const &rxtraits() const$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:() const
boost::xpressive::regex_compiler::self_	xpressive/regex_compiler.hpp	/^    shared_ptr<detail::regex_impl<BidiIter> > self_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_compiler::string_type	xpressive/regex_compiler.hpp	/^    typedef typename traits_type::string_type string_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
boost::xpressive::regex_compiler::traits_	xpressive/regex_compiler.hpp	/^    CompilerTraits traits_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_compiler::traits_type	xpressive/regex_compiler.hpp	/^    typedef RegexTraits traits_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
boost::xpressive::regex_compiler::upper_	xpressive/regex_compiler.hpp	/^    typename RegexTraits::char_class_type upper_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
boost::xpressive::regex_constants	xpressive/detail/core/icase.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost::xpressive
boost::xpressive::regex_constants	xpressive/detail/dynamic/parser_enum.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost::xpressive
boost::xpressive::regex_constants	xpressive/regex_constants.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost::xpressive
boost::xpressive::regex_constants::ECMAScript	xpressive/regex_constants.hpp	/^    ECMAScript  = 0,        \/\/\/< Specifies that the grammar recognized by the regular expression$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::basic_regex::ECMAScript	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::ECMAScript;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::collate	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::collate;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::icase	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::icase;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::ignore_white_space	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::ignore_white_space;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::nosubs	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::nosubs;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::not_dot_newline	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::not_dot_newline;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::not_dot_null	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::not_dot_null;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::optimize	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::optimize;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::basic_regex::single_line	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::single_line;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
boost::xpressive::regex_constants::collate	xpressive/regex_constants.hpp	/^    collate     = 1 << 4,   \/\/\/< Specifies that character ranges of the form "[a-b]" should be$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::compiler_token_type	xpressive/detail/dynamic/parser_enum.hpp	/^enum compiler_token_type$/;"	g	namespace:boost::xpressive::regex_constants
boost::xpressive::regex_constants::detail::icase	xpressive/detail/core/icase.hpp	/^detail::modifier_op<detail::icase_modifier> const icase = {{}, regex_constants::icase_};$/;"	m	class:boost::xpressive::regex_constants::detail
boost::xpressive::regex_constants::error_badarg	xpressive/regex_constants.hpp	/^    error_badarg,               \/\/\/< An argument to an action was unbound.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_badattr	xpressive/regex_constants.hpp	/^    error_badattr,              \/\/\/< Tried to read from an uninitialized attribute.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_badbrace	xpressive/regex_constants.hpp	/^    error_badbrace,             \/\/\/< The expression contained an invalid range in a {} expression.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_badlookbehind	xpressive/regex_constants.hpp	/^    error_badlookbehind,        \/\/\/< An attempt to create a variable-width look-behind assertion$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_badmark	xpressive/regex_constants.hpp	/^    error_badmark,              \/\/\/< An invalid use of a named capture.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_badref	xpressive/regex_constants.hpp	/^    error_badref,               \/\/\/< An nested regex is uninitialized.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_badrepeat	xpressive/regex_constants.hpp	/^    error_badrepeat,            \/\/\/< One of *?+{ was not preceded by a valid regular expression.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_badrule	xpressive/regex_constants.hpp	/^    error_badrule,              \/\/\/< An invalid use of a rule was detected.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_brace	xpressive/regex_constants.hpp	/^    error_brace,                \/\/\/< The expression contained mismatched { and }.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_brack	xpressive/regex_constants.hpp	/^    error_brack,                \/\/\/< The expression contained mismatched [ and ].$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_collate	xpressive/regex_constants.hpp	/^    error_collate,              \/\/\/< The expression contained an invalid collating element name.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_complexity	xpressive/regex_constants.hpp	/^    error_complexity,           \/\/\/< The complexity of an attempted match against a regular$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_ctype	xpressive/regex_constants.hpp	/^    error_ctype,                \/\/\/< The expression contained an invalid character class name.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_escape	xpressive/regex_constants.hpp	/^    error_escape,               \/\/\/< The expression contained an invalid escaped character,$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_internal	xpressive/regex_constants.hpp	/^    error_internal              \/\/\/< An internal error has occurred.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_paren	xpressive/regex_constants.hpp	/^    error_paren,                \/\/\/< The expression contained mismatched ( and ).$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_range	xpressive/regex_constants.hpp	/^    error_range,                \/\/\/< The expression contained an invalid character range, for$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_space	xpressive/regex_constants.hpp	/^    error_space,                \/\/\/< There was insufficient memory to convert the expression into a$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_stack	xpressive/regex_constants.hpp	/^    error_stack,                \/\/\/< There was insufficient memory to determine whether the regular$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_subreg	xpressive/regex_constants.hpp	/^    error_subreg,               \/\/\/< The expression contained an invalid back-reference.$/;"	e	enum:boost::xpressive::regex_constants::error_type
boost::xpressive::regex_constants::error_type	xpressive/regex_constants.hpp	/^enum error_type$/;"	g	namespace:boost::xpressive::regex_constants
boost::xpressive::regex_constants::format_all	xpressive/regex_constants.hpp	/^    format_all              = 1 << 18   \/\/\/< Specifies that all syntax extensions are enabled,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::format_default	xpressive/regex_constants.hpp	/^    format_default          = 0,        \/\/\/< Specifies that when a regular expression match is to be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::format_first_only	xpressive/regex_constants.hpp	/^    format_first_only       = 1 << 16,  \/\/\/< When specified during a search and replace operation,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::format_literal	xpressive/regex_constants.hpp	/^    format_literal          = 1 << 17,  \/\/\/< Treat the format string as a literal.$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::format_no_copy	xpressive/regex_constants.hpp	/^    format_no_copy          = 1 << 15,  \/\/\/< When specified during a search and replace operation,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::format_perl	xpressive/regex_constants.hpp	/^    format_perl             = 1 << 14,  \/\/\/< Specifies that when a regular expression match is to be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::format_sed	xpressive/regex_constants.hpp	/^    format_sed              = 1 << 13,  \/\/\/< Specifies that when a regular expression match is to be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::icase	xpressive/regex_constants.hpp	/^    icase       = 1 << 1,   \/\/\/< Specifies that matching of regular expressions against a character$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::ignore_white_space	xpressive/regex_constants.hpp	/^    ignore_white_space  = 1 << 13   \/\/\/< Specifies that non-escaped white-space is not significant.$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::match_any	xpressive/regex_constants.hpp	/^    match_any               = 1 << 7,   \/\/\/< Specifies that if more than one match is possible then$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_continuous	xpressive/regex_constants.hpp	/^    match_continuous        = 1 << 10,  \/\/\/< Specifies that the expression must match a sub-sequence$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_default	xpressive/regex_constants.hpp	/^    match_default           = 0,        \/\/\/< Specifies that matching of regular expressions proceeds$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_flag_type	xpressive/regex_constants.hpp	/^enum match_flag_type$/;"	g	namespace:boost::xpressive::regex_constants
boost::xpressive::regex_constants::match_not_bol	xpressive/regex_constants.hpp	/^    match_not_bol           = 1 << 1,   \/\/\/< Specifies that the expression "^" should not be matched$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_not_bow	xpressive/regex_constants.hpp	/^    match_not_bow           = 1 << 3,   \/\/\/< Specifies that the expression "\\\\b" should not be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_not_eol	xpressive/regex_constants.hpp	/^    match_not_eol           = 1 << 2,   \/\/\/< Specifies that the expression "\\$" should not be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_not_eow	xpressive/regex_constants.hpp	/^    match_not_eow           = 1 << 4,   \/\/\/< Specifies that the expression "\\\\b" should not be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_not_null	xpressive/regex_constants.hpp	/^    match_not_null          = 1 << 8,   \/\/\/< Specifies that the expression can not be matched$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_partial	xpressive/regex_constants.hpp	/^    match_partial           = 1 << 11,  \/\/\/< Specifies that if no match can be found, then it is$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::match_prev_avail	xpressive/regex_constants.hpp	/^    match_prev_avail        = 1 << 12,  \/\/\/< Specifies that --first is a valid iterator position,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
boost::xpressive::regex_constants::nosubs	xpressive/regex_constants.hpp	/^    nosubs      = 1 << 2,   \/\/\/< Specifies that when a regular expression is matched against a$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::not_dot_newline	xpressive/regex_constants.hpp	/^    not_dot_newline     = 1 << 12,  \/\/\/< Specifies that the . metacharacter does not match the$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::not_dot_null	xpressive/regex_constants.hpp	/^    not_dot_null        = 1 << 11,  \/\/\/< Specifies that the . metacharacter does not match the null$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::operator &	xpressive/regex_constants.hpp	/^inline match_flag_type operator &(match_flag_type b1, match_flag_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b1, match_flag_type b2)
boost::xpressive::regex_constants::operator &	xpressive/regex_constants.hpp	/^inline syntax_option_type operator &(syntax_option_type b1, syntax_option_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b1, syntax_option_type b2)
boost::xpressive::regex_constants::operator ^	xpressive/regex_constants.hpp	/^inline match_flag_type operator ^(match_flag_type b1, match_flag_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b1, match_flag_type b2)
boost::xpressive::regex_constants::operator ^	xpressive/regex_constants.hpp	/^inline syntax_option_type operator ^(syntax_option_type b1, syntax_option_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b1, syntax_option_type b2)
boost::xpressive::regex_constants::operator |	xpressive/regex_constants.hpp	/^inline match_flag_type operator |(match_flag_type b1, match_flag_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b1, match_flag_type b2)
boost::xpressive::regex_constants::operator |	xpressive/regex_constants.hpp	/^inline syntax_option_type operator |(syntax_option_type b1, syntax_option_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b1, syntax_option_type b2)
boost::xpressive::regex_constants::operator ~	xpressive/regex_constants.hpp	/^inline match_flag_type operator ~(match_flag_type b)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b)
boost::xpressive::regex_constants::operator ~	xpressive/regex_constants.hpp	/^inline syntax_option_type operator ~(syntax_option_type b)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b)
boost::xpressive::regex_constants::optimize	xpressive/regex_constants.hpp	/^    optimize    = 1 << 3,   \/\/\/< Specifies that the regular expression engine should pay more$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::single_line	xpressive/regex_constants.hpp	/^    single_line         = 1 << 10,  \/\/\/< Specifies that the ^ and \\$ metacharacters DO NOT match at$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
boost::xpressive::regex_constants::syntax_option_type	xpressive/regex_constants.hpp	/^enum syntax_option_type$/;"	g	namespace:boost::xpressive::regex_constants
boost::xpressive::regex_constants::token_alternate	xpressive/detail/dynamic/parser_enum.hpp	/^    token_alternate,                    \/\/ |$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_any	xpressive/detail/dynamic/parser_enum.hpp	/^    token_any,                          \/\/ .$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_assert_begin_line	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_begin_line,            \/\/ ^$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_assert_begin_sequence	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_begin_sequence,        \/\/ \\A$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_assert_end_line	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_end_line,              \/\/ \$$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_assert_end_sequence	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_end_sequence,          \/\/ \\Z$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_assert_not_word_boundary	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_not_word_boundary,     \/\/ \\B$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_assert_word_begin	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_word_begin,            \/\/ \\<$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_assert_word_boundary	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_word_boundary,         \/\/ \\b$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_assert_word_end	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_word_end,              \/\/ \\>$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_charset_backspace	xpressive/detail/dynamic/parser_enum.hpp	/^    token_charset_backspace,            \/\/ \\b$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_charset_begin	xpressive/detail/dynamic/parser_enum.hpp	/^    token_charset_begin,                \/\/ [$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_charset_end	xpressive/detail/dynamic/parser_enum.hpp	/^    token_charset_end,                  \/\/ ]$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_charset_hyphen	xpressive/detail/dynamic/parser_enum.hpp	/^    token_charset_hyphen,               \/\/ -$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_charset_invert	xpressive/detail/dynamic/parser_enum.hpp	/^    token_charset_invert,               \/\/ ^$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_collation_element_begin	xpressive/detail/dynamic/parser_enum.hpp	/^    token_collation_element_begin,      \/\/ [.$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_collation_element_end	xpressive/detail/dynamic/parser_enum.hpp	/^    token_collation_element_end,        \/\/ .]$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_comment	xpressive/detail/dynamic/parser_enum.hpp	/^    token_comment,                      \/\/ ?#$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_end_of_pattern	xpressive/detail/dynamic/parser_enum.hpp	/^    token_end_of_pattern$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_equivalence_class_begin	xpressive/detail/dynamic/parser_enum.hpp	/^    token_equivalence_class_begin,      \/\/ [=$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_equivalence_class_end	xpressive/detail/dynamic/parser_enum.hpp	/^    token_equivalence_class_end,        \/\/ =]$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_escape	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape,                       \/\/$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_escape_bell	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape_bell,                  \/\/ \\a$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_escape_control	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape_control,               \/\/ \\c$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_escape_escape	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape_escape,                \/\/ \\e$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_escape_formfeed	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape_formfeed,              \/\/ \\f$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_escape_horizontal_tab	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape_horizontal_tab,        \/\/ \\t$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_escape_newline	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape_newline,               \/\/ \\n$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_escape_vertical_tab	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape_vertical_tab,          \/\/ \\v$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_group_begin	xpressive/detail/dynamic/parser_enum.hpp	/^    token_group_begin,                  \/\/ ($/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_group_end	xpressive/detail/dynamic/parser_enum.hpp	/^    token_group_end,                    \/\/ )$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_independent_sub_expression	xpressive/detail/dynamic/parser_enum.hpp	/^    token_independent_sub_expression,   \/\/ ?>$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_invalid_quantifier	xpressive/detail/dynamic/parser_enum.hpp	/^    token_invalid_quantifier,           \/\/ {$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_literal	xpressive/detail/dynamic/parser_enum.hpp	/^    token_literal,$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_named_mark	xpressive/detail/dynamic/parser_enum.hpp	/^    token_named_mark,                   \/\/ ?P<name>$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_named_mark_ref	xpressive/detail/dynamic/parser_enum.hpp	/^    token_named_mark_ref,               \/\/ ?P=name$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_negative_lookahead	xpressive/detail/dynamic/parser_enum.hpp	/^    token_negative_lookahead,           \/\/ ?!$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_negative_lookbehind	xpressive/detail/dynamic/parser_enum.hpp	/^    token_negative_lookbehind,          \/\/ ?<!$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_no_mark	xpressive/detail/dynamic/parser_enum.hpp	/^    token_no_mark,                      \/\/ ?:$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_positive_lookahead	xpressive/detail/dynamic/parser_enum.hpp	/^    token_positive_lookahead,           \/\/ ?=$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_positive_lookbehind	xpressive/detail/dynamic/parser_enum.hpp	/^    token_positive_lookbehind,          \/\/ ?<=$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_posix_charset_begin	xpressive/detail/dynamic/parser_enum.hpp	/^    token_posix_charset_begin,          \/\/ [:$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_posix_charset_end	xpressive/detail/dynamic/parser_enum.hpp	/^    token_posix_charset_end,            \/\/ :]$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_quote_meta_begin	xpressive/detail/dynamic/parser_enum.hpp	/^    token_quote_meta_begin,             \/\/ \\Q$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_quote_meta_end	xpressive/detail/dynamic/parser_enum.hpp	/^    token_quote_meta_end,               \/\/ \\E$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_recurse	xpressive/detail/dynamic/parser_enum.hpp	/^    token_recurse,                      \/\/ ?R$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_rule_assign	xpressive/detail/dynamic/parser_enum.hpp	/^    token_rule_assign,                  \/\/ ?$[name]=$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_constants::token_rule_ref	xpressive/detail/dynamic/parser_enum.hpp	/^    token_rule_ref,                     \/\/ ?$[name]$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
boost::xpressive::regex_error	xpressive/regex_error.hpp	/^struct regex_error$/;"	s	namespace:boost::xpressive	inherits:std::runtime_error,boost::exception
boost::xpressive::regex_error::code	xpressive/regex_error.hpp	/^    regex_constants::error_type code() const$/;"	f	struct:boost::xpressive::regex_error	access:public	signature:() const
boost::xpressive::regex_error::code_	xpressive/regex_error.hpp	/^    regex_constants::error_type code_;$/;"	m	struct:boost::xpressive::regex_error	access:private
boost::xpressive::regex_error::regex_error	xpressive/regex_error.hpp	/^    explicit regex_error(regex_constants::error_type code, char const *str = "")$/;"	f	struct:boost::xpressive::regex_error	access:public	signature:(regex_constants::error_type code, char const *str = )
boost::xpressive::regex_error::~regex_error	xpressive/regex_error.hpp	/^    virtual ~regex_error() throw()$/;"	f	struct:boost::xpressive::regex_error	access:public	signature:()
boost::xpressive::regex_id_filter_predicate	xpressive/match_results.hpp	/^struct regex_id_filter_predicate$/;"	s	namespace:boost::xpressive	inherits:std::unary_function
boost::xpressive::regex_id_filter_predicate::operator ()	xpressive/match_results.hpp	/^    bool operator ()(match_results<BidiIter> const &res) const$/;"	f	struct:boost::xpressive::regex_id_filter_predicate	access:public	signature:(match_results<BidiIter> const &res) const
boost::xpressive::regex_id_filter_predicate::regex_id_	xpressive/match_results.hpp	/^    regex_id_type regex_id_;$/;"	m	struct:boost::xpressive::regex_id_filter_predicate	access:private
boost::xpressive::regex_id_filter_predicate::regex_id_filter_predicate	xpressive/match_results.hpp	/^    regex_id_filter_predicate(regex_id_type regex_id)$/;"	f	struct:boost::xpressive::regex_id_filter_predicate	access:public	signature:(regex_id_type regex_id)
boost::xpressive::regex_id_type	xpressive/xpressive_fwd.hpp	/^    typedef void const *regex_id_type;$/;"	t	namespace:boost::xpressive
boost::xpressive::regex_iterator	xpressive/regex_iterator.hpp	/^struct regex_iterator$/;"	s	namespace:boost::xpressive
boost::xpressive::regex_iterator::difference_type	xpressive/regex_iterator.hpp	/^    typedef typename iterator_difference<BidiIter>::type difference_type;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
boost::xpressive::regex_iterator::fork_	xpressive/regex_iterator.hpp	/^    void fork_()$/;"	f	struct:boost::xpressive::regex_iterator	access:private	signature:()
boost::xpressive::regex_iterator::impl_	xpressive/regex_iterator.hpp	/^    intrusive_ptr<impl_type_> impl_;$/;"	m	struct:boost::xpressive::regex_iterator	access:private
boost::xpressive::regex_iterator::impl_type_	xpressive/regex_iterator.hpp	/^    typedef detail::regex_iterator_impl<BidiIter> impl_type_;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
boost::xpressive::regex_iterator::iterator_category	xpressive/regex_iterator.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
boost::xpressive::regex_iterator::next_	xpressive/regex_iterator.hpp	/^    void next_()$/;"	f	struct:boost::xpressive::regex_iterator	access:private	signature:()
boost::xpressive::regex_iterator::operator !=	xpressive/regex_iterator.hpp	/^    friend bool operator !=(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_iterator	access:friend	signature:(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)
boost::xpressive::regex_iterator::operator *	xpressive/regex_iterator.hpp	/^    value_type const &operator *() const$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:() const
boost::xpressive::regex_iterator::operator ++	xpressive/regex_iterator.hpp	/^    regex_iterator<BidiIter> &operator ++()$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:()
boost::xpressive::regex_iterator::operator ++	xpressive/regex_iterator.hpp	/^    regex_iterator<BidiIter> operator ++(int)$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:(int)
boost::xpressive::regex_iterator::operator ->	xpressive/regex_iterator.hpp	/^    value_type const *operator ->() const$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:() const
boost::xpressive::regex_iterator::operator =	xpressive/regex_iterator.hpp	/^    regex_iterator<BidiIter> &operator =(regex_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:(regex_iterator<BidiIter> const &that)
boost::xpressive::regex_iterator::operator ==	xpressive/regex_iterator.hpp	/^    friend bool operator ==(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_iterator	access:friend	signature:(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)
boost::xpressive::regex_iterator::pointer	xpressive/regex_iterator.hpp	/^    typedef value_type const *pointer;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
boost::xpressive::regex_iterator::reference	xpressive/regex_iterator.hpp	/^    typedef value_type const &reference;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
boost::xpressive::regex_iterator::regex_iterator	xpressive/regex_iterator.hpp	/^    regex_iterator$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , detail::let_<LetExpr> const &args , regex_constants::match_flag_type flags = regex_constants::match_default )
boost::xpressive::regex_iterator::regex_iterator	xpressive/regex_iterator.hpp	/^    regex_iterator$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , regex_constants::match_flag_type flags = regex_constants::match_default )
boost::xpressive::regex_iterator::regex_iterator	xpressive/regex_iterator.hpp	/^    regex_iterator()$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:()
boost::xpressive::regex_iterator::regex_iterator	xpressive/regex_iterator.hpp	/^    regex_iterator(regex_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:(regex_iterator<BidiIter> const &that)
boost::xpressive::regex_iterator::regex_type	xpressive/regex_iterator.hpp	/^    typedef basic_regex<BidiIter> regex_type;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
boost::xpressive::regex_iterator::value_type	xpressive/regex_iterator.hpp	/^    typedef match_results<BidiIter> value_type;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
boost::xpressive::regex_token_iterator	xpressive/regex_token_iterator.hpp	/^struct regex_token_iterator$/;"	s	namespace:boost::xpressive
boost::xpressive::regex_token_iterator::char_type	xpressive/regex_token_iterator.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_token_iterator::difference_type	xpressive/regex_token_iterator.hpp	/^    typedef std::ptrdiff_t difference_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_token_iterator::fork_	xpressive/regex_token_iterator.hpp	/^    void fork_()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:private	signature:()
boost::xpressive::regex_token_iterator::impl_	xpressive/regex_token_iterator.hpp	/^    intrusive_ptr<impl_type_> impl_;$/;"	m	struct:boost::xpressive::regex_token_iterator	access:private
boost::xpressive::regex_token_iterator::impl_type_	xpressive/regex_token_iterator.hpp	/^    typedef detail::regex_token_iterator_impl<BidiIter> impl_type_;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_token_iterator::iterator_category	xpressive/regex_token_iterator.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_token_iterator::next_	xpressive/regex_token_iterator.hpp	/^    void next_()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:private	signature:()
boost::xpressive::regex_token_iterator::operator !=	xpressive/regex_token_iterator.hpp	/^    friend bool operator !=(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:friend	signature:(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)
boost::xpressive::regex_token_iterator::operator *	xpressive/regex_token_iterator.hpp	/^    value_type const &operator *() const$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:() const
boost::xpressive::regex_token_iterator::operator ++	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator<BidiIter> &operator ++()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:()
boost::xpressive::regex_token_iterator::operator ++	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator<BidiIter> operator ++(int)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:(int)
boost::xpressive::regex_token_iterator::operator ->	xpressive/regex_token_iterator.hpp	/^    value_type const *operator ->() const$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:() const
boost::xpressive::regex_token_iterator::operator =	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator<BidiIter> &operator =(regex_token_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:(regex_token_iterator<BidiIter> const &that)
boost::xpressive::regex_token_iterator::operator ==	xpressive/regex_token_iterator.hpp	/^    friend bool operator ==(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:friend	signature:(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)
boost::xpressive::regex_token_iterator::pointer	xpressive/regex_token_iterator.hpp	/^    typedef value_type const *pointer;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_token_iterator::reference	xpressive/regex_token_iterator.hpp	/^    typedef value_type const &reference;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_token_iterator::regex_token_iterator	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex )
boost::xpressive::regex_token_iterator::regex_token_iterator	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , Subs const &subs , detail::let_<LetExpr> const &args , regex_constants::match_flag_type flags = regex_constants::match_default )
boost::xpressive::regex_token_iterator::regex_token_iterator	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , Subs const &subs , regex_constants::match_flag_type flags = regex_constants::match_default )
boost::xpressive::regex_token_iterator::regex_token_iterator	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , detail::let_<LetExpr> const &args )
boost::xpressive::regex_token_iterator::regex_token_iterator	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:()
boost::xpressive::regex_token_iterator::regex_token_iterator	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator(regex_token_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:(regex_token_iterator<BidiIter> const &that)
boost::xpressive::regex_token_iterator::regex_type	xpressive/regex_token_iterator.hpp	/^    typedef basic_regex<BidiIter> regex_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_token_iterator::value_type	xpressive/regex_token_iterator.hpp	/^    typedef sub_match<BidiIter> value_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
boost::xpressive::regex_traits	xpressive/regex_traits.hpp	/^struct regex_traits$/;"	s	namespace:boost::xpressive	inherits:Impl
boost::xpressive::regex_traits::locale_type	xpressive/regex_traits.hpp	/^    typedef typename Impl::locale_type locale_type;$/;"	t	struct:boost::xpressive::regex_traits	access:public
boost::xpressive::regex_traits::regex_traits	xpressive/regex_traits.hpp	/^    explicit regex_traits(locale_type const &loc)$/;"	f	struct:boost::xpressive::regex_traits	access:public	signature:(locale_type const &loc)
boost::xpressive::regex_traits::regex_traits	xpressive/regex_traits.hpp	/^    regex_traits()$/;"	f	struct:boost::xpressive::regex_traits	access:public	signature:()
boost::xpressive::regex_traits_version_1_case_fold_tag	xpressive/regex_traits.hpp	/^struct regex_traits_version_1_case_fold_tag$/;"	s	namespace:boost::xpressive	inherits:regex_traits_version_1_tag
boost::xpressive::regex_traits_version_1_tag	xpressive/regex_traits.hpp	/^struct regex_traits_version_1_tag$/;"	s	namespace:boost::xpressive
boost::xpressive::regex_traits_version_2_tag	xpressive/regex_traits.hpp	/^struct regex_traits_version_2_tag$/;"	s	namespace:boost::xpressive	inherits:regex_traits_version_1_tag
boost::xpressive::repeat_max	xpressive/regex_primitives.hpp	/^unsigned int const repeat_max = UINT_MAX-1;$/;"	m	namespace:boost::xpressive
boost::xpressive::skip	xpressive/regex_primitives.hpp	/^detail::skip_directive<Skip> skip(Skip const &skip)$/;"	f	namespace:boost::xpressive	signature:(Skip const &skip)
boost::xpressive::smatch	xpressive/xpressive_fwd.hpp	/^    typedef match_results<std::string::const_iterator>              smatch;$/;"	t	namespace:boost::xpressive
boost::xpressive::sregex	xpressive/xpressive_fwd.hpp	/^    typedef basic_regex<std::string::const_iterator>                sregex;$/;"	t	namespace:boost::xpressive
boost::xpressive::sregex_compiler	xpressive/xpressive_fwd.hpp	/^    typedef regex_compiler<std::string::const_iterator>             sregex_compiler;$/;"	t	namespace:boost::xpressive
boost::xpressive::sregex_id_filter_predicate	xpressive/xpressive_fwd.hpp	/^    typedef regex_id_filter_predicate<std::string::const_iterator>  sregex_id_filter_predicate;$/;"	t	namespace:boost::xpressive
boost::xpressive::sregex_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_iterator<std::string::const_iterator>             sregex_iterator;$/;"	t	namespace:boost::xpressive
boost::xpressive::sregex_token_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_token_iterator<std::string::const_iterator>       sregex_token_iterator;$/;"	t	namespace:boost::xpressive
boost::xpressive::ssub_match	xpressive/xpressive_fwd.hpp	/^    typedef sub_match<std::string::const_iterator>                  ssub_match;$/;"	t	namespace:boost::xpressive
boost::xpressive::sub_match	xpressive/sub_match.hpp	/^struct sub_match$/;"	s	namespace:boost::xpressive	inherits:std::pair
boost::xpressive::sub_match::compare	xpressive/sub_match.hpp	/^    int compare(string_type const &str) const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:(string_type const &str) const
boost::xpressive::sub_match::compare	xpressive/sub_match.hpp	/^    int compare(sub_match const &sub) const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:(sub_match const &sub) const
boost::xpressive::sub_match::compare	xpressive/sub_match.hpp	/^    int compare(value_type const *ptr) const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:(value_type const *ptr) const
boost::xpressive::sub_match::difference_type	xpressive/sub_match.hpp	/^    typedef typename iterator_difference<BidiIter>::type difference_type;$/;"	t	struct:boost::xpressive::sub_match	access:public
boost::xpressive::sub_match::dummy	xpressive/sub_match.hpp	/^    struct dummy { int i_; };$/;"	s	struct:boost::xpressive::sub_match	access:private
boost::xpressive::sub_match::dummy::bool_type	xpressive/sub_match.hpp	/^    typedef int dummy::*bool_type;$/;"	t	class:boost::xpressive::sub_match::dummy	access:private
boost::xpressive::sub_match::dummy::i_	xpressive/sub_match.hpp	/^    struct dummy { int i_; };$/;"	m	struct:boost::xpressive::sub_match::dummy	access:public
boost::xpressive::sub_match::iterator	xpressive/sub_match.hpp	/^    typedef BidiIter iterator;$/;"	t	struct:boost::xpressive::sub_match	access:public
boost::xpressive::sub_match::length	xpressive/sub_match.hpp	/^    difference_type length() const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:() const
boost::xpressive::sub_match::matched	xpressive/sub_match.hpp	/^    bool matched;$/;"	m	struct:boost::xpressive::sub_match	access:public
boost::xpressive::sub_match::operator !	xpressive/sub_match.hpp	/^    bool operator !() const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:() const
boost::xpressive::sub_match::operator bool_type	xpressive/sub_match.hpp	/^    operator bool_type() const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:() const
boost::xpressive::sub_match::operator string_type	xpressive/sub_match.hpp	/^    operator string_type() const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:() const
boost::xpressive::sub_match::str	xpressive/sub_match.hpp	/^    string_type str() const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:() const
boost::xpressive::sub_match::string_type	xpressive/sub_match.hpp	/^    typedef typename detail::string_type<value_type>::type string_type;$/;"	t	struct:boost::xpressive::sub_match	access:public
boost::xpressive::sub_match::sub_match	xpressive/sub_match.hpp	/^    sub_match()$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:()
boost::xpressive::sub_match::sub_match	xpressive/sub_match.hpp	/^    sub_match(BidiIter first, BidiIter second, bool matched_ = false)$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:(BidiIter first, BidiIter second, bool matched_ = false)
boost::xpressive::sub_match::value_type	xpressive/sub_match.hpp	/^    typedef typename iterator_value<BidiIter>::type value_type;$/;"	t	struct:boost::xpressive::sub_match	access:public
boost::xpressive::swap	xpressive/basic_regex.hpp	/^inline void swap(basic_regex<BidiIter> &left, basic_regex<BidiIter> &right) \/\/ throw()$/;"	f	namespace:boost::xpressive	signature:(basic_regex<BidiIter> &left, basic_regex<BidiIter> &right)
boost::xpressive::val	xpressive/regex_actions.hpp	/^    value<T> const val(T const &t)$/;"	f	namespace:boost::xpressive	signature:(T const &t)
boost::xpressive::value	xpressive/regex_actions.hpp	/^    struct value$/;"	s	namespace:boost::xpressive	inherits:proto::extends
boost::xpressive::value::base_type	xpressive/regex_actions.hpp	/^        typedef proto::extends<typename proto::terminal<T>::type, value<T> > base_type;$/;"	t	struct:boost::xpressive::value	access:public
boost::xpressive::value::get	xpressive/regex_actions.hpp	/^        T &get()$/;"	f	struct:boost::xpressive::value	access:public	signature:()
boost::xpressive::value::get	xpressive/regex_actions.hpp	/^        T const &get() const$/;"	f	struct:boost::xpressive::value	access:public	signature:() const
boost::xpressive::value::value	xpressive/regex_actions.hpp	/^        explicit value(T const &t)$/;"	f	struct:boost::xpressive::value	access:public	signature:(T const &t)
boost::xpressive::value::value	xpressive/regex_actions.hpp	/^        value()$/;"	f	struct:boost::xpressive::value	access:public	signature:()
boost::xpressive::wcmatch	xpressive/xpressive_fwd.hpp	/^    typedef match_results<wchar_t const *>                          wcmatch;$/;"	t	namespace:boost::xpressive
boost::xpressive::wcregex	xpressive/xpressive_fwd.hpp	/^    typedef basic_regex<wchar_t const *>                            wcregex;$/;"	t	namespace:boost::xpressive
boost::xpressive::wcregex_compiler	xpressive/xpressive_fwd.hpp	/^    typedef regex_compiler<wchar_t const *>                         wcregex_compiler;$/;"	t	namespace:boost::xpressive
boost::xpressive::wcregex_id_filter_predicate	xpressive/xpressive_fwd.hpp	/^    typedef regex_id_filter_predicate<wchar_t const *>              wcregex_id_filter_predicate;$/;"	t	namespace:boost::xpressive
boost::xpressive::wcregex_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_iterator<wchar_t const *>                         wcregex_iterator;$/;"	t	namespace:boost::xpressive
boost::xpressive::wcregex_token_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_token_iterator<wchar_t const *>                   wcregex_token_iterator;$/;"	t	namespace:boost::xpressive
boost::xpressive::wcsub_match	xpressive/xpressive_fwd.hpp	/^    typedef sub_match<wchar_t const *>                              wcsub_match;$/;"	t	namespace:boost::xpressive
boost::xpressive::wsmatch	xpressive/xpressive_fwd.hpp	/^    typedef match_results<std::wstring::const_iterator>             wsmatch;$/;"	t	namespace:boost::xpressive
boost::xpressive::wsregex	xpressive/xpressive_fwd.hpp	/^    typedef basic_regex<std::wstring::const_iterator>               wsregex;$/;"	t	namespace:boost::xpressive
boost::xpressive::wsregex_compiler	xpressive/xpressive_fwd.hpp	/^    typedef regex_compiler<std::wstring::const_iterator>            wsregex_compiler;$/;"	t	namespace:boost::xpressive
boost::xpressive::wsregex_id_filter_predicate	xpressive/xpressive_fwd.hpp	/^    typedef regex_id_filter_predicate<std::wstring::const_iterator> wsregex_id_filter_predicate;$/;"	t	namespace:boost::xpressive
boost::xpressive::wsregex_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_iterator<std::wstring::const_iterator>            wsregex_iterator;$/;"	t	namespace:boost::xpressive
boost::xpressive::wsregex_token_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_token_iterator<std::wstring::const_iterator>      wsregex_token_iterator;$/;"	t	namespace:boost::xpressive
boost::xpressive::wssub_match	xpressive/xpressive_fwd.hpp	/^    typedef sub_match<std::wstring::const_iterator>                 wssub_match;$/;"	t	namespace:boost::xpressive
bos	xpressive/detail/core/state.hpp	/^    bool bos() const$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:() const
bos	xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_bos_matcher>::type const bos = {{}};$/;"	m	class:boost::xpressive::proto::terminal
bow	xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_word_begin>::type const bow = {{}};$/;"	m	class:boost::xpressive::proto::terminal
boyer_moore	xpressive/detail/utility/boyer_moore.hpp	/^    boyer_moore(char_type const *begin, char_type const *end, Traits const &tr, bool icase)$/;"	f	struct:boost::xpressive::detail::boyer_moore	access:public	signature:(char_type const *begin, char_type const *end, Traits const &tr, bool icase)
boyer_moore	xpressive/detail/utility/boyer_moore.hpp	/^struct boyer_moore$/;"	s	namespace:boost::xpressive::detail	inherits:noncopyable
boyer_moore_finder	xpressive/detail/core/finder.hpp	/^    boyer_moore_finder(boyer_moore_finder const &);$/;"	p	struct:boost::xpressive::detail::boyer_moore_finder	access:private	signature:(boyer_moore_finder const &)
boyer_moore_finder	xpressive/detail/core/finder.hpp	/^    boyer_moore_finder(char_type const *begin, char_type const *end, Traits const &tr, bool icase)$/;"	f	struct:boost::xpressive::detail::boyer_moore_finder	access:public	signature:(char_type const *begin, char_type const *end, Traits const &tr, bool icase)
boyer_moore_finder	xpressive/detail/core/finder.hpp	/^struct boyer_moore_finder$/;"	s	namespace:boost::xpressive::detail	inherits:finder
bset_	xpressive/detail/core/finder.hpp	/^    hash_peek_bitset<char_type> bset_;$/;"	m	struct:boost::xpressive::detail::hash_peek_finder	access:private
bset_	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        mutable hash_peek_bitset<char_type> bset_;$/;"	m	struct:boost::xpressive::detail::alternate_matcher	access:public
bset_	xpressive/detail/core/peeker.hpp	/^    hash_peek_bitset<Char> &bset_;$/;"	m	struct:boost::xpressive::detail::xpression_peeker	access:private
bset_	xpressive/detail/core/peeker.hpp	/^    hash_peek_bitset<char_type> &bset_;$/;"	m	struct:boost::xpressive::detail::char_sink	access:public
bset_	xpressive/detail/utility/chset/basic_chset.hpp	/^    std::bitset<256> bset_; \/\/ BUGBUG range-checking slows this down$/;"	m	struct:boost::xpressive::detail::basic_chset_8bit	access:private
bset_	xpressive/detail/utility/hash_peek_bitset.hpp	/^    std::bitset<256> bset_;$/;"	m	struct:boost::xpressive::detail::hash_peek_bitset	access:private
by_ref	xpressive/regex_primitives.hpp	/^by_ref(basic_regex<BidiIter> const &rex)$/;"	f	class:boost::xpressive::proto::terminal	signature:(basic_regex<BidiIter> const &rex)
by_ref_transform	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct by_ref_transform : proto::transform<by_ref_transform>$/;"	s	namespace:boost::xpressive::detail	inherits:proto::transform
c_regex_traits	xpressive/traits/c_regex_traits.hpp	/^    c_regex_traits(locale_type const &loc = locale_type())$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(locale_type const &loc = locale_type())
c_regex_traits	xpressive/traits/c_regex_traits.hpp	/^struct c_regex_traits$/;"	s	namespace:boost::xpressive	inherits:detail::c_regex_traits_base
c_regex_traits_base	xpressive/traits/c_regex_traits.hpp	/^    struct c_regex_traits_base$/;"	s	namespace:boost::xpressive::detail
c_regex_traits_base	xpressive/traits/c_regex_traits.hpp	/^    struct c_regex_traits_base<Char, 1>$/;"	s	namespace:boost::xpressive::detail
c_regex_traits_base	xpressive/traits/c_regex_traits.hpp	/^    struct c_regex_traits_base<wchar_t, SizeOfChar>$/;"	s	namespace:boost::xpressive::detail
c_tolower	xpressive/traits/c_regex_traits.hpp	/^    Char c_tolower(Char);$/;"	p	namespace:boost::xpressive::detail	signature:(Char)
c_tolower	xpressive/traits/c_regex_traits.hpp	/^    inline char c_tolower(char ch)$/;"	f	namespace:boost::xpressive::detail	signature:(char ch)
c_tolower	xpressive/traits/c_regex_traits.hpp	/^    inline wchar_t c_tolower(wchar_t ch)$/;"	f	namespace:boost::xpressive::detail	signature:(wchar_t ch)
c_toupper	xpressive/traits/c_regex_traits.hpp	/^    Char c_toupper(Char);$/;"	p	namespace:boost::xpressive::detail	signature:(Char)
c_toupper	xpressive/traits/c_regex_traits.hpp	/^    inline char c_toupper(char ch)$/;"	f	namespace:boost::xpressive::detail	signature:(char ch)
c_toupper	xpressive/traits/c_regex_traits.hpp	/^    inline wchar_t c_toupper(wchar_t ch)$/;"	f	namespace:boost::xpressive::detail	signature:(wchar_t ch)
cache_	xpressive/detail/core/results_cache.hpp	/^        nested_results<BidiIter> cache_;$/;"	m	struct:boost::xpressive::detail::results_cache	access:private
call	xpressive/detail/core/linker.hpp	/^    call(Visitor &visitor) const$/;"	f	struct:boost::xpressive::detail::locale_modifier	access:public	signature:(Visitor &visitor) const
call	xpressive/detail/core/linker.hpp	/^    call(Visitor &visitor)$/;"	f	struct:boost::xpressive::detail::icase_modifier	access:public	signature:(Visitor &visitor)
call	xpressive/detail/static/transforms/as_inverse.hpp	/^        static T call(T t)$/;"	f	struct:boost::xpressive::grammar_detail::inverter	access:public	signature:(T t)
call	xpressive/detail/static/transforms/as_inverse.hpp	/^        static type call(detail::assert_word_matcher<detail::word_boundary<mpl::true_>, Traits> t)$/;"	f	struct:boost::xpressive::grammar_detail::inverter	access:public	signature:(detail::assert_word_matcher<detail::word_boundary<mpl::true_>, Traits> t)
call	xpressive/detail/static/transforms/as_inverse.hpp	/^        static type call(detail::literal_matcher<Traits, ICase, Not> t)$/;"	f	struct:boost::xpressive::grammar_detail::inverter	access:public	signature:(detail::literal_matcher<Traits, ICase, Not> t)
call	xpressive/detail/static/transforms/as_inverse.hpp	/^        static type call(detail::logical_newline_matcher<Traits> t)$/;"	f	struct:boost::xpressive::grammar_detail::inverter	access:public	signature:(detail::logical_newline_matcher<Traits> t)
call	xpressive/detail/static/transmogrify.hpp	/^        static Matcher2 const &call(Matcher2 const &m, dont_care)$/;"	f	struct:boost::xpressive::detail::default_transmogrify	access:public	signature:(Matcher2 const &m, dont_care)
call	xpressive/detail/static/transmogrify.hpp	/^        static type call(Matcher2 const &m, Visitor &visitor)$/;"	f	struct:boost::xpressive::detail::default_transmogrify	access:public	signature:(Matcher2 const &m, Visitor &visitor)
call	xpressive/detail/static/transmogrify.hpp	/^        static type call(Matcher2 const &m, Visitor &visitor)$/;"	f	struct:boost::xpressive::detail::transmogrify	access:public	signature:(Matcher2 const &m, Visitor &visitor)
call	xpressive/detail/static/transmogrify.hpp	/^        static type call(Matcher2 const &m, dont_care)$/;"	f	struct:boost::xpressive::detail::transmogrify	access:public	signature:(Matcher2 const &m, dont_care)
call	xpressive/detail/static/transmogrify.hpp	/^        static type call(Matcher2 m, Visitor &visitor)$/;"	f	struct:boost::xpressive::detail::transmogrify	access:public	signature:(Matcher2 m, Visitor &visitor)
call	xpressive/detail/static/transmogrify.hpp	/^        static type call(Matcher2, Visitor &visitor)$/;"	f	struct:boost::xpressive::detail::transmogrify	access:public	signature:(Matcher2, Visitor &visitor)
call	xpressive/detail/static/transmogrify.hpp	/^        static type call(dont_care, Visitor &visitor)$/;"	f	struct:boost::xpressive::detail::transmogrify	access:public	signature:(dont_care, Visitor &visitor)
call	xpressive/detail/static/visitor.hpp	/^        call(Matcher const &matcher)$/;"	f	struct:boost::xpressive::detail::xpression_visitor	access:public	signature:(Matcher const &matcher)
call	xpressive/detail/utility/cons.hpp	/^            call(Cons& t)$/;"	f	struct:boost::fusion::cons_detail::begin_traits_impl	access:public	signature:(Cons& t)
call	xpressive/detail/utility/cons.hpp	/^            call(Cons& t)$/;"	f	struct:boost::fusion::cons_detail::end_traits_impl	access:public	signature:(Cons& t)
call	xpressive/detail/utility/cons.hpp	/^            call(Iterator const& i)$/;"	f	struct:boost::fusion::cons_detail::deref_traits_impl	access:public	signature:(Iterator const& i)
call	xpressive/detail/utility/cons.hpp	/^            call(Iterator const& i)$/;"	f	struct:boost::fusion::cons_detail::next_traits_impl	access:public	signature:(Iterator const& i)
call_	xpressive/detail/static/transforms/as_set.hpp	/^        void call_(Expr const &expr, Tag) const$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:private	signature:(Expr const &expr, Tag) const
call_	xpressive/detail/static/transforms/as_set.hpp	/^        void call_(Expr const &expr, tag::bitwise_or) const$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:private	signature:(Expr const &expr, tag::bitwise_or) const
call_	xpressive/detail/static/transmogrify.hpp	/^        static type call_(Matcher2 const &m, Visitor &visitor, mpl::false_)$/;"	f	struct:boost::xpressive::detail::default_transmogrify	access:public	signature:(Matcher2 const &m, Visitor &visitor, mpl::false_)
call_	xpressive/detail/static/transmogrify.hpp	/^        static type call_(Matcher2 const &m, Visitor &visitor, mpl::true_)$/;"	f	struct:boost::xpressive::detail::default_transmogrify	access:public	signature:(Matcher2 const &m, Visitor &visitor, mpl::true_)
can_match_	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        bool can_match_(char_type ch, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::alternate_matcher	access:private	signature:(char_type ch, Traits const &tr) const
car	xpressive/detail/utility/cons.hpp	/^        car_type car;$/;"	m	struct:boost::fusion::cons	access:public
car_type	xpressive/detail/utility/cons.hpp	/^        typedef typename call_traits<Car>::value_type car_type;$/;"	t	struct:boost::fusion::cons	access:public
car_type	xpressive/detail/utility/cons.hpp	/^        typedef void_t car_type;$/;"	t	struct:boost::fusion::nil	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_$/;"	s	struct:boost::xpressive::grammar_detail::ActionableCases	inherits:Cases::,case_	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:not_	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_$/;"	s	struct:boost::xpressive::grammar_detail::InvertibleCases	inherits:not_	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_$/;"	s	struct:boost::xpressive::grammar_detail::NonGreedyRepeatCases	inherits:not_	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::generic_quant_tag<Min, Max>, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::generic_quant_tag<Min, Max>, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NonGreedyRepeatCases	inherits:unary_expr	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::keeper_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::lookahead_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::lookahead_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::InvertibleCases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::lookbehind_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::lookbehind_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::InvertibleCases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<detail::modifier_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<optional_tag<Greedy> , Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<proto::tag::assign, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::ActionableCases	inherits:or_	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::assign, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:or_	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::assign, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::InvertibleCases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::bitwise_or, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::comma, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::comma, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::InvertibleCases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::complement, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::dereference, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::dereference, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NonGreedyRepeatCases	inherits:dereference	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::logical_not, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::logical_not, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NonGreedyRepeatCases	inherits:logical_not	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::negate, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::shift_right, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::subscript, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:or_	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::subscript, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::InvertibleCases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::terminal, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::terminal, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::InvertibleCases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::unary_plus, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::Cases	inherits:when	access:public
case_	xpressive/detail/static/grammar.hpp	/^            struct case_<tag::unary_plus, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NonGreedyRepeatCases	inherits:unary_plus	access:public
case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:proto::nary_expr	access:public
case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_<detail::keeper_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:proto::_	access:public
case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_<detail::lookahead_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:proto::_	access:public
case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_<detail::lookbehind_tag, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:proto::_	access:public
case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_<proto::tag::comma, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:proto::_	access:public
case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_<proto::tag::complement, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:proto::_	access:public
case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_<proto::tag::subscript, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:proto::subscript	access:public
case_	xpressive/detail/static/transforms/as_independent.hpp	/^        struct case_<proto::tag::terminal, Dummy>$/;"	s	struct:boost::xpressive::grammar_detail::NotHasActionCases	inherits:not_	access:public
case_converting_iterator	xpressive/match_results.hpp	/^    case_converting_iterator(OutputIterator const &out, traits<Char> const *tr)$/;"	f	struct:boost::xpressive::detail::case_converting_iterator	access:public	signature:(OutputIterator const &out, traits<Char> const *tr)
case_converting_iterator	xpressive/match_results.hpp	/^struct case_converting_iterator$/;"	s	namespace:boost::xpressive::detail	inherits:std::iterator
case_fold	xpressive/detail/utility/boyer_moore.hpp	/^    typedef has_fold_case<Traits> case_fold;$/;"	t	struct:boost::xpressive::detail::boyer_moore	access:public
cast	xpressive/regex_actions.hpp	/^            reference cast(void *pv) const$/;"	f	struct:boost::xpressive::detail::action_arg	access:public	signature:(void *pv) const
cdr	xpressive/detail/utility/cons.hpp	/^        cdr_type cdr;$/;"	m	struct:boost::fusion::cons	access:public
cdr_type	xpressive/detail/utility/cons.hpp	/^            typedef typename cons_type::cdr_type cdr_type;$/;"	t	struct:boost::fusion::cons_detail::next_traits_impl	access:public
cdr_type	xpressive/detail/utility/cons.hpp	/^        typedef Cdr cdr_type;$/;"	t	struct:boost::fusion::cons	access:public
cdr_type	xpressive/detail/utility/cons.hpp	/^        typedef void_t cdr_type;$/;"	t	struct:boost::fusion::nil	access:public
ch	xpressive/detail/utility/symbols.hpp	/^            char_type ch;$/;"	m	struct:boost::xpressive::detail::symbols::node	access:public
ch_	xpressive/detail/core/matcher/literal_matcher.hpp	/^        char_type ch_;$/;"	m	struct:boost::xpressive::detail::literal_matcher	access:public
ch_	xpressive/detail/dynamic/parse_charset.hpp	/^    Char ch_;$/;"	m	struct:boost::xpressive::detail::escape_value	access:public
ch_	xpressive/detail/utility/chset/chset.hpp	/^        char_type ch_;$/;"	m	struct:boost::xpressive::detail::compound_charset::not_posix_pred	access:public
ch_max_	xpressive/detail/core/matcher/range_matcher.hpp	/^        char_type ch_max_;$/;"	m	struct:boost::xpressive::detail::range_matcher	access:public
ch_max_	xpressive/detail/static/placeholders.hpp	/^    Char ch_max_;$/;"	m	struct:boost::xpressive::detail::range_placeholder	access:public
ch_min_	xpressive/detail/core/matcher/range_matcher.hpp	/^        char_type ch_min_;$/;"	m	struct:boost::xpressive::detail::range_matcher	access:public
ch_min_	xpressive/detail/static/placeholders.hpp	/^    Char ch_min_;$/;"	m	struct:boost::xpressive::detail::range_placeholder	access:public
char_cast	xpressive/detail/utility/traits_utils.hpp	/^    char_cast(FromChar from, Traits const &, typename enable_if<is_same<ToChar, FromChar> >::type * = 0)$/;"	f	namespace:boost::xpressive::detail	signature:(FromChar from, Traits const &, typename enable_if<is_same<ToChar, FromChar> >::type * = 0)
char_cast	xpressive/detail/utility/traits_utils.hpp	/^    char_cast(FromChar from, Traits const &tr, typename disable_if<is_same<ToChar, FromChar> >::type * = 0)$/;"	f	namespace:boost::xpressive::detail	signature:(FromChar from, Traits const &tr, typename disable_if<is_same<ToChar, FromChar> >::type * = 0)
char_class	xpressive/traits/cpp_regex_traits.hpp	/^    static char_class_pair const &char_class(std::size_t j)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:private	signature:(std::size_t j)
char_class_impl	xpressive/traits/detail/c_ctype.hpp	/^struct char_class_impl<char>$/;"	s	namespace:boost::xpressive::detail
char_class_impl	xpressive/traits/detail/c_ctype.hpp	/^struct char_class_impl<wchar_t>$/;"	s	namespace:boost::xpressive::detail
char_class_pair	xpressive/traits/cpp_regex_traits.hpp	/^    struct char_class_pair$/;"	s	struct:boost::xpressive::cpp_regex_traits	access:private
char_class_type	xpressive/detail/core/finder.hpp	/^    typedef typename Traits::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::detail::line_start_finder	access:public
char_class_type	xpressive/detail/core/matcher/assert_line_base.hpp	/^        typedef typename Traits::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::detail::assert_line_base	access:public
char_class_type	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        typedef typename Traits::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::detail::assert_word_matcher	access:public
char_class_type	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        typedef typename Traits::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::detail::logical_newline_matcher	access:public
char_class_type	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^        typedef typename Traits::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::detail::posix_charset_matcher	access:public
char_class_type	xpressive/detail/utility/chset/chset.hpp	/^    typedef typename Traits::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::detail::compound_charset	access:public
char_class_type	xpressive/regex_compiler.hpp	/^    typedef typename traits_type::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
char_class_type	xpressive/traits/c_regex_traits.hpp	/^    typedef typename detail::char_class_impl<Char>::char_class_type char_class_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
char_class_type	xpressive/traits/cpp_regex_traits.hpp	/^    typedef detail::umaskex_t char_class_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
char_class_type	xpressive/traits/detail/c_ctype.hpp	/^    typedef int char_class_type;$/;"	t	struct:boost::xpressive::detail::char_class_impl	access:public
char_class_type	xpressive/traits/detail/c_ctype.hpp	/^    typedef short char_class_type;$/;"	t	struct:boost::xpressive::detail::char_class_impl	access:public
char_class_type	xpressive/traits/detail/c_ctype.hpp	/^    typedef wctype_t char_class_type;$/;"	t	struct:boost::xpressive::detail::char_class_impl	access:public
char_class_type	xpressive/traits/null_regex_traits.hpp	/^    typedef int char_class_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
char_literal	xpressive/detail/utility/literals.hpp	/^struct char_literal<Char, Ch, Ch>$/;"	s	namespace:boost::xpressive::detail
char_overflow_handler	xpressive/detail/dynamic/parse_charset.hpp	/^struct char_overflow_handler$/;"	s	namespace:boost::xpressive::detail
char_overflow_handler_	xpressive/match_results.hpp	/^struct char_overflow_handler_$/;"	s	namespace:boost::xpressive::detail
char_sink	xpressive/detail/core/peeker.hpp	/^    char_sink(hash_peek_bitset<char_type> &bset, Traits const &tr)$/;"	f	struct:boost::xpressive::detail::char_sink	access:public	signature:(hash_peek_bitset<char_type> &bset, Traits const &tr)
char_sink	xpressive/detail/core/peeker.hpp	/^struct char_sink$/;"	s	namespace:boost::xpressive::detail
char_translate	xpressive/detail/core/matcher/attr_matcher.hpp	/^        explicit char_translate(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::char_translate	access:public	signature:(Traits const &tr)
char_translate	xpressive/detail/core/matcher/attr_matcher.hpp	/^    struct char_translate$/;"	s	namespace:boost::xpressive::detail
char_translate	xpressive/detail/core/matcher/attr_matcher.hpp	/^    struct char_translate<Traits, true>$/;"	s	namespace:boost::xpressive::detail
char_type	xpressive/basic_regex.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
char_type	xpressive/detail/core/access.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::core_access	access:public
char_type	xpressive/detail/core/adaptor.hpp	/^    typedef typename iterator_value<iterator_type>::type char_type;$/;"	t	struct:boost::xpressive::detail::xpression_adaptor	access:public
char_type	xpressive/detail/core/finder.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::boyer_moore_finder	access:public
char_type	xpressive/detail/core/finder.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::hash_peek_finder	access:public
char_type	xpressive/detail/core/finder.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::line_start_finder	access:public
char_type	xpressive/detail/core/linker.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::regex_traits_type	access:public
char_type	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::alternate_matcher	access:public
char_type	xpressive/detail/core/matcher/assert_bol_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::assert_bol_matcher	access:public
char_type	xpressive/detail/core/matcher/assert_eol_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::assert_eol_matcher	access:public
char_type	xpressive/detail/core/matcher/assert_line_base.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::assert_line_base	access:public
char_type	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::assert_word_matcher	access:public
char_type	xpressive/detail/core/matcher/attr_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::char_translate	access:public
char_type	xpressive/detail/core/matcher/charset_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::charset_matcher	access:public
char_type	xpressive/detail/core/matcher/literal_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::literal_matcher	access:public
char_type	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::logical_newline_matcher	access:public
char_type	xpressive/detail/core/matcher/range_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::range_matcher	access:public
char_type	xpressive/detail/core/matcher/set_matcher.hpp	/^    typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::set_matcher	access:public
char_type	xpressive/detail/core/matcher/string_matcher.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::string_matcher	access:public
char_type	xpressive/detail/core/peeker.hpp	/^    typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::char_sink	access:public
char_type	xpressive/detail/core/regex_impl.hpp	/^    typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::traits_holder	access:public
char_type	xpressive/detail/core/regex_impl.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::regex_impl	access:public
char_type	xpressive/detail/core/state.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::match_context	access:public
char_type	xpressive/detail/core/sub_match_vector.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
char_type	xpressive/detail/dynamic/dynamic.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::dynamic_xpression	access:public
char_type	xpressive/detail/dynamic/matchable.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::shared_matchable	access:public
char_type	xpressive/detail/dynamic/matchable.hpp	/^    typedef typename iterator_value<iterator_type>::type char_type;$/;"	t	struct:boost::xpressive::detail::matchable	access:public
char_type	xpressive/detail/dynamic/matchable.hpp	/^    typedef typename iterator_value<iterator_type>::type char_type;$/;"	t	struct:boost::xpressive::detail::matchable_ex	access:public
char_type	xpressive/detail/dynamic/parser_traits.hpp	/^    typedef typename regex_traits::char_type char_type;$/;"	t	struct:boost::xpressive::compiler_traits	access:public
char_type	xpressive/detail/static/transforms/as_set.hpp	/^            typedef typename data_type::char_type char_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_set_matcher::impl	access:public
char_type	xpressive/detail/static/transforms/as_set.hpp	/^        typedef typename CharSet::char_type char_type;$/;"	t	struct:boost::xpressive::grammar_detail::merge_charset	access:public
char_type	xpressive/detail/static/transmogrify.hpp	/^        typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::default_transmogrify	access:public
char_type	xpressive/detail/static/transmogrify.hpp	/^        typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
char_type	xpressive/detail/static/visitor.hpp	/^        typedef typename boost::iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::xpression_visitor	access:public
char_type	xpressive/detail/utility/boyer_moore.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::detail::boyer_moore	access:public
char_type	xpressive/detail/utility/chset/chset.hpp	/^    typedef typename Traits::char_type char_type;$/;"	t	struct:boost::xpressive::detail::compound_charset	access:public
char_type	xpressive/detail/utility/hash_peek_bitset.hpp	/^    typedef Char char_type;$/;"	t	struct:boost::xpressive::detail::hash_peek_bitset	access:public
char_type	xpressive/detail/utility/symbols.hpp	/^        typedef typename range_value<key_type>::type char_type;$/;"	t	struct:boost::xpressive::detail::symbols	access:public
char_type	xpressive/match_results.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::match_results	access:public
char_type	xpressive/regex_compiler.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
char_type	xpressive/regex_token_iterator.hpp	/^    typedef typename iterator_value<BidiIter>::type char_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
char_type	xpressive/traits/c_regex_traits.hpp	/^    typedef Char char_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
char_type	xpressive/traits/cpp_regex_traits.hpp	/^    typedef Char char_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
char_type	xpressive/traits/null_regex_traits.hpp	/^    typedef Elem char_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
charset_	xpressive/detail/core/matcher/charset_matcher.hpp	/^        CharSet charset_;$/;"	m	struct:boost::xpressive::detail::charset_matcher	access:public
charset_	xpressive/detail/static/transforms/as_set.hpp	/^        CharSet &charset_;$/;"	m	struct:boost::xpressive::grammar_detail::merge_charset	access:private
charset_matcher	xpressive/detail/core/matcher/charset_matcher.hpp	/^        charset_matcher(CharSet const &charset = CharSet())$/;"	f	struct:boost::xpressive::detail::charset_matcher	access:public	signature:(CharSet const &charset = CharSet())
charset_matcher	xpressive/detail/core/matcher/charset_matcher.hpp	/^    struct charset_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_fixed_width
charset_type	xpressive/detail/static/transforms/as_set.hpp	/^            charset_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_set_matcher::impl	access:public
check	xpressive/regex_actions.hpp	/^    detail::unspecified check(T const &t);$/;"	p	namespace:boost::xpressive	signature:(T const &t)
check	xpressive/regex_actions.hpp	/^    proto::terminal<detail::check_tag>::type const check = {{}};$/;"	m	class:boost::xpressive::proto::terminal
check_insert_return	xpressive/regex_actions.hpp	/^                    static no_type check_insert_return(std::pair<typename cont_type::iterator, bool>);$/;"	p	struct:boost::xpressive::op::insert::detail::result_detail	access:public	signature:(std::pair<typename cont_type::iterator, bool>)
check_insert_return	xpressive/regex_actions.hpp	/^                    static yes_type check_insert_return(typename cont_type::iterator);$/;"	p	struct:boost::xpressive::op::insert::detail::result_detail	access:public	signature:(typename cont_type::iterator)
check_is_formatter	xpressive/match_results.hpp	/^binary_type check_is_formatter(T const &, U const &, ternary_type);$/;"	p	namespace:boost::xpressive::detail	signature:(T const &, U const &, ternary_type)
check_is_formatter	xpressive/match_results.hpp	/^binary_type check_is_formatter(unary_type, T const &, ternary_type);$/;"	p	namespace:boost::xpressive::detail	signature:(unary_type, T const &, ternary_type)
check_is_formatter	xpressive/match_results.hpp	/^no_type check_is_formatter(unary_type, binary_type, ternary_type);$/;"	p	namespace:boost::xpressive::detail	signature:(unary_type, binary_type, ternary_type)
check_is_formatter	xpressive/match_results.hpp	/^ternary_type check_is_formatter(T const &, U const &, V const &);$/;"	p	namespace:boost::xpressive::detail	signature:(T const &, U const &, V const &)
check_is_formatter	xpressive/match_results.hpp	/^ternary_type check_is_formatter(T const &, binary_type, U const &);$/;"	p	namespace:boost::xpressive::detail	signature:(T const &, binary_type, U const &)
check_is_formatter	xpressive/match_results.hpp	/^ternary_type check_is_formatter(unary_type, T const &, U const &);$/;"	p	namespace:boost::xpressive::detail	signature:(unary_type, T const &, U const &)
check_is_formatter	xpressive/match_results.hpp	/^ternary_type check_is_formatter(unary_type, binary_type, T const &);$/;"	p	namespace:boost::xpressive::detail	signature:(unary_type, binary_type, T const &)
check_is_formatter	xpressive/match_results.hpp	/^unary_type check_is_formatter(T const &, binary_type, ternary_type);$/;"	p	namespace:boost::xpressive::detail	signature:(T const &, binary_type, ternary_type)
check_tag	xpressive/regex_actions.hpp	/^        struct check_tag$/;"	s	namespace:boost::xpressive::detail
child_	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct child_$/;"	s	namespace:boost::xpressive::detail	inherits:remove_reference
chunk	xpressive/detail/utility/sequence_stack.hpp	/^        chunk(std::size_t size, T const &t, std::size_t count, chunk *back, chunk *next)$/;"	f	struct:boost::xpressive::detail::sequence_stack::chunk	access:public	signature:(std::size_t size, T const &t, std::size_t count, chunk *back, chunk *next)
chunk	xpressive/detail/utility/sequence_stack.hpp	/^    struct chunk$/;"	s	struct:boost::xpressive::detail::sequence_stack	access:private
class_	xpressive/detail/dynamic/parse_charset.hpp	/^    Class class_;$/;"	m	struct:boost::xpressive::detail::escape_value	access:public
class_name_	xpressive/traits/cpp_regex_traits.hpp	/^        char_type const *class_name_;$/;"	m	struct:boost::xpressive::cpp_regex_traits::char_class_pair	access:public
class_type_	xpressive/traits/cpp_regex_traits.hpp	/^        char_class_type class_type_;$/;"	m	struct:boost::xpressive::cpp_regex_traits::char_class_pair	access:public
classname_a	xpressive/traits/detail/c_ctype.hpp	/^inline std::string classname_a(FwdIter begin, FwdIter end)$/;"	f	namespace:boost::xpressive::detail	signature:(FwdIter begin, FwdIter end)
classname_w	xpressive/traits/detail/c_ctype.hpp	/^inline std::wstring classname_w(FwdIter begin, FwdIter end)$/;"	f	namespace:boost::xpressive::detail	signature:(FwdIter begin, FwdIter end)
clear	xpressive/detail/core/list.hpp	/^        void clear()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear();$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:()
clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear();$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:()
clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char c);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char c)
clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char c);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char c)
clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char c, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char c, Traits const &tr)
clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char c, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char c, Traits const &tr)
clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char from, Char to);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char from, Char to)
clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char from, Char to);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char from, Char to)
clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char from, Char to, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char from, Char to, Traits const &tr)
clear	xpressive/detail/utility/chset/basic_chset.hpp	/^    void clear(Char from, Char to, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char from, Char to, Traits const &tr)
clear	xpressive/detail/utility/chset/range_run.hpp	/^    void clear();$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:()
clear	xpressive/detail/utility/chset/range_run.hpp	/^    void clear(range_type const &r);$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:(range_type const &r)
clear	xpressive/detail/utility/sequence_stack.hpp	/^    void clear()$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:()
cmatch	xpressive/xpressive_fwd.hpp	/^    typedef match_results<char const *>                             cmatch;$/;"	t	namespace:boost::xpressive
cnt_	xpressive/detail/utility/tracking_ptr.hpp	/^    boost::detail::atomic_count cnt_;$/;"	m	struct:boost::xpressive::detail::enable_reference_tracking	access:private
cntrl	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const cntrl = {{"cntrl", false}};$/;"	m	class:boost::xpressive::proto::terminal
code	xpressive/regex_error.hpp	/^    regex_constants::error_type code() const$/;"	f	struct:boost::xpressive::regex_error	access:public	signature:() const
code_	xpressive/regex_error.hpp	/^    regex_constants::error_type code_;$/;"	m	struct:boost::xpressive::regex_error	access:private
collate	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::collate;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
collate	xpressive/regex_constants.hpp	/^    collate     = 1 << 4,   \/\/\/< Specifies that character ranges of the form "[a-b]" should be$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
common_compile	xpressive/detail/core/optimize.hpp	/^void common_compile$/;"	f	namespace:boost::xpressive::detail	signature:( intrusive_ptr<matchable_ex<BidiIter> const> const &regex , regex_impl<BidiIter> &impl , Traits const &tr )
compare	xpressive/sub_match.hpp	/^    int compare(string_type const &str) const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:(string_type const &str) const
compare	xpressive/sub_match.hpp	/^    int compare(sub_match const &sub) const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:(sub_match const &sub) const
compare	xpressive/sub_match.hpp	/^    int compare(value_type const *ptr) const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:(value_type const *ptr) const
compare_	xpressive/traits/cpp_regex_traits.hpp	/^    static bool compare_(char_type const *name, FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:private	signature:(char_type const *name, FwdIter begin, FwdIter end)
compile	xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)
compile	xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)
compile	xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(char_type const *begin, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(char_type const *begin, flag_type flags = regex_constants::ECMAScript)
compile	xpressive/basic_regex.hpp	/^    static basic_regex<BidiIter> compile(char_type const *begin, std::size_t len, flag_type flags)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(char_type const *begin, std::size_t len, flag_type flags)
compile	xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> compile(char_type const *begin, std::size_t size, flag_type flags)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(char_type const *begin, std::size_t size, flag_type flags)
compile	xpressive/regex_compiler.hpp	/^    compile(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(InputIter begin, InputIter end, flag_type flags = regex_constants::ECMAScript)
compile	xpressive/regex_compiler.hpp	/^    compile(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(InputRange const &pat, flag_type flags = regex_constants::ECMAScript)
compile	xpressive/regex_compiler.hpp	/^    compile(char_type const *begin, flag_type flags = regex_constants::ECMAScript)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(char_type const *begin, flag_type flags = regex_constants::ECMAScript)
compile_	xpressive/basic_regex.hpp	/^    void compile_(Expr const &, mpl::false_)$/;"	f	struct:boost::xpressive::basic_regex	access:private	signature:(Expr const &, mpl::false_)
compile_	xpressive/basic_regex.hpp	/^    void compile_(Expr const &expr, mpl::true_)$/;"	f	struct:boost::xpressive::basic_regex	access:private	signature:(Expr const &expr, mpl::true_)
compile_	xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> compile_(FwdIter begin, FwdIter end, flag_type flags, std::forward_iterator_tag)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter begin, FwdIter end, flag_type flags, std::forward_iterator_tag)
compile_	xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> compile_(InputIter begin, InputIter end, flag_type flags, std::input_iterator_tag)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(InputIter begin, InputIter end, flag_type flags, std::input_iterator_tag)
compiler_token_type	xpressive/detail/dynamic/parser_enum.hpp	/^enum compiler_token_type$/;"	g	namespace:boost::xpressive::regex_constants
compiler_traits	xpressive/detail/dynamic/parser_traits.hpp	/^    explicit compiler_traits(RegexTraits const &traits = RegexTraits())$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(RegexTraits const &traits = RegexTraits())
compiler_traits	xpressive/detail/dynamic/parser_traits.hpp	/^struct compiler_traits$/;"	s	namespace:boost::xpressive
complement_	xpressive/detail/utility/chset/chset.hpp	/^    bool complement_;$/;"	m	struct:boost::xpressive::detail::compound_charset	access:private
compound_charset	xpressive/detail/utility/chset/chset.hpp	/^    compound_charset()$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:()
compound_charset	xpressive/detail/utility/chset/chset.hpp	/^struct compound_charset$/;"	s	namespace:boost::xpressive::detail	inherits:basic_chset
cond_rotation	xpressive/detail/utility/symbols.hpp	/^        bool cond_rotation(bool left, node* const i, node* const j) const$/;"	f	struct:boost::xpressive::detail::symbols	access:private	signature:(bool left, node* const i, node* const j) const
cons	xpressive/detail/utility/cons.hpp	/^        cons()$/;"	f	struct:boost::fusion::cons	access:public	signature:()
cons	xpressive/detail/utility/cons.hpp	/^        cons_type& cons;$/;"	m	struct:boost::fusion::cons_iterator	access:public
cons	xpressive/detail/utility/cons.hpp	/^        explicit cons($/;"	f	struct:boost::fusion::cons	access:public	signature:( typename call_traits<Car>::param_type car_ , typename call_traits<Cdr>::param_type cdr_ = Cdr())
cons	xpressive/detail/utility/cons.hpp	/^    struct cons : sequence_base<cons<Car,Cdr> >$/;"	s	namespace:boost::fusion	inherits:sequence_base
cons_detail	xpressive/detail/utility/cons.hpp	/^    namespace cons_detail$/;"	n	namespace:boost::fusion
cons_iterator	xpressive/detail/utility/cons.hpp	/^        cons_iterator() {}$/;"	f	struct:boost::fusion::cons_iterator	access:public	signature:()
cons_iterator	xpressive/detail/utility/cons.hpp	/^        explicit cons_iterator(cons_type& cons_)$/;"	f	struct:boost::fusion::cons_iterator	access:public	signature:(cons_type& cons_)
cons_iterator	xpressive/detail/utility/cons.hpp	/^        explicit cons_iterator(nil const&) {}$/;"	f	struct:boost::fusion::cons_iterator	access:public	signature:(nil const&)
cons_iterator	xpressive/detail/utility/cons.hpp	/^    struct cons_iterator : iterator_base<cons_iterator<Cons> >$/;"	s	namespace:boost::fusion	inherits:iterator_base
cons_iterator	xpressive/detail/utility/cons.hpp	/^    struct cons_iterator<nil const> : iterator_base<cons_iterator<nil const> >$/;"	s	namespace:boost::fusion	inherits:iterator_base
cons_iterator	xpressive/detail/utility/cons.hpp	/^    struct cons_iterator<nil> : iterator_base<cons_iterator<nil> >$/;"	s	namespace:boost::fusion	inherits:iterator_base
cons_type	xpressive/detail/utility/cons.hpp	/^            typedef typename Iterator::cons_type cons_type;$/;"	t	struct:boost::fusion::cons_detail::deref_traits_impl	access:public
cons_type	xpressive/detail/utility/cons.hpp	/^            typedef typename Iterator::cons_type cons_type;$/;"	t	struct:boost::fusion::cons_detail::next_traits_impl	access:public
cons_type	xpressive/detail/utility/cons.hpp	/^            typedef typename Iterator::cons_type cons_type;$/;"	t	struct:boost::fusion::cons_detail::value_traits_impl	access:public
cons_type	xpressive/detail/utility/cons.hpp	/^        typedef Cons cons_type;$/;"	t	struct:boost::fusion::cons_iterator	access:public
cons_type	xpressive/detail/utility/cons.hpp	/^        typedef nil cons_type;$/;"	t	struct:boost::fusion::cons_iterator	access:public
cons_type	xpressive/detail/utility/cons.hpp	/^        typedef nil const cons_type;$/;"	t	struct:boost::fusion::cons_iterator	access:public
conserve	xpressive/detail/utility/sequence_stack.hpp	/^    void conserve()$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:()
const_cast_	xpressive/regex_actions.hpp	/^        struct const_cast_$/;"	s	namespace:boost::xpressive::op
const_cast_	xpressive/regex_actions.hpp	/^    const_cast_(A const &a)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A const &a)
const_iterator	xpressive/detail/core/list.hpp	/^        typedef list_iterator<T const &> const_iterator;$/;"	t	struct:boost::xpressive::detail::list	access:public
const_iterator	xpressive/detail/core/sub_match_vector.hpp	/^    > const_iterator;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
const_iterator	xpressive/detail/utility/chset/range_run.hpp	/^    typedef typename run_type::const_iterator const_iterator;$/;"	t	struct:boost::xpressive::detail::range_run	access:public
const_iterator	xpressive/match_results.hpp	/^    typedef typename detail::sub_match_vector<BidiIter>::const_iterator const_iterator;$/;"	t	struct:boost::xpressive::match_results	access:public
const_pointer	xpressive/detail/core/list.hpp	/^        typedef T const *const_pointer;$/;"	t	struct:boost::xpressive::detail::list	access:public
const_reference	xpressive/detail/core/list.hpp	/^        typedef T const &const_reference;$/;"	t	struct:boost::xpressive::detail::list	access:public
const_reference	xpressive/detail/core/sub_match_vector.hpp	/^    typedef value_type const &const_reference;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
const_reference	xpressive/match_results.hpp	/^    typedef value_type const &const_reference;$/;"	t	struct:boost::xpressive::match_results	access:public
construct	xpressive/regex_actions.hpp	/^        struct construct$/;"	s	namespace:boost::xpressive::op
construct	xpressive/regex_actions.hpp	/^    detail::unspecified construct(Args const &...args);$/;"	p	namespace:boost::xpressive	signature:(Args const &....args)
cont_type	xpressive/regex_actions.hpp	/^                    typedef typename remove_reference<Cont>::type cont_type;$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
context_	xpressive/detail/core/state.hpp	/^    match_context context_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
core_access	xpressive/detail/core/access.hpp	/^struct core_access$/;"	s	namespace:boost::xpressive::detail
count	xpressive/detail/utility/hash_peek_bitset.hpp	/^    std::size_t count() const$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:() const
count_	xpressive/detail/utility/counted_base.hpp	/^        mutable boost::detail::atomic_count count_;$/;"	m	struct:boost::xpressive::detail::counted_base	access:private
counted_base	xpressive/detail/utility/counted_base.hpp	/^        counted_base()$/;"	f	struct:boost::xpressive::detail::counted_base	access:protected	signature:()
counted_base	xpressive/detail/utility/counted_base.hpp	/^        counted_base(counted_base<Derived> const &)$/;"	f	struct:boost::xpressive::detail::counted_base	access:protected	signature:(counted_base<Derived> const &)
counted_base	xpressive/detail/utility/counted_base.hpp	/^    struct counted_base$/;"	s	namespace:boost::xpressive::detail
counted_base_access	xpressive/detail/utility/counted_base.hpp	/^    struct counted_base_access$/;"	s	namespace:boost::xpressive::detail
cpp_regex_traits	xpressive/traits/cpp_regex_traits.hpp	/^    cpp_regex_traits(locale_type const &loc = locale_type())$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(locale_type const &loc = locale_type())
cpp_regex_traits	xpressive/traits/cpp_regex_traits.hpp	/^struct cpp_regex_traits$/;"	s	namespace:boost::xpressive	inherits:detail::cpp_regex_traits_base
cpp_regex_traits_base	xpressive/traits/cpp_regex_traits.hpp	/^    struct cpp_regex_traits_base$/;"	s	namespace:boost::xpressive::detail
cpp_regex_traits_base	xpressive/traits/cpp_regex_traits.hpp	/^    struct cpp_regex_traits_base<Char, 1>$/;"	s	namespace:boost::xpressive::detail
cr_	xpressive/detail/core/matcher/assert_line_base.hpp	/^        char_type nl_, cr_;$/;"	m	struct:boost::xpressive::detail::assert_line_base	access:protected
cr_	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        char_type nl_, cr_;$/;"	m	struct:boost::xpressive::detail::logical_newline_matcher	access:private
cref	xpressive/regex_actions.hpp	/^    reference<T const> const cref(T const &t)$/;"	f	namespace:boost::xpressive	signature:(T const &t)
cregex	xpressive/xpressive_fwd.hpp	/^    typedef basic_regex<char const *>                               cregex;$/;"	t	namespace:boost::xpressive
cregex_compiler	xpressive/xpressive_fwd.hpp	/^    typedef regex_compiler<char const *>                            cregex_compiler;$/;"	t	namespace:boost::xpressive
cregex_id_filter_predicate	xpressive/xpressive_fwd.hpp	/^    typedef regex_id_filter_predicate<char const *>                 cregex_id_filter_predicate;$/;"	t	namespace:boost::xpressive
cregex_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_iterator<char const *>                            cregex_iterator;$/;"	t	namespace:boost::xpressive
cregex_token_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_token_iterator<char const *>                      cregex_token_iterator;$/;"	t	namespace:boost::xpressive
csub_match	xpressive/xpressive_fwd.hpp	/^    typedef sub_match<char const *>                                 csub_match;$/;"	t	namespace:boost::xpressive
ctype_	xpressive/traits/cpp_regex_traits.hpp	/^    std::ctype<char_type> const *ctype_;$/;"	m	class:boost::xpressive::cpp_regex_traits::std	access:private
cur_	xpressive/detail/core/state.hpp	/^    BidiIter cur_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
cur_	xpressive/detail/utility/tracking_ptr.hpp	/^    shared_ptr<Derived> cur_;$/;"	m	struct:boost::xpressive::detail::weak_iterator	access:private
curr_	xpressive/detail/utility/sequence_stack.hpp	/^        T *const begin_, *curr_, *const end_;$/;"	m	struct:boost::xpressive::detail::sequence_stack::chunk	access:public
curr_	xpressive/detail/utility/sequence_stack.hpp	/^    T *curr_;$/;"	m	struct:boost::xpressive::detail::sequence_stack	access:private
current_chunk_	xpressive/detail/utility/sequence_stack.hpp	/^    chunk *current_chunk_;$/;"	m	struct:boost::xpressive::detail::sequence_stack	access:private
data_begin	xpressive/detail/utility/algorithm.hpp	/^Char const *data_begin(Char const *const &sz)$/;"	f	namespace:boost::xpressive::detail	signature:(Char const *const &sz)
data_begin	xpressive/detail/utility/algorithm.hpp	/^Char const *data_begin(std::basic_string<Char, Traits, Alloc> const &str)$/;"	f	namespace:boost::xpressive::detail	signature:(std::basic_string<Char, Traits, Alloc> const &str)
data_begin	xpressive/detail/utility/algorithm.hpp	/^typename range_data<Cont>::type const *data_begin(Cont const &cont)$/;"	f	class:boost::xpressive::detail::range_data	signature:(Cont const &cont)
data_end	xpressive/detail/utility/algorithm.hpp	/^Char const *data_end(Char const *const &sz)$/;"	f	namespace:boost::xpressive::detail	signature:(Char const *const &sz)
data_end	xpressive/detail/utility/algorithm.hpp	/^Char const *data_end(std::basic_string<Char, Traits, Alloc> const &str)$/;"	f	namespace:boost::xpressive::detail	signature:(std::basic_string<Char, Traits, Alloc> const &str)
data_end	xpressive/detail/utility/algorithm.hpp	/^typename range_data<Cont>::type const *data_end(Cont const &cont)$/;"	f	class:boost::xpressive::detail::range_data	signature:(Cont const &cont)
data_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename impl::data data_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_attr_matcher::impl	access:public
data_type	xpressive/detail/static/transforms/as_alternate.hpp	/^                typedef typename impl::data data_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_alternate_matcher::impl	access:public
data_type	xpressive/detail/static/transforms/as_matcher.hpp	/^            typedef typename impl::data data_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_matcher::impl	access:public
data_type	xpressive/detail/static/transforms/as_set.hpp	/^            typedef typename impl::data data_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_list_set_matcher::impl	access:public
data_type	xpressive/detail/static/transforms/as_set.hpp	/^            typedef typename impl::data data_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_set_matcher::impl	access:public
deallocate	xpressive/detail/utility/sequence_stack.hpp	/^    static void deallocate(T *p, std::size_t i)$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:private	signature:(T *p, std::size_t i)
decrement	xpressive/detail/core/list.hpp	/^            void decrement() { _node = _node->_prev; }$/;"	f	struct:boost::xpressive::detail::list::list_iterator	access:private	signature:()
default_regex_traits	xpressive/xpressive_fwd.hpp	/^        struct default_regex_traits$/;"	s	namespace:boost::xpressive::detail
default_transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct default_transmogrify$/;"	s	namespace:boost::xpressive::detail
default_transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct default_transmogrify<BidiIter, ICase, Traits, Matcher, typename Matcher::is_boost_xpressive_xpression_>$/;"	s	namespace:boost::xpressive::detail
dependents_type	xpressive/detail/utility/tracking_ptr.hpp	/^    typedef std::set<weak_ptr<Derived> > dependents_type;$/;"	t	struct:boost::xpressive::detail::enable_reference_tracking	access:public
deps_	xpressive/detail/utility/tracking_ptr.hpp	/^    dependents_type deps_;$/;"	m	struct:boost::xpressive::detail::enable_reference_tracking	access:private
deref	xpressive/detail/utility/cons.hpp	/^    struct deref<fusion::cons_iterator<Cons> >$/;"	s	namespace:boost::mpl	inherits:fusion::cons_detail::value_traits_impl
deref_impl	xpressive/detail/utility/cons.hpp	/^        struct deref_impl<cons_iterator_tag>$/;"	s	namespace:boost::fusion::meta
deref_traits_impl	xpressive/detail/utility/cons.hpp	/^        struct deref_traits_impl$/;"	s	namespace:boost::fusion::cons_detail
dereference	xpressive/detail/core/list.hpp	/^            Ref dereference() const { return static_cast<node *>(_node)->_value; }$/;"	f	struct:boost::xpressive::detail::list::list_iterator	access:private	signature:() const
dereference	xpressive/detail/utility/tracking_ptr.hpp	/^    shared_ptr<Derived> const &dereference() const$/;"	f	struct:boost::xpressive::detail::weak_iterator	access:private	signature:() const
derived_	xpressive/detail/utility/tracking_ptr.hpp	/^    Derived &derived_()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:()
detail	xpressive/basic_regex.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/access.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/action.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/adaptor.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/finder.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/flow_control.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/icase.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/linker.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/list.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/action_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/alternate_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/alternate_matcher.hpp	/^    namespace detail { struct iterator_root; }$/;"	n	namespace:boost::fusion
detail	xpressive/detail/core/matcher/alternate_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/any_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/assert_bol_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/assert_bos_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/assert_eol_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/assert_eos_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/assert_line_base.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/attr_begin_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/attr_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/attr_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/charset_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/epsilon_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/keeper_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/literal_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/mark_begin_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/mark_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/mark_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/optional_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/predicate_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/range_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/regex_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/repeat_begin_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/set_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/string_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/matcher/true_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/optimize.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/peeker.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/quant_style.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/regex_domain.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/regex_impl.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/results_cache.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/state.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/sub_match_impl.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/core/sub_match_vector.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/dynamic/dynamic.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/dynamic/matchable.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/dynamic/parse_charset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/dynamic/parser.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/dynamic/sequence.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/static/compile.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/static/is_pure.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/static/modifier.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/static/placeholders.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/static/static.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/static/transforms/as_action.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/static/transforms/as_alternate.hpp	/^    namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/static/transforms/as_independent.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/static/transforms/as_modifier.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/static/transforms/as_quantifier.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/static/transmogrify.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/static/type_traits.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/static/visitor.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/static/width_of.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/algorithm.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/any.hpp	/^    namespace detail$/;"	n	namespace:boost::fusion
detail	xpressive/detail/utility/boyer_moore.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/chset/basic_chset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/chset/chset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/chset/range_run.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/counted_base.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/dont_care.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/hash_peek_bitset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/ignore_unused.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/literals.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/never_true.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/save_restore.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/sequence_stack.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/symbols.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/tracking_ptr.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/traits_utils.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/detail/utility/width.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/match_results.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/regex_actions.hpp	/^            struct detail$/;"	s	struct:boost::xpressive::op::insert	access:public
detail	xpressive/regex_actions.hpp	/^    namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/regex_algorithms.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/regex_error.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/regex_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/regex_primitives.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/regex_primitives.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/regex_token_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/traits/c_regex_traits.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/traits/cpp_regex_traits.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/traits/detail/c_ctype.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/traits/null_regex_traits.hpp	/^namespace detail$/;"	n	namespace:boost::xpressive
detail	xpressive/xpressive_fwd.hpp	/^    namespace detail$/;"	n	namespace:boost::xpressive
diff_type	xpressive/detail/core/finder.hpp	/^    typedef typename iterator_difference<BidiIter>::type diff_type;$/;"	t	struct:boost::xpressive::detail::line_start_finder	access:public
difference_type	xpressive/detail/core/sub_match_vector.hpp	/^    typedef typename iterator_difference<BidiIter>::type difference_type;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
difference_type	xpressive/match_results.hpp	/^    typedef typename iterator_difference<BidiIter>::type difference_type;$/;"	t	struct:boost::xpressive::match_results	access:public
difference_type	xpressive/regex_iterator.hpp	/^    typedef typename iterator_difference<BidiIter>::type difference_type;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
difference_type	xpressive/regex_token_iterator.hpp	/^    typedef std::ptrdiff_t difference_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
difference_type	xpressive/sub_match.hpp	/^    typedef typename iterator_difference<BidiIter>::type difference_type;$/;"	t	struct:boost::xpressive::sub_match	access:public
digit	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const digit = {{"digit", false}};$/;"	m	class:boost::xpressive::proto::terminal
dismissed	xpressive/detail/utility/sequence_stack.hpp	/^        bool dismissed;$/;"	m	struct:boost::xpressive::detail::sequence_stack::allocate_guard_t	access:public
dont_care	xpressive/detail/utility/dont_care.hpp	/^        dont_care() {}$/;"	f	struct:boost::xpressive::detail::dont_care	access:public	signature:()
dont_care	xpressive/detail/utility/dont_care.hpp	/^        dont_care(T const &) {}$/;"	f	struct:boost::xpressive::detail::dont_care	access:public	signature:(T const &)
dont_care	xpressive/detail/utility/dont_care.hpp	/^    struct dont_care$/;"	s	namespace:boost::xpressive::detail
dummy	xpressive/detail/core/sub_match_vector.hpp	/^    struct dummy { int i_; };$/;"	s	struct:boost::xpressive::detail::sub_match_vector	access:private
dummy	xpressive/match_results.hpp	/^    struct dummy { int i_; };$/;"	s	struct:boost::xpressive::match_results	access:private
dummy	xpressive/sub_match.hpp	/^    struct dummy { int i_; };$/;"	s	struct:boost::xpressive::sub_match	access:private
dump_	xpressive/detail/utility/tracking_ptr.hpp	/^    void dump_(std::ostream &sout) const;$/;"	p	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:(std::ostream &sout) const
dump_	xpressive/detail/utility/tracking_ptr.hpp	/^inline void enable_reference_tracking<Derived>::dump_(std::ostream &sout) const$/;"	f	class:boost::xpressive::detail::enable_reference_tracking	signature:(std::ostream &sout) const
dynamic_cast_	xpressive/regex_actions.hpp	/^        struct dynamic_cast_$/;"	s	namespace:boost::xpressive::op
dynamic_cast_	xpressive/regex_actions.hpp	/^    dynamic_cast_(A const &a)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A const &a)
dynamic_xpression	xpressive/detail/dynamic/dynamic.hpp	/^    dynamic_xpression(Matcher const &matcher = Matcher())$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:public	signature:(Matcher const &matcher = Matcher())
dynamic_xpression	xpressive/detail/dynamic/dynamic.hpp	/^struct dynamic_xpression$/;"	s	namespace:boost::xpressive::detail	inherits:Matcher,matchable_ex
eat_ws_	xpressive/detail/dynamic/parser_traits.hpp	/^    FwdIter &eat_ws_(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::compiler_traits	access:private	signature:(FwdIter &begin, FwdIter end)
element_type	xpressive/detail/utility/tracking_ptr.hpp	/^    typedef Type element_type;$/;"	t	struct:boost::xpressive::detail::tracking_ptr	access:public
empty	xpressive/detail/core/list.hpp	/^        bool empty() const$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:() const
empty	xpressive/detail/core/sub_match_vector.hpp	/^    bool empty() const$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:() const
empty	xpressive/detail/dynamic/sequence.hpp	/^    bool empty() const$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:() const
empty	xpressive/detail/utility/chset/basic_chset.hpp	/^    bool empty() const;$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:() const
empty	xpressive/detail/utility/chset/basic_chset.hpp	/^    bool empty() const;$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:() const
empty	xpressive/detail/utility/chset/range_run.hpp	/^    bool empty() const;$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:() const
empty	xpressive/match_results.hpp	/^    bool empty() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
empty_locale	xpressive/traits/c_regex_traits.hpp	/^    struct empty_locale$/;"	s	namespace:boost::xpressive::detail
enable_reference_tracking	xpressive/detail/utility/tracking_ptr.hpp	/^    enable_reference_tracking()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:protected	signature:()
enable_reference_tracking	xpressive/detail/utility/tracking_ptr.hpp	/^    enable_reference_tracking(enable_reference_tracking<Derived> const &that)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:protected	signature:(enable_reference_tracking<Derived> const &that)
enable_reference_tracking	xpressive/detail/utility/tracking_ptr.hpp	/^struct enable_reference_tracking$/;"	s	namespace:boost::xpressive::detail
end	xpressive/detail/core/list.hpp	/^        const_iterator end() const$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:() const
end	xpressive/detail/core/list.hpp	/^        iterator end()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
end	xpressive/detail/core/sub_match_vector.hpp	/^    const_iterator end() const$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:() const
end	xpressive/detail/utility/chset/range_run.hpp	/^    const_iterator end() const;$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:() const
end	xpressive/match_results.hpp	/^    const_iterator end() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
end	xpressive/regex_algorithms.hpp	/^      , BOOST_XPR_NONDEDUCED_TYPE_(BidiIter) end$/;"	m	namespace:boost::xpressive::detail
end_	xpressive/detail/core/matcher/string_matcher.hpp	/^        char_type const *end_;$/;"	m	struct:boost::xpressive::detail::string_matcher	access:public
end_	xpressive/detail/core/peeker.hpp	/^    Char const *end_;$/;"	m	struct:boost::xpressive::detail::peeker_string	access:public
end_	xpressive/detail/core/state.hpp	/^    BidiIter end_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
end_	xpressive/detail/utility/sequence_stack.hpp	/^        T *const begin_, *curr_, *const end_;$/;"	m	struct:boost::xpressive::detail::sequence_stack::chunk	access:public
end_	xpressive/detail/utility/sequence_stack.hpp	/^    T *end_;$/;"	m	struct:boost::xpressive::detail::sequence_stack	access:private
end_impl	xpressive/detail/utility/cons.hpp	/^        struct end_impl<cons_tag>$/;"	s	namespace:boost::fusion::meta
end_impl	xpressive/detail/utility/cons.hpp	/^    struct end_impl<fusion::cons_tag>$/;"	s	namespace:boost::mpl	inherits:fusion::meta::end_impl
end_matcher	xpressive/detail/core/matcher/end_matcher.hpp	/^    struct end_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_assertion
end_traits_impl	xpressive/detail/utility/cons.hpp	/^        struct end_traits_impl$/;"	s	namespace:boost::fusion::cons_detail
end_xpr	xpressive/detail/static/transforms/as_quantifier.hpp	/^            end_xpr;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_optional::impl	access:public
end_xpr	xpressive/detail/static/transforms/as_quantifier.hpp	/^            end_xpr;$/;"	t	struct:boost::xpressive::grammar_detail::as_mark_optional::impl	access:public
end_xpr_type	xpressive/detail/static/transforms/as_independent.hpp	/^            end_xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_keeper::impl	access:public
end_xpr_type	xpressive/detail/static/transforms/as_independent.hpp	/^            end_xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookahead::impl	access:public
end_xpr_type	xpressive/detail/static/transforms/as_independent.hpp	/^            end_xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookbehind::impl	access:public
end_xpression	xpressive/detail/detail_fwd.hpp	/^    typedef static_xpression<end_matcher, no_next> end_xpression;$/;"	t	namespace:boost::xpressive::detail
ensure_	xpressive/regex_error.hpp	/^    inline bool ensure_($/;"	f	namespace:boost::xpressive::detail	signature:( bool cond , regex_constants::error_type code , char const *msg , char const *fun , char const *file , unsigned long line )
eol	xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_eol_placeholder>::type const eol = {{}};$/;"	m	class:boost::xpressive::proto::terminal
eos	xpressive/detail/core/state.hpp	/^    bool eos()$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:()
eos	xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_eos_matcher>::type const eos = {{}};$/;"	m	class:boost::xpressive::proto::terminal
eow	xpressive/regex_primitives.hpp	/^proto::terminal<detail::assert_word_end>::type const eow = {{}};$/;"	m	class:boost::xpressive::proto::terminal
epsilon	xpressive/regex_primitives.hpp	/^proto::terminal<detail::epsilon_matcher>::type const epsilon = {{}};$/;"	m	class:boost::xpressive::proto::terminal
epsilon_matcher	xpressive/detail/core/matcher/epsilon_matcher.hpp	/^    struct epsilon_matcher$/;"	s	namespace:boost::xpressive::detail
eq	xpressive/detail/utility/symbols.hpp	/^                node* eq;$/;"	m	union:boost::xpressive::detail::symbols::node::__anon1	access:public
equal	xpressive/detail/core/list.hpp	/^            bool equal(list_iterator const &it) const { return _node == it._node; }$/;"	f	struct:boost::xpressive::detail::list::list_iterator	access:private	signature:(list_iterator const &it) const
equal	xpressive/detail/utility/tracking_ptr.hpp	/^    bool equal(weak_iterator<Derived> const &that) const$/;"	f	struct:boost::xpressive::detail::weak_iterator	access:private	signature:(weak_iterator<Derived> const &that) const
equal_to	xpressive/regex_iterator.hpp	/^    bool equal_to(regex_iterator_impl<BidiIter> const &that) const$/;"	f	struct:boost::xpressive::detail::regex_iterator_impl	access:public	signature:(regex_iterator_impl<BidiIter> const &that) const
equal_to	xpressive/regex_token_iterator.hpp	/^    bool equal_to(regex_token_iterator_impl<BidiIter> const &that) const$/;"	f	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public	signature:(regex_token_iterator_impl<BidiIter> const &that) const
error_badarg	xpressive/regex_constants.hpp	/^    error_badarg,               \/\/\/< An argument to an action was unbound.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_badattr	xpressive/regex_constants.hpp	/^    error_badattr,              \/\/\/< Tried to read from an uninitialized attribute.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_badbrace	xpressive/regex_constants.hpp	/^    error_badbrace,             \/\/\/< The expression contained an invalid range in a {} expression.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_badlookbehind	xpressive/regex_constants.hpp	/^    error_badlookbehind,        \/\/\/< An attempt to create a variable-width look-behind assertion$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_badmark	xpressive/regex_constants.hpp	/^    error_badmark,              \/\/\/< An invalid use of a named capture.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_badref	xpressive/regex_constants.hpp	/^    error_badref,               \/\/\/< An nested regex is uninitialized.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_badrepeat	xpressive/regex_constants.hpp	/^    error_badrepeat,            \/\/\/< One of *?+{ was not preceded by a valid regular expression.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_badrule	xpressive/regex_constants.hpp	/^    error_badrule,              \/\/\/< An invalid use of a rule was detected.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_brace	xpressive/regex_constants.hpp	/^    error_brace,                \/\/\/< The expression contained mismatched { and }.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_brack	xpressive/regex_constants.hpp	/^    error_brack,                \/\/\/< The expression contained mismatched [ and ].$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_collate	xpressive/regex_constants.hpp	/^    error_collate,              \/\/\/< The expression contained an invalid collating element name.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_complexity	xpressive/regex_constants.hpp	/^    error_complexity,           \/\/\/< The complexity of an attempted match against a regular$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_ctype	xpressive/regex_constants.hpp	/^    error_ctype,                \/\/\/< The expression contained an invalid character class name.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_escape	xpressive/regex_constants.hpp	/^    error_escape,               \/\/\/< The expression contained an invalid escaped character,$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_internal	xpressive/regex_constants.hpp	/^    error_internal              \/\/\/< An internal error has occurred.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_paren	xpressive/regex_constants.hpp	/^    error_paren,                \/\/\/< The expression contained mismatched ( and ).$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_range	xpressive/regex_constants.hpp	/^    error_range,                \/\/\/< The expression contained an invalid character range, for$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_space	xpressive/regex_constants.hpp	/^    error_space,                \/\/\/< There was insufficient memory to convert the expression into a$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_stack	xpressive/regex_constants.hpp	/^    error_stack,                \/\/\/< There was insufficient memory to determine whether the regular$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_subreg	xpressive/regex_constants.hpp	/^    error_subreg,               \/\/\/< The expression contained an invalid back-reference.$/;"	e	enum:boost::xpressive::regex_constants::error_type
error_type	xpressive/regex_constants.hpp	/^enum error_type$/;"	g	namespace:boost::xpressive::regex_constants
escape_char	xpressive/detail/dynamic/parse_charset.hpp	/^    escape_char$/;"	e	enum:boost::xpressive::detail::escape_type
escape_class	xpressive/detail/dynamic/parse_charset.hpp	/^  , escape_class$/;"	e	enum:boost::xpressive::detail::escape_type
escape_mark	xpressive/detail/dynamic/parse_charset.hpp	/^  , escape_mark$/;"	e	enum:boost::xpressive::detail::escape_type
escape_type	xpressive/detail/dynamic/parse_charset.hpp	/^enum escape_type$/;"	g	namespace:boost::xpressive::detail
escape_value	xpressive/detail/dynamic/parse_charset.hpp	/^struct escape_value$/;"	s	namespace:boost::xpressive::detail
escape_value	xpressive/regex_compiler.hpp	/^    typedef detail::escape_value<char_type, char_class_type> escape_value;$/;"	t	struct:boost::xpressive::regex_compiler	access:private
eval	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval$/;"	s	struct:boost::xpressive::detail::action_context	inherits:proto::default_eval	access:public
eval	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval<Expr, attr_with_default_tag>$/;"	s	struct:boost::xpressive::detail::action_context	access:public
eval	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval<Expr, proto::tag::mem_ptr>$/;"	s	struct:boost::xpressive::detail::action_context	inherits:mem_ptr_eval	access:public
eval	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval<Expr, proto::tag::terminal>$/;"	s	struct:boost::xpressive::detail::action_context	inherits:eval_terminal	access:public
eval	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        static bool eval(bool prevword, bool thisword, match_state<BidiIter> &state)$/;"	f	struct:boost::xpressive::detail::word_begin	access:public	signature:(bool prevword, bool thisword, match_state<BidiIter> &state)
eval	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        static bool eval(bool prevword, bool thisword, match_state<BidiIter> &state)$/;"	f	struct:boost::xpressive::detail::word_boundary	access:public	signature:(bool prevword, bool thisword, match_state<BidiIter> &state)
eval	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        static bool eval(bool prevword, bool thisword, match_state<BidiIter> &state)$/;"	f	struct:boost::xpressive::detail::word_end	access:public	signature:(bool prevword, bool thisword, match_state<BidiIter> &state)
eval	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval$/;"	s	struct:boost::xpressive::detail::predicate_context	inherits:proto::default_eval	access:public
eval	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval<Expr, proto::tag::mem_ptr>$/;"	s	struct:boost::xpressive::detail::predicate_context	inherits:mem_ptr_eval	access:public
eval	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval<Expr, proto::tag::terminal>$/;"	s	struct:boost::xpressive::detail::predicate_context	inherits:eval_terminal	access:public
eval_terminal	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval_terminal$/;"	s	struct:boost::xpressive::detail::action_context	inherits:proto::default_eval	access:public
eval_terminal	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval_terminal<Expr, action_arg<Type, Int> >$/;"	s	struct:boost::xpressive::detail::action_context	access:public
eval_terminal	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval_terminal<Expr, opt<Arg> >$/;"	s	struct:boost::xpressive::detail::action_context	access:public
eval_terminal	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct eval_terminal<Expr, reference_wrapper<Arg> >$/;"	s	struct:boost::xpressive::detail::action_context	access:public
eval_terminal	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval_terminal$/;"	s	struct:boost::xpressive::detail::predicate_context	inherits:proto::default_eval	access:public
eval_terminal	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval_terminal<Expr, action_arg<Type, Int> >$/;"	s	struct:boost::xpressive::detail::predicate_context	access:public
eval_terminal	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval_terminal<Expr, any_matcher>$/;"	s	struct:boost::xpressive::detail::predicate_context	access:public
eval_terminal	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval_terminal<Expr, mark_placeholder>$/;"	s	struct:boost::xpressive::detail::predicate_context	access:public
eval_terminal	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        struct eval_terminal<Expr, reference_wrapper<Arg> >$/;"	s	struct:boost::xpressive::detail::predicate_context	access:public
evaluated_args	xpressive/detail/core/matcher/action_matcher.hpp	/^        evaluated_args;$/;"	t	struct:boost::xpressive::detail::mem_ptr_eval	access:public
execute	xpressive/detail/core/action.hpp	/^        virtual void execute(action_args_type *) const {}$/;"	f	struct:boost::xpressive::detail::actionable	access:public	signature:(action_args_type *) const
execute	xpressive/detail/core/matcher/action_matcher.hpp	/^        virtual void execute(action_args_type *action_args) const$/;"	f	struct:boost::xpressive::detail::action	access:public	signature:(action_args_type *action_args) const
expr_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::detail::attr_transform::impl	access:public
expr_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::add_attrs::impl	access:public
expr_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_attr_matcher::impl	access:public
expr_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_read_attr::impl	access:public
expr_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::attr_nbr::impl	access:public
expr_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename proto::result_of::left<Expr>::type expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_action::impl	access:public
expr_type	xpressive/detail/static/transforms/as_modifier.hpp	/^            expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_modifier::impl	access:public
expr_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::add_hidden_mark::impl	access:public
expr_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_quantifier::impl	access:public
expr_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            typedef typename impl::expr expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::make_optional_::impl	access:public
extras_	xpressive/detail/core/state.hpp	/^    results_extras *extras_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
extras_ptr_	xpressive/match_results.hpp	/^    intrusive_ptr<extras_type> extras_ptr_;$/;"	m	struct:boost::xpressive::match_results	access:private
extras_type	xpressive/match_results.hpp	/^    typedef detail::results_extras<BidiIter> extras_type;$/;"	t	struct:boost::xpressive::match_results	access:private
fail	xpressive/detail/core/peeker.hpp	/^    void fail()$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:()
fill	xpressive/detail/utility/sequence_stack.hpp	/^struct fill_t {} const fill = {};$/;"	m	namespace:boost::xpressive::detail
fill_list_set	xpressive/detail/static/transforms/as_set.hpp	/^    void fill_list_set(Char *&, detail::set_initializer_type, Traits const &)$/;"	f	namespace:boost::xpressive::grammar_detail	signature:(Char *&, detail::set_initializer_type, Traits const &)
fill_list_set	xpressive/detail/static/transforms/as_set.hpp	/^    void fill_list_set(Char *&buffer, Expr const &expr, Traits const &traits)$/;"	f	namespace:boost::xpressive::grammar_detail	signature:(Char *&buffer, Expr const &expr, Traits const &traits)
fill_t	xpressive/detail/utility/sequence_stack.hpp	/^struct fill_t {} const fill = {};$/;"	s	namespace:boost::xpressive::detail
filter_self	xpressive/detail/utility/tracking_ptr.hpp	/^    filter_self(enable_reference_tracking<Derived> *self)$/;"	f	struct:boost::xpressive::detail::filter_self	access:public	signature:(enable_reference_tracking<Derived> *self)
filter_self	xpressive/detail/utility/tracking_ptr.hpp	/^struct filter_self$/;"	s	namespace:boost::xpressive::detail	inherits:std::unary_function
find	xpressive/detail/utility/boyer_moore.hpp	/^    BidiIter find(BidiIter begin, BidiIter end, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::boyer_moore	access:public	signature:(BidiIter begin, BidiIter end, Traits const &tr) const
find_	xpressive/detail/core/finder.hpp	/^    BidiIter find_(BidiIter begin, BidiIter end, Traits const &tr, ICase) const$/;"	f	struct:boost::xpressive::detail::hash_peek_finder	access:private	signature:(BidiIter begin, BidiIter end, Traits const &tr, ICase) const
find_	xpressive/detail/utility/boyer_moore.hpp	/^    BidiIter find_(BidiIter begin, BidiIter end, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::boyer_moore	access:private	signature:(BidiIter begin, BidiIter end, Traits const &tr) const
find_fun_	xpressive/detail/utility/boyer_moore.hpp	/^    BidiIter (boyer_moore::*const find_fun_)(BidiIter, BidiIter, Traits const &) const;$/;"	m	struct:boost::xpressive::detail::boyer_moore	access:private
find_nocase_	xpressive/detail/utility/boyer_moore.hpp	/^    BidiIter find_nocase_(BidiIter begin, BidiIter end, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::boyer_moore	access:private	signature:(BidiIter begin, BidiIter end, Traits const &tr) const
find_nocase_fold_	xpressive/detail/utility/boyer_moore.hpp	/^    BidiIter find_nocase_fold_(BidiIter begin, BidiIter end, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::boyer_moore	access:private	signature:(BidiIter begin, BidiIter end, Traits const &tr) const
find_nth_if	xpressive/detail/utility/algorithm.hpp	/^FwdIter find_nth_if(FwdIter begin, FwdIter end, Diff count, Pred pred)$/;"	f	namespace:boost::xpressive::detail	signature:(FwdIter begin, FwdIter end, Diff count, Pred pred)
finder	xpressive/detail/core/regex_impl.hpp	/^struct finder$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
finder_	xpressive/detail/core/regex_impl.hpp	/^    intrusive_ptr<finder<BidiIter> > finder_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
first	xpressive/regex_actions.hpp	/^        struct first$/;"	s	namespace:boost::xpressive::op
first	xpressive/regex_actions.hpp	/^    function<op::first>::type const first = {{}};$/;"	m	class:boost::xpressive::function
first_	xpressive/detail/utility/chset/range_run.hpp	/^    Char first_;$/;"	m	struct:boost::xpressive::detail::range	access:public
first_type	xpressive/regex_actions.hpp	/^                typedef typename decay<First>::type first_type;$/;"	t	struct:boost::xpressive::op::make_pair::result	access:public
flag_	xpressive/detail/dynamic/parser_traits.hpp	/^    void flag_(bool set, regex_constants::syntax_option_type flag)$/;"	f	struct:boost::xpressive::compiler_traits	access:private	signature:(bool set, regex_constants::syntax_option_type flag)
flag_type	xpressive/basic_regex.hpp	/^    typedef regex_constants::syntax_option_type flag_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
flag_type	xpressive/regex_compiler.hpp	/^    typedef regex_constants::syntax_option_type flag_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
flags	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_constants::syntax_option_type flags() const$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:() const
flags	xpressive/detail/dynamic/parser_traits.hpp	/^    void flags(regex_constants::syntax_option_type flags)$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(regex_constants::syntax_option_type flags)
flags_	xpressive/detail/core/state.hpp	/^    match_flags flags_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
flags_	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_constants::syntax_option_type flags_;$/;"	m	struct:boost::xpressive::compiler_traits	access:private
flags_	xpressive/regex_iterator.hpp	/^    regex_constants::match_flag_type const flags_;$/;"	m	class:boost::xpressive::detail::regex_iterator_impl::regex_constants	access:public
fold_	xpressive/detail/utility/boyer_moore.hpp	/^    std::vector<string_type> fold_;$/;"	m	struct:boost::xpressive::detail::boyer_moore	access:private
fold_case	xpressive/traits/c_regex_traits.hpp	/^    string_type fold_case(char_type ch) const$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch) const
fold_case	xpressive/traits/cpp_regex_traits.hpp	/^    string_type fold_case(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
fork_	xpressive/detail/utility/tracking_ptr.hpp	/^    intrusive_ptr<element_type> fork_() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:private	signature:() const
fork_	xpressive/regex_iterator.hpp	/^    void fork_()$/;"	f	struct:boost::xpressive::regex_iterator	access:private	signature:()
fork_	xpressive/regex_token_iterator.hpp	/^    void fork_()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:private	signature:()
format	xpressive/match_results.hpp	/^    OutputIterator format$/;"	f	struct:boost::xpressive::match_results	access:public	signature:( OutputIterator out , Format const &fmt , regex_constants::match_flag_type flags = regex_constants::format_default , typename disable_if<detail::is_char_ptr<Format> >::type * = 0 ) const
format	xpressive/match_results.hpp	/^    OutputIterator format$/;"	f	struct:boost::xpressive::match_results	access:public	signature:( OutputIterator out , char_type const *fmt , regex_constants::match_flag_type flags = regex_constants::format_default ) const
format	xpressive/match_results.hpp	/^    string_type format$/;"	f	struct:boost::xpressive::match_results	access:public	signature:( Format const &fmt , regex_constants::match_flag_type flags = regex_constants::format_default , typename disable_if<detail::is_char_ptr<Format> >::type * = 0 ) const
format	xpressive/match_results.hpp	/^    string_type format$/;"	f	struct:boost::xpressive::match_results	access:public	signature:( char_type const *fmt , regex_constants::match_flag_type flags = regex_constants::format_default ) const
format2_	xpressive/match_results.hpp	/^    OutputIterator format2_(OutputIterator out, Char const *const &result) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(OutputIterator out, Char const *const &result) const
format2_	xpressive/match_results.hpp	/^    OutputIterator format2_(OutputIterator out, ForwardRange const &result) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(OutputIterator out, ForwardRange const &result) const
format_	xpressive/match_results.hpp	/^    OutputIterator format_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( OutputIterator out , Callable1 const &format , regex_constants::match_flag_type , mpl::size_t<1> ) const
format_	xpressive/match_results.hpp	/^    OutputIterator format_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( OutputIterator out , Callable2 const &format , regex_constants::match_flag_type , mpl::size_t<2> ) const
format_	xpressive/match_results.hpp	/^    OutputIterator format_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( OutputIterator out , Callable3 const &format , regex_constants::match_flag_type flags , mpl::size_t<3> ) const
format_	xpressive/match_results.hpp	/^    OutputIterator format_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( OutputIterator out , Expr const &format , regex_constants::match_flag_type , mpl::size_t<4> ) const
format_	xpressive/match_results.hpp	/^    OutputIterator format_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( OutputIterator out , ForwardRange const &format , regex_constants::match_flag_type flags , mpl::size_t<0> ) const
format_all	xpressive/regex_constants.hpp	/^    format_all              = 1 << 18   \/\/\/< Specifies that all syntax extensions are enabled,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
format_all_	xpressive/match_results.hpp	/^    OutputIterator format_all_(ForwardIterator cur, ForwardIterator end, OutputIterator out) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(ForwardIterator cur, ForwardIterator end, OutputIterator out) const
format_all_impl_	xpressive/match_results.hpp	/^    OutputIterator format_all_impl_(ForwardIterator &cur, ForwardIterator end, OutputIterator out, bool metacolon = false) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(ForwardIterator &cur, ForwardIterator end, OutputIterator out, bool metacolon = false) const
format_backref_	xpressive/match_results.hpp	/^    OutputIterator format_backref_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( ForwardIterator &cur , ForwardIterator end , OutputIterator out ) const
format_default	xpressive/regex_constants.hpp	/^    format_default          = 0,        \/\/\/< Specifies that when a regular expression match is to be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
format_ecma_262_	xpressive/match_results.hpp	/^    OutputIterator format_ecma_262_(ForwardIterator cur, ForwardIterator end, OutputIterator out) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(ForwardIterator cur, ForwardIterator end, OutputIterator out) const
format_escape_	xpressive/match_results.hpp	/^    OutputIterator format_escape_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( ForwardIterator &cur , ForwardIterator end , OutputIterator out ) const
format_first_only	xpressive/regex_constants.hpp	/^    format_first_only       = 1 << 16,  \/\/\/< When specified during a search and replace operation,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
format_literal	xpressive/regex_constants.hpp	/^    format_literal          = 1 << 17,  \/\/\/< Treat the format string as a literal.$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
format_named_backref_	xpressive/match_results.hpp	/^    OutputIterator format_named_backref_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( ForwardIterator &cur , ForwardIterator end , OutputIterator out ) const
format_no_copy	xpressive/regex_constants.hpp	/^    format_no_copy          = 1 << 15,  \/\/\/< When specified during a search and replace operation,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
format_perl	xpressive/regex_constants.hpp	/^    format_perl             = 1 << 14,  \/\/\/< Specifies that when a regular expression match is to be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
format_perl_	xpressive/match_results.hpp	/^    OutputIterator format_perl_(ForwardIterator cur, ForwardIterator end, OutputIterator out) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(ForwardIterator cur, ForwardIterator end, OutputIterator out) const
format_sed	xpressive/regex_constants.hpp	/^    format_sed              = 1 << 13,  \/\/\/< Specifies that when a regular expression match is to be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
format_sed_	xpressive/match_results.hpp	/^    OutputIterator format_sed_(ForwardIterator cur, ForwardIterator end, OutputIterator out) const$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(ForwardIterator cur, ForwardIterator end, OutputIterator out) const
formatter	xpressive/match_results.hpp	/^    static formatter_wrapper<Formatter> &formatter;$/;"	m	struct:boost::xpressive::detail::formatter_arity	access:public
formatter_arity	xpressive/match_results.hpp	/^struct formatter_arity$/;"	s	namespace:boost::xpressive::detail
formatter_arity	xpressive/match_results.hpp	/^struct formatter_arity<Formatter, What, Out, typename Formatter::proto_is_expr_>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
formatter_wrapper	xpressive/match_results.hpp	/^    formatter_wrapper();$/;"	p	struct:boost::xpressive::detail::formatter_wrapper	access:public	signature:()
formatter_wrapper	xpressive/match_results.hpp	/^struct formatter_wrapper$/;"	s	namespace:boost::xpressive::detail	inherits:Formatter,unary_binary_ternary
formatter_wrapper	xpressive/match_results.hpp	/^struct formatter_wrapper<Formatter *, false>$/;"	s	namespace:boost::xpressive::detail	inherits:unary_binary_ternary
formatter_wrapper	xpressive/match_results.hpp	/^struct formatter_wrapper<Formatter, true>$/;"	s	namespace:boost::xpressive::detail	inherits:unary_binary_ternary
found_partial_match	xpressive/detail/core/state.hpp	/^    bool found_partial_match()$/;"	f	struct:boost::xpressive::detail::match_state	access:private	signature:()
found_partial_match_	xpressive/detail/core/state.hpp	/^    bool found_partial_match_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
front	xpressive/detail/core/list.hpp	/^        const_reference front() const$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:() const
front	xpressive/detail/core/list.hpp	/^        reference front()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
front	xpressive/regex_actions.hpp	/^        struct front$/;"	s	namespace:boost::xpressive::op
front	xpressive/regex_actions.hpp	/^    function<op::front>::type const front = {{}};$/;"	m	class:boost::xpressive::function
function	xpressive/detail/utility/any.hpp	/^    namespace function$/;"	n	namespace:boost::fusion
function	xpressive/regex_actions.hpp	/^    struct function$/;"	s	namespace:boost::xpressive
function_type	xpressive/detail/core/matcher/action_matcher.hpp	/^        function_type;$/;"	t	struct:boost::xpressive::detail::mem_ptr_eval	access:public
fusion	xpressive/detail/core/matcher/alternate_matcher.hpp	/^namespace boost { namespace fusion$/;"	n	namespace:boost
fusion	xpressive/detail/utility/any.hpp	/^namespace boost { namespace fusion$/;"	n	namespace:boost
fusion	xpressive/detail/utility/cons.hpp	/^namespace boost { namespace fusion$/;"	n	namespace:boost
generic_quant_tag	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct generic_quant_tag$/;"	s	namespace:boost::xpressive::detail
get	xpressive/detail/utility/tracking_ptr.hpp	/^    shared_ptr<element_type> const &get() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:() const
get	xpressive/regex_actions.hpp	/^        T &get() const$/;"	f	struct:boost::xpressive::reference	access:public	signature:() const
get	xpressive/regex_actions.hpp	/^        T &get()$/;"	f	struct:boost::xpressive::local	access:public	signature:()
get	xpressive/regex_actions.hpp	/^        T &get()$/;"	f	struct:boost::xpressive::value	access:public	signature:()
get	xpressive/regex_actions.hpp	/^        T const &get() const$/;"	f	struct:boost::xpressive::local	access:public	signature:() const
get	xpressive/regex_actions.hpp	/^        T const &get() const$/;"	f	struct:boost::xpressive::value	access:public	signature:() const
get_action_args	xpressive/detail/core/access.hpp	/^    static action_args_type &get_action_args(match_results<BidiIter> &what)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what)
get_base	xpressive/detail/core/access.hpp	/^    static BidiIter get_base(match_results<BidiIter> &what)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what)
get_charset_token	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_constants::compiler_token_type get_charset_token(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(FwdIter &begin, FwdIter end)
get_escape_token	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_constants::compiler_token_type get_escape_token(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(FwdIter &begin, FwdIter end)
get_extras	xpressive/detail/core/access.hpp	/^    static results_extras<BidiIter> &get_extras(match_results<BidiIter> &what)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what)
get_extras_	xpressive/match_results.hpp	/^    extras_type &get_extras_()$/;"	f	struct:boost::xpressive::match_results	access:private	signature:()
get_group_type	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_constants::compiler_token_type get_group_type(FwdIter &begin, FwdIter end, string_type &name)$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(FwdIter &begin, FwdIter end, string_type &name)
get_hidden_mark	xpressive/detail/static/visitor.hpp	/^        int get_hidden_mark()$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:public	signature:()
get_hidden_mark_count	xpressive/detail/core/access.hpp	/^    static std::size_t get_hidden_mark_count(basic_regex<BidiIter> const &rex)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(basic_regex<BidiIter> const &rex)
get_invalid_xpression	xpressive/detail/dynamic/dynamic.hpp	/^inline shared_matchable<BidiIter> const &get_invalid_xpression()$/;"	f	namespace:boost::xpressive::detail	signature:()
get_mark_number	xpressive/detail/detail_fwd.hpp	/^    int get_mark_number(basic_mark_tag const &);$/;"	p	namespace:boost::xpressive::detail	signature:(basic_mark_tag const &)
get_mark_number	xpressive/detail/static/static.hpp	/^inline int get_mark_number(basic_mark_tag const &mark)$/;"	f	namespace:boost::xpressive::detail	signature:(basic_mark_tag const &mark)
get_mark_number	xpressive/regex_token_iterator.hpp	/^inline int get_mark_number(int i)$/;"	f	namespace:boost::xpressive::detail	signature:(int i)
get_name_	xpressive/detail/dynamic/parser_traits.hpp	/^    void get_name_(FwdIter &begin, FwdIter end, string_type &name)$/;"	f	struct:boost::xpressive::compiler_traits	access:private	signature:(FwdIter &begin, FwdIter end, string_type &name)
get_nested_results	xpressive/detail/core/access.hpp	/^    static nested_results<BidiIter> &get_nested_results(match_results<BidiIter> &what)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what)
get_quant_spec	xpressive/detail/dynamic/parser_traits.hpp	/^    bool get_quant_spec(FwdIter &begin, FwdIter end, detail::quant_spec &spec)$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(FwdIter &begin, FwdIter end, detail::quant_spec &spec)
get_regex_impl	xpressive/detail/core/access.hpp	/^    get_regex_impl(basic_regex<BidiIter> const &rex)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(basic_regex<BidiIter> const &rex)
get_string	xpressive/detail/core/peeker.hpp	/^    peeker_string<Char> const &get_string() const$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:() const
get_sub_match_vector	xpressive/detail/core/access.hpp	/^    static sub_match_vector<BidiIter> &get_sub_match_vector(match_results<BidiIter> &what)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what)
get_sub_matches	xpressive/detail/core/access.hpp	/^    static sub_match_impl<BidiIter> *get_sub_matches(sub_match_vector<BidiIter> &subs)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(sub_match_vector<BidiIter> &subs)
get_token	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_constants::compiler_token_type get_token(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(FwdIter &begin, FwdIter end)
get_traits	xpressive/detail/core/linker.hpp	/^    Traits const &get_traits() const$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:private	signature:() const
get_traits	xpressive/detail/core/state.hpp	/^    Traits const &get_traits() const$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:() const
get_traits_	xpressive/detail/core/peeker.hpp	/^    Traits const &get_traits_() const$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:private	signature:() const
get_width	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        detail::width get_width() const$/;"	f	struct:boost::xpressive::detail::alternate_matcher	access:public	signature:() const
get_width	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        detail::width get_width() const$/;"	f	struct:boost::xpressive::detail::simple_repeat_matcher	access:public	signature:() const
get_width	xpressive/detail/core/matcher/string_matcher.hpp	/^        detail::width get_width() const$/;"	f	struct:boost::xpressive::detail::string_matcher	access:public	signature:() const
get_width	xpressive/detail/core/quant_style.hpp	/^    static detail::width get_width()$/;"	f	struct:boost::xpressive::detail::quant_style	access:public	signature:()
get_width	xpressive/detail/static/static.hpp	/^    detail::width get_width() const$/;"	f	struct:boost::xpressive::detail::no_next	access:public	signature:() const
get_width	xpressive/detail/static/static.hpp	/^    detail::width get_width() const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:public	signature:() const
get_width_	xpressive/detail/static/static.hpp	/^    detail::width get_width_(mpl::size_t<Width>) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:private	signature:(mpl::size_t<Width>) const
get_width_	xpressive/detail/static/static.hpp	/^    detail::width get_width_(unknown_width) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:private	signature:(unknown_width) const
getloc	xpressive/detail/core/linker.hpp	/^    Locale getloc() const$/;"	f	struct:boost::xpressive::detail::locale_modifier	access:public	signature:() const
getloc	xpressive/detail/dynamic/parser_traits.hpp	/^    locale_type getloc() const$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:() const
getloc	xpressive/regex_compiler.hpp	/^    locale_type getloc() const$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:() const
getloc	xpressive/traits/c_regex_traits.hpp	/^    static locale_type getloc()$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:()
getloc	xpressive/traits/cpp_regex_traits.hpp	/^    locale_type getloc() const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:() const
getloc	xpressive/traits/null_regex_traits.hpp	/^    static locale_type getloc()$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:()
glibc_isctype	xpressive/traits/detail/c_ctype.hpp	/^    static bool glibc_isctype(char ch, char_class_type mask)$/;"	f	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(char ch, char_class_type mask)
grammar_detail	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
grammar_detail	xpressive/detail/static/grammar.hpp	/^    namespace grammar_detail$/;"	n	namespace:boost::xpressive
grammar_detail	xpressive/detail/static/transforms/as_action.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
grammar_detail	xpressive/detail/static/transforms/as_alternate.hpp	/^    namespace grammar_detail$/;"	n	namespace:boost::xpressive
grammar_detail	xpressive/detail/static/transforms/as_independent.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
grammar_detail	xpressive/detail/static/transforms/as_inverse.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
grammar_detail	xpressive/detail/static/transforms/as_marker.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
grammar_detail	xpressive/detail/static/transforms/as_matcher.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
grammar_detail	xpressive/detail/static/transforms/as_modifier.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
grammar_detail	xpressive/detail/static/transforms/as_quantifier.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
grammar_detail	xpressive/detail/static/transforms/as_sequence.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
grammar_detail	xpressive/detail/static/transforms/as_set.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost::xpressive
graph	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const graph = {{"graph", false}};$/;"	m	class:boost::xpressive::proto::terminal
greedy_	xpressive/detail/dynamic/matchable.hpp	/^    bool greedy_;$/;"	m	struct:boost::xpressive::detail::quant_spec	access:public
greedy_fast_tag	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    struct greedy_fast_tag {};$/;"	s	namespace:boost::xpressive::detail
greedy_slow_tag	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    struct greedy_slow_tag {};$/;"	s	namespace:boost::xpressive::detail
greedy_type	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        typedef Greedy greedy_type;$/;"	t	struct:boost::xpressive::detail::repeat_end_matcher	access:public
greedy_type	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        typedef Greedy greedy_type;$/;"	t	struct:boost::xpressive::detail::simple_repeat_matcher	access:public
grow_	xpressive/detail/utility/sequence_stack.hpp	/^    T *grow_(std::size_t count, T const &t)$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:private	signature:(std::size_t count, T const &t)
has_backrefs	xpressive/detail/core/linker.hpp	/^    bool has_backrefs() const$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:() const
has_backrefs_	xpressive/detail/core/linker.hpp	/^    bool has_backrefs_;$/;"	m	struct:boost::xpressive::detail::xpression_linker	access:private
has_backrefs_	xpressive/detail/core/peeker.hpp	/^    bool has_backrefs_;$/;"	m	struct:boost::xpressive::detail::xpression_peeker	access:private
has_deps_	xpressive/detail/utility/tracking_ptr.hpp	/^    bool has_deps_() const$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:() const
has_deps_	xpressive/detail/utility/tracking_ptr.hpp	/^    bool has_deps_() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:private	signature:() const
has_fold_case	xpressive/regex_traits.hpp	/^struct has_fold_case$/;"	s	namespace:boost::xpressive	inherits:is_convertible
has_fold_case	xpressive/traits/c_regex_traits.hpp	/^struct has_fold_case<c_regex_traits<char> >$/;"	s	namespace:boost::xpressive	inherits:mpl::true_
has_fold_case	xpressive/traits/cpp_regex_traits.hpp	/^struct has_fold_case<cpp_regex_traits<char> >$/;"	s	namespace:boost::xpressive	inherits:mpl::true_
has_posix_	xpressive/detail/utility/chset/chset.hpp	/^    bool has_posix_;$/;"	m	struct:boost::xpressive::detail::compound_charset	access:private
hash	xpressive/traits/c_regex_traits.hpp	/^    static unsigned char hash(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
hash	xpressive/traits/c_regex_traits.hpp	/^inline unsigned char c_regex_traits<char>::hash(char ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch)
hash	xpressive/traits/c_regex_traits.hpp	/^inline unsigned char c_regex_traits<wchar_t>::hash(wchar_t ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(wchar_t ch)
hash	xpressive/traits/cpp_regex_traits.hpp	/^    static unsigned char hash(char_type ch)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch)
hash	xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<char>::hash(char ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(char ch)
hash	xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<signed char>::hash(signed char ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(signed char ch)
hash	xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<unsigned char>::hash(unsigned char ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(unsigned char ch)
hash	xpressive/traits/cpp_regex_traits.hpp	/^inline unsigned char cpp_regex_traits<wchar_t>::hash(wchar_t ch)$/;"	f	class:boost::xpressive::cpp_regex_traits	signature:(wchar_t ch)
hash	xpressive/traits/null_regex_traits.hpp	/^    static unsigned char hash(char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch)
hash_peek_bitset	xpressive/detail/utility/hash_peek_bitset.hpp	/^    hash_peek_bitset()$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:()
hash_peek_bitset	xpressive/detail/utility/hash_peek_bitset.hpp	/^struct hash_peek_bitset$/;"	s	namespace:boost::xpressive::detail
hash_peek_finder	xpressive/detail/core/finder.hpp	/^    hash_peek_finder(hash_peek_bitset<char_type> const &bset)$/;"	f	struct:boost::xpressive::detail::hash_peek_finder	access:public	signature:(hash_peek_bitset<char_type> const &bset)
hash_peek_finder	xpressive/detail/core/finder.hpp	/^    hash_peek_finder(hash_peek_finder const &);$/;"	p	struct:boost::xpressive::detail::hash_peek_finder	access:private	signature:(hash_peek_finder const &)
hash_peek_finder	xpressive/detail/core/finder.hpp	/^struct hash_peek_finder$/;"	s	namespace:boost::xpressive::detail	inherits:finder
head_	xpressive/detail/dynamic/sequence.hpp	/^    shared_matchable<BidiIter> head_;$/;"	m	struct:boost::xpressive::detail::sequence	access:private
hi	xpressive/detail/utility/symbols.hpp	/^            node* hi;$/;"	m	struct:boost::xpressive::detail::symbols::node	access:public
hidden_mark_count_	xpressive/detail/core/regex_impl.hpp	/^    std::size_t hidden_mark_count_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
hidden_mark_count_	xpressive/detail/dynamic/matchable.hpp	/^    std::size_t *hidden_mark_count_;$/;"	m	struct:boost::xpressive::detail::quant_spec	access:public
hidden_mark_count_	xpressive/regex_compiler.hpp	/^    std::size_t hidden_mark_count_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
highest_bit	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const highest_bit = static_cast<umaskex_t>(1) << (sizeof(umaskex_t) * CHAR_BIT - 1);$/;"	m	namespace:boost::xpressive::detail
i	xpressive/detail/utility/sequence_stack.hpp	/^        std::size_t i;$/;"	m	struct:boost::xpressive::detail::sequence_stack::allocate_guard_t	access:public
i_	xpressive/detail/core/sub_match_vector.hpp	/^    struct dummy { int i_; };$/;"	m	struct:boost::xpressive::detail::sub_match_vector::dummy	access:public
i_	xpressive/match_results.hpp	/^    struct dummy { int i_; };$/;"	m	struct:boost::xpressive::match_results::dummy	access:public
i_	xpressive/sub_match.hpp	/^    struct dummy { int i_; };$/;"	m	struct:boost::xpressive::sub_match::dummy	access:public
icase	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::icase;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
icase	xpressive/detail/core/icase.hpp	/^detail::modifier_op<detail::icase_modifier> const icase = {{}, regex_constants::icase_};$/;"	m	class:boost::xpressive::regex_constants::detail
icase	xpressive/detail/utility/hash_peek_bitset.hpp	/^    bool icase() const$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:() const
icase	xpressive/regex_constants.hpp	/^    icase       = 1 << 1,   \/\/\/< Specifies that matching of regular expressions against a character$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
icase	xpressive/regex_constants.hpp	21;"	d
icase	xpressive/regex_constants.hpp	291;"	d
icase	xpressive/regex_primitives.hpp	/^template<typename Expr> detail::unspecified icase(Expr const &expr) { return 0; }$/;"	f	namespace:boost::xpressive	signature:(Expr const &expr)
icase_	xpressive/detail/core/matcher/set_matcher.hpp	/^    bool icase_;$/;"	m	struct:boost::xpressive::detail::set_matcher	access:public
icase_	xpressive/detail/core/peeker.hpp	/^    bool icase_;$/;"	m	struct:boost::xpressive::detail::peeker_string	access:public
icase_	xpressive/detail/utility/hash_peek_bitset.hpp	/^    bool icase_;$/;"	m	struct:boost::xpressive::detail::hash_peek_bitset	access:private
icase_modifier	xpressive/detail/core/linker.hpp	/^struct icase_modifier$/;"	s	namespace:boost::xpressive::detail
icase_type	xpressive/detail/core/matcher/charset_matcher.hpp	/^        typedef ICase icase_type;$/;"	t	struct:boost::xpressive::detail::charset_matcher	access:public
icase_type	xpressive/detail/core/matcher/literal_matcher.hpp	/^        typedef ICase icase_type;$/;"	t	struct:boost::xpressive::detail::literal_matcher	access:public
icase_type	xpressive/detail/core/matcher/mark_matcher.hpp	/^        typedef ICase icase_type;$/;"	t	struct:boost::xpressive::detail::mark_matcher	access:public
icase_type	xpressive/detail/core/matcher/range_matcher.hpp	/^        typedef ICase icase_type;$/;"	t	struct:boost::xpressive::detail::range_matcher	access:public
icase_type	xpressive/detail/core/matcher/string_matcher.hpp	/^        typedef ICase icase_type;$/;"	t	struct:boost::xpressive::detail::string_matcher	access:public
icase_type	xpressive/detail/static/transforms/as_set.hpp	/^        typedef typename CharSet::icase_type icase_type;$/;"	t	struct:boost::xpressive::grammar_detail::merge_charset	access:public
icase_type	xpressive/detail/static/visitor.hpp	/^        typedef ICase icase_type;$/;"	t	struct:boost::xpressive::detail::xpression_visitor	access:public
ignore_unused_icase	xpressive/detail/core/icase.hpp	/^    inline void ignore_unused_icase()$/;"	f	namespace:boost::xpressive::detail	signature:()
ignore_unused_regex_actions	xpressive/regex_actions.hpp	/^        inline void ignore_unused_regex_actions()$/;"	f	namespace:boost::xpressive::detail	signature:()
ignore_unused_regex_primitives	xpressive/regex_primitives.hpp	/^    inline void ignore_unused_regex_primitives()$/;"	f	namespace:boost::xpressive::detail	signature:()
ignore_white_space	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::ignore_white_space;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
ignore_white_space	xpressive/regex_constants.hpp	/^    ignore_white_space  = 1 << 13   \/\/\/< Specifies that non-escaped white-space is not significant.$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
imbue	xpressive/detail/dynamic/parser_traits.hpp	/^    locale_type imbue(locale_type const &loc)$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:(locale_type const &loc)
imbue	xpressive/regex_compiler.hpp	/^    locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(locale_type loc)
imbue	xpressive/regex_primitives.hpp	/^imbue(Locale const &loc)$/;"	f	class:boost::xpressive::detail	signature:(Locale const &loc)
imbue	xpressive/traits/c_regex_traits.hpp	/^        static void imbue(Traits const &)$/;"	f	struct:boost::xpressive::detail::c_regex_traits_base	access:protected	signature:(Traits const &)
imbue	xpressive/traits/c_regex_traits.hpp	/^        void imbue(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::c_regex_traits_base	access:protected	signature:(Traits const &tr)
imbue	xpressive/traits/c_regex_traits.hpp	/^    locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(locale_type loc)
imbue	xpressive/traits/cpp_regex_traits.hpp	/^        void imbue(std::locale const &)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::locale const &)
imbue	xpressive/traits/cpp_regex_traits.hpp	/^        void imbue(std::locale const &loc)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::locale const &loc)
imbue	xpressive/traits/cpp_regex_traits.hpp	/^    locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(locale_type loc)
imbue	xpressive/traits/null_regex_traits.hpp	/^    static locale_type imbue(locale_type loc)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(locale_type loc)
impl	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::detail::attr_transform	inherits:proto::transform_impl	access:public
impl	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::detail::attr_with_default_transform	inherits:proto::transform_impl	access:public
impl	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::detail::by_ref_transform	inherits:proto::transform_impl	access:public
impl	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::detail::mark_transform	inherits:proto::transform_impl	access:public
impl	xpressive/detail/core/matcher/action_matcher.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::detail::subreg_transform	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_action.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::add_attrs	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_action.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_action	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_action.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_attr_matcher	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_action.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_read_attr	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_action.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::attr_nbr	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_action.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::max_attr	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_alternate.hpp	/^            struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_alternate_matcher	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_alternate.hpp	/^            struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::in_alternate_list	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_independent.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_keeper	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_independent.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_lookahead	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_independent.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_lookbehind	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_marker.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_marker	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_matcher.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_matcher	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_modifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_modifier	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::add_hidden_mark	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_default_optional	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_default_quantifier	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_default_quantifier_impl	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_mark_optional	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_simple_quantifier	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_quantifier.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::make_optional_	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_sequence.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::in_sequence	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_set.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_list_set_matcher	inherits:proto::transform_impl	access:public
impl	xpressive/detail/static/transforms/as_set.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::grammar_detail::as_set_matcher	inherits:proto::transform_impl	access:public
impl	xpressive/regex_actions.hpp	/^            T impl(sub_match<BidiIter> const &val, mpl::false_) const$/;"	f	struct:boost::xpressive::op::as	access:private	signature:(sub_match<BidiIter> const &val, mpl::false_) const
impl	xpressive/regex_actions.hpp	/^            T impl(sub_match<RandIter> const &val, mpl::true_) const$/;"	f	struct:boost::xpressive::op::as	access:private	signature:(sub_match<RandIter> const &val, mpl::true_) const
impl	xpressive/regex_primitives.hpp	/^        struct impl : proto::transform_impl<Expr, State, Data>$/;"	s	struct:boost::xpressive::detail::skip_primitives	inherits:proto::transform_impl	access:public
impl_	xpressive/detail/core/matcher/regex_matcher.hpp	/^        regex_impl<BidiIter> impl_;$/;"	m	struct:boost::xpressive::detail::regex_matcher	access:public
impl_	xpressive/detail/utility/tracking_ptr.hpp	/^    mutable intrusive_ptr<element_type> impl_;$/;"	m	struct:boost::xpressive::detail::tracking_ptr	access:private
impl_	xpressive/regex_iterator.hpp	/^    intrusive_ptr<impl_type_> impl_;$/;"	m	struct:boost::xpressive::regex_iterator	access:private
impl_	xpressive/regex_token_iterator.hpp	/^    intrusive_ptr<impl_type_> impl_;$/;"	m	struct:boost::xpressive::regex_token_iterator	access:private
impl_type_	xpressive/regex_iterator.hpp	/^    typedef detail::regex_iterator_impl<BidiIter> impl_type_;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
impl_type_	xpressive/regex_token_iterator.hpp	/^    typedef detail::regex_token_iterator_impl<BidiIter> impl_type_;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
in_alternate_list	xpressive/detail/static/transforms/as_alternate.hpp	/^        struct in_alternate_list : proto::transform<in_alternate_list<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
in_current_chunk	xpressive/detail/utility/sequence_stack.hpp	/^    bool in_current_chunk(T *ptr) const$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:private	signature:(T *ptr) const
in_range	xpressive/detail/core/matcher/range_matcher.hpp	/^        bool in_range(Traits const &tr, char_type ch, mpl::false_) const \/\/ case-sensitive$/;"	f	struct:boost::xpressive::detail::range_matcher	access:public	signature:(Traits const &tr, char_type ch, mpl::false_) const
in_range	xpressive/detail/core/matcher/range_matcher.hpp	/^        bool in_range(Traits const &tr, char_type ch, mpl::true_) const \/\/ case-insensitive$/;"	f	struct:boost::xpressive::detail::range_matcher	access:public	signature:(Traits const &tr, char_type ch, mpl::true_) const
in_range	xpressive/detail/core/regex_impl.hpp	/^    bool in_range(char_type from, char_type to, char_type ch) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type from, char_type to, char_type ch) const
in_range	xpressive/detail/core/regex_impl.hpp	/^    virtual bool in_range(Char from, Char to, Char ch) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char from, Char to, Char ch) const
in_range	xpressive/traits/c_regex_traits.hpp	/^    static bool in_range(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
in_range	xpressive/traits/cpp_regex_traits.hpp	/^    static bool in_range(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
in_range	xpressive/traits/null_regex_traits.hpp	/^    static bool in_range(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
in_range_nocase	xpressive/traits/c_regex_traits.hpp	/^    static bool in_range_nocase(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
in_range_nocase	xpressive/traits/cpp_regex_traits.hpp	/^    bool in_range_nocase(char_type first, char_type last, char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch) const
in_range_nocase	xpressive/traits/null_regex_traits.hpp	/^    static bool in_range_nocase(char_type first, char_type last, char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type first, char_type last, char_type ch)
in_sequence	xpressive/detail/static/transforms/as_sequence.hpp	/^    struct in_sequence : proto::transform<in_sequence<Grammar, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
in_set	xpressive/detail/core/matcher/set_matcher.hpp	/^    bool in_set(Traits const &tr, char_type ch) const$/;"	f	struct:boost::xpressive::detail::set_matcher	access:public	signature:(Traits const &tr, char_type ch) const
includes	xpressive/detail/utility/chset/range_run.hpp	/^    bool includes(Char v) const;$/;"	p	struct:boost::xpressive::detail::range	access:public	signature:(Char v) const
includes	xpressive/detail/utility/chset/range_run.hpp	/^    bool includes(range const &r) const;$/;"	p	struct:boost::xpressive::detail::range	access:public	signature:(range const &r) const
increment	xpressive/detail/core/list.hpp	/^            void increment() { _node = _node->_next; }$/;"	f	struct:boost::xpressive::detail::list::list_iterator	access:private	signature:()
increment	xpressive/detail/utility/tracking_ptr.hpp	/^    void increment()$/;"	f	struct:boost::xpressive::detail::weak_iterator	access:private	signature:()
independent_end_matcher	xpressive/detail/core/matcher/end_matcher.hpp	/^    struct independent_end_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_assertion
independent_end_xpression	xpressive/detail/detail_fwd.hpp	/^    typedef static_xpression<independent_end_matcher, no_next> independent_end_xpression;$/;"	t	namespace:boost::xpressive::detail
inf	xpressive/regex_primitives.hpp	/^unsigned int const inf = UINT_MAX-1;$/;"	m	namespace:boost::xpressive
init_	xpressive/detail/core/state.hpp	/^    void init_(regex_impl const &impl, match_results &what)$/;"	f	struct:boost::xpressive::detail::match_state	access:private	signature:(regex_impl const &impl, match_results &what)
init_	xpressive/detail/core/sub_match_vector.hpp	/^    void init_(sub_match_impl<BidiIter> *sub_matches, size_type size)$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:private	signature:(sub_match_impl<BidiIter> *sub_matches, size_type size)
init_	xpressive/detail/core/sub_match_vector.hpp	/^    void init_(sub_match_impl<BidiIter> *sub_matches, size_type size, sub_match_vector<BidiIter> const &that)$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:private	signature:(sub_match_impl<BidiIter> *sub_matches, size_type size, sub_match_vector<BidiIter> const &that)
init_	xpressive/detail/utility/boyer_moore.hpp	/^    void init_(Traits const &tr, mpl::false_)$/;"	f	struct:boost::xpressive::detail::boyer_moore	access:private	signature:(Traits const &tr, mpl::false_)
init_	xpressive/detail/utility/boyer_moore.hpp	/^    void init_(Traits const &tr, mpl::true_)$/;"	f	struct:boost::xpressive::detail::boyer_moore	access:private	signature:(Traits const &tr, mpl::true_)
init_	xpressive/match_results.hpp	/^    void init_$/;"	f	struct:boost::xpressive::match_results	access:private	signature:( regex_id_type regex_id , intrusive_ptr<detail::traits<char_type> const> const &tr , detail::sub_match_impl<BidiIter> *sub_matches , size_type size , std::vector<detail::named_mark<char_type> > const &named_marks )
init_match_results	xpressive/detail/core/access.hpp	/^    static void init_match_results$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:( match_results<BidiIter> &what , regex_id_type regex_id , intrusive_ptr<traits<char_type> const> const &tr , sub_match_impl<BidiIter> *sub_matches , std::size_t size , std::vector<named_mark<char_type> > const &named_marks )
init_sub_match_vector	xpressive/detail/core/access.hpp	/^    static void init_sub_match_vector$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:( sub_match_vector<BidiIter> &subs_vect , sub_match_impl<BidiIter> *subs_ptr , std::size_t size )
init_sub_match_vector	xpressive/detail/core/access.hpp	/^    static void init_sub_match_vector$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:( sub_match_vector<BidiIter> &subs_vect , sub_match_impl<BidiIter> *subs_ptr , std::size_t size , sub_match_vector<BidiIter> const &that )
insert	xpressive/detail/utility/symbols.hpp	/^        node* insert(node* p, key_iterator &begin, key_iterator end, result_type r, Trans trans) const$/;"	f	struct:boost::xpressive::detail::symbols	access:private	signature:(node* p, key_iterator &begin, key_iterator end, result_type r, Trans trans) const
insert	xpressive/regex_actions.hpp	/^        struct insert$/;"	s	namespace:boost::xpressive::op
insert	xpressive/regex_actions.hpp	/^    function<op::insert>::type const insert = {{}};$/;"	m	class:boost::xpressive::function
instances	xpressive/detail/core/regex_impl.hpp	/^    static int instances;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
instances	xpressive/detail/core/regex_impl.hpp	/^int regex_impl<BidiIter>::instances = 0;$/;"	m	class:boost::xpressive::detail::regex_impl
int_type	xpressive/detail/utility/hash_peek_bitset.hpp	/^    typedef typename std::char_traits<char_type>::int_type int_type;$/;"	t	struct:boost::xpressive::detail::hash_peek_bitset	access:public
intrusive_ptr_add_ref	xpressive/detail/utility/counted_base.hpp	/^    inline void intrusive_ptr_add_ref(counted_base<Derived> const *that)$/;"	f	namespace:boost::xpressive::detail	signature:(counted_base<Derived> const *that)
intrusive_ptr_add_ref	xpressive/detail/utility/tracking_ptr.hpp	/^inline void intrusive_ptr_add_ref(enable_reference_tracking<Derived> *p)$/;"	f	namespace:boost::xpressive::detail	signature:(enable_reference_tracking<Derived> *p)
intrusive_ptr_release	xpressive/detail/utility/counted_base.hpp	/^    inline void intrusive_ptr_release(counted_base<Derived> const *that)$/;"	f	namespace:boost::xpressive::detail	signature:(counted_base<Derived> const *that)
intrusive_ptr_release	xpressive/detail/utility/tracking_ptr.hpp	/^inline void intrusive_ptr_release(enable_reference_tracking<Derived> *p)$/;"	f	namespace:boost::xpressive::detail	signature:(enable_reference_tracking<Derived> *p)
invalid_xpression	xpressive/detail/dynamic/dynamic.hpp	/^    invalid_xpression()$/;"	f	struct:boost::xpressive::detail::invalid_xpression	access:public	signature:()
invalid_xpression	xpressive/detail/dynamic/dynamic.hpp	/^struct invalid_xpression$/;"	s	namespace:boost::xpressive::detail	inherits:matchable_ex
inverse	xpressive/detail/core/matcher/charset_matcher.hpp	/^        void inverse()$/;"	f	struct:boost::xpressive::detail::charset_matcher	access:public	signature:()
inverse	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        void inverse()$/;"	f	struct:boost::xpressive::detail::lookahead_matcher	access:public	signature:()
inverse	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        void inverse()$/;"	f	struct:boost::xpressive::detail::lookbehind_matcher	access:public	signature:()
inverse	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^        void inverse()$/;"	f	struct:boost::xpressive::detail::posix_charset_matcher	access:public	signature:()
inverse	xpressive/detail/core/matcher/range_matcher.hpp	/^        void inverse()$/;"	f	struct:boost::xpressive::detail::range_matcher	access:public	signature:()
inverse	xpressive/detail/core/matcher/set_matcher.hpp	/^    void inverse()$/;"	f	struct:boost::xpressive::detail::set_matcher	access:public	signature:()
inverse	xpressive/detail/utility/chset/basic_chset.hpp	/^    void inverse();$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:()
inverse	xpressive/detail/utility/chset/basic_chset.hpp	/^    void inverse();$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:()
inverse	xpressive/detail/utility/chset/chset.hpp	/^    void inverse()$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:()
inverter	xpressive/detail/static/transforms/as_inverse.hpp	/^    struct inverter$/;"	s	namespace:boost::xpressive::grammar_detail
inverter	xpressive/detail/static/transforms/as_inverse.hpp	/^    struct inverter<detail::assert_word_matcher<detail::word_boundary<mpl::true_>, Traits> >$/;"	s	namespace:boost::xpressive::grammar_detail
inverter	xpressive/detail/static/transforms/as_inverse.hpp	/^    struct inverter<detail::literal_matcher<Traits, ICase, Not> >$/;"	s	namespace:boost::xpressive::grammar_detail
inverter	xpressive/detail/static/transforms/as_inverse.hpp	/^    struct inverter<detail::logical_newline_matcher<Traits> >$/;"	s	namespace:boost::xpressive::grammar_detail
is	xpressive/traits/cpp_regex_traits.hpp	/^        bool is(std::ctype<Char> const &, Char ch, umaskex_t mask) const$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::ctype<Char> const &, Char ch, umaskex_t mask) const
is	xpressive/traits/cpp_regex_traits.hpp	/^        static bool is(std::ctype<Char> const &ct, Char ch, umaskex_t mask)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:protected	signature:(std::ctype<Char> const &ct, Char ch, umaskex_t mask)
is_active_regex	xpressive/detail/core/state.hpp	/^    bool is_active_regex(regex_impl const &impl) const$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:(regex_impl const &impl) const
is_alnum_	xpressive/detail/dynamic/parser_traits.hpp	/^    bool is_alnum_(char_type ch) const$/;"	f	struct:boost::xpressive::compiler_traits	access:private	signature:(char_type ch) const
is_blank	xpressive/traits/cpp_regex_traits.hpp	/^        static bool is_blank(Char ch)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private	signature:(Char ch)
is_boost_xpressive_xpression_	xpressive/detail/core/quant_style.hpp	/^    typedef void is_boost_xpressive_xpression_;$/;"	t	struct:boost::xpressive::detail::quant_style	access:public
is_char	xpressive/detail/static/type_traits.hpp	/^struct is_char$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
is_char	xpressive/detail/static/type_traits.hpp	/^struct is_char<char>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
is_char	xpressive/detail/static/type_traits.hpp	/^struct is_char<wchar_t>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
is_char_literal	xpressive/detail/static/transmogrify.hpp	/^    struct is_char_literal$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::or_
is_char_ptr	xpressive/match_results.hpp	/^struct is_char_ptr$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
is_char_ptr	xpressive/match_results.hpp	/^struct is_char_ptr<T *>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::not_
is_inverted	xpressive/detail/utility/chset/chset.hpp	/^    bool is_inverted() const$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:() const
is_narrow_char	xpressive/detail/utility/chset/basic_chset.hpp	/^struct is_narrow_char$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
is_narrow_char	xpressive/detail/utility/chset/basic_chset.hpp	/^struct is_narrow_char<char>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
is_narrow_char	xpressive/detail/utility/chset/basic_chset.hpp	/^struct is_narrow_char<signed char>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
is_narrow_char	xpressive/detail/utility/chset/basic_chset.hpp	/^struct is_narrow_char<unsigned char>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
is_newline	xpressive/traits/cpp_regex_traits.hpp	/^        static bool is_newline(Char ch)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private	signature:(Char ch)
is_null_terminated	xpressive/detail/utility/algorithm.hpp	/^inline std::ptrdiff_t is_null_terminated(char const *) { return 1; }$/;"	f	namespace:boost::xpressive::detail	signature:(char const *)
is_null_terminated	xpressive/detail/utility/algorithm.hpp	/^inline std::ptrdiff_t is_null_terminated(wchar_t const *) { return 1; }$/;"	f	namespace:boost::xpressive::detail	signature:(wchar_t const *)
is_null_terminated	xpressive/detail/utility/algorithm.hpp	/^template<typename T> std::ptrdiff_t is_null_terminated(T const &) { return 0; }$/;"	f	namespace:boost::xpressive::detail	signature:(T const &)
is_random	xpressive/detail/static/type_traits.hpp	/^struct is_random$/;"	s	namespace:boost::xpressive::detail	inherits:is_convertible
is_space_	xpressive/detail/dynamic/parser_traits.hpp	/^    bool is_space_(char_type ch) const$/;"	f	struct:boost::xpressive::compiler_traits	access:private	signature:(char_type ch) const
is_static_xpression	xpressive/detail/static/type_traits.hpp	/^struct is_static_xpression$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
is_static_xpression	xpressive/detail/static/type_traits.hpp	/^struct is_static_xpression<stacked_xpression<Top, Next> >$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
is_static_xpression	xpressive/detail/static/type_traits.hpp	/^struct is_static_xpression<static_xpression<Matcher, Next> >$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
is_string_iterator	xpressive/detail/static/type_traits.hpp	/^struct is_string_iterator$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
is_string_iterator	xpressive/detail/static/type_traits.hpp	/^struct is_string_iterator<std::string::const_iterator>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
is_string_iterator	xpressive/detail/static/type_traits.hpp	/^struct is_string_iterator<std::string::iterator>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
is_string_iterator	xpressive/detail/static/type_traits.hpp	/^struct is_string_iterator<std::wstring::const_iterator>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
is_string_iterator	xpressive/detail/static/type_traits.hpp	/^struct is_string_iterator<std::wstring::iterator>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
is_underscore	xpressive/traits/cpp_regex_traits.hpp	/^        static bool is_underscore(Char ch)$/;"	f	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private	signature:(Char ch)
is_unknown	xpressive/detail/utility/width.hpp	/^bool is_unknown(width const &that);$/;"	p	namespace:boost::xpressive::detail	signature:(width const &that)
is_unknown	xpressive/detail/utility/width.hpp	/^inline bool is_unknown(width const &that)$/;"	f	namespace:boost::xpressive::detail	signature:(width const &that)
is_upper_	xpressive/regex_compiler.hpp	/^    bool is_upper_(char_type ch) const$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(char_type ch) const
is_valid	xpressive/detail/utility/chset/range_run.hpp	/^    bool is_valid() const;$/;"	p	struct:boost::xpressive::detail::range	access:public	signature:() const
is_valid_regex	xpressive/detail/static/grammar.hpp	/^    struct is_valid_regex$/;"	s	namespace:boost::xpressive	inherits:proto::matches
is_word	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        bool is_word(Traits const &tr, char_type ch) const$/;"	f	struct:boost::xpressive::detail::assert_word_matcher	access:public	signature:(Traits const &tr, char_type ch) const
is_xpr	xpressive/detail/core/quant_style.hpp	/^struct is_xpr$/;"	s	namespace:boost::xpressive::detail	inherits:has_is_boost_xpressive_xpression_
isctype	xpressive/traits/c_regex_traits.hpp	/^    static bool isctype(char_type ch, char_class_type mask)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch, char_class_type mask)
isctype	xpressive/traits/cpp_regex_traits.hpp	/^    bool isctype(char_type ch, char_class_type mask) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch, char_class_type mask) const
isctype	xpressive/traits/detail/c_ctype.hpp	/^    static bool isctype(char ch, char_class_type mask)$/;"	f	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(char ch, char_class_type mask)
isctype	xpressive/traits/detail/c_ctype.hpp	/^    static bool isctype(wchar_t ch, char_class_type mask)$/;"	f	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(wchar_t ch, char_class_type mask)
isctype	xpressive/traits/null_regex_traits.hpp	/^    static bool isctype(char_type ch, char_class_type mask)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch, char_class_type mask)
isnewline	xpressive/traits/detail/c_ctype.hpp	/^inline bool isnewline(char ch)$/;"	f	namespace:boost::xpressive::detail	signature:(char ch)
iswnewline	xpressive/traits/detail/c_ctype.hpp	/^inline bool iswnewline(wchar_t ch)$/;"	f	namespace:boost::xpressive::detail	signature:(wchar_t ch)
iter_	xpressive/detail/utility/tracking_ptr.hpp	/^    base_iterator iter_;$/;"	m	struct:boost::xpressive::detail::weak_iterator	access:private
iter_	xpressive/regex_token_iterator.hpp	/^    regex_iterator_impl<BidiIter> iter_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
iterator	xpressive/detail/core/list.hpp	/^        typedef list_iterator<> iterator;$/;"	t	struct:boost::xpressive::detail::list	access:public
iterator	xpressive/detail/core/state.hpp	/^    typedef BidiIter iterator;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
iterator	xpressive/detail/core/sub_match_vector.hpp	/^    typedef const_iterator iterator;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
iterator	xpressive/detail/utility/chset/range_run.hpp	/^    typedef typename run_type::iterator iterator;$/;"	t	struct:boost::xpressive::detail::range_run	access:public
iterator	xpressive/detail/utility/symbols.hpp	/^        typedef typename range_const_iterator<Map>::type iterator;$/;"	t	struct:boost::xpressive::detail::symbols	access:public
iterator	xpressive/match_results.hpp	/^    typedef typename detail::sub_match_vector<BidiIter>::iterator iterator;$/;"	t	struct:boost::xpressive::match_results	access:public
iterator	xpressive/sub_match.hpp	/^    typedef BidiIter iterator;$/;"	t	struct:boost::xpressive::sub_match	access:public
iterator_category	xpressive/regex_iterator.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
iterator_category	xpressive/regex_token_iterator.hpp	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
iterator_type	xpressive/basic_regex.hpp	/^    typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
iterator_type	xpressive/detail/core/adaptor.hpp	/^    typedef typename Base::iterator_type iterator_type;$/;"	t	struct:boost::xpressive::detail::xpression_adaptor	access:public
iterator_type	xpressive/detail/dynamic/matchable.hpp	/^    typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::detail::matchable	access:public
iterator_type	xpressive/detail/dynamic/matchable.hpp	/^    typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::detail::matchable_ex	access:public
iterator_type	xpressive/detail/dynamic/matchable.hpp	/^    typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::detail::shared_matchable	access:public
iterator_type	xpressive/detail/static/visitor.hpp	/^        typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::detail::xpression_visitor	access:public
iterator_type	xpressive/regex_compiler.hpp	/^    typedef BidiIter iterator_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
keep	xpressive/regex_primitives.hpp	/^keep(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
keeper_matcher	xpressive/detail/core/matcher/keeper_matcher.hpp	/^        keeper_matcher(Xpr const &xpr, bool pure = Xpr::pure)$/;"	f	struct:boost::xpressive::detail::keeper_matcher	access:public	signature:(Xpr const &xpr, bool pure = Xpr::pure)
keeper_matcher	xpressive/detail/core/matcher/keeper_matcher.hpp	/^    struct keeper_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
keeper_tag	xpressive/detail/static/transforms/as_independent.hpp	/^    struct keeper_tag$/;"	s	namespace:boost::xpressive::detail
key_iterator	xpressive/detail/utility/symbols.hpp	/^        typedef typename range_const_iterator<key_type>::type key_iterator;$/;"	t	struct:boost::xpressive::detail::symbols	access:public
key_type	xpressive/detail/utility/symbols.hpp	/^        typedef typename range_value<Map>::type::first_type key_type;$/;"	t	struct:boost::xpressive::detail::symbols	access:public
last_	xpressive/detail/utility/boyer_moore.hpp	/^    char_type const *last_;$/;"	m	struct:boost::xpressive::detail::boyer_moore	access:private
last_	xpressive/detail/utility/chset/range_run.hpp	/^    Char last_;$/;"	m	struct:boost::xpressive::detail::range	access:public
leading_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        mutable bool leading_;$/;"	m	struct:boost::xpressive::detail::simple_repeat_matcher	access:public
leading_simple_repeat	xpressive/detail/core/peeker.hpp	/^    bool leading_simple_repeat() const$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:() const
leading_simple_repeat_	xpressive/detail/core/peeker.hpp	/^    int leading_simple_repeat_;$/;"	m	struct:boost::xpressive::detail::xpression_peeker	access:private
leading_simple_repeat_finder	xpressive/detail/core/finder.hpp	/^    leading_simple_repeat_finder()$/;"	f	struct:boost::xpressive::detail::leading_simple_repeat_finder	access:public	signature:()
leading_simple_repeat_finder	xpressive/detail/core/finder.hpp	/^    leading_simple_repeat_finder(leading_simple_repeat_finder const &);$/;"	p	struct:boost::xpressive::detail::leading_simple_repeat_finder	access:private	signature:(leading_simple_repeat_finder const &)
leading_simple_repeat_finder	xpressive/detail/core/finder.hpp	/^struct leading_simple_repeat_finder$/;"	s	namespace:boost::xpressive::detail	inherits:finder
left_type	xpressive/detail/core/matcher/action_matcher.hpp	/^        typedef typename child_<Expr, 0>::type left_type;$/;"	t	struct:boost::xpressive::detail::mem_ptr_eval	access:public
length	xpressive/match_results.hpp	/^    difference_type length(size_type sub = 0) const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(size_type sub = 0) const
length	xpressive/regex_actions.hpp	/^        struct length$/;"	s	namespace:boost::xpressive::op
length	xpressive/regex_actions.hpp	/^    function<op::length>::type const length = {{}};$/;"	m	class:boost::xpressive::function
length	xpressive/sub_match.hpp	/^    difference_type length() const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:() const
length_	xpressive/detail/utility/boyer_moore.hpp	/^    unsigned char length_;$/;"	m	struct:boost::xpressive::detail::boyer_moore	access:private
let	xpressive/match_results.hpp	/^    match_results<BidiIter> &let(Arg const &arg)$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(Arg const &arg)
let	xpressive/regex_actions.hpp	/^    detail::let_<proto::terminal<detail::let_tag>::type> const let = {{{}}};$/;"	m	class:boost::xpressive::detail
let	xpressive/regex_actions.hpp	/^    detail::unspecified let(ArgBindings const &...args);$/;"	p	namespace:boost::xpressive	signature:(ArgBindings const &....args)
let_	xpressive/regex_actions.hpp	/^        struct let_$/;"	s	namespace:boost::xpressive::detail
let_domain	xpressive/regex_actions.hpp	/^        struct let_domain$/;"	s	namespace:boost::xpressive::detail	inherits:boost::proto::domain
let_tag	xpressive/regex_actions.hpp	/^        struct let_tag$/;"	s	namespace:boost::xpressive::detail
line_start	xpressive/detail/core/peeker.hpp	/^    bool line_start() const$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:() const
line_start_	xpressive/detail/core/peeker.hpp	/^    bool line_start_;$/;"	m	struct:boost::xpressive::detail::xpression_peeker	access:private
line_start_finder	xpressive/detail/core/finder.hpp	/^    line_start_finder(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::line_start_finder	access:public	signature:(Traits const &tr)
line_start_finder	xpressive/detail/core/finder.hpp	/^    line_start_finder(line_start_finder const &);$/;"	p	struct:boost::xpressive::detail::line_start_finder	access:private	signature:(line_start_finder const &)
line_start_finder	xpressive/detail/core/finder.hpp	/^struct line_start_finder$/;"	s	namespace:boost::xpressive::detail	inherits:finder
line_start_finder	xpressive/detail/core/finder.hpp	/^struct line_start_finder<BidiIter, Traits, 1u>$/;"	s	namespace:boost::xpressive::detail	inherits:finder
link	xpressive/detail/core/adaptor.hpp	/^    void link(xpression_linker<char_type> &linker) const$/;"	f	struct:boost::xpressive::detail::xpression_adaptor	access:public	signature:(xpression_linker<char_type> &linker) const
link	xpressive/detail/dynamic/dynamic.hpp	/^    virtual void link(xpression_linker<char_type> &linker) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:public	signature:(xpression_linker<char_type> &linker) const
link	xpressive/detail/dynamic/dynamic.hpp	/^    void link(xpression_linker<Char> &linker) const$/;"	f	struct:boost::xpressive::detail::matcher_wrapper	access:public	signature:(xpression_linker<Char> &linker) const
link	xpressive/detail/dynamic/matchable.hpp	/^    virtual void link(xpression_linker<char_type> &) const$/;"	f	struct:boost::xpressive::detail::matchable_ex	access:public	signature:(xpression_linker<char_type> &) const
link	xpressive/detail/dynamic/matchable.hpp	/^    void link(xpression_linker<char_type> &linker) const$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:public	signature:(xpression_linker<char_type> &linker) const
link	xpressive/detail/static/static.hpp	/^    void link(xpression_linker<Char> &) const$/;"	f	struct:boost::xpressive::detail::no_next	access:public	signature:(xpression_linker<Char> &) const
link	xpressive/detail/static/static.hpp	/^    void link(xpression_linker<Char> &linker) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:public	signature:(xpression_linker<Char> &linker) const
linker_	xpressive/detail/core/linker.hpp	/^        xpression_linker<Char> *linker_;$/;"	m	struct:boost::xpressive::detail::xpression_linker::alt_link_pred	access:public
list	xpressive/detail/core/list.hpp	/^        list()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
list	xpressive/detail/core/list.hpp	/^        list(list const &that)$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:(list const &that)
list	xpressive/detail/core/list.hpp	/^    struct list$/;"	s	namespace:boost::xpressive::detail
list_iterator	xpressive/detail/core/list.hpp	/^            explicit list_iterator(node_base *n = 0) : _node(n) {}$/;"	f	struct:boost::xpressive::detail::list::list_iterator	access:public	signature:(node_base *n = 0)
list_iterator	xpressive/detail/core/list.hpp	/^            list_iterator(list_iterator<> const &it) : _node(it._node) {}$/;"	f	struct:boost::xpressive::detail::list::list_iterator	access:public	signature:(list_iterator< const &it)
list_iterator	xpressive/detail/core/list.hpp	/^        struct list_iterator$/;"	s	struct:boost::xpressive::detail::list	inherits:boost::iterator_facade	access:private
literal_matcher	xpressive/detail/core/matcher/literal_matcher.hpp	/^        explicit literal_matcher(char_type ch)$/;"	f	struct:boost::xpressive::detail::literal_matcher	access:public	signature:(char_type ch)
literal_matcher	xpressive/detail/core/matcher/literal_matcher.hpp	/^        literal_matcher(char_type ch, Traits const &tr)$/;"	f	struct:boost::xpressive::detail::literal_matcher	access:public	signature:(char_type ch, Traits const &tr)
literal_matcher	xpressive/detail/core/matcher/literal_matcher.hpp	/^    struct literal_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_fixed_width
lo	xpressive/detail/utility/symbols.hpp	/^            node* lo;$/;"	m	struct:boost::xpressive::detail::symbols::node	access:public
load	xpressive/detail/utility/symbols.hpp	/^        void load(Map const &map, Trans trans)$/;"	f	struct:boost::xpressive::detail::symbols	access:public	signature:(Map const &map, Trans trans)
loc_	xpressive/detail/core/linker.hpp	/^    Locale loc_;$/;"	m	struct:boost::xpressive::detail::locale_modifier	access:private
loc_	xpressive/traits/cpp_regex_traits.hpp	/^    locale_type loc_;$/;"	m	struct:boost::xpressive::cpp_regex_traits	access:private
local	xpressive/regex_actions.hpp	/^        explicit local(T const &t)$/;"	f	struct:boost::xpressive::local	access:public	signature:(T const &t)
local	xpressive/regex_actions.hpp	/^        local()$/;"	f	struct:boost::xpressive::local	access:public	signature:()
local	xpressive/regex_actions.hpp	/^    struct local$/;"	s	namespace:boost::xpressive	inherits:detail::value_wrapper,proto::terminal::type
locale_modifier	xpressive/detail/core/linker.hpp	/^    locale_modifier(Locale const &loc)$/;"	f	struct:boost::xpressive::detail::locale_modifier	access:public	signature:(Locale const &loc)
locale_modifier	xpressive/detail/core/linker.hpp	/^struct locale_modifier$/;"	s	namespace:boost::xpressive::detail
locale_type	xpressive/detail/core/linker.hpp	/^    typedef Locale locale_type;$/;"	t	struct:boost::xpressive::detail::locale_modifier	access:public
locale_type	xpressive/detail/dynamic/parser_traits.hpp	/^    typedef typename regex_traits::locale_type locale_type;$/;"	t	struct:boost::xpressive::compiler_traits	access:public
locale_type	xpressive/regex_compiler.hpp	/^    typedef typename traits_type::locale_type locale_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
locale_type	xpressive/regex_traits.hpp	/^    typedef typename Impl::locale_type locale_type;$/;"	t	struct:boost::xpressive::regex_traits	access:public
locale_type	xpressive/traits/c_regex_traits.hpp	/^    typedef detail::empty_locale locale_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
locale_type	xpressive/traits/cpp_regex_traits.hpp	/^    typedef std::locale locale_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
locale_type	xpressive/traits/null_regex_traits.hpp	/^    typedef detail::not_a_locale locale_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
logical_newline_matcher	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        logical_newline_matcher(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::logical_newline_matcher	access:public	signature:(Traits const &tr)
logical_newline_matcher	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^    struct logical_newline_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_variable_width
logical_newline_placeholder	xpressive/detail/static/placeholders.hpp	/^struct logical_newline_placeholder$/;"	s	namespace:boost::xpressive::detail
logical_newline_xpression	xpressive/detail/detail_fwd.hpp	/^    typedef proto::expr<proto::tag::terminal, proto::term<logical_newline_placeholder>, 0> logical_newline_xpression;$/;"	t	namespace:boost::xpressive::detail
lookahead_matcher	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        lookahead_matcher(Xpr const &xpr, bool no, bool pure = Xpr::pure)$/;"	f	struct:boost::xpressive::detail::lookahead_matcher	access:public	signature:(Xpr const &xpr, bool no, bool pure = Xpr::pure)
lookahead_matcher	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^    struct lookahead_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
lookahead_tag	xpressive/detail/static/transforms/as_independent.hpp	/^    struct lookahead_tag$/;"	s	namespace:boost::xpressive::detail
lookbehind_matcher	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        lookbehind_matcher(Xpr const &xpr, std::size_t wid, bool no, bool pure = Xpr::pure)$/;"	f	struct:boost::xpressive::detail::lookbehind_matcher	access:public	signature:(Xpr const &xpr, std::size_t wid, bool no, bool pure = Xpr::pure)
lookbehind_matcher	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^    struct lookbehind_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
lookbehind_tag	xpressive/detail/static/transforms/as_independent.hpp	/^    struct lookbehind_tag$/;"	s	namespace:boost::xpressive::detail
lookup_classname	xpressive/detail/detail_fwd.hpp	/^    lookup_classname(Traits const &traits, char const (&cname)[N], bool icase = false);$/;"	p	namespace:boost::xpressive	signature:(Traits const &traits, char const (&cname)[N], bool icase = false)
lookup_classname	xpressive/regex_traits.hpp	/^lookup_classname(Traits const &traits, char const (&cname)[N], bool icase)$/;"	f	namespace:boost::xpressive	signature:(Traits const &traits, char const (&cname)[N], bool icase)
lookup_classname	xpressive/traits/c_regex_traits.hpp	/^    static char_class_type lookup_classname(FwdIter begin, FwdIter end, bool icase)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end, bool icase)
lookup_classname	xpressive/traits/cpp_regex_traits.hpp	/^    char_class_type lookup_classname(FwdIter begin, FwdIter end, bool icase) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter begin, FwdIter end, bool icase) const
lookup_classname	xpressive/traits/detail/c_ctype.hpp	/^    static char_class_type lookup_classname(FwdIter begin, FwdIter end, bool icase)$/;"	f	struct:boost::xpressive::detail::char_class_impl	access:public	signature:(FwdIter begin, FwdIter end, bool icase)
lookup_classname	xpressive/traits/null_regex_traits.hpp	/^    static char_class_type lookup_classname(FwdIter begin, FwdIter end, bool icase)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end, bool icase)
lookup_classname_impl_	xpressive/traits/cpp_regex_traits.hpp	/^    static char_class_type lookup_classname_impl_(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:private	signature:(FwdIter begin, FwdIter end)
lookup_collatename	xpressive/traits/c_regex_traits.hpp	/^    static string_type lookup_collatename(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
lookup_collatename	xpressive/traits/cpp_regex_traits.hpp	/^    string_type lookup_collatename(FwdIter, FwdIter) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter, FwdIter) const
lookup_collatename	xpressive/traits/null_regex_traits.hpp	/^    static string_type lookup_collatename(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
lower	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const lower = {{"lower", false}};$/;"	m	class:boost::xpressive::proto::terminal
make_adaptor	xpressive/detail/core/adaptor.hpp	/^inline intrusive_ptr<Base const> make_adaptor(Xpr const &xpr)$/;"	f	namespace:boost::xpressive::detail	signature:(Xpr const &xpr)
make_any_xpression	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_any_xpression$/;"	f	namespace:boost::xpressive::detail	signature:( regex_constants::syntax_option_type flags , Traits const &tr )
make_assert_begin_line	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_assert_begin_line$/;"	f	namespace:boost::xpressive::detail	signature:( regex_constants::syntax_option_type flags , Traits const &tr )
make_assert_end_line	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_assert_end_line$/;"	f	namespace:boost::xpressive::detail	signature:( regex_constants::syntax_option_type flags , Traits const &tr )
make_assert_word	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_assert_word(Cond, Traits const &tr)$/;"	f	namespace:boost::xpressive::detail	signature:(Cond, Traits const &tr)
make_backref_xpression	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_backref_xpression$/;"	f	namespace:boost::xpressive::detail	signature:( int mark_nbr , regex_constants::syntax_option_type flags , Traits const &tr )
make_char_xpression	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_char_xpression$/;"	f	namespace:boost::xpressive::detail	signature:( Char ch , regex_constants::syntax_option_type flags , Traits const &tr )
make_charset_xpression	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_charset_xpression$/;"	f	namespace:boost::xpressive::detail	signature:( compound_charset<Traits> &chset , Traits const &tr , regex_constants::syntax_option_type flags )
make_cons	xpressive/detail/utility/cons.hpp	/^    make_cons(Car const& car)$/;"	f	namespace:boost::fusion	signature:(Car const& car)
make_cons	xpressive/detail/utility/cons.hpp	/^    make_cons(Car const& car, Cdr const& cdr)$/;"	f	namespace:boost::fusion	signature:(Car const& car, Cdr const& cdr)
make_dynamic	xpressive/detail/detail_fwd.hpp	/^    sequence<BidiIter> make_dynamic(Matcher const &matcher);$/;"	p	namespace:boost::xpressive::detail	signature:(Matcher const &matcher)
make_dynamic	xpressive/detail/dynamic/dynamic.hpp	/^inline sequence<BidiIter> make_dynamic(Matcher const &matcher)$/;"	f	namespace:boost::xpressive::detail	signature:(Matcher const &matcher)
make_function	xpressive/regex_actions.hpp	/^        typedef boost::proto::functional::make_expr<proto::tag::function, proto::default_domain> make_function;$/;"	t	namespace:boost::xpressive::detail
make_independent_end_xpression	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_independent_end_xpression(bool pure)$/;"	f	namespace:boost::xpressive::detail	signature:(bool pure)
make_literal_xpression	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_literal_xpression$/;"	f	namespace:boost::xpressive::detail	signature:( typename Traits::string_type const &literal , regex_constants::syntax_option_type flags , Traits const &tr )
make_optional	xpressive/detail/detail_fwd.hpp	/^    void make_optional(quant_spec const &spec, sequence<BidiIter> &seq);$/;"	p	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq)
make_optional	xpressive/detail/detail_fwd.hpp	/^    void make_optional(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr);$/;"	p	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr)
make_optional	xpressive/detail/dynamic/dynamic.hpp	/^make_optional(quant_spec const &spec, sequence<BidiIter> &seq)$/;"	f	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq)
make_optional	xpressive/detail/dynamic/dynamic.hpp	/^make_optional(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr)$/;"	f	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr)
make_optional_	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct make_optional_ : proto::transform<make_optional_<Greedy, Callable> >$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
make_pair	xpressive/regex_actions.hpp	/^        struct make_pair$/;"	s	namespace:boost::xpressive::op
make_pair	xpressive/regex_actions.hpp	/^    function<op::make_pair>::type const make_pair = {{}};$/;"	m	class:boost::xpressive::function
make_posix_charset_xpression	xpressive/detail/dynamic/parser.hpp	/^inline sequence<BidiIter> make_posix_charset_xpression$/;"	f	namespace:boost::xpressive::detail	signature:( typename Traits::char_class_type m , bool no , regex_constants::syntax_option_type , Traits const & )
make_repeat	xpressive/detail/detail_fwd.hpp	/^    void make_repeat(quant_spec const &spec, sequence<BidiIter> &seq);$/;"	p	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq)
make_repeat	xpressive/detail/detail_fwd.hpp	/^    void make_repeat(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr);$/;"	p	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr)
make_repeat	xpressive/detail/dynamic/dynamic.hpp	/^make_repeat(quant_spec const &spec, sequence<BidiIter> &seq)$/;"	f	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq)
make_repeat	xpressive/detail/dynamic/dynamic.hpp	/^make_repeat(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr)$/;"	f	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq, int mark_nbr)
make_simple_repeat	xpressive/detail/detail_fwd.hpp	/^    void make_simple_repeat(quant_spec const &spec, sequence<BidiIter> &seq);$/;"	p	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq)
make_simple_repeat	xpressive/detail/detail_fwd.hpp	/^    void make_simple_repeat(quant_spec const &spec, sequence<BidiIter> &seq, Xpr const &xpr);$/;"	p	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq, Xpr const &xpr)
make_simple_repeat	xpressive/detail/dynamic/dynamic.hpp	/^make_simple_repeat(quant_spec const &spec, sequence<BidiIter> &seq)$/;"	f	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq)
make_simple_repeat	xpressive/detail/dynamic/dynamic.hpp	/^make_simple_repeat(quant_spec const &spec, sequence<BidiIter> &seq, Xpr const &xpr)$/;"	f	namespace:boost::xpressive::detail	signature:(quant_spec const &spec, sequence<BidiIter> &seq, Xpr const &xpr)
make_static	xpressive/detail/detail_fwd.hpp	/^    make_static(Matcher const &matcher);$/;"	p	namespace:boost::xpressive::detail	signature:(Matcher const &matcher)
make_static	xpressive/detail/detail_fwd.hpp	/^    make_static(Matcher const &matcher, Next const &next);$/;"	p	namespace:boost::xpressive::detail	signature:(Matcher const &matcher, Next const &next)
make_static	xpressive/detail/static/static.hpp	/^make_static(Matcher const &matcher)$/;"	f	namespace:boost::xpressive::detail	signature:(Matcher const &matcher)
make_static	xpressive/detail/static/static.hpp	/^make_static(Matcher const &matcher, Next const &next)$/;"	f	namespace:boost::xpressive::detail	signature:(Matcher const &matcher, Next const &next)
make_tag	xpressive/regex_primitives.hpp	/^    static detail::basic_mark_tag make_tag(int mark_nbr)$/;"	f	struct:boost::xpressive::mark_tag	access:private	signature:(int mark_nbr)
mark_begin_matcher	xpressive/detail/core/matcher/mark_begin_matcher.hpp	/^        mark_begin_matcher(int mark_number)$/;"	f	struct:boost::xpressive::detail::mark_begin_matcher	access:public	signature:(int mark_number)
mark_begin_matcher	xpressive/detail/core/matcher/mark_begin_matcher.hpp	/^    struct mark_begin_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
mark_count	xpressive/basic_regex.hpp	/^    std::size_t mark_count() const$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:() const
mark_count_	xpressive/detail/core/regex_impl.hpp	/^    std::size_t mark_count_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
mark_count_	xpressive/detail/core/state.hpp	/^    std::size_t mark_count_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
mark_count_	xpressive/regex_compiler.hpp	/^    std::size_t mark_count_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
mark_end_matcher	xpressive/detail/core/matcher/mark_end_matcher.hpp	/^        mark_end_matcher(int mark_number)$/;"	f	struct:boost::xpressive::detail::mark_end_matcher	access:public	signature:(int mark_number)
mark_end_matcher	xpressive/detail/core/matcher/mark_end_matcher.hpp	/^    struct mark_end_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
mark_matcher	xpressive/detail/core/matcher/mark_matcher.hpp	/^        mark_matcher(int mark_number, Traits const &)$/;"	f	struct:boost::xpressive::detail::mark_matcher	access:public	signature:(int mark_number, Traits const &)
mark_matcher	xpressive/detail/core/matcher/mark_matcher.hpp	/^    struct mark_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_variable_width
mark_nbr	xpressive/regex_actions.hpp	/^        struct mark_nbr$/;"	s	namespace:boost::xpressive::detail
mark_nbr_	xpressive/detail/core/regex_impl.hpp	/^    std::size_t mark_nbr_;$/;"	m	struct:boost::xpressive::detail::named_mark	access:public
mark_nbr_	xpressive/detail/dynamic/parse_charset.hpp	/^    int mark_nbr_;$/;"	m	struct:boost::xpressive::detail::escape_value	access:public
mark_number	xpressive/detail/static/visitor.hpp	/^        void mark_number(int mark_nbr)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:public	signature:(int mark_nbr)
mark_number	xpressive/regex_primitives.hpp	/^    struct mark_number : proto::callable$/;"	s	namespace:boost::xpressive::detail	inherits:proto::callable
mark_number	xpressive/regex_primitives.hpp	100;"	d
mark_number	xpressive/regex_primitives.hpp	46;"	d
mark_number_	xpressive/detail/core/matcher/mark_begin_matcher.hpp	/^        int mark_number_; \/\/ signed because it could be negative$/;"	m	struct:boost::xpressive::detail::mark_begin_matcher	access:public
mark_number_	xpressive/detail/core/matcher/mark_end_matcher.hpp	/^        int mark_number_;$/;"	m	struct:boost::xpressive::detail::mark_end_matcher	access:public
mark_number_	xpressive/detail/core/matcher/mark_matcher.hpp	/^        int mark_number_;$/;"	m	struct:boost::xpressive::detail::mark_matcher	access:public
mark_number_	xpressive/detail/core/matcher/optional_matcher.hpp	/^        int mark_number_;$/;"	m	struct:boost::xpressive::detail::optional_mark_matcher	access:public
mark_number_	xpressive/detail/core/matcher/repeat_begin_matcher.hpp	/^        int mark_number_;$/;"	m	struct:boost::xpressive::detail::repeat_begin_matcher	access:public
mark_number_	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        int mark_number_;$/;"	m	struct:boost::xpressive::detail::repeat_end_matcher	access:public
mark_number_	xpressive/detail/static/placeholders.hpp	/^    int mark_number_;$/;"	m	struct:boost::xpressive::detail::mark_placeholder	access:public
mark_placeholder	xpressive/detail/static/placeholders.hpp	/^struct mark_placeholder$/;"	s	namespace:boost::xpressive::detail
mark_tag	xpressive/regex_primitives.hpp	/^    mark_tag(int mark_nbr)$/;"	f	struct:boost::xpressive::mark_tag	access:public	signature:(int mark_nbr)
mark_tag	xpressive/regex_primitives.hpp	/^struct mark_tag$/;"	s	namespace:boost::xpressive	inherits:proto::extends
mark_transform	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct mark_transform : proto::transform<mark_transform>$/;"	s	namespace:boost::xpressive::detail	inherits:proto::transform
marked_expr_type	xpressive/detail/static/transforms/as_action.hpp	/^            marked_expr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_action::impl	access:public
marked_sub_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            marked_sub_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_quantifier_impl::impl	access:public
mask_	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^        char_class_type mask_;$/;"	m	struct:boost::xpressive::detail::posix_charset_matcher	access:public
mask_cast	xpressive/traits/cpp_regex_traits.hpp	/^    struct mask_cast$/;"	s	namespace:boost::xpressive::detail
mask_cast	xpressive/traits/cpp_regex_traits.hpp	/^    struct mask_cast<std::ctype_base::print>$/;"	s	namespace:boost::xpressive::detail
masks_	xpressive/traits/cpp_regex_traits.hpp	/^        umaskex_t masks_[UCHAR_MAX + 1];$/;"	m	struct:boost::xpressive::detail::cpp_regex_traits_base	access:private
match	xpressive/detail/core/access.hpp	/^    static bool match(basic_regex<BidiIter> const &rex, match_state<BidiIter> &state)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(basic_regex<BidiIter> const &rex, match_state<BidiIter> &state)
match	xpressive/detail/core/adaptor.hpp	/^    virtual bool match(match_state<iterator_type> &state) const$/;"	f	struct:boost::xpressive::detail::xpression_adaptor	access:public	signature:(match_state<iterator_type> &state) const
match	xpressive/detail/core/matcher/action_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::action_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/alternate_end_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::alternate_end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::alternate_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/any_matcher.hpp	/^        static bool match(match_state<BidiIter> &state, Next const &next)$/;"	f	struct:boost::xpressive::detail::any_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next)
match	xpressive/detail/core/matcher/assert_bol_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::assert_bol_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/assert_bos_matcher.hpp	/^        static bool match(match_state<BidiIter> &state, Next const &next)$/;"	f	struct:boost::xpressive::detail::assert_bos_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next)
match	xpressive/detail/core/matcher/assert_eol_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::assert_eol_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/assert_eos_matcher.hpp	/^        static bool match(match_state<BidiIter> &state, Next const &next)$/;"	f	struct:boost::xpressive::detail::assert_eos_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next)
match	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::assert_word_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/attr_begin_matcher.hpp	/^        static bool match(match_state<BidiIter> &state, Next const &next)$/;"	f	struct:boost::xpressive::detail::attr_begin_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next)
match	xpressive/detail/core/matcher/attr_end_matcher.hpp	/^        static bool match(match_state<BidiIter> &state, Next const &next)$/;"	f	struct:boost::xpressive::detail::attr_end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next)
match	xpressive/detail/core/matcher/attr_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::attr_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/charset_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::charset_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/end_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &) const$/;"	f	struct:boost::xpressive::detail::independent_end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &) const
match	xpressive/detail/core/matcher/end_matcher.hpp	/^        static bool match(match_state<BidiIter> &state, Next const &)$/;"	f	struct:boost::xpressive::detail::end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &)
match	xpressive/detail/core/matcher/epsilon_matcher.hpp	/^        static bool match(match_state<BidiIter> &state, Next const &next)$/;"	f	struct:boost::xpressive::detail::epsilon_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next)
match	xpressive/detail/core/matcher/keeper_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::keeper_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/literal_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::literal_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::logical_newline_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::lookahead_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::lookbehind_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/mark_begin_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::mark_begin_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/mark_end_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::mark_end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/mark_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::mark_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/optional_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::optional_mark_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/optional_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::optional_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::posix_charset_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::predicate_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/range_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::range_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/regex_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::regex_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/repeat_begin_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::repeat_begin_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::repeat_end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/set_matcher.hpp	/^    bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::set_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::simple_repeat_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/string_matcher.hpp	/^        bool match(match_state<BidiIter> &state, Next const &next) const$/;"	f	struct:boost::xpressive::detail::string_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next) const
match	xpressive/detail/core/matcher/true_matcher.hpp	/^        static bool match(match_state<BidiIter> &, Next const &)$/;"	f	struct:boost::xpressive::detail::true_matcher	access:public	signature:(match_state<BidiIter> &, Next const &)
match	xpressive/detail/dynamic/dynamic.hpp	/^    bool match(match_state<BidiIter> &) const$/;"	f	struct:boost::xpressive::detail::invalid_xpression	access:public	signature:(match_state<BidiIter> &) const
match	xpressive/detail/dynamic/dynamic.hpp	/^    bool match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::matcher_wrapper	access:public	signature:(match_state<BidiIter> &state) const
match	xpressive/detail/dynamic/dynamic.hpp	/^    virtual bool match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:public	signature:(match_state<BidiIter> &state) const
match	xpressive/detail/dynamic/matchable.hpp	/^    bool match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:public	signature:(match_state<BidiIter> &state) const
match	xpressive/detail/dynamic/matchable.hpp	/^    virtual bool match(match_state<BidiIter> &state) const = 0;$/;"	p	struct:boost::xpressive::detail::matchable	access:public	signature:(match_state<BidiIter> &state) const
match	xpressive/detail/static/static.hpp	/^    bool match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::stacked_xpression	access:public	signature:(match_state<BidiIter> &state) const
match	xpressive/detail/static/static.hpp	/^    bool match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:public	signature:(match_state<BidiIter> &state) const
match_	xpressive/basic_regex.hpp	/^    bool match_(detail::match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::basic_regex	access:private	signature:(detail::match_state<BidiIter> &state) const
match_	xpressive/detail/core/matcher/keeper_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::keeper_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::false_) const
match_	xpressive/detail/core/matcher/keeper_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::true_) const$/;"	f	struct:boost::xpressive::detail::keeper_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::true_) const
match_	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::lookahead_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::false_) const
match_	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::true_) const$/;"	f	struct:boost::xpressive::detail::lookahead_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::true_) const
match_	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::lookbehind_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::false_) const
match_	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::true_) const$/;"	f	struct:boost::xpressive::detail::lookbehind_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::true_) const
match_	xpressive/detail/core/matcher/optional_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::false_) const \/\/ Non-greedy$/;"	f	struct:boost::xpressive::detail::optional_mark_matcher	access:private	signature:(match_state<BidiIter> &state, Next const &next, mpl::false_) const
match_	xpressive/detail/core/matcher/optional_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::false_) const \/\/ Non-greedy$/;"	f	struct:boost::xpressive::detail::optional_matcher	access:private	signature:(match_state<BidiIter> &state, Next const &next, mpl::false_) const
match_	xpressive/detail/core/matcher/optional_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::true_) const \/\/ Greedy$/;"	f	struct:boost::xpressive::detail::optional_mark_matcher	access:private	signature:(match_state<BidiIter> &state, Next const &next, mpl::true_) const
match_	xpressive/detail/core/matcher/optional_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::true_) const \/\/ Greedy$/;"	f	struct:boost::xpressive::detail::optional_matcher	access:private	signature:(match_state<BidiIter> &state, Next const &next, mpl::true_) const
match_	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::predicate_matcher	access:private	signature:(match_state<BidiIter> &state, Next const &next, mpl::false_) const
match_	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::true_) const$/;"	f	struct:boost::xpressive::detail::predicate_matcher	access:private	signature:(match_state<BidiIter> &state, Next const &next, mpl::true_) const
match_	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::repeat_end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::false_) const
match_	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, mpl::true_) const$/;"	f	struct:boost::xpressive::detail::repeat_end_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, mpl::true_) const
match_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, greedy_fast_tag) const$/;"	f	struct:boost::xpressive::detail::simple_repeat_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, greedy_fast_tag) const
match_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, greedy_slow_tag) const$/;"	f	struct:boost::xpressive::detail::simple_repeat_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, greedy_slow_tag) const
match_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        bool match_(match_state<BidiIter> &state, Next const &next, non_greedy_tag) const$/;"	f	struct:boost::xpressive::detail::simple_repeat_matcher	access:public	signature:(match_state<BidiIter> &state, Next const &next, non_greedy_tag) const
match_all_	xpressive/detail/core/state.hpp	/^    bool match_all_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
match_any	xpressive/regex_constants.hpp	/^    match_any               = 1 << 7,   \/\/\/< Specifies that if more than one match is possible then$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_bol_	xpressive/detail/core/state.hpp	/^    bool match_bol_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
match_context	xpressive/detail/core/state.hpp	/^    match_context()$/;"	f	struct:boost::xpressive::detail::match_context	access:public	signature:()
match_context	xpressive/detail/core/state.hpp	/^    typedef detail::match_context<BidiIter> match_context;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
match_context	xpressive/detail/core/state.hpp	/^struct match_context$/;"	s	namespace:boost::xpressive::detail
match_continuous	xpressive/regex_constants.hpp	/^    match_continuous        = 1 << 10,  \/\/\/< Specifies that the expression must match a sub-sequence$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_continuous_	xpressive/detail/core/state.hpp	/^    bool match_continuous_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
match_default	xpressive/regex_constants.hpp	/^    match_default           = 0,        \/\/\/< Specifies that matching of regular expressions proceeds$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_eol_	xpressive/detail/core/state.hpp	/^    bool match_eol_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
match_flag_type	xpressive/regex_constants.hpp	/^enum match_flag_type$/;"	g	namespace:boost::xpressive::regex_constants
match_flags	xpressive/detail/core/state.hpp	/^    explicit match_flags(regex_constants::match_flag_type flags)$/;"	f	struct:boost::xpressive::detail::match_flags	access:public	signature:(regex_constants::match_flag_type flags)
match_flags	xpressive/detail/core/state.hpp	/^struct match_flags$/;"	s	namespace:boost::xpressive::detail
match_next	xpressive/detail/core/matcher/optional_matcher.hpp	/^    inline bool match_next(match_state<BidiIter> &state, Next const &next, int mark_number)$/;"	f	namespace:boost::xpressive::detail	signature:(match_state<BidiIter> &state, Next const &next, int mark_number)
match_not_bol	xpressive/regex_constants.hpp	/^    match_not_bol           = 1 << 1,   \/\/\/< Specifies that the expression "^" should not be matched$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_not_bow	xpressive/regex_constants.hpp	/^    match_not_bow           = 1 << 3,   \/\/\/< Specifies that the expression "\\\\b" should not be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_not_bow_	xpressive/detail/core/state.hpp	/^    bool match_not_bow_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
match_not_eol	xpressive/regex_constants.hpp	/^    match_not_eol           = 1 << 2,   \/\/\/< Specifies that the expression "\\$" should not be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_not_eow	xpressive/regex_constants.hpp	/^    match_not_eow           = 1 << 4,   \/\/\/< Specifies that the expression "\\\\b" should not be$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_not_eow_	xpressive/detail/core/state.hpp	/^    bool match_not_eow_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
match_not_null	xpressive/regex_constants.hpp	/^    match_not_null          = 1 << 8,   \/\/\/< Specifies that the expression can not be matched$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_not_null_	xpressive/detail/core/state.hpp	/^    bool match_not_null_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
match_partial	xpressive/regex_constants.hpp	/^    match_partial           = 1 << 11,  \/\/\/< Specifies that if no match can be found, then it is$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_partial_	xpressive/detail/core/state.hpp	/^    bool match_partial_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
match_prev_avail	xpressive/regex_constants.hpp	/^    match_prev_avail        = 1 << 12,  \/\/\/< Specifies that --first is a valid iterator position,$/;"	e	enum:boost::xpressive::regex_constants::match_flag_type
match_prev_avail_	xpressive/detail/core/state.hpp	/^    bool match_prev_avail_;$/;"	m	struct:boost::xpressive::detail::match_flags	access:public
match_results	xpressive/detail/core/state.hpp	/^    typedef xpressive::match_results<BidiIter> match_results;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
match_results	xpressive/match_results.hpp	/^    match_results()$/;"	f	struct:boost::xpressive::match_results	access:public	signature:()
match_results	xpressive/match_results.hpp	/^    match_results(match_results<BidiIter> const &that)$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(match_results<BidiIter> const &that)
match_results	xpressive/match_results.hpp	/^struct match_results$/;"	s	namespace:boost::xpressive
match_state	xpressive/detail/core/state.hpp	/^    match_state$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:( BidiIter begin , BidiIter end , match_results &what , regex_impl const &impl , regex_constants::match_flag_type flags )
match_state	xpressive/detail/core/state.hpp	/^struct match_state$/;"	s	namespace:boost::xpressive::detail	inherits:noncopyable
matchable	xpressive/detail/core/state.hpp	/^    typedef detail::matchable<BidiIter> matchable;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
matchable	xpressive/detail/dynamic/matchable.hpp	/^    matchable_ptr const &matchable() const$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:public	signature:() const
matchable	xpressive/detail/dynamic/matchable.hpp	/^struct matchable$/;"	s	namespace:boost::xpressive::detail
matchable_ex	xpressive/detail/dynamic/matchable.hpp	/^struct matchable_ex$/;"	s	namespace:boost::xpressive::detail	inherits:matchable,counted_base
matchable_ptr	xpressive/detail/dynamic/matchable.hpp	/^    typedef intrusive_ptr<matchable_ex<BidiIter> const> matchable_ptr;$/;"	t	struct:boost::xpressive::detail::shared_matchable	access:public
matched	xpressive/regex_actions.hpp	/^        struct matched$/;"	s	namespace:boost::xpressive::op
matched	xpressive/regex_actions.hpp	/^    function<op::matched>::type const matched = {{}};$/;"	m	class:boost::xpressive::function
matched	xpressive/sub_match.hpp	/^    bool matched;$/;"	m	struct:boost::xpressive::sub_match	access:public
matcher_type	xpressive/detail/static/transforms/as_action.hpp	/^            matcher_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_action::impl	access:public
matcher_type	xpressive/detail/static/transforms/as_action.hpp	/^        typedef Matcher matcher_type;$/;"	t	struct:boost::xpressive::detail::read_attr	access:public
matcher_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            matcher_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_simple_quantifier::impl	access:public
matcher_wrapper	xpressive/detail/dynamic/dynamic.hpp	/^    matcher_wrapper(Matcher const &matcher = Matcher())$/;"	f	struct:boost::xpressive::detail::matcher_wrapper	access:public	signature:(Matcher const &matcher = Matcher())
matcher_wrapper	xpressive/detail/dynamic/dynamic.hpp	/^struct matcher_wrapper$/;"	s	namespace:boost::xpressive::detail	inherits:Matcher
max_	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        unsigned int min_, max_;$/;"	m	struct:boost::xpressive::detail::repeat_end_matcher	access:public
max_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        unsigned int min_, max_;$/;"	m	struct:boost::xpressive::detail::simple_repeat_matcher	access:public
max_	xpressive/detail/dynamic/matchable.hpp	/^    unsigned int max_;$/;"	m	struct:boost::xpressive::detail::quant_spec	access:public
max_attr	xpressive/detail/static/transforms/as_action.hpp	/^    struct max_attr : proto::transform<max_attr>$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:proto::transform
max_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^        typedef mpl::integral_c<uint_t, Max> max_type;$/;"	t	struct:boost::xpressive::detail::generic_quant_tag	access:public
max_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct max_type : Tag::max_type {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:Tag::max_type
max_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct max_type<proto::tag::dereference> : mpl::integral_c<uint_t, UINT_MAX-1> {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:mpl::integral_c
max_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct max_type<proto::tag::logical_not> : mpl::integral_c<uint_t, 1> {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:mpl::integral_c
max_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct max_type<proto::tag::unary_plus> : mpl::integral_c<uint_t, UINT_MAX-1> {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:mpl::integral_c
mem_ptr_eval	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct mem_ptr_eval$/;"	s	namespace:boost::xpressive::detail
mem_ptr_eval	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct mem_ptr_eval<Expr, Context, true>$/;"	s	namespace:boost::xpressive::detail
memento	xpressive/detail/core/state.hpp	/^struct memento$/;"	s	namespace:boost::xpressive::detail
merge	xpressive/detail/utility/chset/range_run.hpp	/^    void merge(iterator iter, range_type const &r);$/;"	p	struct:boost::xpressive::detail::range_run	access:private	signature:(iterator iter, range_type const &r)
merge	xpressive/detail/utility/chset/range_run.hpp	/^    void merge(range const &r);$/;"	p	struct:boost::xpressive::detail::range	access:public	signature:(range const &r)
merge_charset	xpressive/detail/dynamic/parser.hpp	/^inline void merge_charset$/;"	f	namespace:boost::xpressive::detail	signature:( basic_chset<Char> &basic , compound_charset<Traits> const &compound , Traits const &tr )
merge_charset	xpressive/detail/static/transforms/as_set.hpp	/^        merge_charset(CharSet &charset, Data &data)$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:public	signature:(CharSet &charset, Data &data)
merge_charset	xpressive/detail/static/transforms/as_set.hpp	/^    struct merge_charset$/;"	s	namespace:boost::xpressive::grammar_detail
meta	xpressive/detail/utility/any.hpp	/^    namespace meta$/;"	n	namespace:boost::fusion
meta	xpressive/detail/utility/cons.hpp	/^    namespace meta$/;"	n	namespace:boost::fusion
min_	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        unsigned int min_, max_;$/;"	m	struct:boost::xpressive::detail::repeat_end_matcher	access:public
min_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        unsigned int min_, max_;$/;"	m	struct:boost::xpressive::detail::simple_repeat_matcher	access:public
min_	xpressive/detail/dynamic/matchable.hpp	/^    unsigned int min_;$/;"	m	struct:boost::xpressive::detail::quant_spec	access:public
min_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^        typedef mpl::integral_c<uint_t, Min> min_type;$/;"	t	struct:boost::xpressive::detail::generic_quant_tag	access:public
min_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct min_type : Tag::min_type {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:Tag::min_type
min_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct min_type<proto::tag::dereference> : mpl::integral_c<uint_t, 0> {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:mpl::integral_c
min_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct min_type<proto::tag::logical_not> : mpl::integral_c<uint_t, 0> {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:mpl::integral_c
min_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct min_type<proto::tag::unary_plus> : mpl::integral_c<uint_t, 1> {};$/;"	s	namespace:boost::xpressive::grammar_detail	inherits:mpl::integral_c
minus_one	xpressive/regex_primitives.hpp	/^    typedef mpl::int_<-1> minus_one;$/;"	t	namespace:boost::xpressive::detail
minus_one	xpressive/regex_primitives.hpp	101;"	d
minus_one	xpressive/regex_primitives.hpp	47;"	d
mod_	xpressive/detail/static/modifier.hpp	/^        Modifier mod_;$/;"	m	struct:boost::xpressive::detail::modifier_op	access:public
modifier_op	xpressive/detail/static/modifier.hpp	/^    struct modifier_op$/;"	s	namespace:boost::xpressive::detail
modifier_tag	xpressive/detail/static/transforms/as_modifier.hpp	/^    struct modifier_tag$/;"	s	namespace:boost::xpressive::detail
modifier_type	xpressive/detail/static/transforms/as_modifier.hpp	/^            modifier_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_modifier::impl	access:public
mpl	xpressive/detail/utility/cons.hpp	/^namespace boost { namespace mpl$/;"	n	namespace:boost
mylog2	xpressive/traits/cpp_regex_traits.hpp	/^    inline int mylog2(umaskex_t i)$/;"	f	namespace:boost::xpressive::detail	signature:(umaskex_t i)
n_	xpressive/regex_token_iterator.hpp	/^    int n_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
name_	xpressive/detail/core/regex_impl.hpp	/^    string_type name_;$/;"	m	struct:boost::xpressive::detail::named_mark	access:public
name_	xpressive/detail/static/placeholders.hpp	/^    char const *name_;$/;"	m	struct:boost::xpressive::detail::posix_charset_placeholder	access:public
named_mark	xpressive/detail/core/regex_impl.hpp	/^    named_mark(string_type name, std::size_t mark_nbr)$/;"	f	struct:boost::xpressive::detail::named_mark	access:public	signature:(string_type name, std::size_t mark_nbr)
named_mark	xpressive/detail/core/regex_impl.hpp	/^struct named_mark$/;"	s	namespace:boost::xpressive::detail
named_marks_	xpressive/detail/core/regex_impl.hpp	/^    std::vector<named_mark<char_type> > named_marks_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
named_marks_	xpressive/match_results.hpp	/^    std::vector<detail::named_mark<char_type> > named_marks_;$/;"	m	struct:boost::xpressive::match_results	access:private
nbr	xpressive/detail/static/placeholders.hpp	/^    static Nbr nbr() { return Nbr(); }$/;"	f	struct:boost::xpressive::detail::attribute_placeholder	access:public	signature:()
nbr	xpressive/detail/static/transforms/as_action.hpp	/^        static Nbr nbr() { return Nbr(); }$/;"	f	struct:boost::xpressive::detail::read_attr	access:public	signature:()
nbr_type	xpressive/detail/static/placeholders.hpp	/^    typedef Nbr nbr_type;$/;"	t	struct:boost::xpressive::detail::attribute_placeholder	access:public
nbr_type	xpressive/detail/static/transforms/as_action.hpp	/^        typedef Nbr nbr_type;$/;"	t	struct:boost::xpressive::detail::read_attr	access:public
nested_results	xpressive/detail/core/results_cache.hpp	/^    struct nested_results$/;"	s	namespace:boost::xpressive::detail	inherits:detail::list
nested_results	xpressive/match_results.hpp	/^    nested_results_type const &nested_results() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
nested_results_	xpressive/match_results.hpp	/^    nested_results_type nested_results_;$/;"	m	struct:boost::xpressive::match_results	access:private
nested_results_count_	xpressive/detail/core/state.hpp	/^    std::size_t nested_results_count_;$/;"	m	struct:boost::xpressive::detail::memento	access:public
nested_results_type	xpressive/match_results.hpp	/^    typedef typename detail::nested_results<BidiIter> nested_results_type;$/;"	t	struct:boost::xpressive::match_results	access:public
never_true	xpressive/detail/utility/never_true.hpp	/^    struct never_true$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
newline	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        char_class_type newline() const$/;"	f	struct:boost::xpressive::detail::logical_newline_matcher	access:public	signature:() const
newline_	xpressive/detail/core/finder.hpp	/^    char_class_type newline_;$/;"	m	struct:boost::xpressive::detail::line_start_finder	access:private
newline_	xpressive/detail/core/matcher/assert_line_base.hpp	/^        char_class_type newline_;$/;"	m	struct:boost::xpressive::detail::assert_line_base	access:protected
newline_	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        char_class_type newline_;$/;"	m	struct:boost::xpressive::detail::logical_newline_matcher	access:private
next	xpressive/detail/core/action.hpp	/^        actionable const *next;$/;"	m	struct:boost::xpressive::detail::actionable	access:public
next	xpressive/detail/utility/cons.hpp	/^    struct next<fusion::cons_iterator<Cons> >$/;"	s	namespace:boost::mpl	inherits:fusion::cons_detail::next_traits_impl
next	xpressive/regex_iterator.hpp	/^    bool next()$/;"	f	struct:boost::xpressive::detail::regex_iterator_impl	access:public	signature:()
next	xpressive/regex_token_iterator.hpp	/^    bool next()$/;"	f	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public	signature:()
next_	xpressive/detail/core/linker.hpp	/^        void const *next_;$/;"	m	struct:boost::xpressive::detail::xpression_linker::alt_link_pred	access:public
next_	xpressive/detail/dynamic/dynamic.hpp	/^    shared_matchable<BidiIter> next_;$/;"	m	struct:boost::xpressive::detail::dynamic_xpression	access:private
next_	xpressive/detail/static/static.hpp	/^    Next next_;$/;"	m	struct:boost::xpressive::detail::static_xpression	access:public
next_	xpressive/detail/utility/sequence_stack.hpp	/^        chunk *back_, *next_;$/;"	m	struct:boost::xpressive::detail::sequence_stack::chunk	access:public
next_	xpressive/match_results.hpp	/^    transform_op next_, rest_;$/;"	m	struct:boost::xpressive::detail::case_converting_iterator	access:private
next_	xpressive/regex_iterator.hpp	/^    void next_()$/;"	f	struct:boost::xpressive::regex_iterator	access:private	signature:()
next_	xpressive/regex_token_iterator.hpp	/^    void next_()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:private	signature:()
next_impl	xpressive/detail/utility/cons.hpp	/^        struct next_impl<cons_iterator_tag>$/;"	s	namespace:boost::fusion::meta
next_ptr_	xpressive/detail/core/state.hpp	/^    matchable<BidiIter> const *next_ptr_;$/;"	m	struct:boost::xpressive::detail::match_context	access:public
next_search_	xpressive/detail/core/state.hpp	/^    BidiIter next_search_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
next_traits_impl	xpressive/detail/utility/cons.hpp	/^        struct next_traits_impl$/;"	s	namespace:boost::fusion::cons_detail
nil	xpressive/detail/utility/cons.hpp	/^    struct nil : sequence_base<nil>$/;"	s	namespace:boost::fusion	inherits:sequence_base
nil	xpressive/regex_primitives.hpp	/^proto::terminal<detail::epsilon_matcher>::type const nil = {{}};$/;"	m	class:boost::xpressive::proto::terminal
nl_	xpressive/detail/core/matcher/assert_line_base.hpp	/^        char_type nl_, cr_;$/;"	m	struct:boost::xpressive::detail::assert_line_base	access:protected
nl_	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^        char_type nl_, cr_;$/;"	m	struct:boost::xpressive::detail::logical_newline_matcher	access:private
no_attr_type	xpressive/detail/static/transforms/as_action.hpp	/^            no_attr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_action::impl	access:public
no_next	xpressive/detail/static/static.hpp	/^struct no_next$/;"	s	namespace:boost::xpressive::detail
no_type	xpressive/match_results.hpp	/^typedef char no_type;$/;"	t	namespace:boost::xpressive::detail
no_type	xpressive/regex_actions.hpp	/^                    typedef char (&no_type)[2];$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
nocase	xpressive/detail/core/matcher/set_matcher.hpp	/^    void nocase(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::set_matcher	access:public	signature:(Traits const &tr)
node	xpressive/detail/core/list.hpp	/^            explicit node(T const &value)$/;"	f	struct:boost::xpressive::detail::list::node	access:public	signature:(T const &value)
node	xpressive/detail/core/list.hpp	/^        struct node : node_base$/;"	s	struct:boost::xpressive::detail::list	inherits:node_base	access:private
node	xpressive/detail/utility/symbols.hpp	/^            node(char_type c)$/;"	f	struct:boost::xpressive::detail::symbols::node	access:public	signature:(char_type c)
node	xpressive/detail/utility/symbols.hpp	/^        struct node$/;"	s	struct:boost::xpressive::detail::symbols	inherits:boost::noncopyable	access:private
node_base	xpressive/detail/core/list.hpp	/^        struct node_base$/;"	s	struct:boost::xpressive::detail::list	access:private
non_greedy_tag	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    struct non_greedy_tag {};$/;"	s	namespace:boost::xpressive::detail
non_std_ctype_blank	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_blank = 1 << 12;$/;"	m	namespace:boost::xpressive::detail
non_std_ctype_blank	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_blank = unused_mask<all_ctype_masks | non_std_ctype_underscore>::value;$/;"	m	namespace:boost::xpressive::detail
non_std_ctype_masks	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_masks = non_std_ctype_underscore | non_std_ctype_blank | non_std_ctype_newline;$/;"	m	namespace:boost::xpressive::detail
non_std_ctype_newline	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_newline = 1 << 13;$/;"	m	namespace:boost::xpressive::detail
non_std_ctype_newline	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_newline = unused_mask<all_ctype_masks | non_std_ctype_underscore | non_std_ctype_blank>::value;$/;"	m	namespace:boost::xpressive::detail
non_std_ctype_underscore	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_underscore = 1 << 11;$/;"	m	namespace:boost::xpressive::detail
non_std_ctype_underscore	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const non_std_ctype_underscore = unused_mask<all_ctype_masks>::value;$/;"	m	namespace:boost::xpressive::detail
noop_output_iterator	xpressive/match_results.hpp	/^struct noop_output_iterator$/;"	s	namespace:boost::xpressive::detail	inherits:std::iterator
nosubs	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::nosubs;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
nosubs	xpressive/regex_constants.hpp	/^    nosubs      = 1 << 2,   \/\/\/< Specifies that when a regular expression is matched against a$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
not_	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        bool not_;$/;"	m	struct:boost::xpressive::detail::lookahead_matcher	access:public
not_	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        bool not_;$/;"	m	struct:boost::xpressive::detail::lookbehind_matcher	access:public
not_	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^        bool not_;$/;"	m	struct:boost::xpressive::detail::posix_charset_matcher	access:public
not_	xpressive/detail/core/matcher/range_matcher.hpp	/^        bool not_;$/;"	m	struct:boost::xpressive::detail::range_matcher	access:public
not_	xpressive/detail/core/matcher/set_matcher.hpp	/^    bool not_;$/;"	m	struct:boost::xpressive::detail::set_matcher	access:public
not_	xpressive/detail/static/placeholders.hpp	/^    bool not_;$/;"	m	struct:boost::xpressive::detail::posix_charset_placeholder	access:public
not_	xpressive/detail/static/placeholders.hpp	/^    bool not_;$/;"	m	struct:boost::xpressive::detail::range_placeholder	access:public
not_a_locale	xpressive/traits/null_regex_traits.hpp	/^    struct not_a_locale {};$/;"	s	namespace:boost::xpressive::detail
not_dot_newline	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::not_dot_newline;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
not_dot_newline	xpressive/regex_constants.hpp	/^    not_dot_newline     = 1 << 12,  \/\/\/< Specifies that the . metacharacter does not match the$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
not_dot_null	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::not_dot_null;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
not_dot_null	xpressive/regex_constants.hpp	/^    not_dot_null        = 1 << 11,  \/\/\/< Specifies that the . metacharacter does not match the null$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
not_null_	xpressive/regex_iterator.hpp	/^    bool not_null_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
not_posix_pred	xpressive/detail/utility/chset/chset.hpp	/^    struct not_posix_pred$/;"	s	struct:boost::xpressive::detail::compound_charset	access:private
not_type	xpressive/detail/core/matcher/literal_matcher.hpp	/^        typedef Not not_type;$/;"	t	struct:boost::xpressive::detail::literal_matcher	access:public
null_regex_traits	xpressive/traits/null_regex_traits.hpp	/^    null_regex_traits(locale_type = locale_type())$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(locale_type = locale_type())
null_regex_traits	xpressive/traits/null_regex_traits.hpp	/^struct null_regex_traits$/;"	s	namespace:boost::xpressive
offsets_	xpressive/detail/utility/boyer_moore.hpp	/^    unsigned char offsets_[UCHAR_MAX + 1];$/;"	m	struct:boost::xpressive::detail::boyer_moore	access:private
ok_for_partial_matches	xpressive/detail/core/finder.hpp	/^    bool ok_for_partial_matches() const$/;"	f	struct:boost::xpressive::detail::boyer_moore_finder	access:public	signature:() const
ok_for_partial_matches	xpressive/detail/core/regex_impl.hpp	/^    virtual bool ok_for_partial_matches() const { return true; }$/;"	f	struct:boost::xpressive::detail::finder	access:public	signature:() const
old_sub_matches_	xpressive/detail/core/state.hpp	/^    sub_match_impl<BidiIter> *old_sub_matches_;$/;"	m	struct:boost::xpressive::detail::memento	access:public
op	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive { namespace op$/;"	n	namespace:boost::xpressive
op	xpressive/regex_actions.hpp	/^    namespace op$/;"	n	namespace:boost::xpressive
op	xpressive/xpressive_fwd.hpp	/^    namespace op$/;"	n	namespace:boost::xpressive
op_lower	xpressive/match_results.hpp	/^enum transform_op { op_none = 0, op_upper = 1, op_lower = 2 };$/;"	e	enum:boost::xpressive::detail::transform_op
op_none	xpressive/match_results.hpp	/^enum transform_op { op_none = 0, op_upper = 1, op_lower = 2 };$/;"	e	enum:boost::xpressive::detail::transform_op
op_upper	xpressive/match_results.hpp	/^enum transform_op { op_none = 0, op_upper = 1, op_lower = 2 };$/;"	e	enum:boost::xpressive::detail::transform_op
operator !	xpressive/detail/core/sub_match_vector.hpp	/^    bool operator !() const$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:() const
operator !	xpressive/detail/dynamic/matchable.hpp	/^    bool operator !() const$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:public	signature:() const
operator !	xpressive/detail/utility/tracking_ptr.hpp	/^    bool operator !() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:() const
operator !	xpressive/detail/utility/width.hpp	/^    bool operator !() const$/;"	f	struct:boost::xpressive::detail::width	access:public	signature:() const
operator !	xpressive/match_results.hpp	/^    bool operator !() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
operator !	xpressive/sub_match.hpp	/^    bool operator !() const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:() const
operator !=	xpressive/detail/dynamic/matchable.hpp	/^    friend bool operator !=(shared_matchable<BidiIter> const &left, shared_matchable<BidiIter> const &right)$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:friend	signature:(shared_matchable<BidiIter> const &left, shared_matchable<BidiIter> const &right)
operator !=	xpressive/detail/utility/width.hpp	/^inline bool operator !=(width const &left, width const &right)$/;"	f	namespace:boost::xpressive::detail	signature:(width const &left, width const &right)
operator !=	xpressive/regex_iterator.hpp	/^    friend bool operator !=(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_iterator	access:friend	signature:(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)
operator !=	xpressive/regex_token_iterator.hpp	/^    friend bool operator !=(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:friend	signature:(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)
operator !=	xpressive/sub_match.hpp	/^bool operator != (sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)
operator !=	xpressive/sub_match.hpp	/^bool operator != (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)
operator !=	xpressive/sub_match.hpp	/^bool operator != (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)
operator !=	xpressive/sub_match.hpp	/^bool operator != (typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)
operator !=	xpressive/sub_match.hpp	/^bool operator != (typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)
operator !=	xpressive/traits/c_regex_traits.hpp	/^    bool operator !=(c_regex_traits<char_type> const &) const$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(c_regex_traits<char_type> const &) const
operator !=	xpressive/traits/cpp_regex_traits.hpp	/^    bool operator !=(cpp_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(cpp_regex_traits<char_type> const &that) const
operator !=	xpressive/traits/null_regex_traits.hpp	/^    bool operator !=(null_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(null_regex_traits<char_type> const &that) const
operator &	xpressive/regex_constants.hpp	/^inline match_flag_type operator &(match_flag_type b1, match_flag_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b1, match_flag_type b2)
operator &	xpressive/regex_constants.hpp	/^inline syntax_option_type operator &(syntax_option_type b1, syntax_option_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b1, syntax_option_type b2)
operator &=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset &operator &=(basic_chset const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(basic_chset const &x)
operator &=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset_8bit &operator &=(basic_chset_8bit const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(basic_chset_8bit const &x)
operator ()	xpressive/detail/core/finder.hpp	/^    bool operator ()(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::boyer_moore_finder	access:public	signature:(match_state<BidiIter> &state) const
operator ()	xpressive/detail/core/finder.hpp	/^    bool operator ()(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::hash_peek_finder	access:public	signature:(match_state<BidiIter> &state) const
operator ()	xpressive/detail/core/finder.hpp	/^    bool operator ()(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::leading_simple_repeat_finder	access:public	signature:(match_state<BidiIter> &state) const
operator ()	xpressive/detail/core/finder.hpp	/^    bool operator ()(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::line_start_finder	access:public	signature:(match_state<BidiIter> &state) const
operator ()	xpressive/detail/core/linker.hpp	/^        void operator ()(Xpr const &xpr) const$/;"	f	struct:boost::xpressive::detail::xpression_linker::alt_link_pred	access:public	signature:(Xpr const &xpr) const
operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::detail::attr_transform::impl	access:public	signature:( typename impl::expr_param , typename impl::state_param state , typename impl::data_param ) const
operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::detail::attr_with_default_transform::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::detail::by_ref_transform::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param ) const
operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::detail::mark_transform::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param ) const
operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::detail::subreg_transform::impl	access:public	signature:( typename impl::expr_param , typename impl::state_param state , typename impl::data_param data ) const
operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator ()(Expr const &expr, action_context const &ctx) const$/;"	f	struct:boost::xpressive::detail::action_context::eval	access:public	signature:(Expr const &expr, action_context const &ctx) const
operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator()(Expr &expr, action_context const &) const$/;"	f	struct:boost::xpressive::detail::action_context::eval_terminal	access:public	signature:(Expr &expr, action_context const &) const
operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type operator()(Expr &expr, action_context const &ctx) const$/;"	f	struct:boost::xpressive::detail::action_context::eval_terminal	access:public	signature:(Expr &expr, action_context const &ctx) const
operator ()	xpressive/detail/core/matcher/action_matcher.hpp	/^        result_type operator()(Expr &expr, Context &ctx) const$/;"	f	struct:boost::xpressive::detail::mem_ptr_eval	access:public	signature:(Expr &expr, Context &ctx) const
operator ()	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        bool operator ()(Xpr const &xpr) const$/;"	f	struct:boost::xpressive::detail::alt_match_pred	access:public	signature:(Xpr const &xpr) const
operator ()	xpressive/detail/core/matcher/attr_matcher.hpp	/^        char_type operator ()(char_type ch1) const$/;"	f	struct:boost::xpressive::detail::char_translate	access:public	signature:(char_type ch1) const
operator ()	xpressive/detail/core/matcher/predicate_matcher.hpp	/^            result_type operator()(Expr &, predicate_context const &ctx) const$/;"	f	struct:boost::xpressive::detail::predicate_context::eval_terminal	access:public	signature:(Expr &, predicate_context const &ctx) const
operator ()	xpressive/detail/core/matcher/predicate_matcher.hpp	/^            result_type operator()(Expr &expr, predicate_context const &) const$/;"	f	struct:boost::xpressive::detail::predicate_context::eval_terminal	access:public	signature:(Expr &expr, predicate_context const &) const
operator ()	xpressive/detail/core/matcher/predicate_matcher.hpp	/^            result_type operator()(Expr &expr, predicate_context const &ctx) const$/;"	f	struct:boost::xpressive::detail::predicate_context::eval_terminal	access:public	signature:(Expr &expr, predicate_context const &ctx) const
operator ()	xpressive/detail/core/peeker.hpp	/^    void operator()(char_type ch) const$/;"	f	struct:boost::xpressive::detail::char_sink	access:public	signature:(char_type ch) const
operator ()	xpressive/detail/core/regex_impl.hpp	/^    virtual bool operator ()(match_state<BidiIter> &state) const = 0;$/;"	p	struct:boost::xpressive::detail::finder	access:public	signature:(match_state<BidiIter> &state) const
operator ()	xpressive/detail/dynamic/parse_charset.hpp	/^    void operator ()(numeric::range_check_result result) const \/\/ throw(regex_error)$/;"	f	struct:boost::xpressive::detail::char_overflow_handler	access:public	signature:(numeric::range_check_result result) const
operator ()	xpressive/detail/static/modifier.hpp	/^        operator ()(Expr const &expr) const$/;"	f	class:boost::xpressive::detail::modifier_op::apply	access:public	signature:(Expr const &expr) const
operator ()	xpressive/detail/static/transforms/as_action.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::add_attrs::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param ) const
operator ()	xpressive/detail/static/transforms/as_action.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_action::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_action.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_attr_matcher::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_action.hpp	/^            result_type operator ()(proto::ignore, proto::ignore, proto::ignore) const$/;"	f	struct:boost::xpressive::grammar_detail::as_read_attr::impl	access:public	signature:(proto::ignore, proto::ignore, proto::ignore) const
operator ()	xpressive/detail/static/transforms/as_alternate.hpp	/^                result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_alternate_matcher::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_alternate.hpp	/^                result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::in_alternate_list::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_independent.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_keeper::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_independent.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_lookahead::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_independent.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_lookbehind::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_inverse.hpp	/^        typename inverter<Matcher>::type operator ()(Matcher const &matcher) const$/;"	f	struct:boost::xpressive::grammar_detail::as_inverse	access:public	signature:(Matcher const &matcher) const
operator ()	xpressive/detail/static/transforms/as_marker.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_marker::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param ) const
operator ()	xpressive/detail/static/transforms/as_matcher.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_matcher::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_modifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_modifier::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::add_hidden_mark::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_default_optional::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_default_quantifier::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_default_quantifier_impl::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_mark_optional::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_simple_quantifier::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::make_optional_::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param ) const
operator ()	xpressive/detail/static/transforms/as_sequence.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::in_sequence::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_set.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_list_set_matcher::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_set.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::grammar_detail::as_set_matcher::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param , typename impl::data_param data ) const
operator ()	xpressive/detail/static/transforms/as_set.hpp	/^        void operator ()(Expr const &expr) const$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:public	signature:(Expr const &expr) const
operator ()	xpressive/detail/utility/any.hpp	/^            operator()(Sequence const& seq, F const& f) const$/;"	f	struct:boost::fusion::function::any	access:public	signature:(Sequence const& seq, F const& f) const
operator ()	xpressive/detail/utility/any.hpp	/^            operator()(Sequence& seq, F const& f) const$/;"	f	struct:boost::fusion::function::any	access:public	signature:(Sequence& seq, F const& f) const
operator ()	xpressive/detail/utility/chset/chset.hpp	/^        bool operator ()(typename call_traits<char_class_type>::param_type m) const$/;"	f	struct:boost::xpressive::detail::compound_charset::not_posix_pred	access:public	signature:(typename call_traits<char_class_type>::param_type m) const
operator ()	xpressive/detail/utility/chset/range_run.hpp	/^    bool operator()(range<Char> const &x, range<Char> const &y) const$/;"	f	struct:boost::xpressive::detail::range_compare	access:public	signature:(range<Char> const &x, range<Char> const &y) const
operator ()	xpressive/detail/utility/symbols.hpp	/^        result_type operator ()(BidiIter &begin, BidiIter end, Trans trans) const$/;"	f	struct:boost::xpressive::detail::symbols	access:public	signature:(BidiIter &begin, BidiIter end, Trans trans) const
operator ()	xpressive/detail/utility/tracking_ptr.hpp	/^    bool operator ()(shared_ptr<Derived> const &that) const$/;"	f	struct:boost::xpressive::detail::filter_self	access:public	signature:(shared_ptr<Derived> const &that) const
operator ()	xpressive/detail/utility/traits_utils.hpp	/^        result_type operator()(From const &from, Traits const &) const$/;"	f	struct:boost::xpressive::detail::string_cast_	access:public	signature:(From const &from, Traits const &) const
operator ()	xpressive/detail/utility/traits_utils.hpp	/^        result_type operator()(From const &from, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::string_cast_	access:public	signature:(From const &from, Traits const &tr) const
operator ()	xpressive/detail/utility/traits_utils.hpp	/^        result_type operator()(char ch) const$/;"	f	struct:boost::xpressive::detail::widen_fun	access:public	signature:(char ch) const
operator ()	xpressive/match_results.hpp	/^    bool operator ()(match_results<BidiIter> const &res) const$/;"	f	struct:boost::xpressive::regex_id_filter_predicate	access:public	signature:(match_results<BidiIter> const &res) const
operator ()	xpressive/match_results.hpp	/^    bool operator()(std::type_info const *left, std::type_info const *right) const$/;"	f	struct:boost::xpressive::detail::type_info_less	access:public	signature:(std::type_info const *left, std::type_info const *right) const
operator ()	xpressive/match_results.hpp	/^    match_results<BidiIter> const &operator ()(basic_regex<BidiIter> const &rex, std::size_t index = 0) const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(basic_regex<BidiIter> const &rex, std::size_t index = 0) const
operator ()	xpressive/match_results.hpp	/^    match_results<BidiIter> const &operator ()(regex_id_type regex_id, size_type index = 0) const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(regex_id_type regex_id, size_type index = 0) const
operator ()	xpressive/match_results.hpp	/^    void operator ()(numeric::range_check_result result) const \/\/ throw(regex_error)$/;"	f	struct:boost::xpressive::detail::char_overflow_handler_	access:public	signature:(numeric::range_check_result result) const
operator ()	xpressive/regex_actions.hpp	/^            Expr const & operator ()(MatchResults &what, Expr const &expr) const$/;"	f	struct:boost::xpressive::detail::BindArg	access:public	signature:(MatchResults &what, Expr const &expr) const
operator ()	xpressive/regex_actions.hpp	/^            T &operator()(boost::reference_wrapper<T> r) const$/;"	f	struct:boost::xpressive::op::unwrap_reference	access:public	signature:(boost::reference_wrapper<T> r) const
operator ()	xpressive/regex_actions.hpp	/^            T operator()() const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:() const
operator ()	xpressive/regex_actions.hpp	/^            T operator()(A0 const &a0) const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:(A0 const &a0) const
operator ()	xpressive/regex_actions.hpp	/^            T operator()(A0 const &a0, A1 const &a1) const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:(A0 const &a0, A1 const &a1) const
operator ()	xpressive/regex_actions.hpp	/^            T operator()(A0 const &a0, A1 const &a1, A2 const &a2) const$/;"	f	struct:boost::xpressive::op::construct	access:public	signature:(A0 const &a0, A1 const &a1, A2 const &a2) const
operator ()	xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(Value const &val) const
operator ()	xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::const_cast_	access:public	signature:(Value const &val) const
operator ()	xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::dynamic_cast_	access:public	signature:(Value const &val) const
operator ()	xpressive/regex_actions.hpp	/^            T operator()(Value const &val) const$/;"	f	struct:boost::xpressive::op::static_cast_	access:public	signature:(Value const &val) const
operator ()	xpressive/regex_actions.hpp	/^            T operator()(csub_match const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(csub_match const &val) const
operator ()	xpressive/regex_actions.hpp	/^            T operator()(sub_match<BidiIter> const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(sub_match<BidiIter> const &val) const
operator ()	xpressive/regex_actions.hpp	/^            T operator()(wcsub_match const &val) const$/;"	f	struct:boost::xpressive::op::as	access:public	signature:(wcsub_match const &val) const
operator ()	xpressive/regex_actions.hpp	/^            bool operator()(Sub const &sub) const$/;"	f	struct:boost::xpressive::op::matched	access:public	signature:(Sub const &sub) const
operator ()	xpressive/regex_actions.hpp	/^            int operator()(mark_placeholder m) const$/;"	f	struct:boost::xpressive::detail::mark_nbr	access:public	signature:(mark_placeholder m) const
operator ()	xpressive/regex_actions.hpp	/^            operator()(Cont &cont, A0 const &a0) const$/;"	f	struct:boost::xpressive::op::insert	access:public	signature:(Cont &cont, A0 const &a0) const
operator ()	xpressive/regex_actions.hpp	/^            operator()(Cont &cont, A0 const &a0, A1 const &a1) const$/;"	f	struct:boost::xpressive::op::insert	access:public	signature:(Cont &cont, A0 const &a0, A1 const &a1) const
operator ()	xpressive/regex_actions.hpp	/^            operator()(Cont &cont, A0 const &a0, A1 const &a1, A2 const &a2) const$/;"	f	struct:boost::xpressive::op::insert	access:public	signature:(Cont &cont, A0 const &a0, A1 const &a1, A2 const &a2) const
operator ()	xpressive/regex_actions.hpp	/^            operator()(Cont &cont, A0 const &a0, A1 const &a1, A2 const &a2, A3 const &a3) const$/;"	f	struct:boost::xpressive::op::insert	access:public	signature:(Cont &cont, A0 const &a0, A1 const &a1, A2 const &a2, A3 const &a3) const
operator ()	xpressive/regex_actions.hpp	/^            std::pair<First, Second> operator()(First const &first, Second const &second) const$/;"	f	struct:boost::xpressive::op::make_pair	access:public	signature:(First const &first, Second const &second) const
operator ()	xpressive/regex_actions.hpp	/^            typename Cont::const_reference operator()(Cont const &c, Idx idx) const$/;"	f	struct:boost::xpressive::op::at	access:public	signature:(Cont const &c, Idx idx) const
operator ()	xpressive/regex_actions.hpp	/^            typename Cont::reference operator()(Cont &c, Idx idx BOOST_PROTO_DISABLE_IF_IS_CONST(Cont)) const$/;"	f	struct:boost::xpressive::op::at	access:public	signature:(Cont &c, Idx idx BOOST_PROTO_DISABLE_IF_IS_CONST(Cont)) const
operator ()	xpressive/regex_actions.hpp	/^            typename Pair::first_type operator()(Pair const &p) const$/;"	f	struct:boost::xpressive::op::first	access:public	signature:(Pair const &p) const
operator ()	xpressive/regex_actions.hpp	/^            typename Pair::second_type operator()(Pair const &p) const$/;"	f	struct:boost::xpressive::op::second	access:public	signature:(Pair const &p) const
operator ()	xpressive/regex_actions.hpp	/^            typename Sub::difference_type operator()(Sub const &sub) const$/;"	f	struct:boost::xpressive::op::length	access:public	signature:(Sub const &sub) const
operator ()	xpressive/regex_actions.hpp	/^            typename Sub::string_type operator()(Sub const &sub) const$/;"	f	struct:boost::xpressive::op::str	access:public	signature:(Sub const &sub) const
operator ()	xpressive/regex_actions.hpp	/^            typename result<back(Sequence &)>::type operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::back	access:public	signature:(Sequence &seq) const
operator ()	xpressive/regex_actions.hpp	/^            typename result<front(Sequence &)>::type operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::front	access:public	signature:(Sequence &seq) const
operator ()	xpressive/regex_actions.hpp	/^            typename result<top(Sequence &)>::type operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::top	access:public	signature:(Sequence &seq) const
operator ()	xpressive/regex_actions.hpp	/^            void operator()() const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:() const
operator ()	xpressive/regex_actions.hpp	/^            void operator()(A0 const &a0) const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:(A0 const &a0) const
operator ()	xpressive/regex_actions.hpp	/^            void operator()(A0 const &a0, A1 const &a1) const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:(A0 const &a0, A1 const &a1) const
operator ()	xpressive/regex_actions.hpp	/^            void operator()(A0 const &a0, A1 const &a1, A2 const &a2) const$/;"	f	struct:boost::xpressive::op::throw_	access:public	signature:(A0 const &a0, A1 const &a1, A2 const &a2) const
operator ()	xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::pop	access:public	signature:(Sequence &seq) const
operator ()	xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::pop_back	access:public	signature:(Sequence &seq) const
operator ()	xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq) const$/;"	f	struct:boost::xpressive::op::pop_front	access:public	signature:(Sequence &seq) const
operator ()	xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq, Value const &val) const$/;"	f	struct:boost::xpressive::op::push	access:public	signature:(Sequence &seq, Value const &val) const
operator ()	xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq, Value const &val) const$/;"	f	struct:boost::xpressive::op::push_back	access:public	signature:(Sequence &seq, Value const &val) const
operator ()	xpressive/regex_actions.hpp	/^            void operator()(Sequence &seq, Value const &val) const$/;"	f	struct:boost::xpressive::op::push_front	access:public	signature:(Sequence &seq, Value const &val) const
operator ()	xpressive/regex_primitives.hpp	/^            result_type operator ()($/;"	f	struct:boost::xpressive::detail::skip_primitives::impl	access:public	signature:( typename impl::expr_param expr , typename impl::state_param state , typename impl::data_param ) const
operator ()	xpressive/regex_primitives.hpp	/^        int operator ()(Expr const &expr) const$/;"	f	struct:boost::xpressive::detail::mark_number	access:public	signature:(Expr const &expr) const
operator ()	xpressive/regex_primitives.hpp	/^        int operator ()(Subs &subs, int i) const$/;"	f	struct:boost::xpressive::detail::push_back	access:public	signature:(Subs &subs, int i) const
operator ()	xpressive/regex_primitives.hpp	/^        operator ()(Expr const &expr) const$/;"	f	struct:boost::xpressive::detail::skip_directive	access:public	signature:(Expr const &expr) const
operator *	xpressive/detail/utility/tracking_ptr.hpp	/^    element_type const &operator *() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:() const
operator *	xpressive/match_results.hpp	/^    case_converting_iterator &operator *()$/;"	f	struct:boost::xpressive::detail::case_converting_iterator	access:public	signature:()
operator *	xpressive/match_results.hpp	/^    noop_output_iterator &operator *()$/;"	f	struct:boost::xpressive::detail::noop_output_iterator	access:public	signature:()
operator *	xpressive/regex_iterator.hpp	/^    value_type const &operator *() const$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:() const
operator *	xpressive/regex_token_iterator.hpp	/^    value_type const &operator *() const$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:() const
operator +	xpressive/detail/dynamic/sequence.hpp	/^inline sequence<BidiIter> operator +(sequence<BidiIter> left, sequence<BidiIter> const &right)$/;"	f	namespace:boost::xpressive::detail	signature:(sequence<BidiIter> left, sequence<BidiIter> const &right)
operator +	xpressive/detail/utility/width.hpp	/^inline width operator +(width left, width const &right)$/;"	f	namespace:boost::xpressive::detail	signature:(width left, width const &right)
operator +	xpressive/sub_match.hpp	/^operator + (sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)
operator +	xpressive/sub_match.hpp	/^operator + (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)
operator +	xpressive/sub_match.hpp	/^operator + (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)
operator +	xpressive/sub_match.hpp	/^operator + (sub_match<BidiIter> const &lhs, typename sub_match<BidiIter>::string_type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename sub_match<BidiIter>::string_type const &rhs)
operator +	xpressive/sub_match.hpp	/^operator + (typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)
operator +	xpressive/sub_match.hpp	/^operator + (typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)
operator +	xpressive/sub_match.hpp	/^operator + (typename sub_match<BidiIter>::string_type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename sub_match<BidiIter>::string_type const &lhs, sub_match<BidiIter> const &rhs)
operator ++	xpressive/match_results.hpp	/^    case_converting_iterator &operator ++()$/;"	f	struct:boost::xpressive::detail::case_converting_iterator	access:public	signature:()
operator ++	xpressive/match_results.hpp	/^    case_converting_iterator operator ++(int)$/;"	f	struct:boost::xpressive::detail::case_converting_iterator	access:public	signature:(int)
operator ++	xpressive/match_results.hpp	/^    noop_output_iterator &operator ++()$/;"	f	struct:boost::xpressive::detail::noop_output_iterator	access:public	signature:()
operator ++	xpressive/match_results.hpp	/^    noop_output_iterator &operator ++(int)$/;"	f	struct:boost::xpressive::detail::noop_output_iterator	access:public	signature:(int)
operator ++	xpressive/regex_iterator.hpp	/^    regex_iterator<BidiIter> &operator ++()$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:()
operator ++	xpressive/regex_iterator.hpp	/^    regex_iterator<BidiIter> operator ++(int)$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:(int)
operator ++	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator<BidiIter> &operator ++()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:()
operator ++	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator<BidiIter> operator ++(int)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:(int)
operator +=	xpressive/detail/dynamic/sequence.hpp	/^    sequence<BidiIter> &operator +=(sequence<BidiIter> const &that)$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:(sequence<BidiIter> const &that)
operator +=	xpressive/detail/utility/width.hpp	/^    width &operator +=(width const &that)$/;"	f	struct:boost::xpressive::detail::width	access:public	signature:(width const &that)
operator -=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset &operator -=(basic_chset const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(basic_chset const &x)
operator -=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset_8bit &operator -=(basic_chset_8bit const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(basic_chset_8bit const &x)
operator ->	xpressive/detail/utility/tracking_ptr.hpp	/^    element_type const *operator ->() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:() const
operator ->	xpressive/regex_iterator.hpp	/^    value_type const *operator ->() const$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:() const
operator ->	xpressive/regex_token_iterator.hpp	/^    value_type const *operator ->() const$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:() const
operator <	xpressive/sub_match.hpp	/^bool operator < (sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)
operator <	xpressive/sub_match.hpp	/^bool operator < (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)
operator <	xpressive/sub_match.hpp	/^bool operator < (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)
operator <	xpressive/sub_match.hpp	/^bool operator < (typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)
operator <	xpressive/sub_match.hpp	/^bool operator < (typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)
operator <<	xpressive/detail/utility/tracking_ptr.hpp	/^    friend std::ostream &operator <<(std::ostream &sout, enable_reference_tracking<Derived> const &that)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:friend	signature:(std::ostream &sout, enable_reference_tracking<Derived> const &that)
operator <<	xpressive/sub_match.hpp	/^inline std::basic_ostream<Char, Traits> &operator <<$/;"	f	namespace:boost::xpressive	signature:( std::basic_ostream<Char, Traits> &sout , sub_match<BidiIter> const &sub )
operator <=	xpressive/sub_match.hpp	/^bool operator <= (sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)
operator <=	xpressive/sub_match.hpp	/^bool operator <= (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)
operator <=	xpressive/sub_match.hpp	/^bool operator <= (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)
operator <=	xpressive/sub_match.hpp	/^bool operator <= (typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)
operator <=	xpressive/sub_match.hpp	/^bool operator <= (typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)
operator =	xpressive/basic_regex.hpp	/^    basic_regex<BidiIter> &operator =(Expr const &expr)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(Expr const &expr)
operator =	xpressive/basic_regex.hpp	/^    basic_regex<BidiIter> &operator =(basic_regex<BidiIter> const &that)$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(basic_regex<BidiIter> const &that)
operator =	xpressive/detail/core/adaptor.hpp	/^    xpression_adaptor &operator =(xpression_adaptor const &);$/;"	p	struct:boost::xpressive::detail::xpression_adaptor	access:private	signature:(xpression_adaptor const &)
operator =	xpressive/detail/core/finder.hpp	/^    boyer_moore_finder &operator =(boyer_moore_finder const &);$/;"	p	struct:boost::xpressive::detail::boyer_moore_finder	access:private	signature:(boyer_moore_finder const &)
operator =	xpressive/detail/core/finder.hpp	/^    hash_peek_finder &operator =(hash_peek_finder const &);$/;"	p	struct:boost::xpressive::detail::hash_peek_finder	access:private	signature:(hash_peek_finder const &)
operator =	xpressive/detail/core/finder.hpp	/^    leading_simple_repeat_finder &operator =(leading_simple_repeat_finder const &);$/;"	p	struct:boost::xpressive::detail::leading_simple_repeat_finder	access:private	signature:(leading_simple_repeat_finder const &)
operator =	xpressive/detail/core/finder.hpp	/^    line_start_finder &operator =(line_start_finder const &);$/;"	p	struct:boost::xpressive::detail::line_start_finder	access:private	signature:(line_start_finder const &)
operator =	xpressive/detail/core/list.hpp	/^        list &operator =(list const &that)$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:(list const &that)
operator =	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        alternate_matcher &operator =(alternate_matcher const &);$/;"	p	struct:boost::xpressive::detail::alternate_matcher	access:private	signature:(alternate_matcher const &)
operator =	xpressive/detail/core/matcher/attr_matcher.hpp	/^        char_translate &operator =(char_translate const &);$/;"	p	struct:boost::xpressive::detail::char_translate	access:private	signature:(char_translate const &)
operator =	xpressive/detail/core/matcher/optional_matcher.hpp	/^        optional_mark_matcher &operator =(optional_mark_matcher const &);$/;"	p	struct:boost::xpressive::detail::optional_mark_matcher	access:private	signature:(optional_mark_matcher const &)
operator =	xpressive/detail/core/matcher/optional_matcher.hpp	/^        optional_matcher &operator =(optional_matcher const &);$/;"	p	struct:boost::xpressive::detail::optional_matcher	access:private	signature:(optional_matcher const &)
operator =	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        simple_repeat_matcher &operator =(simple_repeat_matcher const &);$/;"	p	struct:boost::xpressive::detail::simple_repeat_matcher	access:private	signature:(simple_repeat_matcher const &)
operator =	xpressive/detail/core/peeker.hpp	/^    char_sink &operator =(char_sink const &);$/;"	p	struct:boost::xpressive::detail::char_sink	access:private	signature:(char_sink const &)
operator =	xpressive/detail/core/peeker.hpp	/^    xpression_peeker &operator =(xpression_peeker const &);$/;"	p	struct:boost::xpressive::detail::xpression_peeker	access:private	signature:(xpression_peeker const &)
operator =	xpressive/detail/core/regex_impl.hpp	/^    regex_impl &operator =(regex_impl const &);$/;"	p	struct:boost::xpressive::detail::regex_impl	access:private	signature:(regex_impl const &)
operator =	xpressive/detail/static/static.hpp	/^    static_xpression &operator =(static_xpression const &);$/;"	p	struct:boost::xpressive::detail::static_xpression	access:private	signature:(static_xpression const &)
operator =	xpressive/detail/static/transforms/as_set.hpp	/^        merge_charset &operator =(merge_charset const &);$/;"	p	struct:boost::xpressive::grammar_detail::merge_charset	access:private	signature:(merge_charset const &)
operator =	xpressive/detail/utility/counted_base.hpp	/^        counted_base &operator =(counted_base<Derived> const &)$/;"	f	struct:boost::xpressive::detail::counted_base	access:protected	signature:(counted_base<Derived> const &)
operator =	xpressive/detail/utility/sequence_stack.hpp	/^        chunk &operator =(chunk const &);$/;"	p	struct:boost::xpressive::detail::sequence_stack::chunk	access:private	signature:(chunk const &)
operator =	xpressive/detail/utility/tracking_ptr.hpp	/^    enable_reference_tracking<Derived> &operator =(enable_reference_tracking<Derived> const &that)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:protected	signature:(enable_reference_tracking<Derived> const &that)
operator =	xpressive/detail/utility/tracking_ptr.hpp	/^    tracking_ptr<element_type> &operator =(tracking_ptr<element_type> const &that)$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:(tracking_ptr<element_type> const &that)
operator =	xpressive/match_results.hpp	/^    case_converting_iterator &operator =(Char ch)$/;"	f	struct:boost::xpressive::detail::case_converting_iterator	access:public	signature:(Char ch)
operator =	xpressive/match_results.hpp	/^    match_results<BidiIter> &operator =(match_results<BidiIter> const &that)$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(match_results<BidiIter> const &that)
operator =	xpressive/match_results.hpp	/^    noop_output_iterator &operator =(Char const &)$/;"	f	struct:boost::xpressive::detail::noop_output_iterator	access:public	signature:(Char const &)
operator =	xpressive/regex_actions.hpp	/^        detail::unspecified operator=(T &t) const;$/;"	p	struct:boost::xpressive::placeholder	access:public	signature:(T &t) const
operator =	xpressive/regex_actions.hpp	/^        detail::unspecified operator=(T const &t) const;$/;"	p	struct:boost::xpressive::placeholder	access:public	signature:(T const &t) const
operator =	xpressive/regex_iterator.hpp	/^    regex_iterator<BidiIter> &operator =(regex_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:(regex_iterator<BidiIter> const &that)
operator =	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator<BidiIter> &operator =(regex_token_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:(regex_token_iterator<BidiIter> const &that)
operator ==	xpressive/detail/dynamic/matchable.hpp	/^    friend bool operator ==(shared_matchable<BidiIter> const &left, shared_matchable<BidiIter> const &right)$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:friend	signature:(shared_matchable<BidiIter> const &left, shared_matchable<BidiIter> const &right)
operator ==	xpressive/detail/utility/width.hpp	/^inline bool operator ==(width const &left, width const &right)$/;"	f	namespace:boost::xpressive::detail	signature:(width const &left, width const &right)
operator ==	xpressive/regex_iterator.hpp	/^    friend bool operator ==(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_iterator	access:friend	signature:(regex_iterator<BidiIter> const &left, regex_iterator<BidiIter> const &right)
operator ==	xpressive/regex_token_iterator.hpp	/^    friend bool operator ==(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:friend	signature:(regex_token_iterator<BidiIter> const &left, regex_token_iterator<BidiIter> const &right)
operator ==	xpressive/sub_match.hpp	/^bool operator == (sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)
operator ==	xpressive/sub_match.hpp	/^bool operator == (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)
operator ==	xpressive/sub_match.hpp	/^bool operator == (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)
operator ==	xpressive/sub_match.hpp	/^bool operator == (typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)
operator ==	xpressive/sub_match.hpp	/^bool operator == (typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)
operator ==	xpressive/traits/c_regex_traits.hpp	/^    bool operator ==(c_regex_traits<char_type> const &) const$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(c_regex_traits<char_type> const &) const
operator ==	xpressive/traits/cpp_regex_traits.hpp	/^    bool operator ==(cpp_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(cpp_regex_traits<char_type> const &that) const
operator ==	xpressive/traits/null_regex_traits.hpp	/^    bool operator ==(null_regex_traits<char_type> const &that) const$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(null_regex_traits<char_type> const &that) const
operator >	xpressive/sub_match.hpp	/^bool operator > (sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)
operator >	xpressive/sub_match.hpp	/^bool operator > (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)
operator >	xpressive/sub_match.hpp	/^bool operator > (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)
operator >	xpressive/sub_match.hpp	/^bool operator > (typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)
operator >	xpressive/sub_match.hpp	/^bool operator > (typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)
operator >=	xpressive/sub_match.hpp	/^bool operator >= (sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, sub_match<BidiIter> const &rhs)
operator >=	xpressive/sub_match.hpp	/^bool operator >= (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const &rhs)
operator >=	xpressive/sub_match.hpp	/^bool operator >= (sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &lhs, typename iterator_value<BidiIter>::type const *rhs)
operator >=	xpressive/sub_match.hpp	/^bool operator >= (typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const &lhs, sub_match<BidiIter> const &rhs)
operator >=	xpressive/sub_match.hpp	/^bool operator >= (typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)$/;"	f	namespace:boost::xpressive	signature:(typename iterator_value<BidiIter>::type const *lhs, sub_match<BidiIter> const &rhs)
operator Formatter *	xpressive/match_results.hpp	/^    operator Formatter *();$/;"	p	struct:boost::xpressive::detail::formatter_wrapper	access:public	signature:()
operator []	xpressive/detail/core/sub_match_vector.hpp	/^    const_reference operator [](size_type index) const$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:(size_type index) const
operator []	xpressive/match_results.hpp	/^    const_reference operator [](Sub const &sub) const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(Sub const &sub) const
operator []	xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> &operator [](string_type const &name)$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(string_type const &name)
operator []	xpressive/regex_compiler.hpp	/^    basic_regex<BidiIter> const &operator [](string_type const &name) const$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(string_type const &name) const
operator ^	xpressive/regex_constants.hpp	/^inline match_flag_type operator ^(match_flag_type b1, match_flag_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b1, match_flag_type b2)
operator ^	xpressive/regex_constants.hpp	/^inline syntax_option_type operator ^(syntax_option_type b1, syntax_option_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b1, syntax_option_type b2)
operator ^=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset &operator ^=(basic_chset const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(basic_chset const &x)
operator ^=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset_8bit &operator ^=(basic_chset_8bit const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(basic_chset_8bit const &x)
operator binary_fun	xpressive/match_results.hpp	/^    operator binary_fun();$/;"	p	struct:boost::xpressive::detail::unary_binary_ternary	access:public	signature:()
operator bool	xpressive/detail/utility/tracking_ptr.hpp	/^    operator bool() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:() const
operator bool_type	xpressive/detail/core/sub_match_vector.hpp	/^    operator bool_type() const$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:() const
operator bool_type	xpressive/match_results.hpp	/^    operator bool_type() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
operator bool_type	xpressive/sub_match.hpp	/^    operator bool_type() const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:() const
operator detail::basic_mark_tag const &	xpressive/regex_primitives.hpp	/^    operator detail::basic_mark_tag const &() const$/;"	f	struct:boost::xpressive::mark_tag	access:public	signature:() const
operator opt_type	xpressive/detail/static/modifier.hpp	/^        operator opt_type() const$/;"	f	struct:boost::xpressive::detail::modifier_op	access:public	signature:() const
operator reference	xpressive/detail/core/matcher/action_matcher.hpp	/^        operator reference() const$/;"	f	struct:boost::xpressive::detail::opt	access:public	signature:() const
operator string_type	xpressive/sub_match.hpp	/^    operator string_type() const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:() const
operator ternary_fun	xpressive/match_results.hpp	/^    operator ternary_fun();$/;"	p	struct:boost::xpressive::detail::unary_binary_ternary	access:public	signature:()
operator unary_fun	xpressive/match_results.hpp	/^    operator unary_fun();$/;"	p	struct:boost::xpressive::detail::unary_binary_ternary	access:public	signature:()
operator unspecified_bool_type	xpressive/detail/utility/tracking_ptr.hpp	/^    operator unspecified_bool_type() const$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:() const
operator |	xpressive/detail/dynamic/sequence.hpp	/^inline sequence<BidiIter> operator |(sequence<BidiIter> left, sequence<BidiIter> const &right)$/;"	f	namespace:boost::xpressive::detail	signature:(sequence<BidiIter> left, sequence<BidiIter> const &right)
operator |	xpressive/detail/utility/width.hpp	/^inline width operator |(width left, width const &right)$/;"	f	namespace:boost::xpressive::detail	signature:(width left, width const &right)
operator |	xpressive/regex_constants.hpp	/^inline match_flag_type operator |(match_flag_type b1, match_flag_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b1, match_flag_type b2)
operator |	xpressive/regex_constants.hpp	/^inline syntax_option_type operator |(syntax_option_type b1, syntax_option_type b2)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b1, syntax_option_type b2)
operator |=	xpressive/detail/dynamic/sequence.hpp	/^    sequence<BidiIter> &operator |=(sequence<BidiIter> that)$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:(sequence<BidiIter> that)
operator |=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset &operator |=(basic_chset const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(basic_chset const &x)
operator |=	xpressive/detail/utility/chset/basic_chset.hpp	/^    basic_chset_8bit &operator |=(basic_chset_8bit const &x);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(basic_chset_8bit const &x)
operator |=	xpressive/detail/utility/width.hpp	/^    width &operator |=(width const &that)$/;"	f	struct:boost::xpressive::detail::width	access:public	signature:(width const &that)
operator ~	xpressive/regex_constants.hpp	/^inline match_flag_type operator ~(match_flag_type b)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(match_flag_type b)
operator ~	xpressive/regex_constants.hpp	/^inline syntax_option_type operator ~(syntax_option_type b)$/;"	f	namespace:boost::xpressive::regex_constants	signature:(syntax_option_type b)
opt	xpressive/detail/core/matcher/action_matcher.hpp	/^        opt(T const *t)$/;"	f	struct:boost::xpressive::detail::opt	access:public	signature:(T const *t)
opt	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct opt$/;"	s	namespace:boost::xpressive::detail
opt_	xpressive/detail/static/modifier.hpp	/^        opt_type opt_;$/;"	m	struct:boost::xpressive::detail::modifier_op	access:public
opt_type	xpressive/detail/static/modifier.hpp	/^        typedef regex_constants::syntax_option_type opt_type;$/;"	t	struct:boost::xpressive::detail::modifier_op	access:public
optimize	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::optimize;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
optimize	xpressive/regex_constants.hpp	/^    optimize    = 1 << 3,   \/\/\/< Specifies that the regular expression engine should pay more$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
optimize_regex	xpressive/detail/core/optimize.hpp	/^intrusive_ptr<finder<BidiIter> > optimize_regex$/;"	f	namespace:boost::xpressive::detail	signature:( xpression_peeker<typename iterator_value<BidiIter>::type> const &peeker , Traits const &tr , mpl::false_ )
optimize_regex	xpressive/detail/core/optimize.hpp	/^intrusive_ptr<finder<BidiIter> > optimize_regex$/;"	f	namespace:boost::xpressive::detail	signature:( xpression_peeker<typename iterator_value<BidiIter>::type> const &peeker , Traits const &tr , mpl::true_ )
optional	xpressive/regex_primitives.hpp	/^optional(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
optional_mark_matcher	xpressive/detail/core/matcher/optional_matcher.hpp	/^        explicit optional_mark_matcher(Xpr const &xpr, int mark_number)$/;"	f	struct:boost::xpressive::detail::optional_mark_matcher	access:public	signature:(Xpr const &xpr, int mark_number)
optional_mark_matcher	xpressive/detail/core/matcher/optional_matcher.hpp	/^    struct optional_mark_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
optional_matcher	xpressive/detail/core/matcher/optional_matcher.hpp	/^        explicit optional_matcher(Xpr const &xpr)$/;"	f	struct:boost::xpressive::detail::optional_matcher	access:public	signature:(Xpr const &xpr)
optional_matcher	xpressive/detail/core/matcher/optional_matcher.hpp	/^    struct optional_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
optional_tag	xpressive/detail/static/transforms/as_quantifier.hpp	/^    struct optional_tag$/;"	s	namespace:boost::xpressive::grammar_detail
or_widths	xpressive/detail/static/width_of.hpp	/^    struct or_widths$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
or_widths	xpressive/detail/static/width_of.hpp	/^    struct or_widths<N, N>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
other	xpressive/detail/static/transforms/as_quantifier.hpp	/^            other;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_quantifier::impl	access:public
out	xpressive/match_results.hpp	/^    static Out &out;$/;"	m	struct:boost::xpressive::detail::formatter_arity	access:public
out_	xpressive/match_results.hpp	/^    OutputIterator out_;$/;"	m	struct:boost::xpressive::detail::case_converting_iterator	access:private
overlaps	xpressive/detail/utility/chset/range_run.hpp	/^    bool overlaps(range const &r) const;$/;"	p	struct:boost::xpressive::detail::range	access:public	signature:(range const &r) const
p	xpressive/detail/utility/sequence_stack.hpp	/^        T *p;$/;"	m	struct:boost::xpressive::detail::sequence_stack::allocate_guard_t	access:public
pair	xpressive/sub_match.hpp	/^    template<typename, typename> struct pair {};$/;"	s	namespace:std
parse_alternates	xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_alternates(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_atom	xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_atom(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_charset	xpressive/detail/dynamic/parse_charset.hpp	/^inline void parse_charset$/;"	f	namespace:boost::xpressive::detail	signature:( FwdIter &begin , FwdIter end , compound_charset<RegexTraits> &chset , CompilerTraits &tr )
parse_charset	xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_charset(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_escape	xpressive/detail/dynamic/parse_charset.hpp	/^parse_escape(FwdIter &begin, FwdIter end, CompilerTraits &tr)$/;"	f	namespace:boost::xpressive::detail	signature:(FwdIter &begin, FwdIter end, CompilerTraits &tr)
parse_escape	xpressive/regex_compiler.hpp	/^    escape_value parse_escape(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_group	xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_group(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_literal	xpressive/regex_compiler.hpp	/^    string_type parse_literal(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_mods_	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_constants::compiler_token_type parse_mods_(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::compiler_traits	access:private	signature:(FwdIter &begin, FwdIter end)
parse_quant	xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_quant(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_quote_meta	xpressive/regex_compiler.hpp	/^    string_type parse_quote_meta(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
parse_sequence	xpressive/regex_compiler.hpp	/^    detail::sequence<BidiIter> parse_sequence(FwdIter &begin, FwdIter end)$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:(FwdIter &begin, FwdIter end)
peek	xpressive/detail/core/adaptor.hpp	/^    void peek(xpression_peeker<char_type> &peeker) const$/;"	f	struct:boost::xpressive::detail::xpression_adaptor	access:public	signature:(xpression_peeker<char_type> &peeker) const
peek	xpressive/detail/dynamic/dynamic.hpp	/^    virtual void peek(xpression_peeker<char_type> &peeker) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:public	signature:(xpression_peeker<char_type> &peeker) const
peek	xpressive/detail/dynamic/dynamic.hpp	/^    void peek(xpression_peeker<Char> &peeker) const$/;"	f	struct:boost::xpressive::detail::matcher_wrapper	access:public	signature:(xpression_peeker<Char> &peeker) const
peek	xpressive/detail/dynamic/matchable.hpp	/^    virtual void peek(xpression_peeker<char_type> &peeker) const$/;"	f	struct:boost::xpressive::detail::matchable_ex	access:public	signature:(xpression_peeker<char_type> &peeker) const
peek	xpressive/detail/dynamic/matchable.hpp	/^    void peek(xpression_peeker<char_type> &peeker) const$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:public	signature:(xpression_peeker<char_type> &peeker) const
peek	xpressive/detail/static/static.hpp	/^    void peek(xpression_peeker<Char> &peeker) const$/;"	f	struct:boost::xpressive::detail::no_next	access:public	signature:(xpression_peeker<Char> &peeker) const
peek	xpressive/detail/static/static.hpp	/^    void peek(xpression_peeker<Char> &peeker) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:public	signature:(xpression_peeker<Char> &peeker) const
peek	xpressive/detail/utility/symbols.hpp	/^        void peek(Sink const &sink) const$/;"	f	struct:boost::xpressive::detail::symbols	access:public	signature:(Sink const &sink) const
peek_	xpressive/detail/utility/symbols.hpp	/^        void peek_(node const *const &p, Sink const &sink) const$/;"	f	struct:boost::xpressive::detail::symbols	access:private	signature:(node const *const &p, Sink const &sink) const
peek_next_	xpressive/detail/dynamic/dynamic.hpp	/^    void peek_next_(mpl::false_, xpression_peeker<char_type> &) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:private	signature:(mpl::false_, xpression_peeker<char_type> &) const
peek_next_	xpressive/detail/dynamic/dynamic.hpp	/^    void peek_next_(mpl::true_, xpression_peeker<char_type> &peeker) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:private	signature:(mpl::true_, xpression_peeker<char_type> &peeker) const
peek_next_	xpressive/detail/static/static.hpp	/^    void peek_next_(mpl::false_, xpression_peeker<Char> &) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:private	signature:(mpl::false_, xpression_peeker<Char> &) const
peek_next_	xpressive/detail/static/static.hpp	/^    void peek_next_(mpl::true_, xpression_peeker<Char> &peeker) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:private	signature:(mpl::true_, xpression_peeker<Char> &peeker) const
peeker_	xpressive/detail/core/linker.hpp	/^        xpression_peeker<Char> *peeker_;$/;"	m	struct:boost::xpressive::detail::xpression_linker::alt_link_pred	access:public
peeker_string	xpressive/detail/core/peeker.hpp	/^struct peeker_string$/;"	s	namespace:boost::xpressive::detail
pick	xpressive/detail/utility/literals.hpp	/^    static BOOST_CONSTEXPR char const *pick(char const *cstr, wchar_t const *)$/;"	f	struct:boost::xpressive::detail::string_literal	access:public	signature:(char const *cstr, wchar_t const *)
pick	xpressive/detail/utility/literals.hpp	/^    static BOOST_CONSTEXPR char pick(char ch, wchar_t)$/;"	f	struct:boost::xpressive::detail::string_literal	access:public	signature:(char ch, wchar_t)
pick	xpressive/detail/utility/literals.hpp	/^    static BOOST_CONSTEXPR wchar_t const *pick(char const *, wchar_t const *cstr)$/;"	f	struct:boost::xpressive::detail::string_literal	access:public	signature:(char const *, wchar_t const *cstr)
pick	xpressive/detail/utility/literals.hpp	/^    static BOOST_CONSTEXPR wchar_t pick(char, wchar_t ch)$/;"	f	struct:boost::xpressive::detail::string_literal	access:public	signature:(char, wchar_t ch)
pimpl_	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        regex_impl<BidiIter> const *pimpl_;$/;"	m	struct:boost::xpressive::detail::regex_byref_matcher	access:public
pimpl_type	xpressive/basic_regex.hpp	/^    typedef proto::expr<proto::tag::terminal, proto::term<detail::tracking_ptr<detail::regex_impl<BidiIter> > >, 0> pimpl_type;$/;"	t	struct:boost::xpressive::basic_regex	access:private
placeholder	xpressive/regex_actions.hpp	/^    struct placeholder$/;"	s	namespace:boost::xpressive
pointer	xpressive/detail/core/list.hpp	/^        typedef T *pointer;$/;"	t	struct:boost::xpressive::detail::list	access:public
pointer	xpressive/regex_iterator.hpp	/^    typedef value_type const *pointer;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
pointer	xpressive/regex_token_iterator.hpp	/^    typedef value_type const *pointer;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
pop	xpressive/regex_actions.hpp	/^        struct pop$/;"	s	namespace:boost::xpressive::op
pop	xpressive/regex_actions.hpp	/^    function<op::pop>::type const pop = {{}};$/;"	m	class:boost::xpressive::function
pop_back	xpressive/detail/core/list.hpp	/^        void pop_back()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
pop_back	xpressive/regex_actions.hpp	/^        struct pop_back$/;"	s	namespace:boost::xpressive::op
pop_back	xpressive/regex_actions.hpp	/^    function<op::pop_back>::type const pop_back = {{}};$/;"	m	class:boost::xpressive::function
pop_context	xpressive/detail/core/state.hpp	/^    bool pop_context(regex_impl const &impl, bool success)$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:(regex_impl const &impl, bool success)
pop_context_match	xpressive/detail/core/flow_control.hpp	/^inline bool pop_context_match(match_state<BidiIter> &state)$/;"	f	namespace:boost::xpressive::detail	signature:(match_state<BidiIter> &state)
pop_front	xpressive/detail/core/list.hpp	/^        void pop_front()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
pop_front	xpressive/regex_actions.hpp	/^        struct pop_front$/;"	s	namespace:boost::xpressive::op
pop_front	xpressive/regex_actions.hpp	/^    function<op::pop_front>::type const pop_front = {{}};$/;"	m	class:boost::xpressive::function
pop_match	xpressive/detail/dynamic/matchable.hpp	/^    static bool pop_match(match_state<BidiIter> &state, void const *top)$/;"	f	struct:boost::xpressive::detail::matchable_ex	access:public	signature:(match_state<BidiIter> &state, void const *top)
pop_match	xpressive/detail/static/static.hpp	/^    static bool pop_match(match_state<BidiIter> &state, void const *top)$/;"	f	struct:boost::xpressive::detail::stacked_xpression	access:public	signature:(match_state<BidiIter> &state, void const *top)
position	xpressive/match_results.hpp	/^    difference_type position(size_type sub = 0) const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(size_type sub = 0) const
posix_charset_matcher	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^        posix_charset_matcher(char_class_type m, bool no)$/;"	f	struct:boost::xpressive::detail::posix_charset_matcher	access:public	signature:(char_class_type m, bool no)
posix_charset_matcher	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^    struct posix_charset_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_fixed_width
posix_charset_placeholder	xpressive/detail/static/placeholders.hpp	/^struct posix_charset_placeholder$/;"	s	namespace:boost::xpressive::detail
posix_no	xpressive/detail/utility/chset/chset.hpp	/^    std::vector<char_class_type> const &posix_no() const$/;"	f	class:boost::xpressive::detail::compound_charset::std	access:public	signature:() const
posix_no_	xpressive/detail/utility/chset/chset.hpp	/^    std::vector<char_class_type> posix_no_;$/;"	m	struct:boost::xpressive::detail::compound_charset	access:private
posix_yes	xpressive/detail/utility/chset/chset.hpp	/^    char_class_type posix_yes() const$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:() const
posix_yes_	xpressive/detail/utility/chset/chset.hpp	/^    char_class_type posix_yes_;$/;"	m	struct:boost::xpressive::detail::compound_charset	access:private
predicate_	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        Predicate predicate_;$/;"	m	struct:boost::xpressive::detail::predicate_matcher	access:public
predicate_context	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        explicit predicate_context(int sub, sub_match_impl<BidiIter> const *sub_matches, action_args_type *action_args)$/;"	f	struct:boost::xpressive::detail::predicate_context	access:public	signature:(int sub, sub_match_impl<BidiIter> const *sub_matches, action_args_type *action_args)
predicate_context	xpressive/detail/core/matcher/predicate_matcher.hpp	/^    struct predicate_context$/;"	s	namespace:boost::xpressive::detail
predicate_matcher	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        predicate_matcher(Predicate const &pred, int sub)$/;"	f	struct:boost::xpressive::detail::predicate_matcher	access:public	signature:(Predicate const &pred, int sub)
predicate_matcher	xpressive/detail/core/matcher/predicate_matcher.hpp	/^    struct predicate_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_assertion
prefix	xpressive/match_results.hpp	/^    const_reference prefix() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
prefix_	xpressive/match_results.hpp	/^    boost::optional<sub_match<BidiIter> > prefix_;$/;"	m	struct:boost::xpressive::match_results	access:private
prev_attr_context_	xpressive/detail/core/state.hpp	/^    attr_context *prev_attr_context_;$/;"	m	struct:boost::xpressive::detail::attr_context	access:public
prev_context_	xpressive/detail/core/state.hpp	/^    match_context<BidiIter> *prev_context_;$/;"	m	struct:boost::xpressive::detail::match_context	access:public
print	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const print = {{"print", false}};$/;"	m	class:boost::xpressive::proto::terminal
punct	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const punct = {{"punct", false}};$/;"	m	class:boost::xpressive::proto::terminal
pure	xpressive/detail/dynamic/sequence.hpp	/^    bool pure() const$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:() const
pure_	xpressive/detail/core/matcher/keeper_matcher.hpp	/^        bool pure_; \/\/ false if matching xpr_ could modify the sub-matches$/;"	m	struct:boost::xpressive::detail::keeper_matcher	access:public
pure_	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        bool pure_; \/\/ false if matching xpr_ could modify the sub-matches$/;"	m	struct:boost::xpressive::detail::lookahead_matcher	access:public
pure_	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        bool pure_; \/\/ false if matching xpr_ could modify the sub-matches$/;"	m	struct:boost::xpressive::detail::lookbehind_matcher	access:public
pure_	xpressive/detail/dynamic/sequence.hpp	/^    bool pure_;$/;"	m	struct:boost::xpressive::detail::sequence	access:private
purge_stale_deps_	xpressive/detail/utility/tracking_ptr.hpp	/^    void purge_stale_deps_()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:()
push	xpressive/regex_actions.hpp	/^        struct push$/;"	s	namespace:boost::xpressive::op
push	xpressive/regex_actions.hpp	/^    function<op::push>::type const push = {{}};$/;"	m	class:boost::xpressive::function
push_back	xpressive/detail/core/list.hpp	/^        void push_back(T const &t)$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:(T const &t)
push_back	xpressive/regex_actions.hpp	/^        struct push_back$/;"	s	namespace:boost::xpressive::op
push_back	xpressive/regex_actions.hpp	/^    function<op::push_back>::type const push_back = {{}};$/;"	m	class:boost::xpressive::function
push_back	xpressive/regex_primitives.hpp	/^    struct push_back : proto::callable$/;"	s	namespace:boost::xpressive::detail	inherits:proto::callable
push_context	xpressive/detail/core/state.hpp	/^    match_context push_context(regex_impl const &impl, matchable const &next, match_context &prev)$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:(regex_impl const &impl, matchable const &next, match_context &prev)
push_context_match	xpressive/detail/core/flow_control.hpp	/^inline bool push_context_match$/;"	f	namespace:boost::xpressive::detail	signature:( regex_impl<BidiIter> const &impl , match_state<BidiIter> &state , matchable<BidiIter> const &next )
push_front	xpressive/detail/core/list.hpp	/^        void push_front(T const &t)$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:(T const &t)
push_front	xpressive/regex_actions.hpp	/^        struct push_front$/;"	s	namespace:boost::xpressive::op
push_front	xpressive/regex_actions.hpp	/^    function<op::push_front>::type const push_front = {{}};$/;"	m	class:boost::xpressive::function
push_match	xpressive/detail/dynamic/matchable.hpp	/^    bool push_match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::matchable_ex	access:public	signature:(match_state<BidiIter> &state) const
push_match	xpressive/detail/dynamic/matchable.hpp	/^    bool push_match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:public	signature:(match_state<BidiIter> &state) const
push_match	xpressive/detail/static/static.hpp	/^    bool push_match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::static_xpression	access:public	signature:(match_state<BidiIter> &state) const
push_sequence	xpressive/detail/utility/sequence_stack.hpp	/^    T *push_sequence(std::size_t count, T const &t)$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:(std::size_t count, T const &t)
push_sequence	xpressive/detail/utility/sequence_stack.hpp	/^    T *push_sequence(std::size_t count, T const &t, fill_t)$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:(std::size_t count, T const &t, fill_t)
quant	xpressive/detail/dynamic/sequence.hpp	/^    quant_enum quant() const$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:() const
quant_	xpressive/detail/dynamic/sequence.hpp	/^    quant_enum quant_;$/;"	m	struct:boost::xpressive::detail::sequence	access:private
quant_enum	xpressive/detail/core/quant_style.hpp	/^enum quant_enum$/;"	g	namespace:boost::xpressive::detail
quant_fixed_width	xpressive/detail/core/quant_style.hpp	/^    quant_fixed_width,$/;"	e	enum:boost::xpressive::detail::quant_enum
quant_none	xpressive/detail/core/quant_style.hpp	/^    quant_none,$/;"	e	enum:boost::xpressive::detail::quant_enum
quant_spec	xpressive/detail/dynamic/matchable.hpp	/^struct quant_spec$/;"	s	namespace:boost::xpressive::detail
quant_style	xpressive/detail/core/quant_style.hpp	/^struct quant_style$/;"	s	namespace:boost::xpressive::detail
quant_style_assertion	xpressive/detail/core/quant_style.hpp	/^struct quant_style_assertion$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
quant_style_fixed_unknown_width	xpressive/detail/core/quant_style.hpp	/^typedef quant_style<quant_fixed_width> quant_style_fixed_unknown_width;$/;"	t	namespace:boost::xpressive::detail
quant_style_fixed_width	xpressive/detail/core/quant_style.hpp	/^struct quant_style_fixed_width$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
quant_style_none	xpressive/detail/core/quant_style.hpp	/^typedef quant_style<quant_none> quant_style_none;$/;"	t	namespace:boost::xpressive::detail
quant_style_variable_width	xpressive/detail/core/quant_style.hpp	/^typedef quant_style<quant_variable_width> quant_style_variable_width;$/;"	t	namespace:boost::xpressive::detail
quant_type	xpressive/detail/core/quant_style.hpp	/^struct quant_type$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::int_
quant_variable_width	xpressive/detail/core/quant_style.hpp	/^    quant_variable_width$/;"	e	enum:boost::xpressive::detail::quant_enum
range	xpressive/detail/utility/chset/range_run.hpp	/^    range(Char first, Char last);$/;"	p	struct:boost::xpressive::detail::range	access:public	signature:(Char first, Char last)
range	xpressive/detail/utility/chset/range_run.hpp	/^struct range$/;"	s	namespace:boost::xpressive::detail
range	xpressive/regex_primitives.hpp	/^range(Char ch_min, Char ch_max)$/;"	f	class:boost::xpressive::proto::terminal	signature:(Char ch_min, Char ch_max)
range_begin	xpressive/sub_match.hpp	/^inline BidiIter range_begin(sub_match<BidiIter> &sub)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> &sub)
range_begin	xpressive/sub_match.hpp	/^inline BidiIter range_begin(sub_match<BidiIter> const &sub)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &sub)
range_compare	xpressive/detail/utility/chset/range_run.hpp	/^struct range_compare$/;"	s	namespace:boost::xpressive::detail
range_const_iterator	xpressive/sub_match.hpp	/^    struct range_const_iterator<xpressive::sub_match<BidiIter> >$/;"	s	namespace:boost
range_data	xpressive/detail/utility/algorithm.hpp	/^struct range_data$/;"	s	namespace:boost::xpressive::detail	inherits:range_value
range_data	xpressive/detail/utility/algorithm.hpp	/^struct range_data<T *>$/;"	s	namespace:boost::xpressive::detail	inherits:remove_const
range_end	xpressive/sub_match.hpp	/^inline BidiIter range_end(sub_match<BidiIter> &sub)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> &sub)
range_end	xpressive/sub_match.hpp	/^inline BidiIter range_end(sub_match<BidiIter> const &sub)$/;"	f	namespace:boost::xpressive	signature:(sub_match<BidiIter> const &sub)
range_matcher	xpressive/detail/core/matcher/range_matcher.hpp	/^        range_matcher(char_type ch_min, char_type ch_max, bool no, Traits const &)$/;"	f	struct:boost::xpressive::detail::range_matcher	access:public	signature:(char_type ch_min, char_type ch_max, bool no, Traits const &)
range_matcher	xpressive/detail/core/matcher/range_matcher.hpp	/^    struct range_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_fixed_width
range_mutable_iterator	xpressive/sub_match.hpp	/^    struct range_mutable_iterator<xpressive::sub_match<BidiIter> >$/;"	s	namespace:boost
range_placeholder	xpressive/detail/static/placeholders.hpp	/^struct range_placeholder$/;"	s	namespace:boost::xpressive::detail
range_run	xpressive/detail/utility/chset/range_run.hpp	/^struct range_run$/;"	s	namespace:boost::xpressive::detail
range_type	xpressive/detail/utility/chset/range_run.hpp	/^    typedef range<Char> range_type;$/;"	t	struct:boost::xpressive::detail::range_run	access:public
raw_copy_	xpressive/detail/utility/tracking_ptr.hpp	/^    void raw_copy_(Derived that)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:(Derived that)
re	xpressive/regex_algorithms.hpp	/^      , basic_regex<BidiIter> const &re$/;"	m	namespace:boost::xpressive::detail
read_attr	xpressive/detail/static/transforms/as_action.hpp	/^    struct read_attr$/;"	s	namespace:boost::xpressive::detail
read_attr	xpressive/detail/static/transforms/as_action.hpp	/^    struct read_attr<Nbr, Matcher &>$/;"	s	namespace:boost::xpressive::detail
reclaim_all	xpressive/detail/core/results_cache.hpp	/^        void reclaim_all(nested_results<BidiIter> &out)$/;"	f	struct:boost::xpressive::detail::results_cache	access:public	signature:(nested_results<BidiIter> &out)
reclaim_last	xpressive/detail/core/results_cache.hpp	/^        void reclaim_last(nested_results<BidiIter> &out)$/;"	f	struct:boost::xpressive::detail::results_cache	access:public	signature:(nested_results<BidiIter> &out)
reclaim_last_n	xpressive/detail/core/results_cache.hpp	/^        void reclaim_last_n(nested_results<BidiIter> &out, std::size_t count)$/;"	f	struct:boost::xpressive::detail::results_cache	access:public	signature:(nested_results<BidiIter> &out, std::size_t count)
reclaim_sub_matches	xpressive/detail/core/state.hpp	/^inline void reclaim_sub_matches(memento<BidiIter> const &mem, match_state<BidiIter> &state, bool success)$/;"	f	namespace:boost::xpressive::detail	signature:(memento<BidiIter> const &mem, match_state<BidiIter> &state, bool success)
ref	xpressive/detail/utility/save_restore.hpp	/^        T &ref;$/;"	m	struct:boost::xpressive::detail::save_restore	access:private
ref	xpressive/regex_actions.hpp	/^    reference<T> const ref(T &t)$/;"	f	namespace:boost::xpressive	signature:(T &t)
reference	xpressive/detail/core/list.hpp	/^        typedef T &reference;$/;"	t	struct:boost::xpressive::detail::list	access:public
reference	xpressive/detail/core/matcher/action_matcher.hpp	/^            reference;$/;"	t	struct:boost::xpressive::detail::by_ref_transform::impl	access:public
reference	xpressive/detail/core/matcher/action_matcher.hpp	/^        typedef T const &reference;$/;"	t	struct:boost::xpressive::detail::opt	access:public
reference	xpressive/detail/core/sub_match_vector.hpp	/^    typedef const_reference reference;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
reference	xpressive/match_results.hpp	/^    typedef value_type const &reference;$/;"	t	struct:boost::xpressive::match_results	access:public
reference	xpressive/regex_actions.hpp	/^            typedef typename add_reference<T>::type reference;$/;"	t	struct:boost::xpressive::detail::action_arg	access:public
reference	xpressive/regex_actions.hpp	/^        explicit reference(T &t)$/;"	f	struct:boost::xpressive::reference	access:public	signature:(T &t)
reference	xpressive/regex_actions.hpp	/^    struct reference$/;"	s	namespace:boost::xpressive	inherits:proto::extends
reference	xpressive/regex_iterator.hpp	/^    typedef value_type const &reference;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
reference	xpressive/regex_token_iterator.hpp	/^    typedef value_type const &reference;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
references_type	xpressive/detail/utility/tracking_ptr.hpp	/^    typedef std::set<shared_ptr<Derived> > references_type;$/;"	t	struct:boost::xpressive::detail::enable_reference_tracking	access:public
refs_	xpressive/detail/utility/tracking_ptr.hpp	/^    references_type refs_;$/;"	m	struct:boost::xpressive::detail::enable_reference_tracking	access:private
regex_byref_matcher	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        regex_byref_matcher(shared_ptr<regex_impl<BidiIter> > const &impl)$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:public	signature:(shared_ptr<regex_impl<BidiIter> > const &impl)
regex_byref_matcher	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^    struct regex_byref_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
regex_compiler	xpressive/regex_compiler.hpp	/^    explicit regex_compiler(RegexTraits const &traits = RegexTraits())$/;"	f	struct:boost::xpressive::regex_compiler	access:public	signature:(RegexTraits const &traits = RegexTraits())
regex_compiler	xpressive/regex_compiler.hpp	/^struct regex_compiler$/;"	s	namespace:boost::xpressive
regex_constants	xpressive/detail/core/icase.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost::xpressive
regex_constants	xpressive/detail/dynamic/parser_enum.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost::xpressive
regex_constants	xpressive/regex_constants.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost::xpressive
regex_domain	xpressive/detail/core/regex_domain.hpp	/^    struct regex_domain$/;"	s	namespace:boost::xpressive::detail	inherits:proto::domain
regex_error	xpressive/regex_error.hpp	/^    explicit regex_error(regex_constants::error_type code, char const *str = "")$/;"	f	struct:boost::xpressive::regex_error	access:public	signature:(regex_constants::error_type code, char const *str = )
regex_error	xpressive/regex_error.hpp	/^struct regex_error$/;"	s	namespace:boost::xpressive	inherits:std::runtime_error,boost::exception
regex_id	xpressive/basic_regex.hpp	/^    regex_id_type regex_id() const$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:() const
regex_id	xpressive/match_results.hpp	/^    regex_id_type regex_id() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
regex_id_	xpressive/match_results.hpp	/^    regex_id_type regex_id_;$/;"	m	struct:boost::xpressive::match_results	access:private
regex_id_	xpressive/match_results.hpp	/^    regex_id_type regex_id_;$/;"	m	struct:boost::xpressive::regex_id_filter_predicate	access:private
regex_id_filter_predicate	xpressive/match_results.hpp	/^    regex_id_filter_predicate(regex_id_type regex_id)$/;"	f	struct:boost::xpressive::regex_id_filter_predicate	access:public	signature:(regex_id_type regex_id)
regex_id_filter_predicate	xpressive/match_results.hpp	/^struct regex_id_filter_predicate$/;"	s	namespace:boost::xpressive	inherits:std::unary_function
regex_id_type	xpressive/xpressive_fwd.hpp	/^    typedef void const *regex_id_type;$/;"	t	namespace:boost::xpressive
regex_impl	xpressive/detail/core/regex_impl.hpp	/^    regex_impl()$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:()
regex_impl	xpressive/detail/core/regex_impl.hpp	/^    regex_impl(regex_impl<BidiIter> const &that)$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:(regex_impl<BidiIter> const &that)
regex_impl	xpressive/detail/core/regex_impl.hpp	/^struct regex_impl$/;"	s	namespace:boost::xpressive::detail	inherits:enable_reference_tracking
regex_impl	xpressive/detail/core/state.hpp	/^    typedef detail::regex_impl<BidiIter> regex_impl;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
regex_iterator	xpressive/regex_iterator.hpp	/^    regex_iterator$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , detail::let_<LetExpr> const &args , regex_constants::match_flag_type flags = regex_constants::match_default )
regex_iterator	xpressive/regex_iterator.hpp	/^    regex_iterator$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , regex_constants::match_flag_type flags = regex_constants::match_default )
regex_iterator	xpressive/regex_iterator.hpp	/^    regex_iterator()$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:()
regex_iterator	xpressive/regex_iterator.hpp	/^    regex_iterator(regex_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_iterator	access:public	signature:(regex_iterator<BidiIter> const &that)
regex_iterator	xpressive/regex_iterator.hpp	/^struct regex_iterator$/;"	s	namespace:boost::xpressive
regex_iterator_impl	xpressive/regex_iterator.hpp	/^    regex_iterator_impl$/;"	f	struct:boost::xpressive::detail::regex_iterator_impl	access:public	signature:( BidiIter begin , BidiIter cur , BidiIter end , BidiIter next_search , basic_regex<BidiIter> const &rex , regex_constants::match_flag_type flags , bool not_null = false )
regex_iterator_impl	xpressive/regex_iterator.hpp	/^struct regex_iterator_impl$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
regex_matcher	xpressive/detail/core/matcher/regex_matcher.hpp	/^        regex_matcher(shared_ptr<regex_impl<BidiIter> > const &impl)$/;"	f	struct:boost::xpressive::detail::regex_matcher	access:public	signature:(shared_ptr<regex_impl<BidiIter> > const &impl)
regex_matcher	xpressive/detail/core/matcher/regex_matcher.hpp	/^    struct regex_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
regex_token_iterator	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex )
regex_token_iterator	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , Subs const &subs , detail::let_<LetExpr> const &args , regex_constants::match_flag_type flags = regex_constants::match_default )
regex_token_iterator	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , Subs const &subs , regex_constants::match_flag_type flags = regex_constants::match_default )
regex_token_iterator	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:( BidiIter begin , BidiIter end , basic_regex<BidiIter> const &rex , detail::let_<LetExpr> const &args )
regex_token_iterator	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator()$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:()
regex_token_iterator	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator(regex_token_iterator<BidiIter> const &that)$/;"	f	struct:boost::xpressive::regex_token_iterator	access:public	signature:(regex_token_iterator<BidiIter> const &that)
regex_token_iterator	xpressive/regex_token_iterator.hpp	/^struct regex_token_iterator$/;"	s	namespace:boost::xpressive
regex_token_iterator_impl	xpressive/regex_token_iterator.hpp	/^    regex_token_iterator_impl$/;"	f	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public	signature:( BidiIter begin , BidiIter cur , BidiIter end , BidiIter next_search , basic_regex<BidiIter> const &rex , regex_constants::match_flag_type flags = regex_constants::match_default , std::vector<int> subs = std::vector<int>(1, 0) , int n = -2 , bool not_null = false )
regex_token_iterator_impl	xpressive/regex_token_iterator.hpp	/^struct regex_token_iterator_impl$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
regex_traits	xpressive/detail/dynamic/parser_traits.hpp	/^    typedef RegexTraits regex_traits;$/;"	t	struct:boost::xpressive::compiler_traits	access:public
regex_traits	xpressive/regex_traits.hpp	/^    explicit regex_traits(locale_type const &loc)$/;"	f	struct:boost::xpressive::regex_traits	access:public	signature:(locale_type const &loc)
regex_traits	xpressive/regex_traits.hpp	/^    regex_traits()$/;"	f	struct:boost::xpressive::regex_traits	access:public	signature:()
regex_traits	xpressive/regex_traits.hpp	/^struct regex_traits$/;"	s	namespace:boost::xpressive	inherits:Impl
regex_traits_type	xpressive/detail/core/linker.hpp	/^struct regex_traits_type$/;"	s	namespace:boost::xpressive::detail
regex_traits_version_1_case_fold_tag	xpressive/regex_traits.hpp	/^struct regex_traits_version_1_case_fold_tag$/;"	s	namespace:boost::xpressive	inherits:regex_traits_version_1_tag
regex_traits_version_1_tag	xpressive/regex_traits.hpp	/^struct regex_traits_version_1_tag$/;"	s	namespace:boost::xpressive
regex_traits_version_2_tag	xpressive/regex_traits.hpp	/^struct regex_traits_version_2_tag$/;"	s	namespace:boost::xpressive	inherits:regex_traits_version_1_tag
regex_type	xpressive/regex_iterator.hpp	/^    typedef basic_regex<BidiIter> regex_type;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
regex_type	xpressive/regex_token_iterator.hpp	/^    typedef basic_regex<BidiIter> regex_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
release	xpressive/detail/utility/counted_base.hpp	/^        static void release(counted_base<Derived> const *that)$/;"	f	struct:boost::xpressive::detail::counted_base_access	access:public	signature:(counted_base<Derived> const *that)
release	xpressive/detail/utility/tracking_ptr.hpp	/^    void release()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:public	signature:()
repeat	xpressive/detail/dynamic/dynamic.hpp	/^    virtual void repeat(quant_spec const &spec, sequence<BidiIter> &seq) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:public	signature:(quant_spec const &spec, sequence<BidiIter> &seq) const
repeat	xpressive/detail/dynamic/matchable.hpp	/^    virtual void repeat(quant_spec const &, sequence<BidiIter> &) const$/;"	f	struct:boost::xpressive::detail::matchable_ex	access:public	signature:(quant_spec const &, sequence<BidiIter> &) const
repeat	xpressive/detail/dynamic/sequence.hpp	/^    void repeat(quant_spec const &spec)$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:(quant_spec const &spec)
repeat	xpressive/regex_primitives.hpp	/^repeat(Expr const &expr)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr const &expr)
repeat	xpressive/regex_primitives.hpp	/^repeat(Expr2 const &expr2)$/;"	f	class:boost::xpressive::proto::result_of::make_expr	signature:(Expr2 const &expr2)
repeat_	xpressive/detail/dynamic/dynamic.hpp	/^    void repeat_(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_fixed_width>, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:private	signature:(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_fixed_width>, mpl::false_) const
repeat_	xpressive/detail/dynamic/dynamic.hpp	/^    void repeat_(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_fixed_width>, mpl::true_) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:private	signature:(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_fixed_width>, mpl::true_) const
repeat_	xpressive/detail/dynamic/dynamic.hpp	/^    void repeat_(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_none>, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:private	signature:(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_none>, mpl::false_) const
repeat_	xpressive/detail/dynamic/dynamic.hpp	/^    void repeat_(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_variable_width>, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::dynamic_xpression	access:private	signature:(quant_spec const &spec, sequence<BidiIter> &seq, mpl::int_<quant_variable_width>, mpl::false_) const
repeat_begin_matcher	xpressive/detail/core/matcher/repeat_begin_matcher.hpp	/^        repeat_begin_matcher(int mark_number)$/;"	f	struct:boost::xpressive::detail::repeat_begin_matcher	access:public	signature:(int mark_number)
repeat_begin_matcher	xpressive/detail/core/matcher/repeat_begin_matcher.hpp	/^    struct repeat_begin_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
repeat_count_	xpressive/detail/core/sub_match_impl.hpp	/^    unsigned int repeat_count_;$/;"	m	struct:boost::xpressive::detail::sub_match_impl	access:public
repeat_end_matcher	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^        repeat_end_matcher(int mark_nbr, unsigned int min, unsigned int max)$/;"	f	struct:boost::xpressive::detail::repeat_end_matcher	access:public	signature:(int mark_nbr, unsigned int min, unsigned int max)
repeat_end_matcher	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^    struct repeat_end_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style
repeat_max	xpressive/regex_primitives.hpp	/^unsigned int const repeat_max = UINT_MAX-1;$/;"	m	namespace:boost::xpressive
reset	xpressive/detail/core/access.hpp	/^    static void reset(match_results<BidiIter> &what)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what)
reset	xpressive/detail/core/state.hpp	/^    void reset(match_results &what, regex_impl const &impl)$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:(match_results &what, regex_impl const &impl)
reset	xpressive/regex_compiler.hpp	/^    void reset()$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:()
reset_	xpressive/match_results.hpp	/^    void reset_()$/;"	f	struct:boost::xpressive::match_results	access:private	signature:()
rest_	xpressive/match_results.hpp	/^    transform_op next_, rest_;$/;"	m	struct:boost::xpressive::detail::case_converting_iterator	access:private
restore	xpressive/detail/utility/save_restore.hpp	/^        void restore()$/;"	f	struct:boost::xpressive::detail::save_restore	access:public	signature:()
restore_action_queue	xpressive/detail/core/state.hpp	/^inline void restore_action_queue(memento<BidiIter> const &mem, match_state<BidiIter> &state)$/;"	f	namespace:boost::xpressive::detail	signature:(memento<BidiIter> const &mem, match_state<BidiIter> &state)
restore_sub_matches	xpressive/detail/core/state.hpp	/^inline void restore_sub_matches(memento<BidiIter> const &mem, match_state<BidiIter> &state)$/;"	f	namespace:boost::xpressive::detail	signature:(memento<BidiIter> const &mem, match_state<BidiIter> &state)
result	xpressive/detail/static/transforms/as_inverse.hpp	/^        struct result<This(Matcher)>$/;"	s	struct:boost::xpressive::grammar_detail::as_inverse	inherits:inverter	access:public
result	xpressive/detail/utility/symbols.hpp	/^                result_type result;$/;"	m	union:boost::xpressive::detail::symbols::node::__anon1	access:public
result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::detail::BindArg	access:public
result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::at	access:public
result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::back	access:public
result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::first	access:public
result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::front	access:public
result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::length	access:public
result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::make_pair	access:public
result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::second	access:public
result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::str	access:public
result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::top	access:public
result	xpressive/regex_actions.hpp	/^            struct result {};$/;"	s	struct:boost::xpressive::op::unwrap_reference	access:public
result	xpressive/regex_actions.hpp	/^            struct result$/;"	s	struct:boost::xpressive::op::insert	access:public
result	xpressive/regex_actions.hpp	/^            struct result<This(Cont &, Idx)>$/;"	s	struct:boost::xpressive::op::at	access:public
result	xpressive/regex_actions.hpp	/^            struct result<This(Cont const &, Idx)>$/;"	s	struct:boost::xpressive::op::at	access:public
result	xpressive/regex_actions.hpp	/^            struct result<This(Cont, Idx)>$/;"	s	struct:boost::xpressive::op::at	access:public
result	xpressive/regex_actions.hpp	/^            struct result<This(First, Second)>$/;"	s	struct:boost::xpressive::op::make_pair	access:public
result	xpressive/regex_actions.hpp	/^            struct result<This(MatchResults, Expr)>$/;"	s	struct:boost::xpressive::detail::BindArg	access:public
result	xpressive/regex_actions.hpp	/^            struct result<This(Pair)>$/;"	s	struct:boost::xpressive::op::first	access:public
result	xpressive/regex_actions.hpp	/^            struct result<This(Pair)>$/;"	s	struct:boost::xpressive::op::second	access:public
result	xpressive/regex_actions.hpp	/^            struct result<This(Ref &)>$/;"	s	struct:boost::xpressive::op::unwrap_reference	access:public
result	xpressive/regex_actions.hpp	/^            struct result<This(Ref)>$/;"	s	struct:boost::xpressive::op::unwrap_reference	access:public
result	xpressive/regex_actions.hpp	/^            struct result<This(Sequence)>$/;"	s	struct:boost::xpressive::op::back	access:public
result	xpressive/regex_actions.hpp	/^            struct result<This(Sequence)>$/;"	s	struct:boost::xpressive::op::front	access:public
result	xpressive/regex_actions.hpp	/^            struct result<This(Sequence)>$/;"	s	struct:boost::xpressive::op::top	access:public
result	xpressive/regex_actions.hpp	/^            struct result<This(Sub)>$/;"	s	struct:boost::xpressive::op::length	access:public
result	xpressive/regex_actions.hpp	/^            struct result<This(Sub)>$/;"	s	struct:boost::xpressive::op::str	access:public
result	xpressive/regex_primitives.hpp	/^        struct result {};$/;"	s	struct:boost::xpressive::detail::skip_directive	access:public
result	xpressive/regex_primitives.hpp	/^        struct result<This(Expr)>$/;"	s	struct:boost::xpressive::detail::skip_directive	access:public
result_	xpressive/regex_token_iterator.hpp	/^    value_type result_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
result_detail	xpressive/regex_actions.hpp	/^                struct result_detail$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
result_detail	xpressive/regex_actions.hpp	/^                struct result_detail<This(Cont, It, It), void>$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
result_detail	xpressive/regex_actions.hpp	/^                struct result_detail<This(Cont, It, Size, Value),$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
result_detail	xpressive/regex_actions.hpp	/^                struct result_detail<This(Cont, It, Value),$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
result_detail	xpressive/regex_actions.hpp	/^                struct result_detail<This(Cont, Pos0, String, Pos1, Length)>$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
result_detail	xpressive/regex_actions.hpp	/^                struct result_detail<This(Cont, Size, A0, A1),$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
result_detail	xpressive/regex_actions.hpp	/^                struct result_detail<This(Cont, Size, T),$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
result_detail	xpressive/regex_actions.hpp	/^                struct result_detail<This(Cont, Value), void>$/;"	s	struct:boost::xpressive::op::insert::detail	access:public
result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::detail::attr_transform::impl	access:public
result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::detail::attr_with_default_transform::impl	access:public
result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::detail::by_ref_transform::impl	access:public
result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::detail::mark_transform::impl	access:public
result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::detail::subreg_transform::impl	access:public
result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            typedef Arg &result_type;$/;"	t	struct:boost::xpressive::detail::action_context::eval_terminal	access:public
result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            typedef Arg const &result_type;$/;"	t	struct:boost::xpressive::detail::action_context::eval_terminal	access:public
result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            typedef typename action_arg<Type, Int>::reference result_type;$/;"	t	struct:boost::xpressive::detail::action_context::eval_terminal	access:public
result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            typedef typename temp_type::type result_type;$/;"	t	struct:boost::xpressive::detail::action_context::eval	access:public
result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^        >::type result_type;$/;"	t	struct:boost::xpressive::detail::mem_ptr_eval	access:public
result_type	xpressive/detail/core/matcher/action_matcher.hpp	/^        result_type;$/;"	t	struct:boost::xpressive::detail::mem_ptr_eval	access:public
result_type	xpressive/detail/core/matcher/attr_matcher.hpp	/^        typedef typename Matcher::value_type::second_type const* result_type;$/;"	t	class:boost::xpressive::detail::attr_matcher::Matcher::value_type	access:public
result_type	xpressive/detail/core/matcher/predicate_matcher.hpp	/^            typedef Arg &result_type;$/;"	t	struct:boost::xpressive::detail::predicate_context::eval_terminal	access:public
result_type	xpressive/detail/core/matcher/predicate_matcher.hpp	/^            typedef sub_match<BidiIter> const &result_type;$/;"	t	struct:boost::xpressive::detail::predicate_context::eval_terminal	access:public
result_type	xpressive/detail/core/matcher/predicate_matcher.hpp	/^            typedef typename action_arg<Type, Int>::reference result_type;$/;"	t	struct:boost::xpressive::detail::predicate_context::eval_terminal	access:public
result_type	xpressive/detail/static/transforms/as_action.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::add_attrs::impl	access:public
result_type	xpressive/detail/static/transforms/as_action.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_action::impl	access:public
result_type	xpressive/detail/static/transforms/as_action.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_attr_matcher::impl	access:public
result_type	xpressive/detail/static/transforms/as_action.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_read_attr::impl	access:public
result_type	xpressive/detail/static/transforms/as_action.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::max_attr::impl	access:public
result_type	xpressive/detail/static/transforms/as_action.hpp	/^            typedef typename expr_type::proto_child0::nbr_type::type result_type;$/;"	t	struct:boost::xpressive::grammar_detail::attr_nbr::impl	access:public
result_type	xpressive/detail/static/transforms/as_alternate.hpp	/^                result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_alternate_matcher::impl	access:public
result_type	xpressive/detail/static/transforms/as_alternate.hpp	/^                result_type;$/;"	t	struct:boost::xpressive::grammar_detail::in_alternate_list::impl	access:public
result_type	xpressive/detail/static/transforms/as_independent.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_keeper::impl	access:public
result_type	xpressive/detail/static/transforms/as_independent.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookahead::impl	access:public
result_type	xpressive/detail/static/transforms/as_independent.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookbehind::impl	access:public
result_type	xpressive/detail/static/transforms/as_marker.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_marker::impl	access:public
result_type	xpressive/detail/static/transforms/as_matcher.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_matcher::impl	access:public
result_type	xpressive/detail/static/transforms/as_modifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_modifier::impl	access:public
result_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::add_hidden_mark::impl	access:public
result_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_optional::impl	access:public
result_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_quantifier::impl	access:public
result_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_quantifier_impl::impl	access:public
result_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_mark_optional::impl	access:public
result_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_simple_quantifier::impl	access:public
result_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::make_optional_::impl	access:public
result_type	xpressive/detail/static/transforms/as_sequence.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::in_sequence::impl	access:public
result_type	xpressive/detail/static/transforms/as_set.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_list_set_matcher::impl	access:public
result_type	xpressive/detail/static/transforms/as_set.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_set_matcher::impl	access:public
result_type	xpressive/detail/utility/symbols.hpp	/^        typedef value_type const *result_type;$/;"	t	struct:boost::xpressive::detail::symbols	access:public
result_type	xpressive/detail/utility/traits_utils.hpp	/^        typedef From const &result_type;$/;"	t	struct:boost::xpressive::detail::string_cast_	access:public
result_type	xpressive/detail/utility/traits_utils.hpp	/^        typedef To const result_type;$/;"	t	struct:boost::xpressive::detail::string_cast_	access:public
result_type	xpressive/detail/utility/traits_utils.hpp	/^        typedef typename Traits::char_type result_type;$/;"	t	struct:boost::xpressive::detail::widen_fun	access:public
result_type	xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::as	access:public
result_type	xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::const_cast_	access:public
result_type	xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::construct	access:public
result_type	xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::dynamic_cast_	access:public
result_type	xpressive/regex_actions.hpp	/^            typedef T result_type;$/;"	t	struct:boost::xpressive::op::static_cast_	access:public
result_type	xpressive/regex_actions.hpp	/^            typedef bool result_type;$/;"	t	struct:boost::xpressive::op::matched	access:public
result_type	xpressive/regex_actions.hpp	/^            typedef int result_type;$/;"	t	struct:boost::xpressive::detail::mark_nbr	access:public
result_type	xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::pop	access:public
result_type	xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::pop_back	access:public
result_type	xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::pop_front	access:public
result_type	xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::push	access:public
result_type	xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::push_back	access:public
result_type	xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::push_front	access:public
result_type	xpressive/regex_actions.hpp	/^            typedef void result_type;$/;"	t	struct:boost::xpressive::op::throw_	access:public
result_type	xpressive/regex_primitives.hpp	/^            result_type;$/;"	t	struct:boost::xpressive::detail::skip_primitives::impl	access:public
result_type	xpressive/regex_primitives.hpp	/^        typedef int result_type;$/;"	t	struct:boost::xpressive::detail::mark_number	access:public
result_type	xpressive/regex_primitives.hpp	/^        typedef int result_type;$/;"	t	struct:boost::xpressive::detail::push_back	access:public
results_cache	xpressive/detail/core/results_cache.hpp	/^    struct results_cache$/;"	s	namespace:boost::xpressive::detail
results_cache_	xpressive/match_results.hpp	/^    results_cache<BidiIter> results_cache_;$/;"	m	struct:boost::xpressive::detail::results_extras	access:public
results_extras	xpressive/detail/core/state.hpp	/^    typedef detail::results_extras<BidiIter> results_extras;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
results_extras	xpressive/match_results.hpp	/^struct results_extras$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
results_ptr_	xpressive/detail/core/state.hpp	/^    match_results<BidiIter> *results_ptr_;$/;"	m	struct:boost::xpressive::detail::match_context	access:public
rex_	xpressive/regex_iterator.hpp	/^    basic_regex<BidiIter> rex_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
right_type	xpressive/detail/core/matcher/action_matcher.hpp	/^        typedef typename child_<Expr, 1>::type right_type;$/;"	t	struct:boost::xpressive::detail::mem_ptr_eval	access:public
root	xpressive/detail/utility/symbols.hpp	/^        boost::shared_ptr<node> root;$/;"	m	struct:boost::xpressive::detail::symbols	access:private
rr_	xpressive/detail/utility/chset/basic_chset.hpp	/^    range_run<Char> rr_;$/;"	m	struct:boost::xpressive::detail::basic_chset	access:private
rules_	xpressive/regex_compiler.hpp	/^    std::map<string_type, basic_regex<BidiIter> > rules_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
run_	xpressive/detail/utility/chset/range_run.hpp	/^    run_type run_;$/;"	m	struct:boost::xpressive::detail::range_run	access:private
run_type	xpressive/detail/utility/chset/range_run.hpp	/^    typedef std::vector<range_type> run_type;$/;"	t	struct:boost::xpressive::detail::range_run	access:public
runtime_error	xpressive/regex_error.hpp	/^    struct runtime_error {};$/;"	s	namespace:std
rxtraits	xpressive/regex_compiler.hpp	/^    traits_type &rxtraits()$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:()
rxtraits	xpressive/regex_compiler.hpp	/^    traits_type const &rxtraits() const$/;"	f	struct:boost::xpressive::regex_compiler	access:private	signature:() const
satisfy_	xpressive/detail/utility/tracking_ptr.hpp	/^    void satisfy_()$/;"	f	struct:boost::xpressive::detail::weak_iterator	access:private	signature:()
save_restore	xpressive/detail/utility/save_restore.hpp	/^        explicit save_restore(T &t)$/;"	f	struct:boost::xpressive::detail::save_restore	access:public	signature:(T &t)
save_restore	xpressive/detail/utility/save_restore.hpp	/^        save_restore(T &t, T const &n)$/;"	f	struct:boost::xpressive::detail::save_restore	access:public	signature:(T &t, T const &n)
save_restore	xpressive/detail/utility/save_restore.hpp	/^    struct save_restore$/;"	s	namespace:boost::xpressive::detail	inherits:noncopyable
save_sub_matches	xpressive/detail/core/state.hpp	/^inline memento<BidiIter> save_sub_matches(match_state<BidiIter> &state)$/;"	f	namespace:boost::xpressive::detail	signature:(match_state<BidiIter> &state)
scont_	xpressive/regex_actions.hpp	/^                    static cont_type &scont_;$/;"	m	struct:boost::xpressive::op::insert::detail::result_detail	access:public
scope_next	xpressive/match_results.hpp	/^enum transform_scope { scope_next = 0, scope_rest = 1 };$/;"	e	enum:boost::xpressive::detail::transform_scope
scope_rest	xpressive/match_results.hpp	/^enum transform_scope { scope_next = 0, scope_rest = 1 };$/;"	e	enum:boost::xpressive::detail::transform_scope
search	xpressive/detail/utility/symbols.hpp	/^        result_type search(BidiIter &begin, BidiIter end, Trans trans, node* p) const$/;"	f	struct:boost::xpressive::detail::symbols	access:private	signature:(BidiIter &begin, BidiIter end, Trans trans, node* p) const
second	xpressive/regex_actions.hpp	/^        struct second$/;"	s	namespace:boost::xpressive::op
second	xpressive/regex_actions.hpp	/^    function<op::second>::type const second = {{}};$/;"	m	class:boost::xpressive::function
second_type	xpressive/regex_actions.hpp	/^                typedef typename decay<Second>::type second_type;$/;"	t	struct:boost::xpressive::op::make_pair::result	access:public
self	xpressive/detail/static/visitor.hpp	/^        shared_ptr<regex_impl<BidiIter> > &self()$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:public	signature:()
self	xpressive/regex_primitives.hpp	/^proto::terminal<detail::self_placeholder>::type const self = {{}};$/;"	m	class:boost::xpressive::proto::terminal
self_	xpressive/detail/static/visitor.hpp	/^        shared_ptr<regex_impl<BidiIter> > self_;$/;"	m	struct:boost::xpressive::detail::xpression_visitor_base	access:private
self_	xpressive/detail/utility/tracking_ptr.hpp	/^    enable_reference_tracking<Derived> *self_;$/;"	m	struct:boost::xpressive::detail::filter_self	access:private
self_	xpressive/detail/utility/tracking_ptr.hpp	/^    shared_ptr<Derived> self_;$/;"	m	struct:boost::xpressive::detail::enable_reference_tracking	access:private
self_	xpressive/regex_compiler.hpp	/^    shared_ptr<detail::regex_impl<BidiIter> > self_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
self_placeholder	xpressive/detail/static/placeholders.hpp	/^struct self_placeholder$/;"	s	namespace:boost::xpressive::detail
sequence	xpressive/detail/dynamic/sequence.hpp	/^    sequence()$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:()
sequence	xpressive/detail/dynamic/sequence.hpp	/^    sequence(intrusive_ptr<dynamic_xpression<Matcher, BidiIter> > const &xpr)$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:(intrusive_ptr<dynamic_xpression<Matcher, BidiIter> > const &xpr)
sequence	xpressive/detail/dynamic/sequence.hpp	/^    sequence(intrusive_ptr<dynamic_xpression<alternate_matcher<alternates_vector<BidiIter>, Traits>, BidiIter> > const &xpr)$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:(intrusive_ptr<dynamic_xpression<alternate_matcher<alternates_vector<BidiIter>, Traits>, BidiIter> > const &xpr)
sequence	xpressive/detail/dynamic/sequence.hpp	/^struct sequence$/;"	s	namespace:boost::xpressive::detail
sequence_stack	xpressive/detail/utility/sequence_stack.hpp	/^    sequence_stack()$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:()
sequence_stack	xpressive/detail/utility/sequence_stack.hpp	/^struct sequence_stack$/;"	s	namespace:boost::xpressive::detail
sequence_type	xpressive/regex_actions.hpp	/^                typedef typename remove_reference<Sequence>::type sequence_type;$/;"	t	struct:boost::xpressive::op::back::result	access:public
sequence_type	xpressive/regex_actions.hpp	/^                typedef typename remove_reference<Sequence>::type sequence_type;$/;"	t	struct:boost::xpressive::op::front::result	access:public
sequence_type	xpressive/regex_actions.hpp	/^                typedef typename remove_reference<Sequence>::type sequence_type;$/;"	t	struct:boost::xpressive::op::top::result	access:public
set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char c);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char c)
set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char c);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char c)
set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char c, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char c, Traits const &tr)
set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char c, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char c, Traits const &tr)
set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char from, Char to);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char from, Char to)
set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char from, Char to);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char from, Char to)
set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char from, Char to, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char from, Char to, Traits const &tr)
set	xpressive/detail/utility/chset/basic_chset.hpp	/^    void set(Char from, Char to, Traits const &tr);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char from, Char to, Traits const &tr)
set	xpressive/detail/utility/chset/range_run.hpp	/^    void set(range_type const &r);$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:(range_type const &r)
set	xpressive/regex_primitives.hpp	/^detail::set_initializer_type const set = {{}};$/;"	m	class:boost::xpressive::detail
set_	xpressive/detail/core/matcher/set_matcher.hpp	/^    char_type set_[ Size::value ];$/;"	m	struct:boost::xpressive::detail::set_matcher	access:public
set_	xpressive/detail/static/transforms/as_set.hpp	/^        void set_(detail::literal_matcher<traits_type, icase_type, Not> const &ch) const$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:private	signature:(detail::literal_matcher<traits_type, icase_type, Not> const &ch) const
set_	xpressive/detail/static/transforms/as_set.hpp	/^        void set_(detail::posix_charset_matcher<traits_type> const &posix) const$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:private	signature:(detail::posix_charset_matcher<traits_type> const &posix) const
set_	xpressive/detail/static/transforms/as_set.hpp	/^        void set_(detail::range_matcher<traits_type, icase_type> const &rg) const$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:private	signature:(detail::range_matcher<traits_type, icase_type> const &rg) const
set_	xpressive/detail/static/transforms/as_set.hpp	/^        void set_(detail::set_matcher<traits_type, Size> const &set_) const$/;"	f	struct:boost::xpressive::grammar_detail::merge_charset	access:private	signature:(detail::set_matcher<traits_type, Size> const &set_) const
set_	xpressive/detail/utility/tracking_ptr.hpp	/^    set_type *set_;$/;"	m	struct:boost::xpressive::detail::weak_iterator	access:private
set_all	xpressive/detail/utility/hash_peek_bitset.hpp	/^    void set_all()$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:()
set_base	xpressive/detail/core/access.hpp	/^    static void set_base(match_results<BidiIter> &what, BidiIter base)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what, BidiIter base)
set_base_	xpressive/match_results.hpp	/^    void set_base_(BidiIter base)$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(BidiIter base)
set_bitset	xpressive/detail/utility/hash_peek_bitset.hpp	/^    void set_bitset(hash_peek_bitset<Char> const &that)$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(hash_peek_bitset<Char> const &that)
set_char	xpressive/detail/detail_fwd.hpp	/^    void set_char(basic_chset<Char> &chset, Char ch, Traits const &tr, bool icase);$/;"	p	namespace:boost::xpressive::detail	signature:(basic_chset<Char> &chset, Char ch, Traits const &tr, bool icase)
set_char	xpressive/detail/detail_fwd.hpp	/^    void set_char(compound_charset<Traits> &chset, Char ch, Traits const &tr, bool icase);$/;"	p	namespace:boost::xpressive::detail	signature:(compound_charset<Traits> &chset, Char ch, Traits const &tr, bool icase)
set_char	xpressive/detail/utility/chset/basic_chset.hpp	/^void set_char(basic_chset<Char> &chset, Char ch, Traits const &tr, bool icase);$/;"	p	namespace:boost::xpressive::detail	signature:(basic_chset<Char> &chset, Char ch, Traits const &tr, bool icase)
set_char	xpressive/detail/utility/chset/chset.hpp	/^    void set_char(char_type ch, Traits const &tr, bool icase)$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:(char_type ch, Traits const &tr, bool icase)
set_char	xpressive/detail/utility/chset/chset.hpp	/^inline void set_char(compound_charset<Traits> &chset, Char ch, Traits const &tr, bool icase)$/;"	f	namespace:boost::xpressive::detail	signature:(compound_charset<Traits> &chset, Char ch, Traits const &tr, bool icase)
set_char	xpressive/detail/utility/hash_peek_bitset.hpp	/^    void set_char(char_type ch, bool icase, Traits const &tr)$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(char_type ch, bool icase, Traits const &tr)
set_charset	xpressive/detail/utility/hash_peek_bitset.hpp	/^    void set_charset(basic_chset_8bit<Char> const &that, bool icase)$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(basic_chset_8bit<Char> const &that, bool icase)
set_class	xpressive/detail/detail_fwd.hpp	/^    void set_class(basic_chset<Char> &chset, typename Traits::char_class_type char_class, bool no, Traits const &tr);$/;"	p	namespace:boost::xpressive::detail	signature:(basic_chset<Char> &chset, typename Traits::char_class_type char_class, bool no, Traits const &tr)
set_class	xpressive/detail/detail_fwd.hpp	/^    void set_class(compound_charset<Traits> &chset, typename Traits::char_class_type char_class, bool no, Traits const &tr);$/;"	p	namespace:boost::xpressive::detail	signature:(compound_charset<Traits> &chset, typename Traits::char_class_type char_class, bool no, Traits const &tr)
set_class	xpressive/detail/utility/chset/basic_chset.hpp	/^void set_class(basic_chset<Char> &chset, typename Traits::char_class_type char_class, bool no, Traits const &tr);$/;"	p	namespace:boost::xpressive::detail	signature:(basic_chset<Char> &chset, typename Traits::char_class_type char_class, bool no, Traits const &tr)
set_class	xpressive/detail/utility/chset/chset.hpp	/^    void set_class(char_class_type const &m, bool no)$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:(char_class_type const &m, bool no)
set_class	xpressive/detail/utility/chset/chset.hpp	/^inline void set_class(compound_charset<Traits> &chset, typename Traits::char_class_type char_class, bool no, Traits const &)$/;"	f	namespace:boost::xpressive::detail	signature:(compound_charset<Traits> &chset, typename Traits::char_class_type char_class, bool no, Traits const &)
set_class	xpressive/detail/utility/hash_peek_bitset.hpp	/^    void set_class(typename Traits::char_class_type char_class, bool no, Traits const &tr)$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(typename Traits::char_class_type char_class, bool no, Traits const &tr)
set_initializer	xpressive/detail/core/matcher/set_matcher.hpp	/^struct set_initializer$/;"	s	namespace:boost::xpressive::detail
set_initializer_type	xpressive/detail/detail_fwd.hpp	/^    typedef proto::expr<proto::tag::terminal, proto::term<set_initializer>, 0> set_initializer_type;$/;"	t	namespace:boost::xpressive::detail
set_matcher	xpressive/detail/core/matcher/set_matcher.hpp	/^    set_matcher()$/;"	f	struct:boost::xpressive::detail::set_matcher	access:public	signature:()
set_matcher	xpressive/detail/core/matcher/set_matcher.hpp	/^struct set_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_fixed_width
set_partial_match	xpressive/detail/core/state.hpp	/^    void set_partial_match()$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:()
set_prefix_suffix	xpressive/detail/core/access.hpp	/^    static void set_prefix_suffix(match_results<BidiIter> &what, BidiIter begin, BidiIter end)$/;"	f	struct:boost::xpressive::detail::core_access	access:public	signature:(match_results<BidiIter> &what, BidiIter begin, BidiIter end)
set_prefix_suffix_	xpressive/match_results.hpp	/^    void set_prefix_suffix_(BidiIter begin, BidiIter end)$/;"	f	struct:boost::xpressive::match_results	access:private	signature:(BidiIter begin, BidiIter end)
set_quant_	xpressive/detail/dynamic/sequence.hpp	/^    void set_quant_()$/;"	f	struct:boost::xpressive::detail::sequence	access:private	signature:()
set_range	xpressive/detail/detail_fwd.hpp	/^    void set_range(basic_chset<Char> &chset, Char from, Char to, Traits const &tr, bool icase);$/;"	p	namespace:boost::xpressive::detail	signature:(basic_chset<Char> &chset, Char from, Char to, Traits const &tr, bool icase)
set_range	xpressive/detail/detail_fwd.hpp	/^    void set_range(compound_charset<Traits> &chset, Char from, Char to, Traits const &tr, bool icase);$/;"	p	namespace:boost::xpressive::detail	signature:(compound_charset<Traits> &chset, Char from, Char to, Traits const &tr, bool icase)
set_range	xpressive/detail/utility/chset/basic_chset.hpp	/^void set_range(basic_chset<Char> &chset, Char from, Char to, Traits const &tr, bool icase);$/;"	p	namespace:boost::xpressive::detail	signature:(basic_chset<Char> &chset, Char from, Char to, Traits const &tr, bool icase)
set_range	xpressive/detail/utility/chset/chset.hpp	/^    void set_range(char_type from, char_type to, Traits const &tr, bool icase)$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:(char_type from, char_type to, Traits const &tr, bool icase)
set_range	xpressive/detail/utility/chset/chset.hpp	/^inline void set_range(compound_charset<Traits> &chset, Char from, Char to, Traits const &tr, bool icase)$/;"	f	namespace:boost::xpressive::detail	signature:(compound_charset<Traits> &chset, Char from, Char to, Traits const &tr, bool icase)
set_range	xpressive/detail/utility/hash_peek_bitset.hpp	/^    void set_range(char_type from, char_type to, bool no, bool icase, Traits const &tr)$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(char_type from, char_type to, bool no, bool icase, Traits const &tr)
set_traits	xpressive/detail/core/peeker.hpp	/^    void set_traits(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(Traits const &tr)
set_transform	xpressive/match_results.hpp	/^    friend bool set_transform(case_converting_iterator &iter, transform_op trans, transform_scope scope)$/;"	f	struct:boost::xpressive::detail::case_converting_iterator	access:friend	signature:(case_converting_iterator &iter, transform_op trans, transform_scope scope)
set_transform	xpressive/match_results.hpp	/^inline bool set_transform(Iterator &, transform_op, transform_scope)$/;"	f	namespace:boost::xpressive::detail	signature:(Iterator &, transform_op, transform_scope)
set_type	xpressive/detail/utility/tracking_ptr.hpp	/^    typedef std::set<weak_ptr<Derived> > set_type;$/;"	t	struct:boost::xpressive::detail::weak_iterator	access:public
shared_matchable	xpressive/detail/dynamic/matchable.hpp	/^    shared_matchable(matchable_ptr const &xpr = matchable_ptr())$/;"	f	struct:boost::xpressive::detail::shared_matchable	access:public	signature:(matchable_ptr const &xpr = matchable_ptr())
shared_matchable	xpressive/detail/dynamic/matchable.hpp	/^struct shared_matchable$/;"	s	namespace:boost::xpressive::detail
simple_repeat_matcher	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        simple_repeat_matcher(Xpr const &xpr, unsigned int min, unsigned int max, std::size_t width)$/;"	f	struct:boost::xpressive::detail::simple_repeat_matcher	access:public	signature:(Xpr const &xpr, unsigned int min, unsigned int max, std::size_t width)
simple_repeat_matcher	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    struct simple_repeat_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_variable_width
simple_repeat_traits	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    struct simple_repeat_traits$/;"	s	namespace:boost::xpressive::detail
simple_repeat_traits	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    struct simple_repeat_traits<any_dxpr, mpl::true_, mpl::true_>$/;"	s	namespace:boost::xpressive::detail
simple_repeat_traits	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^    struct simple_repeat_traits<any_sxpr, mpl::true_, mpl::true_>$/;"	s	namespace:boost::xpressive::detail
single_line	xpressive/basic_regex.hpp	/^template<typename BidiIter> regex_constants::syntax_option_type const basic_regex<BidiIter>::single_line;$/;"	m	class:boost::xpressive::regex_constants::basic_regex
single_line	xpressive/regex_constants.hpp	/^    single_line         = 1 << 10,  \/\/\/< Specifies that the ^ and \\$ metacharacters DO NOT match at$/;"	e	enum:boost::xpressive::regex_constants::syntax_option_type
size	xpressive/detail/core/list.hpp	/^        size_type size() const$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:() const
size	xpressive/detail/core/sub_match_vector.hpp	/^    size_type size() const$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:() const
size	xpressive/detail/utility/sequence_stack.hpp	/^        std::size_t size() const$/;"	f	struct:boost::xpressive::detail::sequence_stack::chunk	access:public	signature:() const
size	xpressive/match_results.hpp	/^    size_type size() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
size_	xpressive/detail/core/sub_match_vector.hpp	/^    size_type size_;$/;"	m	struct:boost::xpressive::detail::sub_match_vector	access:private
size_type	xpressive/detail/core/list.hpp	/^        typedef std::size_t size_type;$/;"	t	struct:boost::xpressive::detail::list	access:public
size_type	xpressive/detail/core/sub_match_vector.hpp	/^    typedef std::size_t size_type;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
size_type	xpressive/match_results.hpp	/^    typedef std::size_t size_type;$/;"	t	struct:boost::xpressive::match_results	access:public
sizeof	xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(std::ctype_base::mask), ==, sizeof(umask_t));$/;"	p	namespace:boost::xpressive::detail	signature:(std::ctype_base::mask)
sizeof	xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(std::ctype_base::mask), ==, sizeof(umask_t));$/;"	p	namespace:boost::xpressive::detail	signature:(umask_t)
sizeof	xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(umask_t), <=, sizeof(umaskex_t));$/;"	p	namespace:boost::xpressive::detail	signature:(umask_t)
sizeof	xpressive/traits/cpp_regex_traits.hpp	/^    BOOST_MPL_ASSERT_RELATION(sizeof(umask_t), <=, sizeof(umaskex_t));$/;"	p	namespace:boost::xpressive::detail	signature:(umaskex_t)
skip	xpressive/regex_primitives.hpp	/^detail::skip_directive<Skip> skip(Skip const &skip)$/;"	f	namespace:boost::xpressive	signature:(Skip const &skip)
skip_	xpressive/regex_primitives.hpp	/^        skip_type skip_;$/;"	m	struct:boost::xpressive::detail::skip_directive	access:private
skip_directive	xpressive/regex_primitives.hpp	/^        skip_directive(Skip const &skip)$/;"	f	struct:boost::xpressive::detail::skip_directive	access:public	signature:(Skip const &skip)
skip_directive	xpressive/regex_primitives.hpp	/^    struct skip_directive$/;"	s	namespace:boost::xpressive::detail
skip_impl	xpressive/detail/static/static.hpp	/^    static bool skip_impl(That const &that, match_state<BidiIter> &state)$/;"	f	struct:boost::xpressive::detail::stacked_xpression	access:public	signature:(That const &that, match_state<BidiIter> &state)
skip_impl	xpressive/detail/static/static.hpp	/^    static bool skip_impl(That const &that, match_state<BidiIter> &state)$/;"	f	struct:boost::xpressive::detail::static_xpression	access:public	signature:(That const &that, match_state<BidiIter> &state)
skip_match	xpressive/detail/dynamic/matchable.hpp	/^    bool skip_match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::matchable_ex	access:public	signature:(match_state<BidiIter> &state) const
skip_match	xpressive/detail/static/static.hpp	/^    bool skip_match(match_state<BidiIter> &state) const$/;"	f	struct:boost::xpressive::detail::stacked_xpression	access:public	signature:(match_state<BidiIter> &state) const
skip_primitives	xpressive/regex_primitives.hpp	/^    struct skip_primitives : proto::transform<skip_primitives>$/;"	s	namespace:boost::xpressive::detail	inherits:proto::transform
skip_transform	xpressive/regex_primitives.hpp	/^            skip_transform;$/;"	t	struct:boost::xpressive::detail::skip_directive::result	access:public
skip_type	xpressive/regex_primitives.hpp	/^        typedef typename proto::result_of::as_expr<Skip>::type skip_type;$/;"	t	struct:boost::xpressive::detail::skip_directive	access:public
slot_	xpressive/detail/core/matcher/attr_matcher.hpp	/^        int slot_;$/;"	m	struct:boost::xpressive::detail::attr_matcher	access:public
smatch	xpressive/xpressive_fwd.hpp	/^    typedef match_results<std::string::const_iterator>              smatch;$/;"	t	namespace:boost::xpressive
space	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const space = {{"space", false}};$/;"	m	class:boost::xpressive::proto::terminal
space_	xpressive/detail/dynamic/parser_traits.hpp	/^    typename regex_traits::char_class_type space_;$/;"	m	struct:boost::xpressive::compiler_traits	access:private
splice	xpressive/detail/core/list.hpp	/^        void splice(iterator it, list &, iterator xit)$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:(iterator it, list &, iterator xit)
splice	xpressive/detail/core/list.hpp	/^        void splice(iterator it, list &x)$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:(iterator it, list &x)
sregex	xpressive/xpressive_fwd.hpp	/^    typedef basic_regex<std::string::const_iterator>                sregex;$/;"	t	namespace:boost::xpressive
sregex_compiler	xpressive/xpressive_fwd.hpp	/^    typedef regex_compiler<std::string::const_iterator>             sregex_compiler;$/;"	t	namespace:boost::xpressive
sregex_id_filter_predicate	xpressive/xpressive_fwd.hpp	/^    typedef regex_id_filter_predicate<std::string::const_iterator>  sregex_id_filter_predicate;$/;"	t	namespace:boost::xpressive
sregex_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_iterator<std::string::const_iterator>             sregex_iterator;$/;"	t	namespace:boost::xpressive
sregex_token_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_token_iterator<std::string::const_iterator>       sregex_token_iterator;$/;"	t	namespace:boost::xpressive
ssub_match	xpressive/xpressive_fwd.hpp	/^    typedef sub_match<std::string::const_iterator>                  ssub_match;$/;"	t	namespace:boost::xpressive
stacked_xpression	xpressive/detail/static/static.hpp	/^struct stacked_xpression$/;"	s	namespace:boost::xpressive::detail	inherits:Next
stacked_xpression_cast	xpressive/detail/static/static.hpp	/^inline stacked_xpression<Top, Next> const &stacked_xpression_cast(Next const &next)$/;"	f	namespace:boost::xpressive::detail	signature:(Next const &next)
state_	xpressive/detail/core/matcher/alternate_matcher.hpp	/^        match_state<BidiIter> *state_;$/;"	m	struct:boost::xpressive::detail::alt_match_pred	access:private
state_	xpressive/regex_iterator.hpp	/^    match_state<BidiIter> state_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
state_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            typedef typename impl::state state_type;$/;"	t	struct:boost::xpressive::detail::mark_transform::impl	access:public
state_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            typedef typename impl::state state_type;$/;"	t	struct:boost::xpressive::detail::subreg_transform::impl	access:public
static_cast_	xpressive/regex_actions.hpp	/^        struct static_cast_$/;"	s	namespace:boost::xpressive::op
static_cast_	xpressive/regex_actions.hpp	/^    static_cast_(A const &a)$/;"	f	class:boost::xpressive::detail::make_function::impl	signature:(A const &a)
static_compile	xpressive/detail/detail_fwd.hpp	/^    void static_compile(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl);$/;"	p	namespace:boost::xpressive::detail	signature:(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl)
static_compile	xpressive/detail/static/compile.hpp	/^    void static_compile(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl)$/;"	f	namespace:boost::xpressive::detail	signature:(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl)
static_compile_impl1	xpressive/detail/static/compile.hpp	/^    static_compile_impl1(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl)$/;"	f	namespace:boost::xpressive::detail	signature:(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl)
static_compile_impl2	xpressive/detail/static/compile.hpp	/^    void static_compile_impl2(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl, Traits const &tr)$/;"	f	namespace:boost::xpressive::detail	signature:(Xpr const &xpr, shared_ptr<regex_impl<BidiIter> > const &impl, Traits const &tr)
static_xpression	xpressive/detail/static/static.hpp	/^    static_xpression(Matcher const &matcher = Matcher(), Next const &next = Next())$/;"	f	struct:boost::xpressive::detail::static_xpression	access:public	signature:(Matcher const &matcher = Matcher(), Next const &next = Next())
static_xpression	xpressive/detail/static/static.hpp	/^struct static_xpression$/;"	s	namespace:boost::xpressive::detail	inherits:Matcher
std	xpressive/match_results.hpp	/^namespace std$/;"	n
std	xpressive/regex_error.hpp	/^namespace std$/;"	n
std	xpressive/sub_match.hpp	/^namespace std$/;"	n
std::pair	xpressive/sub_match.hpp	/^    template<typename, typename> struct pair {};$/;"	s	namespace:std
std::runtime_error	xpressive/regex_error.hpp	/^    struct runtime_error {};$/;"	s	namespace:std
std_ctype_alnum	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alnum = 1 << 0;$/;"	m	namespace:boost::xpressive::detail
std_ctype_alnum	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alnum = mask_cast<std::ctype_base::alnum>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_alpha	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alpha = 1 << 1;$/;"	m	namespace:boost::xpressive::detail
std_ctype_alpha	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_alpha = mask_cast<std::ctype_base::alpha>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_cntrl	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_cntrl = 1 << 2;$/;"	m	namespace:boost::xpressive::detail
std_ctype_cntrl	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_cntrl = mask_cast<std::ctype_base::cntrl>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_digit	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_digit = 1 << 3;$/;"	m	namespace:boost::xpressive::detail
std_ctype_digit	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_digit = mask_cast<std::ctype_base::digit>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_graph	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_graph = 1 << 4;$/;"	m	namespace:boost::xpressive::detail
std_ctype_graph	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_graph = mask_cast<std::ctype_base::graph>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_lower	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_lower = 1 << 5;$/;"	m	namespace:boost::xpressive::detail
std_ctype_lower	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_lower = mask_cast<std::ctype_base::lower>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_print	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_print = 1 << 6;$/;"	m	namespace:boost::xpressive::detail
std_ctype_print	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_print = mask_cast<std::ctype_base::print>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_punct	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_punct = 1 << 7;$/;"	m	namespace:boost::xpressive::detail
std_ctype_punct	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_punct = mask_cast<std::ctype_base::punct>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_reserved	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_reserved = 0;$/;"	m	namespace:boost::xpressive::detail
std_ctype_reserved	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_reserved = 0x8000;$/;"	m	namespace:boost::xpressive::detail
std_ctype_reserved	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_reserved = 0x8200;$/;"	m	namespace:boost::xpressive::detail
std_ctype_space	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_space = 1 << 8;$/;"	m	namespace:boost::xpressive::detail
std_ctype_space	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_space = mask_cast<std::ctype_base::space>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_upper	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_upper = 1 << 9;$/;"	m	namespace:boost::xpressive::detail
std_ctype_upper	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_upper = mask_cast<std::ctype_base::upper>::value;$/;"	m	namespace:boost::xpressive::detail
std_ctype_xdigit	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_xdigit = 1 << 10;$/;"	m	namespace:boost::xpressive::detail
std_ctype_xdigit	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const std_ctype_xdigit = mask_cast<std::ctype_base::xdigit>::value;$/;"	m	namespace:boost::xpressive::detail
std_masks	xpressive/traits/cpp_regex_traits.hpp	/^    static umaskex_t const std_masks[] =$/;"	m	namespace:boost::xpressive::detail
str	xpressive/match_results.hpp	/^    string_type str(size_type sub = 0) const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(size_type sub = 0) const
str	xpressive/regex_actions.hpp	/^        struct str$/;"	s	namespace:boost::xpressive::op
str	xpressive/regex_actions.hpp	/^    function<op::str>::type const str = {{}};$/;"	m	class:boost::xpressive::function
str	xpressive/sub_match.hpp	/^    string_type str() const$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:() const
str_	xpressive/detail/core/matcher/string_matcher.hpp	/^        string_type str_;$/;"	m	struct:boost::xpressive::detail::string_matcher	access:public
str_	xpressive/detail/core/peeker.hpp	/^    peeker_string<Char> str_;$/;"	m	struct:boost::xpressive::detail::xpression_peeker	access:private
str_icase_	xpressive/detail/core/peeker.hpp	/^    bool str_icase_;$/;"	m	struct:boost::xpressive::detail::xpression_peeker	access:private
string_cast	xpressive/detail/utility/traits_utils.hpp	/^    string_cast(From const &from, Traits const &tr)$/;"	f	namespace:boost::xpressive::detail	signature:(From const &from, Traits const &tr)
string_cast_	xpressive/detail/utility/traits_utils.hpp	/^    struct string_cast_$/;"	s	namespace:boost::xpressive::detail
string_cast_	xpressive/detail/utility/traits_utils.hpp	/^    struct string_cast_<From, From, Char, Char>$/;"	s	namespace:boost::xpressive::detail
string_cast_	xpressive/detail/utility/traits_utils.hpp	/^    struct string_cast_<To, From, Char, Char>$/;"	s	namespace:boost::xpressive::detail
string_literal	xpressive/detail/utility/literals.hpp	/^struct string_literal<char>$/;"	s	namespace:boost::xpressive::detail
string_literal	xpressive/detail/utility/literals.hpp	/^struct string_literal<wchar_t>$/;"	s	namespace:boost::xpressive::detail
string_matcher	xpressive/detail/core/matcher/string_matcher.hpp	/^        string_matcher(string_matcher<Traits, ICase> const &that)$/;"	f	struct:boost::xpressive::detail::string_matcher	access:public	signature:(string_matcher<Traits, ICase> const &that)
string_matcher	xpressive/detail/core/matcher/string_matcher.hpp	/^        string_matcher(string_type const &str, Traits const &tr)$/;"	f	struct:boost::xpressive::detail::string_matcher	access:public	signature:(string_type const &str, Traits const &tr)
string_matcher	xpressive/detail/core/matcher/string_matcher.hpp	/^    struct string_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_fixed_unknown_width
string_type	xpressive/basic_regex.hpp	/^    typedef typename detail::string_type<char_type>::type string_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
string_type	xpressive/detail/core/matcher/string_matcher.hpp	/^        typedef typename Traits::string_type string_type;$/;"	t	struct:boost::xpressive::detail::string_matcher	access:public
string_type	xpressive/detail/core/regex_impl.hpp	/^    typedef typename detail::string_type<Char>::type string_type;$/;"	t	struct:boost::xpressive::detail::named_mark	access:public
string_type	xpressive/detail/core/sub_match_vector.hpp	/^    typedef typename sub_match<BidiIter>::string_type string_type;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
string_type	xpressive/detail/detail_fwd.hpp	/^    struct string_type$/;"	s	namespace:boost::xpressive::detail
string_type	xpressive/detail/detail_fwd.hpp	/^    struct string_type<char>$/;"	s	namespace:boost::xpressive::detail
string_type	xpressive/detail/detail_fwd.hpp	/^    struct string_type<wchar_t>$/;"	s	namespace:boost::xpressive::detail
string_type	xpressive/detail/dynamic/parser_traits.hpp	/^    typedef typename regex_traits::string_type string_type;$/;"	t	struct:boost::xpressive::compiler_traits	access:public
string_type	xpressive/detail/static/transmogrify.hpp	/^        typedef typename Traits::string_type string_type;$/;"	t	struct:boost::xpressive::detail::default_transmogrify	access:public
string_type	xpressive/detail/utility/boyer_moore.hpp	/^    typedef typename Traits::string_type string_type;$/;"	t	struct:boost::xpressive::detail::boyer_moore	access:public
string_type	xpressive/match_results.hpp	/^    typedef typename detail::string_type<char_type>::type string_type;$/;"	t	struct:boost::xpressive::match_results	access:public
string_type	xpressive/regex_compiler.hpp	/^    typedef typename traits_type::string_type string_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
string_type	xpressive/sub_match.hpp	/^    typedef typename detail::string_type<value_type>::type string_type;$/;"	t	struct:boost::xpressive::sub_match	access:public
string_type	xpressive/traits/c_regex_traits.hpp	/^    typedef std::basic_string<char_type> string_type;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
string_type	xpressive/traits/cpp_regex_traits.hpp	/^    typedef std::basic_string<char_type> string_type;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
string_type	xpressive/traits/null_regex_traits.hpp	/^    typedef std::vector<char_type> string_type;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
sub_	xpressive/detail/core/matcher/action_matcher.hpp	/^        int sub_;$/;"	m	struct:boost::xpressive::detail::action_matcher	access:public
sub_	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        int sub_;$/;"	m	struct:boost::xpressive::detail::predicate_context	access:public
sub_	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        int sub_;$/;"	m	struct:boost::xpressive::detail::predicate_matcher	access:public
sub_match	xpressive/detail/core/state.hpp	/^    sub_match_impl &sub_match(int n)$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:(int n)
sub_match	xpressive/sub_match.hpp	/^    sub_match()$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:()
sub_match	xpressive/sub_match.hpp	/^    sub_match(BidiIter first, BidiIter second, bool matched_ = false)$/;"	f	struct:boost::xpressive::sub_match	access:public	signature:(BidiIter first, BidiIter second, bool matched_ = false)
sub_match	xpressive/sub_match.hpp	/^struct sub_match$/;"	s	namespace:boost::xpressive	inherits:std::pair
sub_match_impl	xpressive/detail/core/state.hpp	/^    typedef detail::sub_match_impl<BidiIter> sub_match_impl;$/;"	t	struct:boost::xpressive::detail::match_state	access:public
sub_match_impl	xpressive/detail/core/sub_match_impl.hpp	/^    sub_match_impl(BidiIter const &begin)$/;"	f	struct:boost::xpressive::detail::sub_match_impl	access:public	signature:(BidiIter const &begin)
sub_match_impl	xpressive/detail/core/sub_match_impl.hpp	/^struct sub_match_impl$/;"	s	namespace:boost::xpressive::detail	inherits:sub_match
sub_match_iterator	xpressive/detail/core/sub_match_vector.hpp	/^    sub_match_iterator(MainIter baseiter)$/;"	f	struct:boost::xpressive::detail::sub_match_iterator	access:public	signature:(MainIter baseiter)
sub_match_iterator	xpressive/detail/core/sub_match_vector.hpp	/^struct sub_match_iterator$/;"	s	namespace:boost::xpressive::detail	inherits:iterator_adaptor
sub_match_stack_	xpressive/match_results.hpp	/^    sequence_stack<sub_match_impl<BidiIter> > sub_match_stack_;$/;"	m	struct:boost::xpressive::detail::results_extras	access:public
sub_match_vector	xpressive/detail/core/sub_match_vector.hpp	/^    sub_match_vector()$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:()
sub_match_vector	xpressive/detail/core/sub_match_vector.hpp	/^struct sub_match_vector$/;"	s	namespace:boost::xpressive::detail	inherits:noncopyable
sub_matches_	xpressive/detail/core/matcher/predicate_matcher.hpp	/^        sub_match_impl<BidiIter> const *sub_matches_;$/;"	m	struct:boost::xpressive::detail::predicate_context	access:public
sub_matches_	xpressive/detail/core/state.hpp	/^    sub_match_impl *sub_matches_;$/;"	m	struct:boost::xpressive::detail::match_state	access:public
sub_matches_	xpressive/detail/core/sub_match_vector.hpp	/^    sub_match_impl<BidiIter> *sub_matches_;$/;"	m	struct:boost::xpressive::detail::sub_match_vector	access:private
sub_matches_	xpressive/match_results.hpp	/^    detail::sub_match_vector<BidiIter> sub_matches_;$/;"	m	struct:boost::xpressive::match_results	access:private
subreg_transform	xpressive/detail/core/matcher/action_matcher.hpp	/^    struct subreg_transform : proto::transform<subreg_transform>$/;"	s	namespace:boost::xpressive::detail	inherits:proto::transform
subs_	xpressive/regex_token_iterator.hpp	/^    std::vector<int> subs_;$/;"	m	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
suffix	xpressive/match_results.hpp	/^    const_reference suffix() const$/;"	f	struct:boost::xpressive::match_results	access:public	signature:() const
suffix_	xpressive/match_results.hpp	/^    boost::optional<sub_match<BidiIter> > suffix_;$/;"	m	struct:boost::xpressive::match_results	access:private
svalue_	xpressive/regex_actions.hpp	/^                    static value_type &svalue_;$/;"	m	struct:boost::xpressive::op::insert::detail::result_detail	access:public
swap	xpressive/basic_regex.hpp	/^    void swap(basic_regex<BidiIter> &that) \/\/ throw()$/;"	f	struct:boost::xpressive::basic_regex	access:public	signature:(basic_regex<BidiIter> &that)
swap	xpressive/basic_regex.hpp	/^inline void swap(basic_regex<BidiIter> &left, basic_regex<BidiIter> &right) \/\/ throw()$/;"	f	namespace:boost::xpressive	signature:(basic_regex<BidiIter> &left, basic_regex<BidiIter> &right)
swap	xpressive/detail/core/list.hpp	/^        void swap(list &that) \/\/ throw()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:(list &that)
swap	xpressive/detail/core/list.hpp	/^    void swap(list<T> &lhs, list<T> &rhs)$/;"	f	namespace:boost::xpressive::detail	signature:(list<T> &lhs, list<T> &rhs)
swap	xpressive/detail/core/regex_impl.hpp	/^    void swap(regex_impl<BidiIter> &that)$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:(regex_impl<BidiIter> &that)
swap	xpressive/detail/core/regex_impl.hpp	/^void swap(regex_impl<BidiIter> &left, regex_impl<BidiIter> &right)$/;"	f	namespace:boost::xpressive::detail	signature:(regex_impl<BidiIter> &left, regex_impl<BidiIter> &right)
swap	xpressive/detail/core/sub_match_vector.hpp	/^    void swap(sub_match_vector<BidiIter> &that)$/;"	f	struct:boost::xpressive::detail::sub_match_vector	access:public	signature:(sub_match_vector<BidiIter> &that)
swap	xpressive/detail/static/visitor.hpp	/^        void swap(xpression_visitor_base<BidiIter> &that)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:public	signature:(xpression_visitor_base<BidiIter> &that)
swap	xpressive/detail/utility/chset/basic_chset.hpp	/^    void swap(basic_chset& x);$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(basic_chset& x)
swap	xpressive/detail/utility/chset/basic_chset.hpp	/^    void swap(basic_chset_8bit& x);$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(basic_chset_8bit& x)
swap	xpressive/detail/utility/chset/range_run.hpp	/^    void swap(range_run& rr);$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:(range_run& rr)
swap	xpressive/detail/utility/symbols.hpp	/^            void swap(node& that)$/;"	f	struct:boost::xpressive::detail::symbols::node	access:public	signature:(node& that)
swap	xpressive/detail/utility/tracking_ptr.hpp	/^    void swap(enable_reference_tracking<Derived> &that)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:protected	signature:(enable_reference_tracking<Derived> &that)
swap	xpressive/detail/utility/tracking_ptr.hpp	/^    void swap(tracking_ptr<element_type> &that) \/\/ throw()$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:(tracking_ptr<element_type> &that)
swap	xpressive/match_results.hpp	/^    void swap(match_results<BidiIter> &that) \/\/ throw()$/;"	f	struct:boost::xpressive::match_results	access:public	signature:(match_results<BidiIter> &that)
swap_context	xpressive/detail/core/state.hpp	/^    void swap_context(match_context &context)$/;"	f	struct:boost::xpressive::detail::match_state	access:public	signature:(match_context &context)
sym_	xpressive/detail/core/matcher/attr_matcher.hpp	/^        boost::xpressive::detail::symbols<Matcher> sym_;$/;"	m	struct:boost::xpressive::detail::attr_matcher	access:public
symbols	xpressive/detail/utility/symbols.hpp	/^    struct symbols$/;"	s	namespace:boost::xpressive::detail
syntax_option_type	xpressive/regex_constants.hpp	/^enum syntax_option_type$/;"	g	namespace:boost::xpressive::regex_constants
t_	xpressive/detail/core/matcher/action_matcher.hpp	/^        T const *t_;$/;"	m	struct:boost::xpressive::detail::opt	access:public
tag	xpressive/detail/utility/cons.hpp	/^        typedef cons_iterator_tag tag;$/;"	t	struct:boost::fusion::cons_iterator	access:public
tag	xpressive/detail/utility/cons.hpp	/^        typedef cons_tag tag;$/;"	t	struct:boost::fusion::cons	access:public
tag	xpressive/detail/utility/cons.hpp	/^        typedef cons_tag tag;$/;"	t	struct:boost::fusion::nil	access:public
tag_type	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        typedef greedy_fast_tag tag_type;$/;"	t	struct:boost::xpressive::detail::simple_repeat_traits	access:public
tag_type	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        typedef typename mpl::if_c<Greedy::value, greedy_slow_tag, non_greedy_tag>::type tag_type;$/;"	t	struct:boost::xpressive::detail::simple_repeat_traits	access:public
tail_	xpressive/detail/dynamic/sequence.hpp	/^    shared_matchable<BidiIter> *tail_;$/;"	m	struct:boost::xpressive::detail::sequence	access:private
tau	xpressive/detail/utility/symbols.hpp	/^            long tau;$/;"	m	struct:boost::xpressive::detail::symbols::node	access:public
temp_type	xpressive/detail/core/matcher/action_matcher.hpp	/^            temp_type;$/;"	t	struct:boost::xpressive::detail::action_context::eval	access:public
ternary_fun	xpressive/match_results.hpp	/^    typedef ternary_type (*ternary_fun)(any_type, any_type, any_type);$/;"	t	struct:boost::xpressive::detail::unary_binary_ternary	access:public
ternary_type	xpressive/match_results.hpp	/^typedef char (&ternary_type)[4];$/;"	t	namespace:boost::xpressive::detail
test	xpressive/detail/utility/chset/basic_chset.hpp	/^    bool test(Char v, Traits const &tr, mpl::false_) const; \/\/ case-sensitive$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char v, Traits const &tr, mpl::false_) const
test	xpressive/detail/utility/chset/basic_chset.hpp	/^    bool test(Char v, Traits const &tr, mpl::false_) const; \/\/ case-sensitive$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char v, Traits const &tr, mpl::false_) const
test	xpressive/detail/utility/chset/basic_chset.hpp	/^    bool test(Char v, Traits const &tr, mpl::true_) const; \/\/ case-insensitive$/;"	p	struct:boost::xpressive::detail::basic_chset	access:public	signature:(Char v, Traits const &tr, mpl::true_) const
test	xpressive/detail/utility/chset/basic_chset.hpp	/^    bool test(Char v, Traits const &tr, mpl::true_) const; \/\/ case-insensitive$/;"	p	struct:boost::xpressive::detail::basic_chset_8bit	access:public	signature:(Char v, Traits const &tr, mpl::true_) const
test	xpressive/detail/utility/chset/chset.hpp	/^    bool test(char_type ch, Traits const &tr, ICase) const$/;"	f	struct:boost::xpressive::detail::compound_charset	access:public	signature:(char_type ch, Traits const &tr, ICase) const
test	xpressive/detail/utility/chset/range_run.hpp	/^    bool test(Char v) const;$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:(Char v) const
test	xpressive/detail/utility/chset/range_run.hpp	/^    bool test(Char v, Traits const &tr) const;$/;"	p	struct:boost::xpressive::detail::range_run	access:public	signature:(Char v, Traits const &tr) const
test	xpressive/detail/utility/hash_peek_bitset.hpp	/^    bool test(char_type ch, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(char_type ch, Traits const &tr) const
test	xpressive/detail/utility/hash_peek_bitset.hpp	/^    bool test(char_type ch, Traits const &tr, mpl::false_) const$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(char_type ch, Traits const &tr, mpl::false_) const
test	xpressive/detail/utility/hash_peek_bitset.hpp	/^    bool test(char_type ch, Traits const &tr, mpl::true_) const$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:public	signature:(char_type ch, Traits const &tr, mpl::true_) const
test_icase_	xpressive/detail/utility/hash_peek_bitset.hpp	/^    bool test_icase_(bool icase)$/;"	f	struct:boost::xpressive::detail::hash_peek_bitset	access:private	signature:(bool icase)
test_posix	xpressive/detail/utility/chset/chset.hpp	/^    bool test_posix(char_type ch, Traits const &tr) const$/;"	f	struct:boost::xpressive::detail::compound_charset	access:private	signature:(char_type ch, Traits const &tr) const
this_type	xpressive/regex_actions.hpp	/^        typedef placeholder<T, I, Dummy> this_type;$/;"	t	struct:boost::xpressive::placeholder	access:public
throw_	xpressive/regex_actions.hpp	/^        struct throw_$/;"	s	namespace:boost::xpressive::op
throw_on_stack_error	xpressive/basic_regex.hpp	/^    inline void throw_on_stack_error(bool stack_error)$/;"	f	namespace:boost::xpressive::detail	signature:(bool stack_error)
to_vector	xpressive/regex_primitives.hpp	/^    to_vector(Subs const &subs)$/;"	f	namespace:boost::xpressive::detail	signature:(Subs const &subs)
to_vector	xpressive/regex_token_iterator.hpp	/^inline std::vector<int> const &to_vector(std::vector<int> const &subs)$/;"	f	class:boost::xpressive::detail::std	signature:(std::vector<int> const &subs)
to_vector	xpressive/regex_token_iterator.hpp	/^inline std::vector<int> to_vector(Int const (&sub_matches)[ Size ])$/;"	f	namespace:boost::xpressive::detail	signature:(Int const (&sub_matches)[ Size ])
to_vector	xpressive/regex_token_iterator.hpp	/^inline std::vector<int> to_vector(int subs)$/;"	f	namespace:boost::xpressive::detail	signature:(int subs)
to_vector	xpressive/regex_token_iterator.hpp	/^inline std::vector<int> to_vector(std::vector<Int> const &sub_matches)$/;"	f	namespace:boost::xpressive::detail	signature:(std::vector<Int> const &sub_matches)
toi	xpressive/detail/utility/algorithm.hpp	/^int toi(InIter &begin, InIter end, Traits const &tr, int radix = 10, int max = INT_MAX)$/;"	f	namespace:boost::xpressive::detail	signature:(InIter &begin, InIter end, Traits const &tr, int radix = 10, int max = INT_MAX)
token_alternate	xpressive/detail/dynamic/parser_enum.hpp	/^    token_alternate,                    \/\/ |$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_any	xpressive/detail/dynamic/parser_enum.hpp	/^    token_any,                          \/\/ .$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_assert_begin_line	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_begin_line,            \/\/ ^$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_assert_begin_sequence	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_begin_sequence,        \/\/ \\A$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_assert_end_line	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_end_line,              \/\/ \$$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_assert_end_sequence	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_end_sequence,          \/\/ \\Z$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_assert_not_word_boundary	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_not_word_boundary,     \/\/ \\B$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_assert_word_begin	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_word_begin,            \/\/ \\<$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_assert_word_boundary	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_word_boundary,         \/\/ \\b$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_assert_word_end	xpressive/detail/dynamic/parser_enum.hpp	/^    token_assert_word_end,              \/\/ \\>$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_charset_backspace	xpressive/detail/dynamic/parser_enum.hpp	/^    token_charset_backspace,            \/\/ \\b$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_charset_begin	xpressive/detail/dynamic/parser_enum.hpp	/^    token_charset_begin,                \/\/ [$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_charset_end	xpressive/detail/dynamic/parser_enum.hpp	/^    token_charset_end,                  \/\/ ]$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_charset_hyphen	xpressive/detail/dynamic/parser_enum.hpp	/^    token_charset_hyphen,               \/\/ -$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_charset_invert	xpressive/detail/dynamic/parser_enum.hpp	/^    token_charset_invert,               \/\/ ^$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_collation_element_begin	xpressive/detail/dynamic/parser_enum.hpp	/^    token_collation_element_begin,      \/\/ [.$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_collation_element_end	xpressive/detail/dynamic/parser_enum.hpp	/^    token_collation_element_end,        \/\/ .]$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_comment	xpressive/detail/dynamic/parser_enum.hpp	/^    token_comment,                      \/\/ ?#$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_end_of_pattern	xpressive/detail/dynamic/parser_enum.hpp	/^    token_end_of_pattern$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_equivalence_class_begin	xpressive/detail/dynamic/parser_enum.hpp	/^    token_equivalence_class_begin,      \/\/ [=$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_equivalence_class_end	xpressive/detail/dynamic/parser_enum.hpp	/^    token_equivalence_class_end,        \/\/ =]$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_escape	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape,                       \/\/$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_escape_bell	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape_bell,                  \/\/ \\a$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_escape_control	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape_control,               \/\/ \\c$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_escape_escape	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape_escape,                \/\/ \\e$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_escape_formfeed	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape_formfeed,              \/\/ \\f$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_escape_horizontal_tab	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape_horizontal_tab,        \/\/ \\t$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_escape_newline	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape_newline,               \/\/ \\n$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_escape_vertical_tab	xpressive/detail/dynamic/parser_enum.hpp	/^    token_escape_vertical_tab,          \/\/ \\v$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_group_begin	xpressive/detail/dynamic/parser_enum.hpp	/^    token_group_begin,                  \/\/ ($/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_group_end	xpressive/detail/dynamic/parser_enum.hpp	/^    token_group_end,                    \/\/ )$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_independent_sub_expression	xpressive/detail/dynamic/parser_enum.hpp	/^    token_independent_sub_expression,   \/\/ ?>$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_invalid_quantifier	xpressive/detail/dynamic/parser_enum.hpp	/^    token_invalid_quantifier,           \/\/ {$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_literal	xpressive/detail/dynamic/parser_enum.hpp	/^    token_literal,$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_named_mark	xpressive/detail/dynamic/parser_enum.hpp	/^    token_named_mark,                   \/\/ ?P<name>$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_named_mark_ref	xpressive/detail/dynamic/parser_enum.hpp	/^    token_named_mark_ref,               \/\/ ?P=name$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_negative_lookahead	xpressive/detail/dynamic/parser_enum.hpp	/^    token_negative_lookahead,           \/\/ ?!$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_negative_lookbehind	xpressive/detail/dynamic/parser_enum.hpp	/^    token_negative_lookbehind,          \/\/ ?<!$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_no_mark	xpressive/detail/dynamic/parser_enum.hpp	/^    token_no_mark,                      \/\/ ?:$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_positive_lookahead	xpressive/detail/dynamic/parser_enum.hpp	/^    token_positive_lookahead,           \/\/ ?=$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_positive_lookbehind	xpressive/detail/dynamic/parser_enum.hpp	/^    token_positive_lookbehind,          \/\/ ?<=$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_posix_charset_begin	xpressive/detail/dynamic/parser_enum.hpp	/^    token_posix_charset_begin,          \/\/ [:$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_posix_charset_end	xpressive/detail/dynamic/parser_enum.hpp	/^    token_posix_charset_end,            \/\/ :]$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_quote_meta_begin	xpressive/detail/dynamic/parser_enum.hpp	/^    token_quote_meta_begin,             \/\/ \\Q$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_quote_meta_end	xpressive/detail/dynamic/parser_enum.hpp	/^    token_quote_meta_end,               \/\/ \\E$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_recurse	xpressive/detail/dynamic/parser_enum.hpp	/^    token_recurse,                      \/\/ ?R$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_rule_assign	xpressive/detail/dynamic/parser_enum.hpp	/^    token_rule_assign,                  \/\/ ?$[name]=$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
token_rule_ref	xpressive/detail/dynamic/parser_enum.hpp	/^    token_rule_ref,                     \/\/ ?$[name]$/;"	e	enum:boost::xpressive::regex_constants::compiler_token_type
tolower	xpressive/detail/core/regex_impl.hpp	/^    char_type tolower(char_type ch) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type ch) const
tolower	xpressive/detail/core/regex_impl.hpp	/^    virtual Char tolower(Char ch) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char ch) const
tolower	xpressive/traits/c_regex_traits.hpp	/^    static char_type tolower(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
tolower	xpressive/traits/cpp_regex_traits.hpp	/^    char_type tolower(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
tolower_	xpressive/detail/core/regex_impl.hpp	/^    char_type tolower_(char_type ch, regex_traits_version_1_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_1_tag) const
tolower_	xpressive/detail/core/regex_impl.hpp	/^    char_type tolower_(char_type ch, regex_traits_version_2_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_2_tag) const
top	xpressive/regex_actions.hpp	/^        struct top$/;"	s	namespace:boost::xpressive::op
top	xpressive/regex_actions.hpp	/^    function<op::top>::type const top = {{}};$/;"	m	class:boost::xpressive::function
top_match	xpressive/detail/dynamic/matchable.hpp	/^    static bool top_match(match_state<BidiIter> &state, void const *top)$/;"	f	struct:boost::xpressive::detail::matchable_ex	access:public	signature:(match_state<BidiIter> &state, void const *top)
top_match	xpressive/detail/static/static.hpp	/^    static bool top_match(match_state<BidiIter> &state, void const *top)$/;"	f	struct:boost::xpressive::detail::stacked_xpression	access:public	signature:(match_state<BidiIter> &state, void const *top)
toupper	xpressive/detail/core/regex_impl.hpp	/^    char_type toupper(char_type ch) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type ch) const
toupper	xpressive/detail/core/regex_impl.hpp	/^    virtual Char toupper(Char ch) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char ch) const
toupper	xpressive/traits/c_regex_traits.hpp	/^    static char_type toupper(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
toupper	xpressive/traits/cpp_regex_traits.hpp	/^    char_type toupper(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
toupper_	xpressive/detail/core/regex_impl.hpp	/^    char_type toupper_(char_type ch, regex_traits_version_1_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_1_tag) const
toupper_	xpressive/detail/core/regex_impl.hpp	/^    char_type toupper_(char_type ch, regex_traits_version_2_tag) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:private	signature:(char_type ch, regex_traits_version_2_tag) const
track_dependency_	xpressive/detail/utility/tracking_ptr.hpp	/^    void track_dependency_(enable_reference_tracking<Derived> &dep)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:(enable_reference_tracking<Derived> &dep)
track_reference	xpressive/detail/utility/tracking_ptr.hpp	/^    void track_reference(enable_reference_tracking<Derived> &that)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:public	signature:(enable_reference_tracking<Derived> &that)
tracking_clear	xpressive/detail/utility/tracking_ptr.hpp	/^    void tracking_clear()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:public	signature:()
tracking_copy	xpressive/detail/utility/tracking_ptr.hpp	/^    void tracking_copy(Derived const &that)$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:public	signature:(Derived const &that)
tracking_ptr	xpressive/detail/utility/tracking_ptr.hpp	/^    tracking_ptr()$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:()
tracking_ptr	xpressive/detail/utility/tracking_ptr.hpp	/^    tracking_ptr(tracking_ptr<element_type> const &that)$/;"	f	struct:boost::xpressive::detail::tracking_ptr	access:public	signature:(tracking_ptr<element_type> const &that)
tracking_ptr	xpressive/detail/utility/tracking_ptr.hpp	/^struct tracking_ptr$/;"	s	namespace:boost::xpressive::detail
tracking_update	xpressive/detail/utility/tracking_ptr.hpp	/^    void tracking_update()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:public	signature:()
traits	xpressive/detail/core/regex_impl.hpp	/^    Traits const &traits() const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:() const
traits	xpressive/detail/core/regex_impl.hpp	/^struct traits$/;"	s	namespace:boost::xpressive::detail	inherits:counted_base
traits	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_traits &traits()$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:()
traits	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_traits const &traits() const$/;"	f	struct:boost::xpressive::compiler_traits	access:public	signature:() const
traits	xpressive/detail/static/visitor.hpp	/^        Traits const &traits() const$/;"	f	struct:boost::xpressive::detail::xpression_visitor	access:public	signature:() const
traits_	xpressive/detail/core/linker.hpp	/^    void const *traits_;$/;"	m	struct:boost::xpressive::detail::xpression_linker	access:private
traits_	xpressive/detail/core/matcher/attr_matcher.hpp	/^        Traits const &traits_;$/;"	m	struct:boost::xpressive::detail::char_translate	access:public
traits_	xpressive/detail/core/peeker.hpp	/^    Traits const &traits_;$/;"	m	struct:boost::xpressive::detail::char_sink	access:public
traits_	xpressive/detail/core/peeker.hpp	/^    void const *traits_;$/;"	m	struct:boost::xpressive::detail::xpression_peeker	access:private
traits_	xpressive/detail/core/regex_impl.hpp	/^    Traits traits_;$/;"	m	struct:boost::xpressive::detail::traits_holder	access:private
traits_	xpressive/detail/core/regex_impl.hpp	/^    intrusive_ptr<traits<char_type> const> traits_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
traits_	xpressive/detail/core/state.hpp	/^    detail::traits<char_type> const *traits_;$/;"	m	class:boost::xpressive::detail::match_context::detail	access:public
traits_	xpressive/detail/dynamic/parser_traits.hpp	/^    regex_traits traits_;$/;"	m	struct:boost::xpressive::compiler_traits	access:private
traits_	xpressive/detail/static/visitor.hpp	/^        Traits traits_;$/;"	m	struct:boost::xpressive::detail::xpression_visitor	access:private
traits_	xpressive/detail/utility/traits_utils.hpp	/^        Traits const &traits_;$/;"	m	struct:boost::xpressive::detail::widen_fun	access:public
traits_	xpressive/match_results.hpp	/^    intrusive_ptr<detail::traits<char_type> const> traits_;$/;"	m	struct:boost::xpressive::match_results	access:private
traits_	xpressive/match_results.hpp	/^    traits<Char> const *traits_;$/;"	m	struct:boost::xpressive::detail::case_converting_iterator	access:private
traits_	xpressive/regex_compiler.hpp	/^    CompilerTraits traits_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
traits_cast	xpressive/detail/core/state.hpp	/^inline Traits const &traits_cast(match_state<BidiIter> const &state)$/;"	f	namespace:boost::xpressive::detail	signature:(match_state<BidiIter> const &state)
traits_cast	xpressive/detail/detail_fwd.hpp	/^    Traits const &traits_cast(match_state<BidiIter> const &state);$/;"	p	namespace:boost::xpressive::detail	signature:(match_state<BidiIter> const &state)
traits_holder	xpressive/detail/core/regex_impl.hpp	/^    explicit traits_holder(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(Traits const &tr)
traits_holder	xpressive/detail/core/regex_impl.hpp	/^struct traits_holder$/;"	s	namespace:boost::xpressive::detail	inherits:traits
traits_ptr_	xpressive/detail/utility/chset/chset.hpp	/^        Traits const *traits_ptr_;$/;"	m	struct:boost::xpressive::detail::compound_charset::not_posix_pred	access:public
traits_type	xpressive/detail/core/linker.hpp	/^        typedef typename regex_traits_type<Locale, BidiIter>::type traits_type;$/;"	t	struct:boost::xpressive::detail::locale_modifier::apply	access:public
traits_type	xpressive/detail/core/matcher/charset_matcher.hpp	/^        typedef Traits traits_type;$/;"	t	struct:boost::xpressive::detail::charset_matcher	access:public
traits_type	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^        typedef Traits traits_type;$/;"	t	struct:boost::xpressive::detail::posix_charset_matcher	access:public
traits_type	xpressive/detail/static/transforms/as_set.hpp	/^        typedef typename Data::traits_type traits_type;$/;"	t	struct:boost::xpressive::grammar_detail::merge_charset	access:public
traits_type	xpressive/detail/static/visitor.hpp	/^        typedef Traits traits_type;$/;"	t	struct:boost::xpressive::detail::xpression_visitor	access:public
traits_type	xpressive/detail/utility/boyer_moore.hpp	/^    typedef Traits traits_type;$/;"	t	struct:boost::xpressive::detail::boyer_moore	access:public
traits_type	xpressive/detail/utility/chset/chset.hpp	/^    typedef Traits traits_type;$/;"	t	struct:boost::xpressive::detail::compound_charset	access:public
traits_type	xpressive/regex_compiler.hpp	/^    typedef RegexTraits traits_type;$/;"	t	struct:boost::xpressive::regex_compiler	access:public
traits_type_	xpressive/detail/core/linker.hpp	/^    std::type_info const *traits_type_;$/;"	m	class:boost::xpressive::detail::xpression_linker::std	access:private
traits_type_	xpressive/detail/core/peeker.hpp	/^    std::type_info const *traits_type_;$/;"	m	class:boost::xpressive::detail::xpression_peeker::std	access:private
transform	xpressive/traits/c_regex_traits.hpp	/^    static string_type transform(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
transform	xpressive/traits/cpp_regex_traits.hpp	/^    string_type transform(FwdIter, FwdIter) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter, FwdIter) const
transform	xpressive/traits/null_regex_traits.hpp	/^    static string_type transform(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
transform_op	xpressive/match_results.hpp	/^enum transform_op { op_none = 0, op_upper = 1, op_lower = 2 };$/;"	g	namespace:boost::xpressive::detail
transform_primary	xpressive/traits/c_regex_traits.hpp	/^    static string_type transform_primary(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
transform_primary	xpressive/traits/cpp_regex_traits.hpp	/^    string_type transform_primary(FwdIter, FwdIter ) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(FwdIter, FwdIter ) const
transform_primary	xpressive/traits/null_regex_traits.hpp	/^    static string_type transform_primary(FwdIter begin, FwdIter end)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(FwdIter begin, FwdIter end)
transform_scope	xpressive/match_results.hpp	/^enum transform_scope { scope_next = 0, scope_rest = 1 };$/;"	g	namespace:boost::xpressive::detail
translate	xpressive/detail/utility/traits_utils.hpp	/^    inline Char translate(Char ch, Traits const &tr, mpl::false_) \/\/ case-sensitive$/;"	f	namespace:boost::xpressive::detail	signature:(Char ch, Traits const &tr, mpl::false_)
translate	xpressive/detail/utility/traits_utils.hpp	/^    inline Char translate(Char ch, Traits const &tr, mpl::true_) \/\/ case-insensitive$/;"	f	namespace:boost::xpressive::detail	signature:(Char ch, Traits const &tr, mpl::true_)
translate	xpressive/traits/c_regex_traits.hpp	/^    static char_type translate(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
translate	xpressive/traits/cpp_regex_traits.hpp	/^    static char_type translate(char_type ch)$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch)
translate	xpressive/traits/null_regex_traits.hpp	/^    static char_type translate(char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch)
translate_nocase	xpressive/traits/c_regex_traits.hpp	/^    static char_type translate_nocase(char_type ch)$/;"	f	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch)
translate_nocase	xpressive/traits/cpp_regex_traits.hpp	/^    char_type translate_nocase(char_type ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch) const
translate_nocase	xpressive/traits/null_regex_traits.hpp	/^    static char_type translate_nocase(char_type ch)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch)
transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify$/;"	s	namespace:boost::xpressive::detail	inherits:default_transmogrify
transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, assert_bol_placeholder >$/;"	s	namespace:boost::xpressive::detail
transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, assert_eol_placeholder >$/;"	s	namespace:boost::xpressive::detail
transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, assert_word_placeholder<Cond> >$/;"	s	namespace:boost::xpressive::detail
transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, logical_newline_placeholder >$/;"	s	namespace:boost::xpressive::detail
transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, mark_placeholder >$/;"	s	namespace:boost::xpressive::detail
transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, posix_charset_placeholder >$/;"	s	namespace:boost::xpressive::detail
transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, range_placeholder<Char> >$/;"	s	namespace:boost::xpressive::detail
transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, reference_wrapper<basic_regex<BidiIter> > >$/;"	s	namespace:boost::xpressive::detail
transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, reference_wrapper<basic_regex<BidiIter> const> >$/;"	s	namespace:boost::xpressive::detail
transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, self_placeholder >$/;"	s	namespace:boost::xpressive::detail
transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, ICase, Traits, tracking_ptr<regex_impl<BidiIter> > >$/;"	s	namespace:boost::xpressive::detail
transmogrify	xpressive/detail/static/transmogrify.hpp	/^    struct transmogrify<BidiIter, mpl::true_, Traits, set_matcher<Traits, Size> >$/;"	s	namespace:boost::xpressive::detail
true_matcher	xpressive/detail/core/matcher/true_matcher.hpp	/^    struct true_matcher$/;"	s	namespace:boost::xpressive::detail	inherits:quant_style_assertion
true_xpression	xpressive/detail/detail_fwd.hpp	/^    typedef static_xpression<true_matcher, no_next> true_xpression;$/;"	t	namespace:boost::xpressive::detail
type	xpressive/detail/core/linker.hpp	/^        typedef xpression_visitor<BidiIter, ICase, traits_type> type;$/;"	t	struct:boost::xpressive::detail::locale_modifier::apply	access:public
type	xpressive/detail/core/linker.hpp	/^        typedef xpression_visitor<BidiIter, mpl::true_, Traits> type;$/;"	t	struct:boost::xpressive::detail::icase_modifier::apply	access:public
type	xpressive/detail/core/linker.hpp	/^    >::type type;$/;"	t	struct:boost::xpressive::detail::regex_traits_type	access:public
type	xpressive/detail/core/matcher/action_matcher.hpp	/^        typedef T type;$/;"	t	struct:boost::xpressive::detail::opt	access:public
type	xpressive/detail/detail_fwd.hpp	/^        typedef std::string type;$/;"	t	struct:boost::xpressive::detail::string_type	access:public
type	xpressive/detail/detail_fwd.hpp	/^        typedef std::vector<Char> type;$/;"	t	struct:boost::xpressive::detail::string_type	access:public
type	xpressive/detail/detail_fwd.hpp	/^        typedef std::wstring type;$/;"	t	struct:boost::xpressive::detail::string_type	access:public
type	xpressive/detail/static/modifier.hpp	/^            >::type type;$/;"	t	struct:boost::xpressive::detail::modifier_op::apply	access:public
type	xpressive/detail/static/transforms/as_inverse.hpp	/^        typedef T type;$/;"	t	struct:boost::xpressive::grammar_detail::inverter	access:public
type	xpressive/detail/static/transforms/as_inverse.hpp	/^        typedef detail::assert_word_matcher<detail::word_boundary<mpl::false_>, Traits> type;$/;"	t	struct:boost::xpressive::grammar_detail::inverter	access:public
type	xpressive/detail/static/transforms/as_inverse.hpp	/^        typedef detail::literal_matcher<Traits, ICase, typename mpl::not_<Not>::type> type;$/;"	t	struct:boost::xpressive::grammar_detail::inverter	access:public
type	xpressive/detail/static/transforms/as_inverse.hpp	/^        typedef detail::posix_charset_matcher<Traits> type;$/;"	t	struct:boost::xpressive::grammar_detail::inverter	access:public
type	xpressive/detail/static/transmogrify.hpp	/^        >::type type;$/;"	t	struct:boost::xpressive::detail::default_transmogrify	access:public
type	xpressive/detail/static/transmogrify.hpp	/^        typedef Matcher type;$/;"	t	struct:boost::xpressive::detail::default_transmogrify	access:public
type	xpressive/detail/static/transmogrify.hpp	/^        typedef assert_bol_matcher<Traits> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
type	xpressive/detail/static/transmogrify.hpp	/^        typedef assert_eol_matcher<Traits> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
type	xpressive/detail/static/transmogrify.hpp	/^        typedef assert_word_matcher<Cond, Traits> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
type	xpressive/detail/static/transmogrify.hpp	/^        typedef logical_newline_matcher<Traits> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
type	xpressive/detail/static/transmogrify.hpp	/^        typedef mark_matcher<Traits, ICase> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
type	xpressive/detail/static/transmogrify.hpp	/^        typedef posix_charset_matcher<Traits> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
type	xpressive/detail/static/transmogrify.hpp	/^        typedef range_matcher<Traits, ICase> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
type	xpressive/detail/static/transmogrify.hpp	/^        typedef regex_byref_matcher<BidiIter> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
type	xpressive/detail/static/transmogrify.hpp	/^        typedef regex_matcher<BidiIter> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
type	xpressive/detail/static/transmogrify.hpp	/^        typedef set_matcher<Traits, Size> type;$/;"	t	struct:boost::xpressive::detail::transmogrify	access:public
type	xpressive/detail/static/visitor.hpp	/^            typedef typename transmogrify<BidiIter, ICase, Traits, Matcher>::type type;$/;"	t	struct:boost::xpressive::detail::xpression_visitor::apply	access:public
type	xpressive/detail/utility/any.hpp	/^                typedef bool type;$/;"	t	struct:boost::fusion::function::any::apply	access:public
type	xpressive/detail/utility/any.hpp	/^            typedef bool type;$/;"	t	struct:boost::fusion::meta::any	access:public
type	xpressive/detail/utility/cons.hpp	/^            type;$/;"	t	struct:boost::fusion::cons_detail::deref_traits_impl	access:public
type	xpressive/detail/utility/cons.hpp	/^            type;$/;"	t	struct:boost::fusion::cons_detail::end_traits_impl	access:public
type	xpressive/detail/utility/cons.hpp	/^            type;$/;"	t	struct:boost::fusion::cons_detail::next_traits_impl	access:public
type	xpressive/detail/utility/cons.hpp	/^            typedef cons_iterator<Cons> type;$/;"	t	struct:boost::fusion::cons_detail::begin_traits_impl	access:public
type	xpressive/detail/utility/cons.hpp	/^            typedef typename cons_type::car_type type;$/;"	t	struct:boost::fusion::cons_detail::value_traits_impl	access:public
type	xpressive/match_results.hpp	/^    typedef mpl::size_t<value> type;$/;"	t	struct:boost::xpressive::detail::formatter_arity	access:public
type	xpressive/regex_actions.hpp	/^                    type;$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
type	xpressive/regex_actions.hpp	/^                    typedef typename remove_reference<Cont>::type &type;$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
type	xpressive/regex_actions.hpp	/^                    typedef typename remove_reference<Cont>::type::iterator type;$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
type	xpressive/regex_actions.hpp	/^                    typedef void type;$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
type	xpressive/regex_actions.hpp	/^                type;$/;"	t	struct:boost::xpressive::op::back::result	access:public
type	xpressive/regex_actions.hpp	/^                type;$/;"	t	struct:boost::xpressive::op::front::result	access:public
type	xpressive/regex_actions.hpp	/^                type;$/;"	t	struct:boost::xpressive::op::top::result	access:public
type	xpressive/regex_actions.hpp	/^                typedef Expr type;$/;"	t	struct:boost::xpressive::detail::BindArg::result	access:public
type	xpressive/regex_actions.hpp	/^                typedef std::pair<first_type, second_type> type;$/;"	t	struct:boost::xpressive::op::make_pair::result	access:public
type	xpressive/regex_actions.hpp	/^                typedef typename Cont::const_reference type;$/;"	t	struct:boost::xpressive::op::at::result	access:public
type	xpressive/regex_actions.hpp	/^                typedef typename Cont::reference type;$/;"	t	struct:boost::xpressive::op::at::result	access:public
type	xpressive/regex_actions.hpp	/^                typedef typename boost::unwrap_reference<Ref>::type &type;$/;"	t	struct:boost::xpressive::op::unwrap_reference::result	access:public
type	xpressive/regex_actions.hpp	/^                typedef typename detail::result_detail<Sig>::type type;$/;"	t	struct:boost::xpressive::op::insert::result	access:public
type	xpressive/regex_actions.hpp	/^                typedef typename remove_reference<Pair>::type::first_type type;$/;"	t	struct:boost::xpressive::op::first::result	access:public
type	xpressive/regex_actions.hpp	/^                typedef typename remove_reference<Pair>::type::second_type type;$/;"	t	struct:boost::xpressive::op::second::result	access:public
type	xpressive/regex_actions.hpp	/^                typedef typename remove_reference<Sub>::type::difference_type type;$/;"	t	struct:boost::xpressive::op::length::result	access:public
type	xpressive/regex_actions.hpp	/^                typedef typename remove_reference<Sub>::type::string_type type;$/;"	t	struct:boost::xpressive::op::str::result	access:public
type	xpressive/regex_actions.hpp	/^            typedef T type;$/;"	t	struct:boost::xpressive::detail::action_arg	access:public
type	xpressive/regex_actions.hpp	/^        typedef typename proto::terminal<PolymorphicFunctionObject>::type type;$/;"	t	struct:boost::xpressive::function	access:public
type	xpressive/regex_primitives.hpp	/^            type;$/;"	t	struct:boost::xpressive::detail::skip_directive::result	access:public
type	xpressive/sub_match.hpp	/^        typedef BidiIter type;$/;"	t	struct:boost::range_const_iterator	access:public
type	xpressive/sub_match.hpp	/^        typedef BidiIter type;$/;"	t	struct:boost::range_mutable_iterator	access:public
type	xpressive/xpressive_fwd.hpp	/^            typedef c_regex_traits<Char> type;$/;"	t	struct:boost::xpressive::detail::default_regex_traits	access:public
type_	xpressive/detail/dynamic/parse_charset.hpp	/^    escape_type type_;$/;"	m	struct:boost::xpressive::detail::escape_value	access:public
type_info_less	xpressive/match_results.hpp	/^struct type_info_less$/;"	s	namespace:boost::xpressive::detail
uint_t	xpressive/detail/detail_fwd.hpp	/^    typedef unsigned int uint_t;$/;"	t	namespace:boost::xpressive::detail
umask_t	xpressive/traits/cpp_regex_traits.hpp	/^    typedef boost::uint_t<sizeof(std::ctype_base::mask) * CHAR_BIT>::least umask_t;$/;"	t	namespace:boost::xpressive::detail
umaskex_bits	xpressive/traits/cpp_regex_traits.hpp	/^    int const umaskex_bits = (14 > (sizeof(umask_t) * CHAR_BIT)) ? 14 : sizeof(umask_t) * CHAR_BIT;$/;"	m	namespace:boost::xpressive::detail
umaskex_t	xpressive/traits/cpp_regex_traits.hpp	/^    typedef boost::uint_t<umaskex_bits>::fast umaskex_t;$/;"	t	namespace:boost::xpressive::detail
unary_binary_ternary	xpressive/match_results.hpp	/^struct unary_binary_ternary$/;"	s	namespace:boost::xpressive::detail
unary_fun	xpressive/match_results.hpp	/^    typedef unary_type (*unary_fun)(any_type);$/;"	t	struct:boost::xpressive::detail::unary_binary_ternary	access:public
unary_type	xpressive/match_results.hpp	/^typedef char (&unary_type)[2];$/;"	t	namespace:boost::xpressive::detail
uninit_	xpressive/detail/core/state.hpp	/^    void uninit_(regex_impl const &impl, match_results &)$/;"	f	struct:boost::xpressive::detail::match_state	access:private	signature:(regex_impl const &impl, match_results &)
unknown_width	xpressive/detail/detail_fwd.hpp	/^    typedef mpl::size_t<INT_MAX \/ 2 - 1> unknown_width;$/;"	t	namespace:boost::xpressive::detail
unknown_width	xpressive/detail/utility/width.hpp	/^typedef mpl::size_t<INT_MAX \/ 2 - 1> unknown_width;$/;"	t	namespace:boost::xpressive::detail
unspecified_bool_type	xpressive/detail/utility/tracking_ptr.hpp	/^    typedef intrusive_ptr<element_type> tracking_ptr::* unspecified_bool_type;$/;"	t	class:boost::xpressive::detail::tracking_ptr::tracking_ptr	access:public
unused_mask	xpressive/traits/cpp_regex_traits.hpp	/^    struct unused_mask$/;"	s	namespace:boost::xpressive::detail
unused_mask	xpressive/traits/cpp_regex_traits.hpp	/^    struct unused_mask<In, Out, true>$/;"	s	namespace:boost::xpressive::detail
unwind	xpressive/detail/utility/sequence_stack.hpp	/^    void unwind()$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:()
unwind_chunk_	xpressive/detail/utility/sequence_stack.hpp	/^    void unwind_chunk_()$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:private	signature:()
unwind_to	xpressive/detail/utility/sequence_stack.hpp	/^    void unwind_to(T *ptr)$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:(T *ptr)
unwrap_reference	xpressive/regex_actions.hpp	/^        struct unwrap_reference$/;"	s	namespace:boost::xpressive::op
unwrap_reference	xpressive/regex_actions.hpp	/^    function<op::unwrap_reference>::type const unwrap_reference = {{}};$/;"	m	class:boost::xpressive::function
update_dependents_	xpressive/detail/utility/tracking_ptr.hpp	/^    void update_dependents_()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:()
update_references_	xpressive/detail/utility/tracking_ptr.hpp	/^    void update_references_()$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:private	signature:()
upper	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const upper = {{"upper", false}};$/;"	m	class:boost::xpressive::proto::terminal
upper_	xpressive/regex_compiler.hpp	/^    typename RegexTraits::char_class_type upper_;$/;"	m	struct:boost::xpressive::regex_compiler	access:private
use_count	xpressive/detail/utility/counted_base.hpp	/^        long use_count() const$/;"	f	struct:boost::xpressive::detail::counted_base	access:public	signature:() const
use_count	xpressive/detail/utility/tracking_ptr.hpp	/^    long use_count() const$/;"	f	struct:boost::xpressive::detail::enable_reference_tracking	access:public	signature:() const
use_simple_repeat	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_
use_simple_repeat	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat<Expr &, Char>$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_$/;"	s	namespace:boost::xpressive::detail
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, generic_quant_tag<Count, Count> >$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, generic_quant_tag<Min, Max> >$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, keeper_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, lookahead_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, lookbehind_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, modifier_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::assign>$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_assign
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::bitwise_or>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::and_
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::comma>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::complement>$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::dereference>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::logical_not>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::negate>$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::shift_right>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::and_
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::subscript>$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_subscript
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::terminal>$/;"	s	namespace:boost::xpressive::detail	inherits:use_simple_repeat_terminal
use_simple_repeat_	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_<Expr, Char, proto::tag::unary_plus>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
use_simple_repeat_assign	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_assign$/;"	s	namespace:boost::xpressive::detail
use_simple_repeat_assign	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_assign<attribute_placeholder<Nbr> >$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
use_simple_repeat_assign	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_assign<mark_placeholder>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
use_simple_repeat_assign	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_assign<set_initializer>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
use_simple_repeat_subscript	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_subscript$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
use_simple_repeat_subscript	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_subscript<Expr, Char, set_initializer_type>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
use_simple_repeat_terminal	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_terminal$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::bool_
use_simple_repeat_terminal	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_terminal<Expr, Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::true_
use_simple_repeat_terminal	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_terminal<reference_wrapper<basic_regex<BidiIter> >, Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
use_simple_repeat_terminal	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_terminal<reference_wrapper<basic_regex<BidiIter> const>, Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
use_simple_repeat_terminal	xpressive/detail/static/is_pure.hpp	/^    struct use_simple_repeat_terminal<tracking_ptr<regex_impl<BidiIter> >, Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::false_
val	xpressive/detail/utility/save_restore.hpp	/^        T const val;$/;"	m	struct:boost::xpressive::detail::save_restore	access:private
val	xpressive/regex_actions.hpp	/^    value<T> const val(T const &t)$/;"	f	namespace:boost::xpressive	signature:(T const &t)
value	xpressive/detail/core/regex_impl.hpp	/^    int value(char_type ch, int radix) const$/;"	f	struct:boost::xpressive::detail::traits_holder	access:public	signature:(char_type ch, int radix) const
value	xpressive/detail/core/regex_impl.hpp	/^    virtual int value(Char ch, int radix) const = 0;$/;"	p	struct:boost::xpressive::detail::traits	access:public	signature:(Char ch, int radix) const
value	xpressive/detail/utility/literals.hpp	/^boost::intmax_t const char_literal<Char, Ch, Ch>::value;$/;"	m	class:boost::xpressive::detail::boost::char_literal
value	xpressive/detail/utility/width.hpp	/^    std::size_t value() const$/;"	f	struct:boost::xpressive::detail::width	access:public	signature:() const
value	xpressive/regex_actions.hpp	/^            T value;$/;"	m	struct:boost::xpressive::detail::value_wrapper	access:public
value	xpressive/regex_actions.hpp	/^        explicit value(T const &t)$/;"	f	struct:boost::xpressive::value	access:public	signature:(T const &t)
value	xpressive/regex_actions.hpp	/^        value()$/;"	f	struct:boost::xpressive::value	access:public	signature:()
value	xpressive/regex_actions.hpp	/^    struct value$/;"	s	namespace:boost::xpressive	inherits:proto::extends
value	xpressive/traits/c_regex_traits.hpp	/^    static int value(char_type ch, int radix);$/;"	p	struct:boost::xpressive::c_regex_traits	access:public	signature:(char_type ch, int radix)
value	xpressive/traits/c_regex_traits.hpp	/^inline int c_regex_traits<char>::value(char ch, int radix)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch, int radix)
value	xpressive/traits/c_regex_traits.hpp	/^inline int c_regex_traits<wchar_t>::value(wchar_t ch, int radix)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(wchar_t ch, int radix)
value	xpressive/traits/cpp_regex_traits.hpp	/^    int value(char_type ch, int radix) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char_type ch, int radix) const
value	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const mask_cast<Mask>::value;$/;"	m	class:boost::xpressive::detail::mask_cast
value	xpressive/traits/cpp_regex_traits.hpp	/^    umaskex_t const unused_mask<In, Out, Done>::value;$/;"	m	class:boost::xpressive::detail::unused_mask
value	xpressive/traits/null_regex_traits.hpp	/^    static int value(char_type ch, int radix)$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char_type ch, int radix)
value_	xpressive/detail/utility/width.hpp	/^    std::size_t value_;$/;"	m	struct:boost::xpressive::detail::width	access:private
value_impl	xpressive/detail/utility/cons.hpp	/^        struct value_impl<cons_iterator_tag>$/;"	s	namespace:boost::fusion::meta
value_traits_impl	xpressive/detail/utility/cons.hpp	/^        struct value_traits_impl$/;"	s	namespace:boost::fusion::cons_detail
value_type	xpressive/basic_regex.hpp	/^    typedef typename iterator_value<BidiIter>::type value_type;$/;"	t	struct:boost::xpressive::basic_regex	access:public
value_type	xpressive/detail/core/sub_match_vector.hpp	/^    typedef sub_match<BidiIter> value_type;$/;"	t	struct:boost::xpressive::detail::sub_match_vector	access:public
value_type	xpressive/detail/utility/cons.hpp	/^            typedef typename cons_type::car_type value_type;$/;"	t	struct:boost::fusion::cons_detail::deref_traits_impl	access:public
value_type	xpressive/detail/utility/symbols.hpp	/^        typedef typename range_value<Map>::type::second_type value_type;$/;"	t	struct:boost::xpressive::detail::symbols	access:public
value_type	xpressive/match_results.hpp	/^    typedef sub_match<BidiIter> value_type;$/;"	t	struct:boost::xpressive::match_results	access:public
value_type	xpressive/regex_actions.hpp	/^                    typedef typename remove_reference<Value>::type value_type;$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
value_type	xpressive/regex_iterator.hpp	/^    typedef match_results<BidiIter> value_type;$/;"	t	struct:boost::xpressive::regex_iterator	access:public
value_type	xpressive/regex_token_iterator.hpp	/^    typedef sub_match<BidiIter> value_type;$/;"	t	struct:boost::xpressive::detail::regex_token_iterator_impl	access:public
value_type	xpressive/regex_token_iterator.hpp	/^    typedef sub_match<BidiIter> value_type;$/;"	t	struct:boost::xpressive::regex_token_iterator	access:public
value_type	xpressive/sub_match.hpp	/^    typedef typename iterator_value<BidiIter>::type value_type;$/;"	t	struct:boost::xpressive::sub_match	access:public
value_wrapper	xpressive/regex_actions.hpp	/^            value_wrapper()$/;"	f	struct:boost::xpressive::detail::value_wrapper	access:public	signature:()
value_wrapper	xpressive/regex_actions.hpp	/^            value_wrapper(T const &t)$/;"	f	struct:boost::xpressive::detail::value_wrapper	access:public	signature:(T const &t)
value_wrapper	xpressive/regex_actions.hpp	/^        struct value_wrapper$/;"	s	namespace:boost::xpressive::detail	inherits:noncopyable
version_tag	xpressive/traits/c_regex_traits.hpp	/^    typedef regex_traits_version_2_tag version_tag;$/;"	t	struct:boost::xpressive::c_regex_traits	access:public
version_tag	xpressive/traits/cpp_regex_traits.hpp	/^    typedef regex_traits_version_2_tag version_tag;$/;"	t	struct:boost::xpressive::cpp_regex_traits	access:public
version_tag	xpressive/traits/null_regex_traits.hpp	/^    typedef regex_traits_version_1_tag version_tag;$/;"	t	struct:boost::xpressive::null_regex_traits	access:public
visit_	xpressive/detail/static/visitor.hpp	/^        void visit_(Matcher const &)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:protected	signature:(Matcher const &)
visit_	xpressive/detail/static/visitor.hpp	/^        void visit_(mark_begin_matcher const &mark_begin)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:protected	signature:(mark_begin_matcher const &mark_begin)
visit_	xpressive/detail/static/visitor.hpp	/^        void visit_(mark_placeholder const &backref)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:protected	signature:(mark_placeholder const &backref)
visit_	xpressive/detail/static/visitor.hpp	/^        void visit_(reference_wrapper<basic_regex<BidiIter> > const &rex)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:protected	signature:(reference_wrapper<basic_regex<BidiIter> > const &rex)
visit_	xpressive/detail/static/visitor.hpp	/^        void visit_(reference_wrapper<basic_regex<BidiIter> const> const &rex)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:protected	signature:(reference_wrapper<basic_regex<BidiIter> const> const &rex)
visit_	xpressive/detail/static/visitor.hpp	/^        void visit_(tracking_ptr<regex_impl<BidiIter> > const &rex)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:protected	signature:(tracking_ptr<regex_impl<BidiIter> > const &rex)
visitor_	xpressive/detail/static/transforms/as_set.hpp	/^        Data &visitor_;$/;"	m	struct:boost::xpressive::grammar_detail::merge_charset	access:private
visitor_type	xpressive/detail/static/transforms/as_modifier.hpp	/^            visitor_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_modifier::impl	access:public
wcmatch	xpressive/xpressive_fwd.hpp	/^    typedef match_results<wchar_t const *>                          wcmatch;$/;"	t	namespace:boost::xpressive
wcregex	xpressive/xpressive_fwd.hpp	/^    typedef basic_regex<wchar_t const *>                            wcregex;$/;"	t	namespace:boost::xpressive
wcregex_compiler	xpressive/xpressive_fwd.hpp	/^    typedef regex_compiler<wchar_t const *>                         wcregex_compiler;$/;"	t	namespace:boost::xpressive
wcregex_id_filter_predicate	xpressive/xpressive_fwd.hpp	/^    typedef regex_id_filter_predicate<wchar_t const *>              wcregex_id_filter_predicate;$/;"	t	namespace:boost::xpressive
wcregex_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_iterator<wchar_t const *>                         wcregex_iterator;$/;"	t	namespace:boost::xpressive
wcregex_token_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_token_iterator<wchar_t const *>                   wcregex_token_iterator;$/;"	t	namespace:boost::xpressive
wcsub_match	xpressive/xpressive_fwd.hpp	/^    typedef sub_match<wchar_t const *>                              wcsub_match;$/;"	t	namespace:boost::xpressive
weak_iterator	xpressive/detail/utility/tracking_ptr.hpp	/^    weak_iterator()$/;"	f	struct:boost::xpressive::detail::weak_iterator	access:public	signature:()
weak_iterator	xpressive/detail/utility/tracking_ptr.hpp	/^    weak_iterator(base_iterator iter, set_type *set)$/;"	f	struct:boost::xpressive::detail::weak_iterator	access:public	signature:(base_iterator iter, set_type *set)
weak_iterator	xpressive/detail/utility/tracking_ptr.hpp	/^struct weak_iterator$/;"	s	namespace:boost::xpressive::detail	inherits:iterator_facade
what	xpressive/match_results.hpp	/^    static What &what;$/;"	m	struct:boost::xpressive::detail::formatter_arity	access:public
what	xpressive/regex_algorithms.hpp	/^      , match_results<BidiIter> &what$/;"	m	namespace:boost::xpressive::detail
what_	xpressive/regex_iterator.hpp	/^    match_results<BidiIter> what_;$/;"	m	struct:boost::xpressive::detail::regex_iterator_impl	access:public
widen	xpressive/traits/c_regex_traits.hpp	/^    static char_type widen(char ch);$/;"	p	struct:boost::xpressive::c_regex_traits	access:public	signature:(char ch)
widen	xpressive/traits/c_regex_traits.hpp	/^inline char c_regex_traits<char>::widen(char ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch)
widen	xpressive/traits/c_regex_traits.hpp	/^inline wchar_t c_regex_traits<wchar_t>::widen(char ch)$/;"	f	class:boost::xpressive::c_regex_traits	signature:(char ch)
widen	xpressive/traits/cpp_regex_traits.hpp	/^    char_type widen(char ch) const$/;"	f	struct:boost::xpressive::cpp_regex_traits	access:public	signature:(char ch) const
widen	xpressive/traits/null_regex_traits.hpp	/^    char_type widen(char ch) const$/;"	f	struct:boost::xpressive::null_regex_traits	access:public	signature:(char ch) const
widen_fun	xpressive/detail/utility/traits_utils.hpp	/^        explicit widen_fun(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::widen_fun	access:public	signature:(Traits const &tr)
widen_fun	xpressive/detail/utility/traits_utils.hpp	/^    struct widen_fun$/;"	s	namespace:boost::xpressive::detail
width	xpressive/detail/dynamic/sequence.hpp	/^    detail::width width() const$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:() const
width	xpressive/detail/utility/width.hpp	/^    width(std::size_t val = 0)$/;"	f	struct:boost::xpressive::detail::width	access:public	signature:(std::size_t val = 0)
width	xpressive/detail/utility/width.hpp	/^struct width$/;"	s	namespace:boost::xpressive::detail
width_	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        std::size_t width_;$/;"	m	struct:boost::xpressive::detail::lookbehind_matcher	access:public
width_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        std::size_t width_;$/;"	m	struct:boost::xpressive::detail::simple_repeat_matcher	access:public
width_	xpressive/detail/dynamic/sequence.hpp	/^    detail::width width_;$/;"	m	struct:boost::xpressive::detail::sequence	access:private
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of$/;"	s	namespace:boost::xpressive::detail
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, generic_quant_tag<Count, Count> >$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::if_c::type
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, generic_quant_tag<Min, Max> >$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, keeper_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, lookahead_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, lookbehind_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, modifier_tag>$/;"	s	namespace:boost::xpressive::detail	inherits:width_of
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::assign>$/;"	s	namespace:boost::xpressive::detail	inherits:width_of_assign
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::bitwise_or>$/;"	s	namespace:boost::xpressive::detail	inherits:or_widths
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::comma>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::complement>$/;"	s	namespace:boost::xpressive::detail	inherits:width_of
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::dereference>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::logical_not>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::negate>$/;"	s	namespace:boost::xpressive::detail	inherits:width_of
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::shift_right>$/;"	s	namespace:boost::xpressive::detail	inherits:add_widths
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::subscript>$/;"	s	namespace:boost::xpressive::detail	inherits:width_of_subscript
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::terminal>$/;"	s	namespace:boost::xpressive::detail	inherits:width_of_terminal
width_of	xpressive/detail/static/width_of.hpp	/^    struct width_of<Expr, Char, proto::tag::unary_plus>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
width_of_assign	xpressive/detail/static/width_of.hpp	/^    struct width_of_assign$/;"	s	namespace:boost::xpressive::detail
width_of_assign	xpressive/detail/static/width_of.hpp	/^    struct width_of_assign<Expr, Char, attribute_placeholder<Nbr> >$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
width_of_assign	xpressive/detail/static/width_of.hpp	/^    struct width_of_assign<Expr, Char, mark_placeholder>$/;"	s	namespace:boost::xpressive::detail	inherits:width_of
width_of_assign	xpressive/detail/static/width_of.hpp	/^    struct width_of_assign<Expr, Char, set_initializer>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
width_of_subscript	xpressive/detail/static/width_of.hpp	/^    struct width_of_subscript$/;"	s	namespace:boost::xpressive::detail	inherits:width_of
width_of_subscript	xpressive/detail/static/width_of.hpp	/^    struct width_of_subscript<Expr, Char, set_initializer_type>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
width_of_terminal	xpressive/detail/static/width_of.hpp	/^    struct width_of_terminal$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
width_of_terminal	xpressive/detail/static/width_of.hpp	/^    struct width_of_terminal<Char, Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
width_of_terminal	xpressive/detail/static/width_of.hpp	/^    struct width_of_terminal<Elem (&) [N], Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
width_of_terminal	xpressive/detail/static/width_of.hpp	/^    struct width_of_terminal<Elem const (&) [N], Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
width_of_terminal	xpressive/detail/static/width_of.hpp	/^    struct width_of_terminal<Expr, Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:unknown_width
width_of_terminal	xpressive/detail/static/width_of.hpp	/^    struct width_of_terminal<char, Char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
width_of_terminal	xpressive/detail/static/width_of.hpp	/^    struct width_of_terminal<char, char, false>$/;"	s	namespace:boost::xpressive::detail	inherits:mpl::size_t
wimpl_	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        weak_ptr<regex_impl<BidiIter> > wimpl_;$/;"	m	struct:boost::xpressive::detail::regex_byref_matcher	access:public
word	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        char_class_type word() const$/;"	f	struct:boost::xpressive::detail::assert_word_matcher	access:public	signature:() const
word_	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^        char_class_type word_;$/;"	m	struct:boost::xpressive::detail::assert_word_matcher	access:private
word_begin	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^    struct word_begin$/;"	s	namespace:boost::xpressive::detail
word_boundary	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^    struct word_boundary$/;"	s	namespace:boost::xpressive::detail
word_end	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^    struct word_end$/;"	s	namespace:boost::xpressive::detail
wrap_	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        static Next const &wrap_(Next const &next, mpl::false_)$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:private	signature:(Next const &next, mpl::false_)
wrap_	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^        static xpression_adaptor<reference_wrapper<Next const>, matchable<BidiIter> > wrap_(Next const &next, mpl::true_)$/;"	f	struct:boost::xpressive::detail::regex_byref_matcher	access:private	signature:(Next const &next, mpl::true_)
wsmatch	xpressive/xpressive_fwd.hpp	/^    typedef match_results<std::wstring::const_iterator>             wsmatch;$/;"	t	namespace:boost::xpressive
wsregex	xpressive/xpressive_fwd.hpp	/^    typedef basic_regex<std::wstring::const_iterator>               wsregex;$/;"	t	namespace:boost::xpressive
wsregex_compiler	xpressive/xpressive_fwd.hpp	/^    typedef regex_compiler<std::wstring::const_iterator>            wsregex_compiler;$/;"	t	namespace:boost::xpressive
wsregex_id_filter_predicate	xpressive/xpressive_fwd.hpp	/^    typedef regex_id_filter_predicate<std::wstring::const_iterator> wsregex_id_filter_predicate;$/;"	t	namespace:boost::xpressive
wsregex_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_iterator<std::wstring::const_iterator>            wsregex_iterator;$/;"	t	namespace:boost::xpressive
wsregex_token_iterator	xpressive/xpressive_fwd.hpp	/^    typedef regex_token_iterator<std::wstring::const_iterator>      wsregex_token_iterator;$/;"	t	namespace:boost::xpressive
wssub_match	xpressive/xpressive_fwd.hpp	/^    typedef sub_match<std::wstring::const_iterator>                 wssub_match;$/;"	t	namespace:boost::xpressive
xdigit	xpressive/regex_primitives.hpp	/^proto::terminal<detail::posix_charset_placeholder>::type const xdigit = {{"xdigit", false}};$/;"	m	class:boost::xpressive::proto::terminal
xpr	xpressive/detail/dynamic/sequence.hpp	/^    shared_matchable<BidiIter> const &xpr() const$/;"	f	struct:boost::xpressive::detail::sequence	access:public	signature:() const
xpr_	xpressive/detail/core/adaptor.hpp	/^    Xpr xpr_;$/;"	m	struct:boost::xpressive::detail::xpression_adaptor	access:public
xpr_	xpressive/detail/core/matcher/keeper_matcher.hpp	/^        Xpr xpr_;$/;"	m	struct:boost::xpressive::detail::keeper_matcher	access:public
xpr_	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^        Xpr xpr_;$/;"	m	struct:boost::xpressive::detail::lookahead_matcher	access:public
xpr_	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^        Xpr xpr_;$/;"	m	struct:boost::xpressive::detail::lookbehind_matcher	access:public
xpr_	xpressive/detail/core/matcher/optional_matcher.hpp	/^        Xpr xpr_;$/;"	m	struct:boost::xpressive::detail::optional_mark_matcher	access:public
xpr_	xpressive/detail/core/matcher/optional_matcher.hpp	/^        Xpr xpr_;$/;"	m	struct:boost::xpressive::detail::optional_matcher	access:public
xpr_	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        Xpr xpr_;$/;"	m	struct:boost::xpressive::detail::simple_repeat_matcher	access:public
xpr_	xpressive/detail/core/regex_impl.hpp	/^    intrusive_ptr<matchable_ex<BidiIter> const> xpr_;$/;"	m	struct:boost::xpressive::detail::regex_impl	access:public
xpr_	xpressive/detail/dynamic/matchable.hpp	/^    matchable_ptr xpr_;$/;"	m	struct:boost::xpressive::detail::shared_matchable	access:private
xpr_type	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^        typedef Xpr xpr_type;$/;"	t	struct:boost::xpressive::detail::simple_repeat_matcher	access:public
xpr_type	xpressive/detail/static/transforms/as_independent.hpp	/^            xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_keeper::impl	access:public
xpr_type	xpressive/detail/static/transforms/as_independent.hpp	/^            xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookahead::impl	access:public
xpr_type	xpressive/detail/static/transforms/as_independent.hpp	/^            xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_lookbehind::impl	access:public
xpr_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_default_quantifier_impl::impl	access:public
xpr_type	xpressive/detail/static/transforms/as_quantifier.hpp	/^            xpr_type;$/;"	t	struct:boost::xpressive::grammar_detail::as_simple_quantifier::impl	access:public
xpression_adaptor	xpressive/detail/core/adaptor.hpp	/^    xpression_adaptor(Xpr const &xpr)$/;"	f	struct:boost::xpressive::detail::xpression_adaptor	access:public	signature:(Xpr const &xpr)
xpression_adaptor	xpressive/detail/core/adaptor.hpp	/^struct xpression_adaptor$/;"	s	namespace:boost::xpressive::detail	inherits:Base
xpression_linker	xpressive/detail/core/linker.hpp	/^    explicit xpression_linker(Traits const &tr)$/;"	f	struct:boost::xpressive::detail::xpression_linker	access:public	signature:(Traits const &tr)
xpression_linker	xpressive/detail/core/linker.hpp	/^struct xpression_linker$/;"	s	namespace:boost::xpressive::detail
xpression_peeker	xpressive/detail/core/peeker.hpp	/^    xpression_peeker(hash_peek_bitset<Char> &bset, Traits const &tr, bool has_backrefs = false)$/;"	f	struct:boost::xpressive::detail::xpression_peeker	access:public	signature:(hash_peek_bitset<Char> &bset, Traits const &tr, bool has_backrefs = false)
xpression_peeker	xpressive/detail/core/peeker.hpp	/^    xpression_peeker(xpression_peeker const &);$/;"	p	struct:boost::xpressive::detail::xpression_peeker	access:private	signature:(xpression_peeker const &)
xpression_peeker	xpressive/detail/core/peeker.hpp	/^struct xpression_peeker$/;"	s	namespace:boost::xpressive::detail
xpression_visitor	xpressive/detail/static/visitor.hpp	/^        explicit xpression_visitor(Traits const &tr, shared_ptr<regex_impl<BidiIter> > const &self)$/;"	f	struct:boost::xpressive::detail::xpression_visitor	access:public	signature:(Traits const &tr, shared_ptr<regex_impl<BidiIter> > const &self)
xpression_visitor	xpressive/detail/static/visitor.hpp	/^    struct xpression_visitor$/;"	s	namespace:boost::xpressive::detail	inherits:xpression_visitor_base
xpression_visitor_base	xpressive/detail/static/visitor.hpp	/^        explicit xpression_visitor_base(shared_ptr<regex_impl<BidiIter> > const &self)$/;"	f	struct:boost::xpressive::detail::xpression_visitor_base	access:public	signature:(shared_ptr<regex_impl<BidiIter> > const &self)
xpression_visitor_base	xpressive/detail/static/visitor.hpp	/^    struct xpression_visitor_base$/;"	s	namespace:boost::xpressive::detail
xpressive	xpressive/basic_regex.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	xpressive/detail/core/access.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/action.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/adaptor.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/finder.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/flow_control.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/icase.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost
xpressive	xpressive/detail/core/linker.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/list.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/action_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/alternate_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/alternate_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/any_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/assert_bol_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/assert_bos_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/assert_eol_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/assert_eos_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/assert_line_base.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/assert_word_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/attr_begin_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/attr_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/attr_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/charset_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/epsilon_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/keeper_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/literal_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/logical_newline_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/lookahead_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/lookbehind_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/mark_begin_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/mark_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/mark_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/optional_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/posix_charset_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/predicate_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/range_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/regex_byref_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/regex_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/repeat_begin_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/repeat_end_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/set_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/simple_repeat_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/string_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/matcher/true_matcher.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/optimize.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/peeker.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/quant_style.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/regex_domain.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/regex_impl.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/results_cache.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/state.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/sub_match_impl.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/core/sub_match_vector.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
xpressive	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive { namespace op$/;"	n	namespace:boost
xpressive	xpressive/detail/detail_fwd.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	xpressive/detail/dynamic/dynamic.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/dynamic/matchable.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/dynamic/parse_charset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/dynamic/parser.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/dynamic/parser_enum.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost
xpressive	xpressive/detail/dynamic/parser_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	xpressive/detail/dynamic/sequence.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/compile.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/grammar.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	xpressive/detail/static/is_pure.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/modifier.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/placeholders.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/static.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/transforms/as_action.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/transforms/as_action.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/transforms/as_alternate.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	xpressive/detail/static/transforms/as_independent.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/transforms/as_independent.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/transforms/as_inverse.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/transforms/as_marker.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/transforms/as_matcher.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/transforms/as_modifier.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/transforms/as_modifier.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/transforms/as_quantifier.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/transforms/as_quantifier.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/transforms/as_sequence.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/transforms/as_set.hpp	/^namespace boost { namespace xpressive { namespace grammar_detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/transmogrify.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/type_traits.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/visitor.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/static/width_of.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/algorithm.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/boyer_moore.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/chset/basic_chset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/chset/chset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/chset/range_run.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/counted_base.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/dont_care.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/hash_peek_bitset.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/ignore_unused.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/literals.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/never_true.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/save_restore.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/sequence_stack.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/symbols.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/tracking_ptr.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/traits_utils.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/detail/utility/width.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/match_results.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/regex_actions.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	xpressive/regex_algorithms.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	xpressive/regex_compiler.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	xpressive/regex_constants.hpp	/^namespace boost { namespace xpressive { namespace regex_constants$/;"	n	namespace:boost
xpressive	xpressive/regex_error.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	xpressive/regex_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/regex_primitives.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/regex_token_iterator.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	xpressive/sub_match.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	xpressive/traits/c_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	xpressive/traits/cpp_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	xpressive/traits/detail/c_ctype.hpp	/^namespace boost { namespace xpressive { namespace detail$/;"	n	namespace:boost
xpressive	xpressive/traits/null_regex_traits.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
xpressive	xpressive/xpressive_fwd.hpp	/^namespace boost { namespace xpressive$/;"	n	namespace:boost
yes_type	xpressive/regex_actions.hpp	/^                    typedef char yes_type;$/;"	t	struct:boost::xpressive::op::insert::detail::result_detail	access:public
zero_width_	xpressive/detail/core/sub_match_impl.hpp	/^    bool zero_width_;$/;"	m	struct:boost::xpressive::detail::sub_match_impl	access:public
~actionable	xpressive/detail/core/action.hpp	/^        virtual ~actionable() {}$/;"	f	struct:boost::xpressive::detail::actionable	access:public	signature:()
~allocate_guard_t	xpressive/detail/utility/sequence_stack.hpp	/^        ~allocate_guard_t()$/;"	f	struct:boost::xpressive::detail::sequence_stack::allocate_guard_t	access:public	signature:()
~chunk	xpressive/detail/utility/sequence_stack.hpp	/^        ~chunk()$/;"	f	struct:boost::xpressive::detail::sequence_stack::chunk	access:public	signature:()
~finder	xpressive/detail/core/regex_impl.hpp	/^    virtual ~finder() {}$/;"	f	struct:boost::xpressive::detail::finder	access:public	signature:()
~list	xpressive/detail/core/list.hpp	/^        ~list()$/;"	f	struct:boost::xpressive::detail::list	access:public	signature:()
~match_results	xpressive/match_results.hpp	/^    ~match_results()$/;"	f	struct:boost::xpressive::match_results	access:public	signature:()
~matchable	xpressive/detail/dynamic/matchable.hpp	/^    virtual ~matchable() {}$/;"	f	struct:boost::xpressive::detail::matchable	access:public	signature:()
~node	xpressive/detail/utility/symbols.hpp	/^            ~node()$/;"	f	struct:boost::xpressive::detail::symbols::node	access:public	signature:()
~regex_error	xpressive/regex_error.hpp	/^    virtual ~regex_error() throw()$/;"	f	struct:boost::xpressive::regex_error	access:public	signature:()
~regex_impl	xpressive/detail/core/regex_impl.hpp	/^    ~regex_impl()$/;"	f	struct:boost::xpressive::detail::regex_impl	access:public	signature:()
~save_restore	xpressive/detail/utility/save_restore.hpp	/^        ~save_restore()$/;"	f	struct:boost::xpressive::detail::save_restore	access:public	signature:()
~sequence_stack	xpressive/detail/utility/sequence_stack.hpp	/^    ~sequence_stack()$/;"	f	struct:boost::xpressive::detail::sequence_stack	access:public	signature:()
~traits	xpressive/detail/core/regex_impl.hpp	/^    virtual ~traits() {}$/;"	f	struct:boost::xpressive::detail::traits	access:public	signature:()
