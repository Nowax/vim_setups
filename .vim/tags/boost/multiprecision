!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BINARY_OP_FUNCTOR	multiprecision/detail/default_ops.hpp	1621;"	d
BINARY_OP_FUNCTOR	multiprecision/detail/default_ops.hpp	2027;"	d
BOOST_MATH_BIG_NUM_BASE_HPP	multiprecision/detail/number_base.hpp	7;"	d
BOOST_MATH_BIG_NUM_DEF_OPS	multiprecision/detail/default_ops.hpp	7;"	d
BOOST_MATH_BN_MPFI_HPP	multiprecision/mpfi.hpp	7;"	d
BOOST_MATH_BN_MPFR_HPP	multiprecision/mpfr.hpp	7;"	d
BOOST_MATH_CONCEPTS_ER_HPP	multiprecision/concepts/mp_number_archetypes.hpp	7;"	d
BOOST_MATH_DEBUG_ADAPTER_HPP	multiprecision/debug_adaptor.hpp	7;"	d
BOOST_MATH_ER_GMP_BACKEND_HPP	multiprecision/gmp.hpp	7;"	d
BOOST_MATH_EXTENDED_REAL_HPP	multiprecision/number.hpp	7;"	d
BOOST_MATH_EXTRACT_EXPONENT_HPP	multiprecision/traits/extract_exponent_type.hpp	7;"	d
BOOST_MATH_LOGGED_ADAPTER_HPP	multiprecision/logged_adaptor.hpp	7;"	d
BOOST_MATH_MP_TOMMATH_BACKEND_HPP	multiprecision/tommath.hpp	7;"	d
BOOST_MATH_RATIONAL_ADAPTER_HPP	multiprecision/rational_adaptor.hpp	7;"	d
BOOST_MP_BIG_LANCZOS	multiprecision/detail/big_lanczos.hpp	8;"	d
BOOST_MP_COMPARE_HPP	multiprecision/detail/number_compare.hpp	7;"	d
BOOST_MP_CPP_DEC_FLOAT_BACKEND_HPP	multiprecision/cpp_dec_float.hpp	17;"	d
BOOST_MP_CPP_INT_ADD_HPP	multiprecision/cpp_int/add.hpp	9;"	d
BOOST_MP_CPP_INT_BIT_HPP	multiprecision/cpp_int/bitwise.hpp	9;"	d
BOOST_MP_CPP_INT_CHECKED_HPP	multiprecision/cpp_int/checked.hpp	7;"	d
BOOST_MP_CPP_INT_COMPARISON_HPP	multiprecision/cpp_int/comparison.hpp	9;"	d
BOOST_MP_CPP_INT_CORE_HPP	multiprecision/cpp_int/cpp_int_config.hpp	7;"	d
BOOST_MP_CPP_INT_DIV_HPP	multiprecision/cpp_int/divide.hpp	9;"	d
BOOST_MP_CPP_INT_HPP	multiprecision/cpp_int.hpp	7;"	d
BOOST_MP_CPP_INT_LIM_HPP	multiprecision/cpp_int/limits.hpp	9;"	d
BOOST_MP_CPP_INT_LITERALS_HPP	multiprecision/cpp_int/literals.hpp	7;"	d
BOOST_MP_CPP_INT_MISC_HPP	multiprecision/cpp_int/misc.hpp	9;"	d
BOOST_MP_CPP_INT_MUL_HPP	multiprecision/cpp_int/multiply.hpp	9;"	d
BOOST_MP_CPP_INT_SERIALIZE_HPP	multiprecision/cpp_int/serialize.hpp	7;"	d
BOOST_MP_CPP_INT_VP_HPP	multiprecision/cpp_int/value_pack.hpp	7;"	d
BOOST_MP_DEFINE_SIZED_CPP_INT_LITERAL	multiprecision/cpp_int/literals.hpp	160;"	d
BOOST_MP_DETAIL_BITSCAN_HPP	multiprecision/detail/bitscan.hpp	9;"	d
BOOST_MP_DETAIL_DYNAMIC_ARRAY_HPP	multiprecision/detail/dynamic_array.hpp	9;"	d
BOOST_MP_DETAIL_REBIND_HPP	multiprecision/detail/rebind.hpp	9;"	d
BOOST_MP_DIGITS_HPP	multiprecision/detail/digits.hpp	7;"	d
BOOST_MP_ENABLE_IF_WORKAROUND	multiprecision/mpfr.hpp	1309;"	d
BOOST_MP_ENABLE_IF_WORKAROUND	multiprecision/mpfr.hpp	1311;"	d
BOOST_MP_ENABLE_IF_WORKAROUND	multiprecision/mpfr.hpp	1328;"	d
BOOST_MP_ET_OPS_HPP	multiprecision/detail/et_ops.hpp	7;"	d
BOOST_MP_EXPLICIT_CONVERTIBLE_HPP	multiprecision/traits/explicit_conversion.hpp	8;"	d
BOOST_MP_FLOAT128_HPP	multiprecision/float128.hpp	7;"	d
BOOST_MP_FLOAT_STRING_CVT_HPP	multiprecision/detail/float_string_cvt.hpp	13;"	d
BOOST_MP_FORCEINLINE	multiprecision/detail/number_base.hpp	23;"	d
BOOST_MP_FORCEINLINE	multiprecision/detail/number_base.hpp	25;"	d
BOOST_MP_GENERIC_INTERCONVERT_HPP	multiprecision/detail/generic_interconvert.hpp	7;"	d
BOOST_MP_INTEGER_HPP	multiprecision/integer.hpp	7;"	d
BOOST_MP_INT_FUNC_HPP	multiprecision/detail/integer_ops.hpp	7;"	d
BOOST_MP_MIN_EXPONENT_DIGITS	multiprecision/detail/number_base.hpp	545;"	d
BOOST_MP_MIN_EXPONENT_DIGITS	multiprecision/detail/number_base.hpp	547;"	d
BOOST_MP_MOVE	multiprecision/detail/number_base.hpp	94;"	d
BOOST_MP_MOVE	multiprecision/detail/number_base.hpp	96;"	d
BOOST_MP_MR_HPP	multiprecision/miller_rabin.hpp	7;"	d
BOOST_MP_NO_DOUBLE_LIMB_TYPE_IO	multiprecision/cpp_int/cpp_int_config.hpp	84;"	d
BOOST_MP_NO_ET_OPS_HPP	multiprecision/detail/no_et_ops.hpp	7;"	d
BOOST_MP_RANDOM_HPP	multiprecision/random.hpp	9;"	d
BOOST_MP_RESTRICTED_CONVERSION_HPP	multiprecision/traits/is_restricted_conversion.hpp	8;"	d
BOOST_MP_TOMMATH_BIT_OP_CHECK	multiprecision/tommath.hpp	366;"	d
BOOST_MP_UBLAS_HPP	multiprecision/detail/ublas_interop.hpp	7;"	d
BOOST_MP_USER_DEFINED_LITERALS	multiprecision/cpp_int/cpp_int_config.hpp	159;"	d
BOOST_MP_USE_FLOAT128	multiprecision/float128.hpp	16;"	d
BOOST_MP_USE_FLOAT128	multiprecision/float128.hpp	26;"	d
BOOST_MP_USE_QUAD	multiprecision/float128.hpp	21;"	d
BOOST_MP_USING_ABS	multiprecision/detail/number_base.hpp	88;"	d
BOOST_MP_UTYPE_HELPER_HPP	multiprecision/detail/utype_helper.hpp	9;"	d
BOOST_NOEXCEPT	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
BOOST_NOEXCEPT	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::cpp_int_base	access:public
BOOST_NOEXCEPT	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_double_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
BOOST_NOEXCEPT	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_double_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::cpp_int_base	access:public
BOOST_NOEXCEPT	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
BOOST_NOEXCEPT	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::cpp_int_base	access:public
BOOST_NOEXCEPT	multiprecision/gmp.hpp	/^   gmp_float(gmp_float&& o) BOOST_NOEXCEPT : detail::gmp_float_imp<0>(static_cast<detail::gmp_float_imp<0>&&>(o)) {}$/;"	m	struct:boost::multiprecision::gmp_float	access:public
BOOST_NOEXCEPT	multiprecision/gmp.hpp	/^   gmp_float(gmp_float&& o) BOOST_NOEXCEPT : detail::gmp_float_imp<digits10>(static_cast<detail::gmp_float_imp<digits10>&&>(o)) {}$/;"	m	struct:boost::multiprecision::backends::gmp_float	access:public
BOOST_NOEXCEPT	multiprecision/mpfi.hpp	/^   mpfi_float_backend(mpfi_float_backend&& o) BOOST_NOEXCEPT : detail::mpfi_float_imp<0>(static_cast<detail::mpfi_float_imp<0>&&>(o)) {}$/;"	m	struct:boost::multiprecision::backends::mpfi_float_backend	access:public
BOOST_NOEXCEPT	multiprecision/mpfr.hpp	/^   mpfr_float_backend(mpfr_float_backend&& o) BOOST_NOEXCEPT : detail::mpfr_float_imp<0, allocate_dynamic>(static_cast<detail::mpfr_float_imp<0, allocate_dynamic>&&>(o)) {}$/;"	m	struct:boost::multiprecision::backends::mpfr_float_backend	access:public
BOOST_NOEXCEPT_IF	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE void do_assign_arithmetic(signed_limb_type i, const mpl::false_&) BOOST_NOEXCEPT_IF((Checked == unchecked))$/;"	f	namespace:boost::multiprecision	signature:(Checked == unchecked)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^      const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^      const limb_type& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^      const signed_limb_type& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^   eval_add(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const limb_type& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^   eval_decrement(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^   eval_increment(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^inline void add_unsigned(CppInt1& result, const CppInt2& a, const CppInt3& b) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^inline void add_unsigned(CppInt1& result, const CppInt2& a, const limb_type& o) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^inline void subtract_unsigned(CppInt1& result, const CppInt2& a, const CppInt3& b) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^inline void subtract_unsigned(CppInt1& result, const CppInt2& a, const limb_type& b) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/bitwise.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/bitwise.hpp	/^      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/bitwise.hpp	/^      double_limb_type s) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/bitwise.hpp	/^   Op op) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<CppInt1>::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/bitwise.hpp	/^   eval_left_shift(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, T s) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/bitwise.hpp	/^   eval_right_shift(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, T s) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/misc.hpp	/^      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& r) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/misc.hpp	/^   eval_abs(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/misc.hpp	/^   eval_convert_to(R* result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& backend) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/misc.hpp	/^   eval_convert_to(R* result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& backend) BOOST_NOEXCEPT_IF(is_arithmetic<R>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_arithmetic<R>::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& b) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const signed_double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const signed_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const signed_double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const signed_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/cpp_dec_float.hpp	/^   bool isfinite BOOST_PREVENT_MACRO_SUBSTITUTION(void) const  { return (fpclass == cpp_dec_float_finite); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/cpp_dec_float.hpp	/^   bool isinf    BOOST_PREVENT_MACRO_SUBSTITUTION(void) const  { return (fpclass == cpp_dec_float_inf); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/cpp_dec_float.hpp	/^   bool isnan    BOOST_PREVENT_MACRO_SUBSTITUTION(void) const  { return (fpclass == cpp_dec_float_NaN); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isfinite BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isfinite BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isinf BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isinf BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isnan BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isnan BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isnormal BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isnormal BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline int fpclassify BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline int fpclassify BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/random.hpp	/^    result_type max BOOST_PREVENT_MACRO_SUBSTITUTION () const { return _max; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/random.hpp	/^    result_type min BOOST_PREVENT_MACRO_SUBSTITUTION () const { return _min; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/random.hpp	/^    static result_type max BOOST_PREVENT_MACRO_SUBSTITUTION ()$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/random.hpp	/^    static result_type min BOOST_PREVENT_MACRO_SUBSTITUTION ()$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
BOOST_RANDOM_DETAIL_ARITHMETIC_CONSTRUCTOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ARITHMETIC_CONSTRUCTOR(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, result_type, seed_arg)
BOOST_RANDOM_DETAIL_ARITHMETIC_SEED	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ARITHMETIC_SEED(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, result_type, seed_arg)
BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR	multiprecision/random.hpp	/^        BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(param_type, lhs, rhs)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(param_type, lhs, rhs)
BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(independent_bits_engine, x, y)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, x, y)
BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(uniform_smallint, lhs, rhs)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(uniform_smallint, lhs, rhs)
BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR	multiprecision/random.hpp	/^        BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, param_type, parm)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(is, param_type, parm)
BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, independent_bits_engine, r)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(is, independent_bits_engine, r)
BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, uniform_smallint, ud)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(is, uniform_smallint, ud)
BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR	multiprecision/random.hpp	/^        BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, param_type, parm)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(os, param_type, parm)
BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, independent_bits_engine, r)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(os, independent_bits_engine, r)
BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, uniform_smallint, ud)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(os, uniform_smallint, ud)
BOOST_RANDOM_DETAIL_SEED_SEQ_CONSTRUCTOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_SEED_SEQ_CONSTRUCTOR(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, SeedSeq, seq)
BOOST_RANDOM_DETAIL_SEED_SEQ_SEED	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_SEED_SEQ_SEED(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, SeedSeq, seq)
BOOST_STATIC_ASSERT	multiprecision/cpp_dec_float.hpp	/^   BOOST_STATIC_ASSERT((cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10 == -cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10));$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10 == -cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10)
BOOST_STATIC_ASSERT	multiprecision/detail/number_base.hpp	/^   BOOST_STATIC_ASSERT((std::numeric_limits<T>::radix == 2) || (std::numeric_limits<T>::radix == 10));$/;"	p	struct:boost::multiprecision::detail::digits2	access:public	signature:(std::numeric_limits<T>::radix == 2) || (std::numeric_limits<T>::radix == 10)
BOOST_STATIC_ASSERT	multiprecision/detail/number_base.hpp	/^   BOOST_STATIC_ASSERT(std::numeric_limits<T>::is_specialized);$/;"	p	struct:boost::multiprecision::detail::digits2	access:public	signature:(std::numeric_limits<T>::is_specialized)
BOOST_STATIC_ASSERT_MSG	multiprecision/cpp_dec_float.hpp	/^   BOOST_STATIC_ASSERT_MSG(boost::is_signed<ExponentType>::value, "ExponentType must be a signed built in integer type.");$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::is_signed<ExponentType>::value, Ó)
BOOST_STATIC_ASSERT_MSG	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_ASSERT_MSG(((sizeof(Allocator) == 0) && !is_void<Allocator>::value), "There is curently no support for unsigned arbitrary precision integers.");$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:((sizeof(Allocator) == 0) && !is_void<Allocator>::value), Ó
BOOST_STATIC_ASSERT_MSG	multiprecision/cpp_int/literals.hpp	/^   BOOST_STATIC_ASSERT_MSG((l2 == 'X') || (l2 == 'x'), "Multi-precision integer literals must be in hexadecimal notation.");$/;"	p	struct:boost::multiprecision::literals::detail::make_packed_value_from_str	access:public	signature:(l2 == Ã) || (l2 == Ã), Ó
BOOST_STATIC_ASSERT_MSG	multiprecision/cpp_int/literals.hpp	/^   BOOST_STATIC_ASSERT_MSG(l1 == '0', "Multi-precision integer literals must be in hexadecimal notation.");$/;"	p	struct:boost::multiprecision::literals::detail::make_packed_value_from_str	access:public	signature:(l1 == Ã, Ó)
BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(bool, variable = false);$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(bool, variable = false)
BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(bool, variable = true);$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(bool, variable = true)
BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, max_limb_value = ~static_cast<limb_type>(0u));$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(limb_type, max_limb_value = ~static_cast<limb_type>(0u))
BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, max_limb_value = ~static_cast<limb_type>(0u));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(limb_type, max_limb_value = ~static_cast<limb_type>(0u))
BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, sign_bit_mask = 1u << (limb_bits - 1));$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(limb_type, sign_bit_mask = 1u << (limb_bits - 1))
BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, sign_bit_mask = 1u << (limb_bits - 1));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(limb_type, sign_bit_mask = 1u << (limb_bits - 1))
BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, upper_limb_mask = MinBits % limb_bits ? (limb_type(1) << (MinBits % limb_bits)) -1 : (~limb_type(0)));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(limb_type, upper_limb_mask = MinBits % limb_bits ? (limb_type(1) << (MinBits % limb_bits)) -1 : (~limb_type(0)))
BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, internal_limb_count = MinBits \/ limb_bits + (MinBits % limb_bits ? 1 : 0));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(unsigned, internal_limb_count = MinBits / limb_bits + (MinBits % limb_bits ? 1 : 0))
BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, internal_limb_count =$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(unsigned, internal_limb_count = MinBits ? MinBits / limb_bits + (MinBits % limb_bits ? 1 : 0) : sizeof(limb_data) / sizeof(limb_type))
BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT);$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT)
BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT);$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT)
HETERO_BINARY_OP_FUNCTOR	multiprecision/detail/default_ops.hpp	1919;"	d
HETERO_BINARY_OP_FUNCTOR_B	multiprecision/detail/default_ops.hpp	1863;"	d
INSTRUMENT_BACKEND	multiprecision/detail/default_ops.hpp	20;"	d
INSTRUMENT_BACKEND	multiprecision/detail/default_ops.hpp	22;"	d
NON_MEMBER_OP1	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP1(decrement, "decrement");$/;"	p	namespace:boost::multiprecision::backends	signature:(decrement, Ó)
NON_MEMBER_OP1	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP1(increment, "increment");$/;"	p	namespace:boost::multiprecision::backends	signature:(increment, Ó)
NON_MEMBER_OP1	multiprecision/debug_adaptor.hpp	132;"	d
NON_MEMBER_OP1	multiprecision/debug_adaptor.hpp	459;"	d
NON_MEMBER_OP1	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP1(decrement, "decrement");$/;"	p	namespace:boost::multiprecision::backends	signature:(decrement, Ó)
NON_MEMBER_OP1	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP1(increment, "increment");$/;"	p	namespace:boost::multiprecision::backends	signature:(increment, Ó)
NON_MEMBER_OP1	multiprecision/logged_adaptor.hpp	149;"	d
NON_MEMBER_OP1	multiprecision/logged_adaptor.hpp	519;"	d
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(abs, "abs");$/;"	p	namespace:boost::multiprecision::backends	signature:(abs, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(acos, "acos");$/;"	p	namespace:boost::multiprecision::backends	signature:(acos, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(add, "+=");$/;"	p	namespace:boost::multiprecision::backends	signature:(add, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(asin, "asin");$/;"	p	namespace:boost::multiprecision::backends	signature:(asin, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(atan, "atan");$/;"	p	namespace:boost::multiprecision::backends	signature:(atan, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(bitwise_and, "&=");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_and, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(bitwise_or, "|=");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_or, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(bitwise_xor, "^=");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_xor, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(ceil, "ceil");$/;"	p	namespace:boost::multiprecision::backends	signature:(ceil, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(complement, "~");$/;"	p	namespace:boost::multiprecision::backends	signature:(complement, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(cos, "cos");$/;"	p	namespace:boost::multiprecision::backends	signature:(cos, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(cosh, "cosh");$/;"	p	namespace:boost::multiprecision::backends	signature:(cosh, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(divide, "\/=");$/;"	p	namespace:boost::multiprecision::backends	signature:(divide, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(exp, "exp");$/;"	p	namespace:boost::multiprecision::backends	signature:(exp, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(fabs, "fabs");$/;"	p	namespace:boost::multiprecision::backends	signature:(fabs, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(floor, "floor");$/;"	p	namespace:boost::multiprecision::backends	signature:(floor, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(log, "log");$/;"	p	namespace:boost::multiprecision::backends	signature:(log, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(log10, "log10");$/;"	p	namespace:boost::multiprecision::backends	signature:(log10, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(modulus, "%=");$/;"	p	namespace:boost::multiprecision::backends	signature:(modulus, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(multiply, "*=");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(round, "round");$/;"	p	namespace:boost::multiprecision::backends	signature:(round, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(sin, "sin");$/;"	p	namespace:boost::multiprecision::backends	signature:(sin, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(sinh, "sinh");$/;"	p	namespace:boost::multiprecision::backends	signature:(sinh, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(sqrt, "sqrt");$/;"	p	namespace:boost::multiprecision::backends	signature:(sqrt, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(subtract, "-=");$/;"	p	namespace:boost::multiprecision::backends	signature:(subtract, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(tan, "tan");$/;"	p	namespace:boost::multiprecision::backends	signature:(tan, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(tanh, "tanh");$/;"	p	namespace:boost::multiprecision::backends	signature:(tanh, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(trunc, "trunc");$/;"	p	namespace:boost::multiprecision::backends	signature:(trunc, Ó)
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	141;"	d
NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	460;"	d
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(abs, "abs");$/;"	p	namespace:boost::multiprecision::backends	signature:(abs, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(acos, "acos");$/;"	p	namespace:boost::multiprecision::backends	signature:(acos, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(add, "+=");$/;"	p	namespace:boost::multiprecision::backends	signature:(add, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(asin, "asin");$/;"	p	namespace:boost::multiprecision::backends	signature:(asin, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(atan, "atan");$/;"	p	namespace:boost::multiprecision::backends	signature:(atan, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(bitwise_and, "&=");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_and, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(bitwise_or, "|=");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_or, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(bitwise_xor, "^=");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_xor, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(ceil, "ceil");$/;"	p	namespace:boost::multiprecision::backends	signature:(ceil, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(complement, "~");$/;"	p	namespace:boost::multiprecision::backends	signature:(complement, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(cos, "cos");$/;"	p	namespace:boost::multiprecision::backends	signature:(cos, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(cosh, "cosh");$/;"	p	namespace:boost::multiprecision::backends	signature:(cosh, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(divide, "\/=");$/;"	p	namespace:boost::multiprecision::backends	signature:(divide, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(exp, "exp");$/;"	p	namespace:boost::multiprecision::backends	signature:(exp, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(fabs, "fabs");$/;"	p	namespace:boost::multiprecision::backends	signature:(fabs, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(floor, "floor");$/;"	p	namespace:boost::multiprecision::backends	signature:(floor, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(log, "log");$/;"	p	namespace:boost::multiprecision::backends	signature:(log, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(log10, "log10");$/;"	p	namespace:boost::multiprecision::backends	signature:(log10, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(modulus, "%=");$/;"	p	namespace:boost::multiprecision::backends	signature:(modulus, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(multiply, "*=");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(round, "round");$/;"	p	namespace:boost::multiprecision::backends	signature:(round, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(sin, "sin");$/;"	p	namespace:boost::multiprecision::backends	signature:(sin, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(sinh, "sinh");$/;"	p	namespace:boost::multiprecision::backends	signature:(sinh, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(sqrt, "sqrt");$/;"	p	namespace:boost::multiprecision::backends	signature:(sqrt, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(subtract, "-=");$/;"	p	namespace:boost::multiprecision::backends	signature:(subtract, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(tan, "tan");$/;"	p	namespace:boost::multiprecision::backends	signature:(tan, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(tanh, "tanh");$/;"	p	namespace:boost::multiprecision::backends	signature:(tanh, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(trunc, "trunc");$/;"	p	namespace:boost::multiprecision::backends	signature:(trunc, Ó)
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	159;"	d
NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	520;"	d
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(add, "+");$/;"	p	namespace:boost::multiprecision::backends	signature:(add, Ó)
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(atan2, "atan2");$/;"	p	namespace:boost::multiprecision::backends	signature:(atan2, Ó)
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(bitwise_and, "&");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_and, Ó)
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(bitwise_or, "|");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_or, Ó)
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(bitwise_xor, "^");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_xor, Ó)
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(divide, "\/");$/;"	p	namespace:boost::multiprecision::backends	signature:(divide, Ó)
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(fmod, "fmod");$/;"	p	namespace:boost::multiprecision::backends	signature:(fmod, Ó)
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(gcd, "gcd");$/;"	p	namespace:boost::multiprecision::backends	signature:(gcd, Ó)
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(lcm, "lcm");$/;"	p	namespace:boost::multiprecision::backends	signature:(lcm, Ó)
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(modulus, "%");$/;"	p	namespace:boost::multiprecision::backends	signature:(modulus, Ó)
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(multiply, "*");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply, Ó)
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(multiply_add, "fused-multiply-add");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_add, Ó)
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(multiply_subtract, "fused-multiply-subtract");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_subtract, Ó)
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(pow, "pow");$/;"	p	namespace:boost::multiprecision::backends	signature:(pow, Ó)
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(subtract, "-");$/;"	p	namespace:boost::multiprecision::backends	signature:(subtract, Ó)
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	157;"	d
NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	461;"	d
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(add, "+");$/;"	p	namespace:boost::multiprecision::backends	signature:(add, Ó)
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(atan2, "atan2");$/;"	p	namespace:boost::multiprecision::backends	signature:(atan2, Ó)
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(bitwise_and, "&");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_and, Ó)
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(bitwise_or, "|");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_or, Ó)
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(bitwise_xor, "^");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_xor, Ó)
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(divide, "\/");$/;"	p	namespace:boost::multiprecision::backends	signature:(divide, Ó)
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(fmod, "fmod");$/;"	p	namespace:boost::multiprecision::backends	signature:(fmod, Ó)
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(gcd, "gcd");$/;"	p	namespace:boost::multiprecision::backends	signature:(gcd, Ó)
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(lcm, "lcm");$/;"	p	namespace:boost::multiprecision::backends	signature:(lcm, Ó)
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(modulus, "%");$/;"	p	namespace:boost::multiprecision::backends	signature:(modulus, Ó)
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(multiply, "*");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply, Ó)
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(multiply_add, "fused-multiply-add");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_add, Ó)
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(multiply_subtract, "fused-multiply-subtract");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_subtract, Ó)
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(pow, "pow");$/;"	p	namespace:boost::multiprecision::backends	signature:(pow, Ó)
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(subtract, "-");$/;"	p	namespace:boost::multiprecision::backends	signature:(subtract, Ó)
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	177;"	d
NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	521;"	d
NON_MEMBER_OP4	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP4(multiply_add, "fused-multiply-add");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_add, Ó)
NON_MEMBER_OP4	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP4(multiply_subtract, "fused-multiply-subtract");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_subtract, Ó)
NON_MEMBER_OP4	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP4(powm, "powm");$/;"	p	namespace:boost::multiprecision::backends	signature:(powm, Ó)
NON_MEMBER_OP4	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP4(qr, "quotient-and-remainder");$/;"	p	namespace:boost::multiprecision::backends	signature:(qr, Ó)
NON_MEMBER_OP4	multiprecision/debug_adaptor.hpp	187;"	d
NON_MEMBER_OP4	multiprecision/debug_adaptor.hpp	462;"	d
NON_MEMBER_OP4	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP4(multiply_add, "fused-multiply-add");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_add, Ó)
NON_MEMBER_OP4	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP4(multiply_subtract, "fused-multiply-subtract");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_subtract, Ó)
NON_MEMBER_OP4	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP4(powm, "powm");$/;"	p	namespace:boost::multiprecision::backends	signature:(powm, Ó)
NON_MEMBER_OP4	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP4(qr, "quotient-and-remainder");$/;"	p	namespace:boost::multiprecision::backends	signature:(qr, Ó)
NON_MEMBER_OP4	multiprecision/logged_adaptor.hpp	211;"	d
NON_MEMBER_OP4	multiprecision/logged_adaptor.hpp	522;"	d
UNARY_OP_FUNCTOR	multiprecision/detail/default_ops.hpp	1559;"	d
UNARY_OP_FUNCTOR	multiprecision/detail/default_ops.hpp	2028;"	d
__acosq	multiprecision/float128.hpp	/^_Quad __acosq(_Quad);$/;"	p	signature:(_Quad)
__asinq	multiprecision/float128.hpp	/^_Quad __asinq(_Quad);$/;"	p	signature:(_Quad)
__atan2q	multiprecision/float128.hpp	/^_Quad __atan2q(_Quad, _Quad);$/;"	p	signature:(_Quad, _Quad)
__atanq	multiprecision/float128.hpp	/^_Quad __atanq(_Quad);$/;"	p	signature:(_Quad)
__ceilq	multiprecision/float128.hpp	/^_Quad __ceilq(_Quad);$/;"	p	signature:(_Quad)
__coshq	multiprecision/float128.hpp	/^_Quad __coshq(_Quad);$/;"	p	signature:(_Quad)
__cosq	multiprecision/float128.hpp	/^_Quad __cosq(_Quad);$/;"	p	signature:(_Quad)
__expq	multiprecision/float128.hpp	/^_Quad __expq(_Quad);$/;"	p	signature:(_Quad)
__fabsq	multiprecision/float128.hpp	/^_Quad __fabsq(_Quad);$/;"	p	signature:(_Quad)
__floorq	multiprecision/float128.hpp	/^_Quad __floorq(_Quad);$/;"	p	signature:(_Quad)
__fmodq	multiprecision/float128.hpp	/^_Quad __fmodq(_Quad, _Quad);$/;"	p	signature:(_Quad, _Quad)
__frexpq	multiprecision/float128.hpp	/^_Quad __frexpq(_Quad, int*);$/;"	p	signature:(_Quad, int*)
__ldexpq	multiprecision/float128.hpp	/^_Quad __ldexpq(_Quad, int);$/;"	p	signature:(_Quad, int)
__log10q	multiprecision/float128.hpp	/^_Quad __log10q(_Quad);$/;"	p	signature:(_Quad)
__logq	multiprecision/float128.hpp	/^_Quad __logq(_Quad);$/;"	p	signature:(_Quad)
__powq	multiprecision/float128.hpp	/^_Quad __powq(_Quad, _Quad);$/;"	p	signature:(_Quad, _Quad)
__sinhq	multiprecision/float128.hpp	/^_Quad __sinhq(_Quad);$/;"	p	signature:(_Quad)
__sinq	multiprecision/float128.hpp	/^_Quad __sinq(_Quad);$/;"	p	signature:(_Quad)
__sqrtq	multiprecision/float128.hpp	/^_Quad __sqrtq(_Quad);$/;"	p	signature:(_Quad)
__tanhq	multiprecision/float128.hpp	/^_Quad __tanhq(_Quad);$/;"	p	signature:(_Quad)
__tanq	multiprecision/float128.hpp	/^_Quad __tanq(_Quad);$/;"	p	signature:(_Quad)
__truncq	multiprecision/float128.hpp	/^_Quad __truncq(_Quad);$/;"	p	signature:(_Quad)
_base	multiprecision/random.hpp	/^    Engine _base;$/;"	m	class:boost::random::independent_bits_engine	access:private
_cppi	multiprecision/cpp_int/literals.hpp	/^constexpr typename boost::multiprecision::literals::detail::signed_cpp_int_literal_result_type<(sizeof...(STR)) - 2>::number_type operator "" _cppi()$/;"	f	namespace:boost::multiprecision::literals	signature:()
_cppui	multiprecision/cpp_int/literals.hpp	/^constexpr typename boost::multiprecision::literals::detail::unsigned_cpp_int_literal_result_type<(sizeof...(STR)) - 2>::number_type operator "" _cppui()$/;"	f	namespace:boost::multiprecision::literals	signature:()
_max	multiprecision/random.hpp	/^        result_type _max;$/;"	m	class:boost::random::uniform_smallint::param_type	access:private
_max	multiprecision/random.hpp	/^    result_type _max;$/;"	m	class:boost::random::uniform_smallint	access:private
_min	multiprecision/random.hpp	/^        result_type _min;$/;"	m	class:boost::random::uniform_smallint::param_type	access:private
_min	multiprecision/random.hpp	/^    result_type _min;$/;"	m	class:boost::random::uniform_smallint	access:private
a	multiprecision/random.hpp	/^        result_type a() const { return _min; }$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:() const
a	multiprecision/random.hpp	/^    result_type a() const { return _min; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
abs	multiprecision/detail/default_ops.hpp	/^abs(const detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& arg)
abs	multiprecision/detail/default_ops.hpp	/^abs(const number<Backend, et_off>& arg)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, et_off>& arg)
abs	multiprecision/detail/default_ops.hpp	/^abs(const number<Backend, et_on>& arg)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, et_on>& arg)
abs_funct	multiprecision/detail/default_ops.hpp	/^struct abs_funct$/;"	s	namespace:boost::multiprecision::detail
acosq	multiprecision/float128.hpp	89;"	d
add	multiprecision/detail/default_ops.hpp	/^   add(number<B, ET>& result, const I& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, ET>& result, const I& a, const I& b)
add	multiprecision/detail/default_ops.hpp	/^inline number<B1, ET1>& add(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)
add	multiprecision/integer.hpp	/^   add(Integer& result, const I2& a, const I2& b)$/;"	f	namespace:boost::multiprecision	signature:(Integer& result, const I2& a, const I2& b)
add_immediates	multiprecision/detail/number_base.hpp	/^struct add_immediates{};$/;"	s	namespace:boost::multiprecision::detail
add_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& add_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
allocate_dynamic	multiprecision/mpfr.hpp	/^   allocate_dynamic$/;"	e	enum:boost::multiprecision::mpfr_allocation_type
allocate_stack	multiprecision/mpfr.hpp	/^   allocate_stack,$/;"	e	enum:boost::multiprecision::mpfr_allocation_type
allocator_type	multiprecision/cpp_int.hpp	/^   typedef typename Allocator::template rebind<limb_type>::other allocator_type;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
append_value_to_pack	multiprecision/cpp_int/literals.hpp	/^struct append_value_to_pack<v, value_pack<PACK...> >$/;"	s	namespace:boost::multiprecision::literals::detail
apply	multiprecision/random.hpp	/^  struct apply$/;"	s	struct:boost::random::detail::select_uniform_01	access:public
archive	multiprecision/cpp_int/serialize.hpp	/^namespace archive{$/;"	n	namespace:boost
archive	multiprecision/float128.hpp	/^namespace archive{$/;"	n	namespace:boost
arg	multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg1>::type arg;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
arg1	multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg1>::type arg1;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
arg2	multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg2>::type arg2;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
arg3	multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg3>::type arg3;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
arg4	multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg4>::type arg4;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
arg_type	multiprecision/detail/number_base.hpp	/^struct arg_type$/;"	s	namespace:boost::multiprecision::detail
arg_type	multiprecision/detail/number_base.hpp	/^struct arg_type<expression<Tag, Arg1, Arg2, Arg3, Arg4> >$/;"	s	namespace:boost::multiprecision::detail
arity	multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<0> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
arity	multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<1> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
arity	multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<2> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
arity	multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<3> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
arity	multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<4> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
array_type	multiprecision/cpp_dec_float.hpp	/^      >::type array_type;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:private
asinq	multiprecision/float128.hpp	88;"	d
assign	multiprecision/cpp_int.hpp	/^   void assign(const cpp_int_base& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_base& o)
assign	multiprecision/number.hpp	/^   number& assign(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
assign_components	multiprecision/detail/default_ops.hpp	/^inline void assign_components(T& result, const V& v1, const V& v2)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const V& v1, const V& v2)
assign_components	multiprecision/mpfi.hpp	/^   assign_components(mpfi_float_backend<Digits10>& result, const V& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const V& a, const V& b)
assign_components	multiprecision/mpfi.hpp	/^inline void assign_components(mpfi_float_backend<D1>& result, const mpfr_float_backend<D2, AllocationType>& a, const mpfr_float_backend<D2, AllocationType>& b)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& result, const mpfr_float_backend<D2, AllocationType>& a, const mpfr_float_backend<D2, AllocationType>& b)
assign_components	multiprecision/rational_adaptor.hpp	/^inline void assign_components(rational_adaptor<IntBackend>& result, const V& v1, const V& v2)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adaptor<IntBackend>& result, const V& v1, const V& v2)
assign_components_imp	multiprecision/detail/default_ops.hpp	/^inline void assign_components_imp(T& result, const V& v1, const V& v2, const mpl::int_<number_kind_rational>&)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const V& v1, const V& v2, const mpl::int_<number_kind_rational>&)
atan2q	multiprecision/float128.hpp	95;"	d
atanq	multiprecision/float128.hpp	90;"	d
b	multiprecision/random.hpp	/^        result_type b() const { return _max; }$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:() const
b	multiprecision/random.hpp	/^    result_type b() const { return _max; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
backend_type	multiprecision/cpp_int/limits.hpp	/^   typedef boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> backend_type;$/;"	t	class:std::numeric_limits	access:private
backend_type	multiprecision/cpp_int/literals.hpp	/^   typedef boost::multiprecision::backends::cpp_int_backend<bits, bits, signed_magnitude, unchecked, void> backend_type;$/;"	t	struct:boost::multiprecision::literals::detail::signed_cpp_int_literal_result_type	access:public
backend_type	multiprecision/cpp_int/literals.hpp	/^   typedef boost::multiprecision::backends::cpp_int_backend<bits, bits, unsigned_magnitude, unchecked, void> backend_type;$/;"	t	struct:boost::multiprecision::literals::detail::unsigned_cpp_int_literal_result_type	access:public
backend_type	multiprecision/detail/number_base.hpp	/^struct backend_type<expression<tag, A1, A2, A3, A4> >$/;"	s	namespace:boost::multiprecision::detail
backend_type	multiprecision/detail/number_base.hpp	/^struct backend_type<number<T, ExpressionTemplates> >$/;"	s	namespace:boost::multiprecision::detail
backend_type	multiprecision/number.hpp	/^   typedef Backend backend_type;$/;"	t	class:boost::multiprecision::number	access:public
backends	multiprecision/cpp_dec_float.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/cpp_int.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/cpp_int/add.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/cpp_int/bitwise.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/cpp_int/checked.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{ namespace detail{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/cpp_int/comparison.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/cpp_int/divide.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/cpp_int/misc.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/cpp_int/multiply.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/debug_adaptor.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/detail/dynamic_array.hpp	/^  namespace boost { namespace multiprecision { namespace backends { namespace detail$/;"	n	namespace:boost::multiprecision
backends	multiprecision/detail/rebind.hpp	/^  namespace boost { namespace multiprecision { namespace backends { namespace detail$/;"	n	namespace:boost::multiprecision
backends	multiprecision/float128.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/gmp.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/logged_adaptor.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/mpfi.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/mpfr.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/rational_adaptor.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/tommath.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
backends	multiprecision/traits/extract_exponent_type.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
base	multiprecision/random.hpp	/^    const base_type& base() const { return _base; }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:() const
base_result	multiprecision/random.hpp	/^    typedef typename base_type::result_type base_result;$/;"	t	class:boost::random::independent_bits_engine	access:private
base_type	multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef std::numeric_limits<long double> base_type;$/;"	t	class:std::numeric_limits	access:private
base_type	multiprecision/debug_adaptor.hpp	/^   typedef std::numeric_limits<boost::multiprecision::number<Backend, ExpressionTemplates> > base_type;$/;"	t	class:std::numeric_limits	access:private
base_type	multiprecision/logged_adaptor.hpp	/^   typedef std::numeric_limits<boost::multiprecision::number<Backend, ExpressionTemplates> > base_type;$/;"	t	class:std::numeric_limits	access:private
base_type	multiprecision/random.hpp	/^    typedef Engine base_type;$/;"	t	class:boost::random::independent_bits_engine	access:public
base_type	multiprecision/rational_adaptor.hpp	/^   typedef std::numeric_limits<boost::multiprecision::number<IntBackend> > base_type;$/;"	t	class:std::numeric_limits	access:private
base_unsigned	multiprecision/random.hpp	/^    typedef typename make_unsigned<base_result>::type base_unsigned;$/;"	t	class:boost::random::independent_bits_engine	access:private
bit_and	multiprecision/cpp_int/bitwise.hpp	/^struct bit_and{ limb_type operator()(limb_type a, limb_type b)const BOOST_NOEXCEPT { return a & b; } };$/;"	s	namespace:boost::multiprecision::backends
bit_flip	multiprecision/detail/integer_ops.hpp	/^   bit_flip(number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& x, unsigned index)
bit_flip	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer&>::type bit_flip(Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(Integer& val, unsigned index)
bit_or	multiprecision/cpp_int/bitwise.hpp	/^struct bit_or { limb_type operator()(limb_type a, limb_type b)const BOOST_NOEXCEPT { return a | b; } };$/;"	s	namespace:boost::multiprecision::backends
bit_set	multiprecision/detail/integer_ops.hpp	/^   bit_set(number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& x, unsigned index)
bit_set	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer&>::type bit_set(Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(Integer& val, unsigned index)
bit_test	multiprecision/detail/integer_ops.hpp	/^   bit_test(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, unsigned index)
bit_test	multiprecision/detail/integer_ops.hpp	/^   bit_test(const number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, unsigned index)
bit_test	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, bool>::type bit_test(const Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& val, unsigned index)
bit_unset	multiprecision/detail/integer_ops.hpp	/^   bit_unset(number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& x, unsigned index)
bit_unset	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer&>::type bit_unset(Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(Integer& val, unsigned index)
bit_xor	multiprecision/cpp_int/bitwise.hpp	/^struct bit_xor{ limb_type operator()(limb_type a, limb_type b)const BOOST_NOEXCEPT { return a ^ b; } };$/;"	s	namespace:boost::multiprecision::backends
bits	multiprecision/cpp_int/literals.hpp	/^   static constexpr unsigned bits = Digits * 4;$/;"	m	struct:boost::multiprecision::literals::detail::signed_cpp_int_literal_result_type	access:public
bits	multiprecision/cpp_int/literals.hpp	/^   static constexpr unsigned bits = Digits * 4;$/;"	m	struct:boost::multiprecision::literals::detail::unsigned_cpp_int_literal_result_type	access:public
bits_of	multiprecision/detail/number_base.hpp	/^struct bits_of$/;"	s	namespace:boost::multiprecision::detail
bits_per_limb	multiprecision/cpp_int/cpp_int_config.hpp	/^static const unsigned bits_per_limb = sizeof(limb_type) * CHAR_BIT;$/;"	m	namespace:boost::multiprecision
bitwise_and	multiprecision/detail/number_base.hpp	/^struct bitwise_and{};$/;"	s	namespace:boost::multiprecision::detail
bitwise_and_immediates	multiprecision/detail/number_base.hpp	/^struct bitwise_and_immediates{};$/;"	s	namespace:boost::multiprecision::detail
bitwise_complement	multiprecision/detail/number_base.hpp	/^struct bitwise_complement{};$/;"	s	namespace:boost::multiprecision::detail
bitwise_or	multiprecision/detail/number_base.hpp	/^struct bitwise_or{};$/;"	s	namespace:boost::multiprecision::detail
bitwise_or_immediates	multiprecision/detail/number_base.hpp	/^struct bitwise_or_immediates{};$/;"	s	namespace:boost::multiprecision::detail
bitwise_xor	multiprecision/detail/number_base.hpp	/^struct bitwise_xor{};$/;"	s	namespace:boost::multiprecision::detail
bitwise_xor_immediates	multiprecision/detail/number_base.hpp	/^struct bitwise_xor_immediates{};$/;"	s	namespace:boost::multiprecision::detail
block_multiplier	multiprecision/cpp_int/cpp_int_config.hpp	/^inline limb_type block_multiplier(unsigned count)$/;"	f	namespace:boost::multiprecision	signature:(unsigned count)
boost	multiprecision/concepts/mp_number_archetypes.hpp	/^namespace boost{$/;"	n
boost	multiprecision/cpp_dec_float.hpp	/^namespace boost{ namespace math{$/;"	n
boost	multiprecision/cpp_dec_float.hpp	/^namespace boost{$/;"	n
boost	multiprecision/cpp_int.hpp	/^namespace boost{$/;"	n
boost	multiprecision/cpp_int/add.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n
boost	multiprecision/cpp_int/bitwise.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n
boost	multiprecision/cpp_int/checked.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{ namespace detail{$/;"	n
boost	multiprecision/cpp_int/comparison.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n
boost	multiprecision/cpp_int/cpp_int_config.hpp	/^namespace boost{ namespace multiprecision{$/;"	n
boost	multiprecision/cpp_int/divide.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n
boost	multiprecision/cpp_int/literals.hpp	/^namespace boost{ namespace multiprecision{$/;"	n
boost	multiprecision/cpp_int/misc.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n
boost	multiprecision/cpp_int/multiply.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n
boost	multiprecision/cpp_int/serialize.hpp	/^namespace boost {$/;"	n
boost	multiprecision/cpp_int/value_pack.hpp	/^namespace boost{ namespace multiprecision{$/;"	n
boost	multiprecision/debug_adaptor.hpp	/^namespace boost{ namespace math{$/;"	n
boost	multiprecision/debug_adaptor.hpp	/^namespace boost{$/;"	n
boost	multiprecision/detail/big_lanczos.hpp	/^namespace boost{ namespace math{$/;"	n
boost	multiprecision/detail/bitscan.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n
boost	multiprecision/detail/default_ops.hpp	/^namespace boost{ namespace multiprecision{ namespace default_ops{$/;"	n
boost	multiprecision/detail/digits.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n
boost	multiprecision/detail/dynamic_array.hpp	/^  namespace boost { namespace multiprecision { namespace backends { namespace detail$/;"	n
boost	multiprecision/detail/et_ops.hpp	/^namespace boost{ namespace multiprecision{$/;"	n
boost	multiprecision/detail/float_string_cvt.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n
boost	multiprecision/detail/generic_interconvert.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n
boost	multiprecision/detail/integer_ops.hpp	/^namespace boost{ namespace multiprecision{$/;"	n
boost	multiprecision/detail/no_et_ops.hpp	/^namespace boost{$/;"	n
boost	multiprecision/detail/number_base.hpp	/^namespace boost{ namespace math{ namespace tools{$/;"	n
boost	multiprecision/detail/number_base.hpp	/^namespace boost{ namespace multiprecision{$/;"	n
boost	multiprecision/detail/number_compare.hpp	/^namespace boost{ namespace multiprecision{$/;"	n
boost	multiprecision/detail/rebind.hpp	/^  namespace boost { namespace multiprecision { namespace backends { namespace detail$/;"	n
boost	multiprecision/detail/ublas_interop.hpp	/^namespace boost { namespace numeric { namespace ublas {$/;"	n
boost	multiprecision/detail/utype_helper.hpp	/^  namespace boost { namespace multiprecision {$/;"	n
boost	multiprecision/float128.hpp	/^namespace boost{ $/;"	n
boost	multiprecision/float128.hpp	/^namespace boost{$/;"	n
boost	multiprecision/gmp.hpp	/^namespace boost{$/;"	n
boost	multiprecision/integer.hpp	/^namespace boost{$/;"	n
boost	multiprecision/logged_adaptor.hpp	/^namespace boost{ namespace math{$/;"	n
boost	multiprecision/logged_adaptor.hpp	/^namespace boost{$/;"	n
boost	multiprecision/miller_rabin.hpp	/^namespace boost{$/;"	n
boost	multiprecision/mpfi.hpp	/^namespace boost{$/;"	n
boost	multiprecision/mpfr.hpp	/^namespace boost{$/;"	n
boost	multiprecision/number.hpp	/^namespace boost{ namespace multiprecision{$/;"	n
boost	multiprecision/random.hpp	/^namespace boost{ namespace random{ namespace detail{$/;"	n
boost	multiprecision/random.hpp	/^namespace boost{$/;"	n
boost	multiprecision/rational_adaptor.hpp	/^namespace boost{$/;"	n
boost	multiprecision/tommath.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n
boost	multiprecision/traits/explicit_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n
boost	multiprecision/traits/extract_exponent_type.hpp	/^namespace boost{$/;"	n
boost	multiprecision/traits/is_restricted_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n
boost::archive	multiprecision/cpp_int/serialize.hpp	/^namespace archive{$/;"	n	namespace:boost
boost::archive	multiprecision/float128.hpp	/^namespace archive{$/;"	n	namespace:boost
boost::component_type	multiprecision/mpfi.hpp	/^struct component_type<number<mpfi_float_backend<Digits10>, ExpressionTemplates> >$/;"	s	namespace:boost
boost::component_type::type	multiprecision/mpfi.hpp	/^   typedef number<mpfr_float_backend<Digits10>, ExpressionTemplates> type;$/;"	t	struct:boost::component_type	access:public
boost::denominator	multiprecision/number.hpp	/^inline multiprecision::number<T, ExpressionTemplates> denominator(const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a)
boost::detail	multiprecision/mpfi.hpp	/^namespace detail{$/;"	n	namespace:boost
boost::detail::is_explicitly_convertible	multiprecision/mpfi.hpp	/^struct is_explicitly_convertible<backends::mpfi_float_backend<D1>, backends::mpfi_float_backend<D2> > : public mpl::true_ {};$/;"	s	namespace:boost::detail	inherits:mpl::true_
boost::empty	multiprecision/mpfi.hpp	/^inline bool empty(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  a)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a)
boost::gmp_float::gmp_float	multiprecision/gmp.hpp	/^inline gmp_float<0>::gmp_float(const gmp_int& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_int& o)
boost::gmp_float::gmp_float	multiprecision/gmp.hpp	/^inline gmp_float<0>::gmp_float(const gmp_rational& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_rational& o)
boost::gmp_float::operator =	multiprecision/gmp.hpp	/^inline gmp_float<0>& gmp_float<0>::operator=(const gmp_int& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_int& o)
boost::gmp_float::operator =	multiprecision/gmp.hpp	/^inline gmp_float<0>& gmp_float<0>::operator=(const gmp_rational& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_rational& o)
boost::gmp_float::operator =	multiprecision/gmp.hpp	/^inline gmp_float<Digits10>& gmp_float<Digits10>::operator=(const gmp_int& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_int& o)
boost::gmp_float::operator =	multiprecision/gmp.hpp	/^inline gmp_float<Digits10>& gmp_float<Digits10>::operator=(const gmp_rational& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_rational& o)
boost::gmp_int::gmp_int	multiprecision/gmp.hpp	/^inline gmp_int::gmp_int(const gmp_rational& o)$/;"	f	class:boost::gmp_int	signature:(const gmp_rational& o)
boost::gmp_int::operator =	multiprecision/gmp.hpp	/^inline gmp_int& gmp_int::operator=(const gmp_rational& o)$/;"	f	class:boost::gmp_int	signature:(const gmp_rational& o)
boost::hull	multiprecision/mpfi.hpp	/^inline number<mpfi_float_backend<Digits10>, ExpressionTemplates> hull(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  b)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& b)
boost::in	multiprecision/mpfi.hpp	/^inline bool in(const number<mpfr_float_backend<Digits10>, ExpressionTemplates1>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates2>&  b)$/;"	f	namespace:boost	signature:(const number<mpfr_float_backend<Digits10>, ExpressionTemplates1>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates2>& b)
boost::integer_traits	multiprecision/cpp_int/cpp_int_config.hpp	/^class integer_traits<multiprecision::double_limb_type>$/;"	c	namespace:boost	inherits:std::numeric_limits,detail::integer_traits_base
boost::integer_traits	multiprecision/cpp_int/cpp_int_config.hpp	/^class integer_traits<multiprecision::signed_double_limb_type>$/;"	c	namespace:boost	inherits:std::numeric_limits,detail::integer_traits_base
boost::intersect	multiprecision/mpfi.hpp	/^inline number<mpfi_float_backend<Digits10>, ExpressionTemplates> intersect(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  b)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& b)
boost::is_interval_number	multiprecision/mpfi.hpp	/^struct is_interval_number<backends::mpfi_float_backend<Digits10> > : public mpl::true_ {};$/;"	s	namespace:boost	inherits:mpl::true_
boost::lower	multiprecision/mpfi.hpp	/^inline number<mpfr_float_backend<Digits10>, ExpressionTemplates> lower(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)
boost::math	multiprecision/cpp_dec_float.hpp	/^namespace boost{ namespace math{$/;"	n	namespace:boost
boost::math	multiprecision/debug_adaptor.hpp	/^namespace boost{ namespace math{$/;"	n	namespace:boost
boost::math	multiprecision/detail/big_lanczos.hpp	/^namespace boost{ namespace math{$/;"	n	namespace:boost
boost::math	multiprecision/detail/default_ops.hpp	/^namespace math{$/;"	n	namespace:boost
boost::math	multiprecision/detail/number_base.hpp	/^namespace boost{ namespace math{ namespace tools{$/;"	n	namespace:boost
boost::math	multiprecision/logged_adaptor.hpp	/^namespace boost{ namespace math{$/;"	n	namespace:boost
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isfinite BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isfinite BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isinf BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isinf BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isnan BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isnan BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isnormal BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline bool isnormal BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline int fpclassify BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/detail/default_ops.hpp	/^inline int fpclassify BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
boost::math::detail	multiprecision/detail/default_ops.hpp	/^namespace detail{$/;"	n	namespace:boost::math
boost::math::detail::sinc_pi_imp	multiprecision/detail/default_ops.hpp	/^   template <class T> T sinc_pi_imp(T);$/;"	p	namespace:boost::math::detail	signature:(T)
boost::math::detail::sinhc_pi_imp	multiprecision/detail/default_ops.hpp	/^   template <class T> T sinhc_pi_imp(T);$/;"	p	namespace:boost::math::detail	signature:(T)
boost::math::lanczos	multiprecision/detail/big_lanczos.hpp	/^namespace lanczos{$/;"	n	namespace:boost::math
boost::math::lanczos::lanczos	multiprecision/detail/big_lanczos.hpp	/^struct lanczos<multiprecision::number<Backend, ExpressionTemplates>, Policy>$/;"	s	namespace:boost::math::lanczos
boost::math::lanczos::lanczos::precision_type	multiprecision/detail/big_lanczos.hpp	/^   typedef typename boost::math::policies::precision<multiprecision::number<Backend, ExpressionTemplates>, Policy>::type precision_type;$/;"	t	struct:boost::math::lanczos::lanczos	access:public
boost::math::policies	multiprecision/cpp_dec_float.hpp	/^namespace policies{$/;"	n	namespace:boost::math
boost::math::policies	multiprecision/debug_adaptor.hpp	/^namespace policies{$/;"	n	namespace:boost::math
boost::math::policies	multiprecision/logged_adaptor.hpp	/^namespace policies{$/;"	n	namespace:boost::math
boost::math::policies::precision	multiprecision/cpp_dec_float.hpp	/^struct precision< boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates>, Policy>$/;"	s	namespace:boost::math::policies
boost::math::policies::precision	multiprecision/debug_adaptor.hpp	/^struct precision< boost::multiprecision::number<boost::multiprecision::debug_adaptor<Backend>, ExpressionTemplates>, Policy>$/;"	s	namespace:boost::math::policies	inherits:precision
boost::math::policies::precision	multiprecision/logged_adaptor.hpp	/^struct precision< boost::multiprecision::number<boost::multiprecision::logged_adaptor<Backend>, ExpressionTemplates>, Policy>$/;"	s	namespace:boost::math::policies	inherits:precision
boost::math::policies::precision::cpp_dec_float_digits10	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10 = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	struct:boost::math::policies::precision	access:public
boost::math::policies::precision::digits_2	multiprecision/cpp_dec_float.hpp	/^   typedef digits2<((cpp_dec_float_digits10 + 1LL) * 1000LL) \/ 301LL> digits_2;$/;"	t	struct:boost::math::policies::precision	access:public
boost::math::policies::precision::precision_type	multiprecision/cpp_dec_float.hpp	/^   typedef typename Policy::precision_type precision_type;$/;"	t	struct:boost::math::policies::precision	access:public
boost::math::sinc_pi	multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x)
boost::math::sinc_pi	multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)
boost::math::sinhc_pi	multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinhc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x)
boost::math::sinhc_pi	multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinhc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)
boost::math::tools	multiprecision/detail/number_base.hpp	/^namespace boost{ namespace math{ namespace tools{$/;"	n	namespace:boost::math
boost::math::tools::promote_arg	multiprecision/detail/number_base.hpp	/^struct promote_arg<boost::multiprecision::detail::expression<tag, A1, A2, A3, A4> >$/;"	s	namespace:boost::math::tools
boost::math::tools::promote_arg::type	multiprecision/detail/number_base.hpp	/^   typedef typename boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type type;$/;"	t	struct:boost::math::tools::promote_arg	access:public
boost::math::tools::real_cast	multiprecision/detail/number_base.hpp	/^inline R real_cast(const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>& val)$/;"	f	namespace:boost::math::tools	signature:(const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>& val)
boost::math::tools::real_cast	multiprecision/detail/number_base.hpp	/^inline R real_cast(const boost::multiprecision::number<B, ET>& val)$/;"	f	namespace:boost::math::tools	signature:(const boost::multiprecision::number<B, ET>& val)
boost::median	multiprecision/mpfi.hpp	/^inline number<mpfr_float_backend<Digits10>, ExpressionTemplates> median(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)
boost::mpfi_float	multiprecision/mpfi.hpp	/^typedef number<mpfi_float_backend<0> >     mpfi_float;$/;"	t	namespace:boost
boost::mpfi_float_100	multiprecision/mpfi.hpp	/^typedef number<mpfi_float_backend<100> >   mpfi_float_100;$/;"	t	namespace:boost
boost::mpfi_float_1000	multiprecision/mpfi.hpp	/^typedef number<mpfi_float_backend<1000> >  mpfi_float_1000;$/;"	t	namespace:boost
boost::mpfi_float_50	multiprecision/mpfi.hpp	/^typedef number<mpfi_float_backend<50> >    mpfi_float_50;$/;"	t	namespace:boost
boost::mpfi_float_500	multiprecision/mpfi.hpp	/^typedef number<mpfi_float_backend<500> >   mpfi_float_500;$/;"	t	namespace:boost
boost::multiprecision	multiprecision/concepts/mp_number_archetypes.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/cpp_dec_float.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/cpp_int.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/cpp_int/add.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/cpp_int/bitwise.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/cpp_int/checked.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{ namespace detail{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/cpp_int/comparison.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/cpp_int/cpp_int_config.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/cpp_int/cpp_int_config.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/cpp_int/divide.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/cpp_int/literals.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/cpp_int/misc.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/cpp_int/multiply.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/cpp_int/value_pack.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/debug_adaptor.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/detail/bitscan.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/detail/default_ops.hpp	/^namespace boost{ namespace multiprecision{ namespace default_ops{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/detail/default_ops.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/detail/digits.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/detail/dynamic_array.hpp	/^  namespace boost { namespace multiprecision { namespace backends { namespace detail$/;"	n	namespace:boost
boost::multiprecision	multiprecision/detail/et_ops.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/detail/float_string_cvt.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/detail/generic_interconvert.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/detail/integer_ops.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/detail/no_et_ops.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/detail/number_base.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/detail/number_compare.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/detail/rebind.hpp	/^  namespace boost { namespace multiprecision { namespace backends { namespace detail$/;"	n	namespace:boost
boost::multiprecision	multiprecision/detail/utype_helper.hpp	/^  namespace boost { namespace multiprecision {$/;"	n	namespace:boost
boost::multiprecision	multiprecision/float128.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/gmp.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/integer.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/logged_adaptor.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/miller_rabin.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/mpfi.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/mpfr.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/number.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/rational_adaptor.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/tommath.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/traits/explicit_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/traits/extract_exponent_type.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	multiprecision/traits/is_restricted_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
boost::multiprecision::BOOST_NOEXCEPT_IF	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE void do_assign_arithmetic(signed_limb_type i, const mpl::false_&) BOOST_NOEXCEPT_IF((Checked == unchecked))$/;"	f	namespace:boost::multiprecision	signature:(Checked == unchecked)
boost::multiprecision::abs	multiprecision/detail/default_ops.hpp	/^abs(const detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& arg)
boost::multiprecision::abs	multiprecision/detail/default_ops.hpp	/^abs(const number<Backend, et_off>& arg)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, et_off>& arg)
boost::multiprecision::abs	multiprecision/detail/default_ops.hpp	/^abs(const number<Backend, et_on>& arg)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, et_on>& arg)
boost::multiprecision::add	multiprecision/detail/default_ops.hpp	/^   add(number<B, ET>& result, const I& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, ET>& result, const I& a, const I& b)
boost::multiprecision::add	multiprecision/detail/default_ops.hpp	/^inline number<B1, ET1>& add(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)
boost::multiprecision::add	multiprecision/integer.hpp	/^   add(Integer& result, const I2& a, const I2& b)$/;"	f	namespace:boost::multiprecision	signature:(Integer& result, const I2& a, const I2& b)
boost::multiprecision::allocate_dynamic	multiprecision/mpfr.hpp	/^   allocate_dynamic$/;"	e	enum:boost::multiprecision::mpfr_allocation_type
boost::multiprecision::allocate_stack	multiprecision/mpfr.hpp	/^   allocate_stack,$/;"	e	enum:boost::multiprecision::mpfr_allocation_type
boost::multiprecision::assign_components	multiprecision/mpfi.hpp	/^   assign_components(mpfi_float_backend<Digits10>& result, const V& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const V& a, const V& b)
boost::multiprecision::assign_components	multiprecision/mpfi.hpp	/^inline void assign_components(mpfi_float_backend<D1>& result, const mpfr_float_backend<D2, AllocationType>& a, const mpfr_float_backend<D2, AllocationType>& b)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& result, const mpfr_float_backend<D2, AllocationType>& a, const mpfr_float_backend<D2, AllocationType>& b)
boost::multiprecision::backends	multiprecision/cpp_dec_float.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/cpp_int.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/cpp_int/add.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/cpp_int/bitwise.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/cpp_int/checked.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{ namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/cpp_int/comparison.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/cpp_int/divide.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/cpp_int/misc.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/cpp_int/multiply.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/debug_adaptor.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/detail/dynamic_array.hpp	/^  namespace boost { namespace multiprecision { namespace backends { namespace detail$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/detail/rebind.hpp	/^  namespace boost { namespace multiprecision { namespace backends { namespace detail$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/float128.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/gmp.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/logged_adaptor.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/mpfi.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/mpfr.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/rational_adaptor.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/tommath.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	multiprecision/traits/extract_exponent_type.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^      const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^      const limb_type& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^      const signed_limb_type& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^   eval_add(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const limb_type& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^   eval_decrement(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^   eval_increment(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^inline void add_unsigned(CppInt1& result, const CppInt2& a, const CppInt3& b) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^inline void add_unsigned(CppInt1& result, const CppInt2& a, const limb_type& o) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^inline void subtract_unsigned(CppInt1& result, const CppInt2& a, const CppInt3& b) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/add.hpp	/^inline void subtract_unsigned(CppInt1& result, const CppInt2& a, const limb_type& b) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/bitwise.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/bitwise.hpp	/^      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/bitwise.hpp	/^      double_limb_type s) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/bitwise.hpp	/^   Op op) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<CppInt1>::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/bitwise.hpp	/^   eval_left_shift(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, T s) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/bitwise.hpp	/^   eval_right_shift(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, T s) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/misc.hpp	/^      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& r) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/misc.hpp	/^   eval_abs(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/misc.hpp	/^   eval_convert_to(R* result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& backend) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/misc.hpp	/^   eval_convert_to(R* result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& backend) BOOST_NOEXCEPT_IF(is_arithmetic<R>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_arithmetic<R>::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& b) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const signed_double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^      const signed_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const signed_double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const signed_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::NON_MEMBER_OP1	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP1(decrement, "decrement");$/;"	p	namespace:boost::multiprecision::backends	signature:(decrement, Ó)
boost::multiprecision::backends::NON_MEMBER_OP1	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP1(increment, "increment");$/;"	p	namespace:boost::multiprecision::backends	signature:(increment, Ó)
boost::multiprecision::backends::NON_MEMBER_OP1	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP1(decrement, "decrement");$/;"	p	namespace:boost::multiprecision::backends	signature:(decrement, Ó)
boost::multiprecision::backends::NON_MEMBER_OP1	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP1(increment, "increment");$/;"	p	namespace:boost::multiprecision::backends	signature:(increment, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(abs, "abs");$/;"	p	namespace:boost::multiprecision::backends	signature:(abs, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(acos, "acos");$/;"	p	namespace:boost::multiprecision::backends	signature:(acos, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(add, "+=");$/;"	p	namespace:boost::multiprecision::backends	signature:(add, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(asin, "asin");$/;"	p	namespace:boost::multiprecision::backends	signature:(asin, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(atan, "atan");$/;"	p	namespace:boost::multiprecision::backends	signature:(atan, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(bitwise_and, "&=");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_and, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(bitwise_or, "|=");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_or, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(bitwise_xor, "^=");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_xor, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(ceil, "ceil");$/;"	p	namespace:boost::multiprecision::backends	signature:(ceil, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(complement, "~");$/;"	p	namespace:boost::multiprecision::backends	signature:(complement, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(cos, "cos");$/;"	p	namespace:boost::multiprecision::backends	signature:(cos, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(cosh, "cosh");$/;"	p	namespace:boost::multiprecision::backends	signature:(cosh, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(divide, "\/=");$/;"	p	namespace:boost::multiprecision::backends	signature:(divide, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(exp, "exp");$/;"	p	namespace:boost::multiprecision::backends	signature:(exp, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(fabs, "fabs");$/;"	p	namespace:boost::multiprecision::backends	signature:(fabs, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(floor, "floor");$/;"	p	namespace:boost::multiprecision::backends	signature:(floor, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(log, "log");$/;"	p	namespace:boost::multiprecision::backends	signature:(log, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(log10, "log10");$/;"	p	namespace:boost::multiprecision::backends	signature:(log10, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(modulus, "%=");$/;"	p	namespace:boost::multiprecision::backends	signature:(modulus, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(multiply, "*=");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(round, "round");$/;"	p	namespace:boost::multiprecision::backends	signature:(round, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(sin, "sin");$/;"	p	namespace:boost::multiprecision::backends	signature:(sin, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(sinh, "sinh");$/;"	p	namespace:boost::multiprecision::backends	signature:(sinh, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(sqrt, "sqrt");$/;"	p	namespace:boost::multiprecision::backends	signature:(sqrt, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(subtract, "-=");$/;"	p	namespace:boost::multiprecision::backends	signature:(subtract, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(tan, "tan");$/;"	p	namespace:boost::multiprecision::backends	signature:(tan, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(tanh, "tanh");$/;"	p	namespace:boost::multiprecision::backends	signature:(tanh, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP2(trunc, "trunc");$/;"	p	namespace:boost::multiprecision::backends	signature:(trunc, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(abs, "abs");$/;"	p	namespace:boost::multiprecision::backends	signature:(abs, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(acos, "acos");$/;"	p	namespace:boost::multiprecision::backends	signature:(acos, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(add, "+=");$/;"	p	namespace:boost::multiprecision::backends	signature:(add, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(asin, "asin");$/;"	p	namespace:boost::multiprecision::backends	signature:(asin, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(atan, "atan");$/;"	p	namespace:boost::multiprecision::backends	signature:(atan, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(bitwise_and, "&=");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_and, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(bitwise_or, "|=");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_or, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(bitwise_xor, "^=");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_xor, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(ceil, "ceil");$/;"	p	namespace:boost::multiprecision::backends	signature:(ceil, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(complement, "~");$/;"	p	namespace:boost::multiprecision::backends	signature:(complement, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(cos, "cos");$/;"	p	namespace:boost::multiprecision::backends	signature:(cos, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(cosh, "cosh");$/;"	p	namespace:boost::multiprecision::backends	signature:(cosh, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(divide, "\/=");$/;"	p	namespace:boost::multiprecision::backends	signature:(divide, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(exp, "exp");$/;"	p	namespace:boost::multiprecision::backends	signature:(exp, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(fabs, "fabs");$/;"	p	namespace:boost::multiprecision::backends	signature:(fabs, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(floor, "floor");$/;"	p	namespace:boost::multiprecision::backends	signature:(floor, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(log, "log");$/;"	p	namespace:boost::multiprecision::backends	signature:(log, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(log10, "log10");$/;"	p	namespace:boost::multiprecision::backends	signature:(log10, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(modulus, "%=");$/;"	p	namespace:boost::multiprecision::backends	signature:(modulus, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(multiply, "*=");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(round, "round");$/;"	p	namespace:boost::multiprecision::backends	signature:(round, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(sin, "sin");$/;"	p	namespace:boost::multiprecision::backends	signature:(sin, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(sinh, "sinh");$/;"	p	namespace:boost::multiprecision::backends	signature:(sinh, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(sqrt, "sqrt");$/;"	p	namespace:boost::multiprecision::backends	signature:(sqrt, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(subtract, "-=");$/;"	p	namespace:boost::multiprecision::backends	signature:(subtract, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(tan, "tan");$/;"	p	namespace:boost::multiprecision::backends	signature:(tan, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(tanh, "tanh");$/;"	p	namespace:boost::multiprecision::backends	signature:(tanh, Ó)
boost::multiprecision::backends::NON_MEMBER_OP2	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP2(trunc, "trunc");$/;"	p	namespace:boost::multiprecision::backends	signature:(trunc, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(add, "+");$/;"	p	namespace:boost::multiprecision::backends	signature:(add, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(atan2, "atan2");$/;"	p	namespace:boost::multiprecision::backends	signature:(atan2, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(bitwise_and, "&");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_and, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(bitwise_or, "|");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_or, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(bitwise_xor, "^");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_xor, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(divide, "\/");$/;"	p	namespace:boost::multiprecision::backends	signature:(divide, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(fmod, "fmod");$/;"	p	namespace:boost::multiprecision::backends	signature:(fmod, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(gcd, "gcd");$/;"	p	namespace:boost::multiprecision::backends	signature:(gcd, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(lcm, "lcm");$/;"	p	namespace:boost::multiprecision::backends	signature:(lcm, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(modulus, "%");$/;"	p	namespace:boost::multiprecision::backends	signature:(modulus, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(multiply, "*");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(multiply_add, "fused-multiply-add");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_add, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(multiply_subtract, "fused-multiply-subtract");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_subtract, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(pow, "pow");$/;"	p	namespace:boost::multiprecision::backends	signature:(pow, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP3(subtract, "-");$/;"	p	namespace:boost::multiprecision::backends	signature:(subtract, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(add, "+");$/;"	p	namespace:boost::multiprecision::backends	signature:(add, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(atan2, "atan2");$/;"	p	namespace:boost::multiprecision::backends	signature:(atan2, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(bitwise_and, "&");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_and, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(bitwise_or, "|");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_or, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(bitwise_xor, "^");$/;"	p	namespace:boost::multiprecision::backends	signature:(bitwise_xor, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(divide, "\/");$/;"	p	namespace:boost::multiprecision::backends	signature:(divide, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(fmod, "fmod");$/;"	p	namespace:boost::multiprecision::backends	signature:(fmod, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(gcd, "gcd");$/;"	p	namespace:boost::multiprecision::backends	signature:(gcd, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(lcm, "lcm");$/;"	p	namespace:boost::multiprecision::backends	signature:(lcm, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(modulus, "%");$/;"	p	namespace:boost::multiprecision::backends	signature:(modulus, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(multiply, "*");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(multiply_add, "fused-multiply-add");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_add, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(multiply_subtract, "fused-multiply-subtract");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_subtract, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(pow, "pow");$/;"	p	namespace:boost::multiprecision::backends	signature:(pow, Ó)
boost::multiprecision::backends::NON_MEMBER_OP3	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP3(subtract, "-");$/;"	p	namespace:boost::multiprecision::backends	signature:(subtract, Ó)
boost::multiprecision::backends::NON_MEMBER_OP4	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP4(multiply_add, "fused-multiply-add");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_add, Ó)
boost::multiprecision::backends::NON_MEMBER_OP4	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP4(multiply_subtract, "fused-multiply-subtract");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_subtract, Ó)
boost::multiprecision::backends::NON_MEMBER_OP4	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP4(powm, "powm");$/;"	p	namespace:boost::multiprecision::backends	signature:(powm, Ó)
boost::multiprecision::backends::NON_MEMBER_OP4	multiprecision/debug_adaptor.hpp	/^NON_MEMBER_OP4(qr, "quotient-and-remainder");$/;"	p	namespace:boost::multiprecision::backends	signature:(qr, Ó)
boost::multiprecision::backends::NON_MEMBER_OP4	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP4(multiply_add, "fused-multiply-add");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_add, Ó)
boost::multiprecision::backends::NON_MEMBER_OP4	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP4(multiply_subtract, "fused-multiply-subtract");$/;"	p	namespace:boost::multiprecision::backends	signature:(multiply_subtract, Ó)
boost::multiprecision::backends::NON_MEMBER_OP4	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP4(powm, "powm");$/;"	p	namespace:boost::multiprecision::backends	signature:(powm, Ó)
boost::multiprecision::backends::NON_MEMBER_OP4	multiprecision/logged_adaptor.hpp	/^NON_MEMBER_OP4(qr, "quotient-and-remainder");$/;"	p	namespace:boost::multiprecision::backends	signature:(qr, Ó)
boost::multiprecision::backends::assign	multiprecision/cpp_int.hpp	/^   void assign(const cpp_int_base& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_base& o)
boost::multiprecision::backends::assign_components	multiprecision/rational_adaptor.hpp	/^inline void assign_components(rational_adaptor<IntBackend>& result, const V& v1, const V& v2)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adaptor<IntBackend>& result, const V& v1, const V& v2)
boost::multiprecision::backends::bit_and	multiprecision/cpp_int/bitwise.hpp	/^struct bit_and{ limb_type operator()(limb_type a, limb_type b)const BOOST_NOEXCEPT { return a & b; } };$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::bit_or	multiprecision/cpp_int/bitwise.hpp	/^struct bit_or { limb_type operator()(limb_type a, limb_type b)const BOOST_NOEXCEPT { return a | b; } };$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::bit_xor	multiprecision/cpp_int/bitwise.hpp	/^struct bit_xor{ limb_type operator()(limb_type a, limb_type b)const BOOST_NOEXCEPT { return a ^ b; } };$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::check_in_range	multiprecision/cpp_int/misc.hpp	/^void check_in_range(const CppInt& val, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends	signature:(const CppInt& val, const mpl::int_<checked>&)
boost::multiprecision::backends::check_is_negative	multiprecision/cpp_int/misc.hpp	/^inline void check_is_negative(const mpl::false_&)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpl::false_&)
boost::multiprecision::backends::cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^class cpp_dec_float$/;"	c	namespace:boost::multiprecision::backends
boost::multiprecision::backends::cpp_dec_float::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/cpp_dec_float.hpp	/^   bool isfinite BOOST_PREVENT_MACRO_SUBSTITUTION(void) const  { return (fpclass == cpp_dec_float_finite); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/cpp_dec_float.hpp	/^   bool isinf    BOOST_PREVENT_MACRO_SUBSTITUTION(void) const  { return (fpclass == cpp_dec_float_inf); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/cpp_dec_float.hpp	/^   bool isnan    BOOST_PREVENT_MACRO_SUBSTITUTION(void) const  { return (fpclass == cpp_dec_float_NaN); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::BOOST_STATIC_ASSERT	multiprecision/cpp_dec_float.hpp	/^   BOOST_STATIC_ASSERT((cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10 == -cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10));$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10 == -cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10)
boost::multiprecision::backends::cpp_dec_float::BOOST_STATIC_ASSERT_MSG	multiprecision/cpp_dec_float.hpp	/^   BOOST_STATIC_ASSERT_MSG(boost::is_signed<ExponentType>::value, "ExponentType must be a signed built in integer type.");$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::is_signed<ExponentType>::value, Ó)
boost::multiprecision::backends::cpp_dec_float::add_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& add_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
boost::multiprecision::backends::cpp_dec_float::array_type	multiprecision/cpp_dec_float.hpp	/^      >::type array_type;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::calculate_inv	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& calculate_inv (void)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
boost::multiprecision::backends::cpp_dec_float::calculate_inv	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::calculate_inv()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:()
boost::multiprecision::backends::cpp_dec_float::calculate_sqrt	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& calculate_sqrt(void)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
boost::multiprecision::backends::cpp_dec_float::calculate_sqrt	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::calculate_sqrt(void)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void)
boost::multiprecision::backends::cpp_dec_float::char_is_nonzero_predicate	multiprecision/cpp_dec_float.hpp	/^   static bool char_is_nonzero_predicate(const char& c)  { return (c != static_cast<char>('0')); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const char& c)
boost::multiprecision::backends::cpp_dec_float::cmp_data	multiprecision/cpp_dec_float.hpp	/^   int cmp_data(const array_type& vd) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const array_type& vd) const
boost::multiprecision::backends::cpp_dec_float::cmp_data	multiprecision/cpp_dec_float.hpp	/^int cpp_dec_float<Digits10, ExponentType, Allocator>::cmp_data(const array_type& vd) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const array_type& vd) const
boost::multiprecision::backends::cpp_dec_float::compare	multiprecision/cpp_dec_float.hpp	/^   int compare(const V& v)const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const V& v) const
boost::multiprecision::backends::cpp_dec_float::compare	multiprecision/cpp_dec_float.hpp	/^   int compare(const cpp_dec_float& v)const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v) const
boost::multiprecision::backends::cpp_dec_float::compare	multiprecision/cpp_dec_float.hpp	/^int cpp_dec_float<Digits10, ExponentType, Allocator>::compare(const cpp_dec_float& v) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float& v) const
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float()   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(I i, typename enable_if<is_signed<I> >::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(I i, typename enable_if<is_signed<I> >::type* = 0)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(I i, typename enable_if<is_unsigned<I> >::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(I i, typename enable_if<is_unsigned<I> >::type* = 0)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const F val, typename enable_if<is_floating_point<F> >::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const F val, typename enable_if<is_floating_point<F> >::type* = 0)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const char* s) : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const char* s)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const cpp_dec_float& f)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& f)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const cpp_dec_float<D, ET, A>& f, typename enable_if_c<D <= Digits10>::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float<D, ET, A>& f, typename enable_if_c<D <= Digits10>::type* = 0)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const double val, ExponentType exponent);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const double val, ExponentType exponent)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(fpclass_type c)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(fpclass_type c)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   explicit cpp_dec_float(const cpp_dec_float<D, ET, A>& f, typename disable_if_c<D <= Digits10>::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float<D, ET, A>& f, typename disable_if_c<D <= Digits10>::type* = 0)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float(const double mantissa, const ExponentType exponent)   $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const double mantissa, const ExponentType exponent)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_NaN	multiprecision/cpp_dec_float.hpp	/^      cpp_dec_float_NaN$/;"	e	enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10          = ((cpp_dec_float_digits10_setting < cpp_dec_float_digits10_limit_lo) ? cpp_dec_float_digits10_limit_lo : ((cpp_dec_float_digits10_setting > cpp_dec_float_digits10_limit_hi) ? cpp_dec_float_digits10_limit_hi : cpp_dec_float_digits10_setting));$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10_limit_hi	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10_limit_hi = boost::integer_traits<boost::int32_t>::const_max - 100;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10_limit_hi	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10_limit_hi;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10_limit_lo	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10_limit_lo = 9L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10_limit_lo	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10_limit_lo;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10_setting	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10_setting = Digits10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10_setting	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10_setting;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_digits10	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_digits10 = 8L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_digits10	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_digits10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_mask	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_mask     = 100000000L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_mask	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_mask;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_number	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_number = static_cast<boost::int32_t>(((cpp_dec_float_elem_number_request < 2L) ? 2L : cpp_dec_float_elem_number_request) + 3L);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_number	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_number;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_number_request	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_number_request = static_cast<boost::int32_t>((cpp_dec_float_digits10 \/ cpp_dec_float_elem_digits10) + (((cpp_dec_float_digits10 % cpp_dec_float_elem_digits10) != 0) ? 1 : 0));$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_number_request	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_number_request;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_finite	multiprecision/cpp_dec_float.hpp	/^      cpp_dec_float_finite,$/;"	e	enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_inf	multiprecision/cpp_dec_float.hpp	/^      cpp_dec_float_inf,$/;"	e	enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_max_exp	multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_max_exp           = static_cast<ExponentType>((cpp_dec_float_max_exp10 \/ 301LL) * 1000LL);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_max_exp	multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_max_exp10	multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_max_exp10         = (static_cast<ExponentType>(1) << (std::numeric_limits<ExponentType>::digits - 5));$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_max_exp10	multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_min_exp	multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_min_exp           = static_cast<ExponentType>((cpp_dec_float_min_exp10 \/ 301LL) * 1000LL);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_min_exp	multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_min_exp10	multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_min_exp10         = -cpp_dec_float_max_exp10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_min_exp10	multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_radix	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_radix             = 10L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_radix	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_radix;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_total_digits10	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_total_digits10 = static_cast<boost::int32_t>(cpp_dec_float_elem_number * cpp_dec_float_elem_digits10);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::data	multiprecision/cpp_dec_float.hpp	/^   array_type      data;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::data_elem_is_non_nine_predicate	multiprecision/cpp_dec_float.hpp	/^   static bool data_elem_is_non_nine_predicate(const boost::uint32_t& d)  { return (d != static_cast<boost::uint32_t>(cpp_dec_float::cpp_dec_float_elem_mask - 1)); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const boost::uint32_t& d)
boost::multiprecision::backends::cpp_dec_float::data_elem_is_non_zero_predicate	multiprecision/cpp_dec_float.hpp	/^   static bool data_elem_is_non_zero_predicate(const boost::uint32_t& d)  { return (d != static_cast<boost::uint32_t>(0u)); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const boost::uint32_t& d)
boost::multiprecision::backends::cpp_dec_float::div_loop_n	multiprecision/cpp_dec_float.hpp	/^   static boost::uint32_t div_loop_n (boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
boost::multiprecision::backends::cpp_dec_float::div_loop_n	multiprecision/cpp_dec_float.hpp	/^boost::uint32_t cpp_dec_float<Digits10, ExponentType, Allocator>::div_loop_n(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
boost::multiprecision::backends::cpp_dec_float::div_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& div_unsigned_long_long(const unsigned long long n);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
boost::multiprecision::backends::cpp_dec_float::div_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::div_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const unsigned long long n)
boost::multiprecision::backends::cpp_dec_float::double_max	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& double_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::double_min	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& double_min()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type	multiprecision/cpp_dec_float.hpp	/^   typedef enum enum_fpclass_type$/;"	g	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::eps	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& eps()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::exp	multiprecision/cpp_dec_float.hpp	/^   ExponentType    exp;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::exponent_type	multiprecision/cpp_dec_float.hpp	/^   typedef ExponentType                   exponent_type;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::extract_double	multiprecision/cpp_dec_float.hpp	/^   double             extract_double            (void) const;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_double	multiprecision/cpp_dec_float.hpp	/^double cpp_dec_float<Digits10, ExponentType, Allocator>::extract_double(void) const$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_integer_part	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float      extract_integer_part      (void) const  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_integer_part	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator> cpp_dec_float<Digits10, ExponentType, Allocator>::extract_integer_part(void) const  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_long_double	multiprecision/cpp_dec_float.hpp	/^   long double        extract_long_double       (void) const;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_long_double	multiprecision/cpp_dec_float.hpp	/^long double cpp_dec_float<Digits10, ExponentType, Allocator>::extract_long_double(void) const$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_parts	multiprecision/cpp_dec_float.hpp	/^   void               extract_parts             (double& mantissa, ExponentType& exponent) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(double& mantissa, ExponentType& exponent) const
boost::multiprecision::backends::cpp_dec_float::extract_parts	multiprecision/cpp_dec_float.hpp	/^void cpp_dec_float<Digits10, ExponentType, Allocator>::extract_parts(double& mantissa, ExponentType& exponent) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(double& mantissa, ExponentType& exponent) const
boost::multiprecision::backends::cpp_dec_float::extract_signed_long_long	multiprecision/cpp_dec_float.hpp	/^   signed long long   extract_signed_long_long  (void) const  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_signed_long_long	multiprecision/cpp_dec_float.hpp	/^signed long long cpp_dec_float<Digits10, ExponentType, Allocator>::extract_signed_long_long(void) const  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^   unsigned long long extract_unsigned_long_long(void) const  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^unsigned long long cpp_dec_float<Digits10, ExponentType, Allocator>::extract_unsigned_long_long(void) const  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::float_types	multiprecision/cpp_dec_float.hpp	/^   typedef mpl::list<long double>         float_types;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::fpclass	multiprecision/cpp_dec_float.hpp	/^   fpclass_type    fpclass;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::fpclass_type	multiprecision/cpp_dec_float.hpp	/^   fpclass_type;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	typeref:enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type	access:private
boost::multiprecision::backends::cpp_dec_float::from_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^   void from_unsigned_long_long(const unsigned long long u) ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const unsigned long long u)
boost::multiprecision::backends::cpp_dec_float::from_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^void cpp_dec_float<Digits10, ExponentType, Allocator>::from_unsigned_long_long(const unsigned long long u) $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const unsigned long long u)
boost::multiprecision::backends::cpp_dec_float::half	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& half()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::inf	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& inf()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::init	multiprecision/cpp_dec_float.hpp	/^      static initializer init;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::init	multiprecision/cpp_dec_float.hpp	/^typename cpp_dec_float<Digits10, ExponentType, Allocator>::initializer cpp_dec_float<Digits10, ExponentType, Allocator>::init;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::initializer	multiprecision/cpp_dec_float.hpp	/^      struct initializer$/;"	s	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::initializer::do_nothing	multiprecision/cpp_dec_float.hpp	/^         void do_nothing(){}$/;"	f	struct:boost::multiprecision::backends::cpp_dec_float::initializer	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::initializer::initializer	multiprecision/cpp_dec_float.hpp	/^         initializer()$/;"	f	struct:boost::multiprecision::backends::cpp_dec_float::initializer	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::isint	multiprecision/cpp_dec_float.hpp	/^   bool isint  (void) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::isint	multiprecision/cpp_dec_float.hpp	/^bool cpp_dec_float<Digits10, ExponentType, Allocator>::isint() const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:() const
boost::multiprecision::backends::cpp_dec_float::isneg	multiprecision/cpp_dec_float.hpp	/^   bool isneg  (void) const  { return neg; }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::isone	multiprecision/cpp_dec_float.hpp	/^   bool isone  (void) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::isone	multiprecision/cpp_dec_float.hpp	/^bool cpp_dec_float<Digits10, ExponentType, Allocator>::isone() const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:() const
boost::multiprecision::backends::cpp_dec_float::iszero	multiprecision/cpp_dec_float.hpp	/^   bool iszero (void) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::long_double_max	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_double_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::long_double_min	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_double_min()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::long_long_max	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_long_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::long_long_min	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_long_min()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::max	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& (max)()$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::min	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& (min)()$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::mul_loop_n	multiprecision/cpp_dec_float.hpp	/^   static boost::uint32_t mul_loop_n (boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
boost::multiprecision::backends::cpp_dec_float::mul_loop_n	multiprecision/cpp_dec_float.hpp	/^boost::uint32_t cpp_dec_float<Digits10, ExponentType, Allocator>::mul_loop_n(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
boost::multiprecision::backends::cpp_dec_float::mul_loop_uv	multiprecision/cpp_dec_float.hpp	/^   static boost::uint32_t mul_loop_uv(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)
boost::multiprecision::backends::cpp_dec_float::mul_loop_uv	multiprecision/cpp_dec_float.hpp	/^boost::uint32_t cpp_dec_float<Digits10, ExponentType, Allocator>::mul_loop_uv(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)
boost::multiprecision::backends::cpp_dec_float::mul_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& mul_unsigned_long_long(const unsigned long long n);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
boost::multiprecision::backends::cpp_dec_float::mul_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::mul_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const unsigned long long n)
boost::multiprecision::backends::cpp_dec_float::nan	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& nan()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::neg	multiprecision/cpp_dec_float.hpp	/^   bool            neg;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::negate	multiprecision/cpp_dec_float.hpp	/^   void negate()   $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::one	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& one()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::operator *=	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator*=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
boost::multiprecision::backends::cpp_dec_float::operator *=	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator*=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
boost::multiprecision::backends::cpp_dec_float::operator ++	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator++(void)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
boost::multiprecision::backends::cpp_dec_float::operator +=	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator+=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
boost::multiprecision::backends::cpp_dec_float::operator +=	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator+=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
boost::multiprecision::backends::cpp_dec_float::operator --	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator--(void)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
boost::multiprecision::backends::cpp_dec_float::operator -=	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator-=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
boost::multiprecision::backends::cpp_dec_float::operator -=	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator-=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
boost::multiprecision::backends::cpp_dec_float::operator /=	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator\/=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
boost::multiprecision::backends::cpp_dec_float::operator /=	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator\/=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
boost::multiprecision::backends::cpp_dec_float::operator =	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (const char* v)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const char* v)
boost::multiprecision::backends::cpp_dec_float::operator =	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (const cpp_dec_float& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
boost::multiprecision::backends::cpp_dec_float::operator =	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (long double v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(long double v)
boost::multiprecision::backends::cpp_dec_float::operator =	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (long long v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(long long v)
boost::multiprecision::backends::cpp_dec_float::operator =	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (unsigned long long v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(unsigned long long v)
boost::multiprecision::backends::cpp_dec_float::operator =	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator=(const cpp_dec_float<D>& f)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float<D>& f)
boost::multiprecision::backends::cpp_dec_float::operator =	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator= (long double a)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(long double a)
boost::multiprecision::backends::cpp_dec_float::order	multiprecision/cpp_dec_float.hpp	/^   ExponentType order()const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:() const
boost::multiprecision::backends::cpp_dec_float::pow2	multiprecision/cpp_dec_float.hpp	/^   static cpp_dec_float pow2(long long i);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(long long i)
boost::multiprecision::backends::cpp_dec_float::pow2	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator> cpp_dec_float<Digits10, ExponentType, Allocator>::pow2(const long long p)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const long long p)
boost::multiprecision::backends::cpp_dec_float::prec_elem	multiprecision/cpp_dec_float.hpp	/^   boost::int32_t  prec_elem;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::precision	multiprecision/cpp_dec_float.hpp	/^   void precision(const boost::int32_t prec_digits) $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const boost::int32_t prec_digits)
boost::multiprecision::backends::cpp_dec_float::rd_string	multiprecision/cpp_dec_float.hpp	/^   bool rd_string(const char* const s);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const char* const s)
boost::multiprecision::backends::cpp_dec_float::rd_string	multiprecision/cpp_dec_float.hpp	/^bool cpp_dec_float<Digits10, ExponentType, Allocator>::rd_string(const char* const s)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const char* const s)
boost::multiprecision::backends::cpp_dec_float::serialize	multiprecision/cpp_dec_float.hpp	/^   void serialize(Archive & ar, const unsigned int \/*version*\/)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(Archive & ar, const unsigned int )
boost::multiprecision::backends::cpp_dec_float::signed_types	multiprecision/cpp_dec_float.hpp	/^   typedef mpl::list<long long>           signed_types;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::sizeof	multiprecision/cpp_dec_float.hpp	/^   BOOST_STATIC_ASSERT_MSG(sizeof(ExponentType) > 1, "ExponentType is too small.");$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(ExponentType)
boost::multiprecision::backends::cpp_dec_float::str	multiprecision/cpp_dec_float.hpp	/^   std::string str(boost::intmax_t digits, std::ios_base::fmtflags f)const;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(boost::intmax_t digits, std::ios_base::fmtflags f) const
boost::multiprecision::backends::cpp_dec_float::str	multiprecision/cpp_dec_float.hpp	/^std::string cpp_dec_float<Digits10, ExponentType, Allocator>::str(boost::intmax_t number_of_digits, std::ios_base::fmtflags f) const$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::intmax_t number_of_digits, std::ios_base::fmtflags f) const
boost::multiprecision::backends::cpp_dec_float::sub_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& sub_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
boost::multiprecision::backends::cpp_dec_float::swap	multiprecision/cpp_dec_float.hpp	/^   void swap(cpp_dec_float& v) $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(cpp_dec_float& v)
boost::multiprecision::backends::cpp_dec_float::two	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& two()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::ulong_long_max	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& ulong_long_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::unsigned_types	multiprecision/cpp_dec_float.hpp	/^   typedef mpl::list<unsigned long long>  unsigned_types;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::zero	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& zero()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_int_base	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE cpp_int_base(const cpp_int_base& o) : allocator_type(o), m_limbs(0), m_internal(true)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_base& o)
boost::multiprecision::backends::cpp_int_base	multiprecision/cpp_int.hpp	/^   cpp_int_base(cpp_int_base&& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_base&& o)
boost::multiprecision::backends::cpp_int_base	multiprecision/cpp_int.hpp	/^struct cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false> : private Allocator::template rebind<limb_type>::other$/;"	s	namespace:boost::multiprecision::backends	inherits:Allocator::,rebind::other
boost::multiprecision::backends::cpp_int_base::BOOST_NOEXCEPT	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::BOOST_NOEXCEPT	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_double_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::BOOST_NOEXCEPT	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(bool, variable = true);$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(bool, variable = true)
boost::multiprecision::backends::cpp_int_base::BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, max_limb_value = ~static_cast<limb_type>(0u));$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(limb_type, max_limb_value = ~static_cast<limb_type>(0u))
boost::multiprecision::backends::cpp_int_base::BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, sign_bit_mask = 1u << (limb_bits - 1));$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(limb_type, sign_bit_mask = 1u << (limb_bits - 1))
boost::multiprecision::backends::cpp_int_base::BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, internal_limb_count =$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(unsigned, internal_limb_count = MinBits ? MinBits / limb_bits + (MinBits % limb_bits ? 1 : 0) : sizeof(limb_data) / sizeof(limb_type))
boost::multiprecision::backends::cpp_int_base::BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT);$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT)
boost::multiprecision::backends::cpp_int_base::allocator_type	multiprecision/cpp_int.hpp	/^   typedef typename Allocator::template rebind<limb_type>::other allocator_type;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::cap	multiprecision/cpp_int.hpp	/^      unsigned cap = capacity();$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::checked_type	multiprecision/cpp_int.hpp	/^   typedef mpl::int_<Checked>                                    checked_type;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::const_limb_pointer	multiprecision/cpp_int.hpp	/^   typedef typename allocator_type::const_pointer                const_limb_pointer;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::data_type	multiprecision/cpp_int.hpp	/^   union data_type$/;"	u	struct:boost::multiprecision::backends::cpp_int_base	access:private
boost::multiprecision::backends::cpp_int_base::data_type::data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type() : first(0) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:()
boost::multiprecision::backends::cpp_int_base::data_type::data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(double_limb_type i) : double_first(i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(double_limb_type i)
boost::multiprecision::backends::cpp_int_base::data_type::data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(limb_type i) : first(i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(limb_type i)
boost::multiprecision::backends::cpp_int_base::data_type::data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(signed_double_limb_type i) : double_first(i < 0 ? -i : i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(signed_double_limb_type i)
boost::multiprecision::backends::cpp_int_base::data_type::data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(signed_limb_type i) : first(i < 0 ? -i : i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(signed_limb_type i)
boost::multiprecision::backends::cpp_int_base::data_type::double_first	multiprecision/cpp_int.hpp	/^      double_limb_type double_first;$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
boost::multiprecision::backends::cpp_int_base::data_type::first	multiprecision/cpp_int.hpp	/^      limb_type first;$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
boost::multiprecision::backends::cpp_int_base::data_type::la	multiprecision/cpp_int.hpp	/^      limb_type la[internal_limb_count];$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
boost::multiprecision::backends::cpp_int_base::data_type::ld	multiprecision/cpp_int.hpp	/^      limb_data ld;$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
boost::multiprecision::backends::cpp_int_base::detail::verify_new_size	multiprecision/cpp_int.hpp	/^      detail::verify_new_size(new_size, min_size, checked_type());$/;"	p	class:boost::multiprecision::backends::cpp_int_base::detail	access:public	signature:(new_size, min_size, checked_type())
boost::multiprecision::backends::cpp_int_base::limb_data	multiprecision/cpp_int.hpp	/^   struct limb_data$/;"	s	struct:boost::multiprecision::backends::cpp_int_base	access:private
boost::multiprecision::backends::cpp_int_base::limb_data::capacity	multiprecision/cpp_int.hpp	/^      unsigned capacity;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base::limb_data	access:public
boost::multiprecision::backends::cpp_int_base::limb_data::data	multiprecision/cpp_int.hpp	/^      limb_pointer data;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base::limb_data	access:public
boost::multiprecision::backends::cpp_int_base::limb_pointer	multiprecision/cpp_int.hpp	/^   typedef typename allocator_type::pointer                      limb_pointer;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::m_data	multiprecision/cpp_int.hpp	/^   data_type   m_data;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
boost::multiprecision::backends::cpp_int_base::m_internal	multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(1), m_sign(false), m_internal(true) { }$/;"	f	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(true)
boost::multiprecision::backends::cpp_int_base::m_internal	multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(i > max_limb_value ? 2 : 1), m_sign(false), m_internal(true) { }$/;"	f	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(true)
boost::multiprecision::backends::cpp_int_base::m_internal	multiprecision/cpp_int.hpp	/^   bool        m_sign, m_internal;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
boost::multiprecision::backends::cpp_int_base::m_limbs	multiprecision/cpp_int.hpp	/^   unsigned    m_limbs;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
boost::multiprecision::backends::cpp_int_base::m_sign	multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(1), m_sign(false), m_internal(true) { }$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(false)
boost::multiprecision::backends::cpp_int_base::m_sign	multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(i > max_limb_value ? 2 : 1), m_sign(false), m_internal(true) { }$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(false)
boost::multiprecision::backends::cpp_int_base::m_sign	multiprecision/cpp_int.hpp	/^   bool        m_sign, m_internal;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
boost::multiprecision::backends::cpp_int_base::new_size	multiprecision/cpp_int.hpp	/^         new_size = max_limbs;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::debug_adaptor	multiprecision/debug_adaptor.hpp	/^struct debug_adaptor$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::debug_adaptor::compare	multiprecision/debug_adaptor.hpp	/^   int compare(const T& i)const$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const T& i) const
boost::multiprecision::backends::debug_adaptor::compare	multiprecision/debug_adaptor.hpp	/^   int compare(const debug_adaptor& o)const$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const debug_adaptor& o) const
boost::multiprecision::backends::debug_adaptor::debug_adaptor	multiprecision/debug_adaptor.hpp	/^   debug_adaptor()$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:()
boost::multiprecision::backends::debug_adaptor::debug_adaptor	multiprecision/debug_adaptor.hpp	/^   debug_adaptor(const T& i, const T& j)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const T& i, const T& j)
boost::multiprecision::backends::debug_adaptor::debug_adaptor	multiprecision/debug_adaptor.hpp	/^   debug_adaptor(const T& i, const typename enable_if_c<is_convertible<T, Backend>::value>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const T& i, const typename enable_if_c<is_convertible<T, Backend>::value>::type* = 0)
boost::multiprecision::backends::debug_adaptor::debug_adaptor	multiprecision/debug_adaptor.hpp	/^   debug_adaptor(const debug_adaptor& o) : debug_value(o.debug_value), m_value(o.m_value)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const debug_adaptor& o)
boost::multiprecision::backends::debug_adaptor::debug_value	multiprecision/debug_adaptor.hpp	/^   std::string debug_value;$/;"	m	struct:boost::multiprecision::backends::debug_adaptor	access:private
boost::multiprecision::backends::debug_adaptor::exponent_type	multiprecision/debug_adaptor.hpp	/^      Backend, number_category<Backend>::value>::type  exponent_type;$/;"	t	struct:boost::multiprecision::backends::debug_adaptor	access:public
boost::multiprecision::backends::debug_adaptor::float_types	multiprecision/debug_adaptor.hpp	/^   typedef typename Backend::float_types               float_types;$/;"	t	struct:boost::multiprecision::backends::debug_adaptor	access:public
boost::multiprecision::backends::debug_adaptor::m_value	multiprecision/debug_adaptor.hpp	/^   Backend m_value;$/;"	m	struct:boost::multiprecision::backends::debug_adaptor	access:private
boost::multiprecision::backends::debug_adaptor::negate	multiprecision/debug_adaptor.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:()
boost::multiprecision::backends::debug_adaptor::operator =	multiprecision/debug_adaptor.hpp	/^   debug_adaptor& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const char* s)
boost::multiprecision::backends::debug_adaptor::operator =	multiprecision/debug_adaptor.hpp	/^   debug_adaptor& operator = (const debug_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const debug_adaptor& o)
boost::multiprecision::backends::debug_adaptor::operator =	multiprecision/debug_adaptor.hpp	/^   typename enable_if_c<is_arithmetic<T>::value || is_convertible<T, Backend>::value, debug_adaptor&>::type operator = (const T& i)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const T& i)
boost::multiprecision::backends::debug_adaptor::serialize	multiprecision/debug_adaptor.hpp	/^   void serialize(Archive& ar, const unsigned int \/*version*\/)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(Archive& ar, const unsigned int )
boost::multiprecision::backends::debug_adaptor::signed_types	multiprecision/debug_adaptor.hpp	/^   typedef typename Backend::signed_types              signed_types;$/;"	t	struct:boost::multiprecision::backends::debug_adaptor	access:public
boost::multiprecision::backends::debug_adaptor::str	multiprecision/debug_adaptor.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
boost::multiprecision::backends::debug_adaptor::swap	multiprecision/debug_adaptor.hpp	/^   void swap(debug_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(debug_adaptor& o)
boost::multiprecision::backends::debug_adaptor::unsigned_types	multiprecision/debug_adaptor.hpp	/^   typedef typename Backend::unsigned_types            unsigned_types;$/;"	t	struct:boost::multiprecision::backends::debug_adaptor	access:public
boost::multiprecision::backends::debug_adaptor::update_view	multiprecision/debug_adaptor.hpp	/^   void update_view()$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:()
boost::multiprecision::backends::debug_adaptor::value	multiprecision/debug_adaptor.hpp	/^   Backend& value()$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:()
boost::multiprecision::backends::debug_adaptor::value	multiprecision/debug_adaptor.hpp	/^   const Backend& value()const$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:() const
boost::multiprecision::backends::detail	multiprecision/cpp_int.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
boost::multiprecision::backends::detail	multiprecision/cpp_int/checked.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{ namespace detail{$/;"	n	namespace:boost::multiprecision::backends
boost::multiprecision::backends::detail	multiprecision/detail/dynamic_array.hpp	/^  namespace boost { namespace multiprecision { namespace backends { namespace detail$/;"	n	namespace:boost::multiprecision::backends
boost::multiprecision::backends::detail	multiprecision/detail/rebind.hpp	/^  namespace boost { namespace multiprecision { namespace backends { namespace detail$/;"	n	namespace:boost::multiprecision::backends
boost::multiprecision::backends::detail	multiprecision/gmp.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
boost::multiprecision::backends::detail	multiprecision/mpfi.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
boost::multiprecision::backends::detail	multiprecision/mpfr.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
boost::multiprecision::backends::detail	multiprecision/tommath.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
boost::multiprecision::backends::detail::check_tommath_result	multiprecision/tommath.hpp	/^inline void check_tommath_result(unsigned v)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(unsigned v)
boost::multiprecision::backends::detail::checked_add	multiprecision/cpp_int/checked.hpp	/^inline A checked_add(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
boost::multiprecision::backends::detail::checked_add	multiprecision/cpp_int/checked.hpp	/^inline A checked_add(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
boost::multiprecision::backends::detail::checked_add_imp	multiprecision/cpp_int/checked.hpp	/^inline A checked_add_imp(A a, A b, const mpl::false_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::false_&)
boost::multiprecision::backends::detail::checked_add_imp	multiprecision/cpp_int/checked.hpp	/^inline A checked_add_imp(A a, A b, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::true_&)
boost::multiprecision::backends::detail::checked_divide	multiprecision/cpp_int/checked.hpp	/^inline A checked_divide(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
boost::multiprecision::backends::detail::checked_divide	multiprecision/cpp_int/checked.hpp	/^inline A checked_divide(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
boost::multiprecision::backends::detail::checked_left_shift	multiprecision/cpp_int/checked.hpp	/^inline A checked_left_shift(A a, unsigned long long shift, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, unsigned long long shift, const mpl::int_<checked>&)
boost::multiprecision::backends::detail::checked_left_shift	multiprecision/cpp_int/checked.hpp	/^inline A checked_left_shift(A a, unsigned long long shift, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, unsigned long long shift, const mpl::int_<unchecked>&)
boost::multiprecision::backends::detail::checked_multiply	multiprecision/cpp_int/checked.hpp	/^inline A checked_multiply(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
boost::multiprecision::backends::detail::checked_multiply	multiprecision/cpp_int/checked.hpp	/^inline A checked_multiply(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
boost::multiprecision::backends::detail::checked_subtract	multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
boost::multiprecision::backends::detail::checked_subtract	multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
boost::multiprecision::backends::detail::checked_subtract_imp	multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract_imp(A a, A b, const mpl::false_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::false_&)
boost::multiprecision::backends::detail::checked_subtract_imp	multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract_imp(A a, A b, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::true_&)
boost::multiprecision::backends::detail::dynamic_array	multiprecision/detail/dynamic_array.hpp	/^    struct dynamic_array : public std::vector<value_type, typename rebind<value_type, my_allocator>::type>$/;"	s	namespace:boost::multiprecision::backends::detail	inherits:std::vector
boost::multiprecision::backends::detail::dynamic_array::data	multiprecision/detail/dynamic_array.hpp	/^             value_type* data()       { return &(*(this->begin())); }$/;"	f	struct:boost::multiprecision::backends::detail::dynamic_array	access:public	signature:()
boost::multiprecision::backends::detail::dynamic_array::data	multiprecision/detail/dynamic_array.hpp	/^       const value_type* data() const { return &(*(this->begin())); }$/;"	f	struct:boost::multiprecision::backends::detail::dynamic_array	access:public	signature:() const
boost::multiprecision::backends::detail::dynamic_array::dynamic_array	multiprecision/detail/dynamic_array.hpp	/^       dynamic_array() :$/;"	f	struct:boost::multiprecision::backends::detail::dynamic_array	access:public	signature:()
boost::multiprecision::backends::detail::get_default_precision	multiprecision/mpfr.hpp	/^inline long get_default_precision() { return 50; }$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
boost::multiprecision::backends::detail::gmp_float_imp	multiprecision/gmp.hpp	/^struct gmp_float_imp$/;"	s	namespace:boost::multiprecision::backends::detail
boost::multiprecision::backends::detail::gmp_float_imp::compare	multiprecision/gmp.hpp	/^   typename enable_if<is_arithmetic<V>, int>::type compare(V v)const$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(V v) const
boost::multiprecision::backends::detail::gmp_float_imp::exponent_type	multiprecision/gmp.hpp	/^   typedef long                                      exponent_type;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
boost::multiprecision::backends::detail::gmp_float_imp::float_types	multiprecision/gmp.hpp	/^   typedef mpl::list<double, long double>            float_types;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
boost::multiprecision::backends::detail::gmp_float_imp::gmp_float_imp	multiprecision/gmp.hpp	/^   gmp_float_imp(const gmp_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(const gmp_float_imp& o)
boost::multiprecision::backends::detail::gmp_float_imp::m_data	multiprecision/gmp.hpp	/^   mpf_t m_data;$/;"	m	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:protected
boost::multiprecision::backends::detail::gmp_float_imp::operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(const char* s)
boost::multiprecision::backends::detail::gmp_float_imp::operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (const gmp_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(const gmp_float_imp& o)
boost::multiprecision::backends::detail::gmp_float_imp::operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (double d)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(double d)
boost::multiprecision::backends::detail::gmp_float_imp::operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (long double a)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(long double a)
boost::multiprecision::backends::detail::gmp_float_imp::operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(long i)
boost::multiprecision::backends::detail::gmp_float_imp::operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (long long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(long long i)
boost::multiprecision::backends::detail::gmp_float_imp::operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (unsigned long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(unsigned long i)
boost::multiprecision::backends::detail::gmp_float_imp::operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(unsigned long long i)
boost::multiprecision::backends::detail::gmp_float_imp::signed_types	multiprecision/gmp.hpp	/^   typedef mpl::list<long, long long>                 signed_types;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
boost::multiprecision::backends::detail::gmp_float_imp::str	multiprecision/gmp.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
boost::multiprecision::backends::detail::gmp_float_imp::unsigned_types	multiprecision/gmp.hpp	/^   typedef mpl::list<unsigned long, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
boost::multiprecision::backends::detail::mpfi_float_imp	multiprecision/mpfi.hpp	/^struct mpfi_float_imp$/;"	s	namespace:boost::multiprecision::backends::detail
boost::multiprecision::backends::detail::mpfi_float_imp::exponent_type	multiprecision/mpfi.hpp	/^   typedef long                                           exponent_type;$/;"	t	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public
boost::multiprecision::backends::detail::mpfi_float_imp::float_types	multiprecision/mpfi.hpp	/^   typedef mpl::list<double, long double>                 float_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public
boost::multiprecision::backends::detail::mpfi_float_imp::m_data	multiprecision/mpfi.hpp	/^   mpfi_t m_data;$/;"	m	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:protected
boost::multiprecision::backends::detail::mpfi_float_imp::mpfi_float_imp	multiprecision/mpfi.hpp	/^   mpfi_float_imp()$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:()
boost::multiprecision::backends::detail::mpfi_float_imp::mpfi_float_imp	multiprecision/mpfi.hpp	/^   mpfi_float_imp(const mpfi_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(const mpfi_float_imp& o)
boost::multiprecision::backends::detail::mpfi_float_imp::mpfi_float_imp	multiprecision/mpfi.hpp	/^   mpfi_float_imp(unsigned prec)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(unsigned prec)
boost::multiprecision::backends::detail::mpfi_float_imp::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(const char* s)
boost::multiprecision::backends::detail::mpfi_float_imp::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (const mpfi_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(const mpfi_float_imp& o)
boost::multiprecision::backends::detail::mpfi_float_imp::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (double d)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(double d)
boost::multiprecision::backends::detail::mpfi_float_imp::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (long double a)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(long double a)
boost::multiprecision::backends::detail::mpfi_float_imp::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(long i)
boost::multiprecision::backends::detail::mpfi_float_imp::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (long long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(long long i)
boost::multiprecision::backends::detail::mpfi_float_imp::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (unsigned long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(unsigned long i)
boost::multiprecision::backends::detail::mpfi_float_imp::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(unsigned long long i)
boost::multiprecision::backends::detail::mpfi_float_imp::signed_types	multiprecision/mpfi.hpp	/^   typedef mpl::list<long, long long>                     signed_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public
boost::multiprecision::backends::detail::mpfi_float_imp::str	multiprecision/mpfi.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
boost::multiprecision::backends::detail::mpfi_float_imp::unsigned_types	multiprecision/mpfi.hpp	/^   typedef mpl::list<unsigned long, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public
boost::multiprecision::backends::detail::mpfi_sgn	multiprecision/mpfi.hpp	/^inline int mpfi_sgn(mpfi_srcptr p)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(mpfi_srcptr p)
boost::multiprecision::backends::detail::mpfr_cleanup	multiprecision/mpfr.hpp	/^struct mpfr_cleanup$/;"	s	namespace:boost::multiprecision::backends::detail
boost::multiprecision::backends::detail::mpfr_cleanup::force_instantiate	multiprecision/mpfr.hpp	/^   static void force_instantiate() { init.force_instantiate(); }$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_cleanup	access:public	signature:()
boost::multiprecision::backends::detail::mpfr_cleanup::init	multiprecision/mpfr.hpp	/^   static const initializer init;$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_cleanup	access:public
boost::multiprecision::backends::detail::mpfr_cleanup::initializer	multiprecision/mpfr.hpp	/^   struct initializer$/;"	s	struct:boost::multiprecision::backends::detail::mpfr_cleanup	access:public
boost::multiprecision::backends::detail::mpfr_cleanup::initializer::force_instantiate	multiprecision/mpfr.hpp	/^      void force_instantiate()const {}$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_cleanup::initializer	access:public	signature:() const
boost::multiprecision::backends::detail::mpfr_cleanup::initializer::initializer	multiprecision/mpfr.hpp	/^      initializer() {}$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_cleanup::initializer	access:public	signature:()
boost::multiprecision::backends::detail::mpfr_cleanup::initializer::~initializer	multiprecision/mpfr.hpp	/^      ~initializer(){ mpfr_free_cache(); }$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_cleanup::initializer	access:public	signature:()
boost::multiprecision::backends::detail::mpfr_cleanup::mpfr_cleanup::init	multiprecision/mpfr.hpp	/^typename mpfr_cleanup<b>::initializer const mpfr_cleanup<b>::init;$/;"	m	class:boost::multiprecision::backends::detail::mpfr_cleanup::mpfr_cleanup
boost::multiprecision::backends::detail::mpfr_float_imp	multiprecision/mpfr.hpp	/^struct mpfr_float_imp<digits10, allocate_dynamic>$/;"	s	namespace:boost::multiprecision::backends::detail
boost::multiprecision::backends::detail::mpfr_float_imp	multiprecision/mpfr.hpp	/^struct mpfr_float_imp<digits10, allocate_stack>$/;"	s	namespace:boost::multiprecision::backends::detail
boost::multiprecision::backends::detail::mpfr_float_imp::digits2	multiprecision/mpfr.hpp	/^   static const unsigned digits2 = (digits10 * 1000uL) \/ 301uL + ((digits10 * 1000uL) % 301 ? 2u : 1u);$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
boost::multiprecision::backends::detail::mpfr_float_imp::exponent_type	multiprecision/mpfr.hpp	/^   typedef long                                           exponent_type;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
boost::multiprecision::backends::detail::mpfr_float_imp::float_types	multiprecision/mpfr.hpp	/^   typedef mpl::list<double, long double>                 float_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
boost::multiprecision::backends::detail::mpfr_float_imp::limb_count	multiprecision/mpfr.hpp	/^   static const unsigned limb_count = mpfr_custom_get_size(digits2) \/ sizeof(mp_limb_t);$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
boost::multiprecision::backends::detail::mpfr_float_imp::m_buffer	multiprecision/mpfr.hpp	/^   mp_limb_t m_buffer[limb_count];$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:protected
boost::multiprecision::backends::detail::mpfr_float_imp::m_data	multiprecision/mpfr.hpp	/^   mpfr_t m_data;$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:protected
boost::multiprecision::backends::detail::mpfr_float_imp::mpfr_float_imp	multiprecision/mpfr.hpp	/^   mpfr_float_imp()$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:()
boost::multiprecision::backends::detail::mpfr_float_imp::mpfr_float_imp	multiprecision/mpfr.hpp	/^   mpfr_float_imp(const mpfr_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(const mpfr_float_imp& o)
boost::multiprecision::backends::detail::mpfr_float_imp::mpfr_float_imp	multiprecision/mpfr.hpp	/^   mpfr_float_imp(unsigned prec)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(unsigned prec)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(const char* s)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (const mpfr_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(const mpfr_float_imp& o)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (double d)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(double d)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (long double a)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(long double a)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(long i)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (long long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(long long i)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (unsigned long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(unsigned long i)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(unsigned long long i)
boost::multiprecision::backends::detail::mpfr_float_imp::signed_types	multiprecision/mpfr.hpp	/^   typedef mpl::list<long, long long>                     signed_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
boost::multiprecision::backends::detail::mpfr_float_imp::str	multiprecision/mpfr.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
boost::multiprecision::backends::detail::mpfr_float_imp::unsigned_types	multiprecision/mpfr.hpp	/^   typedef mpl::list<unsigned long, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
boost::multiprecision::backends::detail::raise_add_overflow	multiprecision/cpp_int/checked.hpp	/^inline void raise_add_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
boost::multiprecision::backends::detail::raise_div_overflow	multiprecision/cpp_int/checked.hpp	/^inline void raise_div_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
boost::multiprecision::backends::detail::raise_mul_overflow	multiprecision/cpp_int/checked.hpp	/^inline void raise_mul_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
boost::multiprecision::backends::detail::raise_overflow	multiprecision/cpp_int/checked.hpp	/^inline void raise_overflow(std::string op)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(std::string op)
boost::multiprecision::backends::detail::raise_subtract_overflow	multiprecision/cpp_int/checked.hpp	/^inline void raise_subtract_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
boost::multiprecision::backends::detail::rebind	multiprecision/detail/rebind.hpp	/^    struct rebind$/;"	s	namespace:boost::multiprecision::backends::detail
boost::multiprecision::backends::detail::rebind::type	multiprecision/detail/rebind.hpp	/^       typedef typename my_allocator::template rebind<value_type>::other type;$/;"	t	struct:boost::multiprecision::backends::detail::rebind	access:public
boost::multiprecision::backends::detail::verify_limb_mask	multiprecision/cpp_int.hpp	/^inline void verify_limb_mask(bool \/*b*\/, U \/*limb*\/, U \/*mask*\/, const mpl::int_<unchecked>&){}$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(bool , U , U , const mpl::int_<unchecked>&)
boost::multiprecision::backends::detail::verify_limb_mask	multiprecision/cpp_int.hpp	/^inline void verify_limb_mask(bool b, U limb, U mask, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(bool b, U limb, U mask, const mpl::int_<checked>&)
boost::multiprecision::backends::detail::verify_new_size	multiprecision/cpp_int.hpp	/^inline void verify_new_size(unsigned \/*new_size*\/, unsigned \/*min_size*\/, const mpl::int_<unchecked>&){}$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(unsigned , unsigned , const mpl::int_<unchecked>&)
boost::multiprecision::backends::detail::verify_new_size	multiprecision/cpp_int.hpp	/^inline void verify_new_size(unsigned new_size, unsigned min_size, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(unsigned new_size, unsigned min_size, const mpl::int_<checked>&)
boost::multiprecision::backends::divide_unsigned_helper	multiprecision/cpp_int/divide.hpp	/^void divide_unsigned_helper($/;"	f	namespace:boost::multiprecision::backends	signature:( CppInt1* result, const CppInt2& x, const CppInt3& y, CppInt1& r)
boost::multiprecision::backends::divide_unsigned_helper	multiprecision/cpp_int/divide.hpp	/^void divide_unsigned_helper($/;"	f	namespace:boost::multiprecision::backends	signature:( CppInt1* result, const CppInt2& x, limb_type y, CppInt1& r)
boost::multiprecision::backends::eval_abs	multiprecision/cpp_dec_float.hpp	/^inline void eval_abs(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x) $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
boost::multiprecision::backends::eval_abs	multiprecision/float128.hpp	/^inline void eval_abs(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_abs	multiprecision/mpfr.hpp	/^inline void eval_abs(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
boost::multiprecision::backends::eval_abs	multiprecision/tommath.hpp	/^inline void eval_abs(tommath_int& result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& val)
boost::multiprecision::backends::eval_acos	multiprecision/float128.hpp	/^inline void eval_acos(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_add	multiprecision/cpp_dec_float.hpp	/^inline void eval_add(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
boost::multiprecision::backends::eval_add	multiprecision/cpp_dec_float.hpp	/^inline void eval_add(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
boost::multiprecision::backends::eval_add	multiprecision/cpp_dec_float.hpp	/^inline void eval_add(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
boost::multiprecision::backends::eval_add	multiprecision/float128.hpp	/^inline void eval_add(float128_backend& result, const A& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const A& a)
boost::multiprecision::backends::eval_add	multiprecision/float128.hpp	/^inline void eval_add(float128_backend& result, const float128_backend& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a)
boost::multiprecision::backends::eval_add	multiprecision/float128.hpp	/^inline void eval_add(float128_backend& result, const float128_backend& a, const A& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const A& b)
boost::multiprecision::backends::eval_add	multiprecision/float128.hpp	/^inline void eval_add(float128_backend& result, const float128_backend& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const float128_backend& b)
boost::multiprecision::backends::eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
boost::multiprecision::backends::eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
boost::multiprecision::backends::eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
boost::multiprecision::backends::eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
boost::multiprecision::backends::eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
boost::multiprecision::backends::eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
boost::multiprecision::backends::eval_add	multiprecision/rational_adaptor.hpp	/^inline void eval_add(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)
boost::multiprecision::backends::eval_add	multiprecision/tommath.hpp	/^inline void eval_add(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
boost::multiprecision::backends::eval_add	multiprecision/tommath.hpp	/^inline void eval_add(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
boost::multiprecision::backends::eval_add	multiprecision/tommath.hpp	/^void eval_add(tommath_int& t, const tommath_int& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
boost::multiprecision::backends::eval_asin	multiprecision/float128.hpp	/^inline void eval_asin(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_atan	multiprecision/float128.hpp	/^inline void eval_atan(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_atan2	multiprecision/float128.hpp	/^inline void eval_atan2(float128_backend& result, const float128_backend& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const float128_backend& b)
boost::multiprecision::backends::eval_bit_flip	multiprecision/cpp_int/misc.hpp	/^   eval_bit_flip(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)
boost::multiprecision::backends::eval_bit_flip	multiprecision/debug_adaptor.hpp	/^inline void eval_bit_flip(const debug_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg, unsigned a)
boost::multiprecision::backends::eval_bit_flip	multiprecision/logged_adaptor.hpp	/^inline void eval_bit_flip(const logged_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg, unsigned a)
boost::multiprecision::backends::eval_bit_set	multiprecision/cpp_int/misc.hpp	/^   eval_bit_set(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)
boost::multiprecision::backends::eval_bit_set	multiprecision/debug_adaptor.hpp	/^inline void eval_bit_set(const debug_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg, unsigned a)
boost::multiprecision::backends::eval_bit_set	multiprecision/logged_adaptor.hpp	/^inline void eval_bit_set(const logged_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg, unsigned a)
boost::multiprecision::backends::eval_bit_test	multiprecision/debug_adaptor.hpp	/^inline bool eval_bit_test(const debug_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg, unsigned a)
boost::multiprecision::backends::eval_bit_test	multiprecision/logged_adaptor.hpp	/^inline bool eval_bit_test(const logged_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg, unsigned a)
boost::multiprecision::backends::eval_bit_unset	multiprecision/debug_adaptor.hpp	/^inline void eval_bit_unset(const debug_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg, unsigned a)
boost::multiprecision::backends::eval_bit_unset	multiprecision/logged_adaptor.hpp	/^inline void eval_bit_unset(const logged_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg, unsigned a)
boost::multiprecision::backends::eval_bitwise_and	multiprecision/tommath.hpp	/^inline void eval_bitwise_and(tommath_int& result, const tommath_int& u, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& u, const tommath_int& v)
boost::multiprecision::backends::eval_bitwise_and	multiprecision/tommath.hpp	/^inline void eval_bitwise_and(tommath_int& result, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& v)
boost::multiprecision::backends::eval_bitwise_or	multiprecision/tommath.hpp	/^inline void eval_bitwise_or(tommath_int& result, const tommath_int& u, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& u, const tommath_int& v)
boost::multiprecision::backends::eval_bitwise_or	multiprecision/tommath.hpp	/^inline void eval_bitwise_or(tommath_int& result, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& v)
boost::multiprecision::backends::eval_bitwise_xor	multiprecision/tommath.hpp	/^inline void eval_bitwise_xor(tommath_int& result, const tommath_int& u, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& u, const tommath_int& v)
boost::multiprecision::backends::eval_bitwise_xor	multiprecision/tommath.hpp	/^inline void eval_bitwise_xor(tommath_int& result, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& v)
boost::multiprecision::backends::eval_ceil	multiprecision/cpp_dec_float.hpp	/^inline void eval_ceil(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
boost::multiprecision::backends::eval_ceil	multiprecision/float128.hpp	/^inline void eval_ceil(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_ceil	multiprecision/mpfr.hpp	/^inline void eval_ceil(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
boost::multiprecision::backends::eval_convert_to	multiprecision/cpp_dec_float.hpp	/^inline void eval_convert_to(long double* result, cpp_dec_float<Digits10, ExponentType, Allocator>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(long double* result, cpp_dec_float<Digits10, ExponentType, Allocator>& val)
boost::multiprecision::backends::eval_convert_to	multiprecision/cpp_dec_float.hpp	/^inline void eval_convert_to(long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)  $/;"	f	namespace:boost::multiprecision::backends	signature:(long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
boost::multiprecision::backends::eval_convert_to	multiprecision/cpp_dec_float.hpp	/^inline void eval_convert_to(unsigned long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)  $/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
boost::multiprecision::backends::eval_convert_to	multiprecision/debug_adaptor.hpp	/^inline void eval_convert_to(R* result, const debug_adaptor<Backend>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(R* result, const debug_adaptor<Backend>& val)
boost::multiprecision::backends::eval_convert_to	multiprecision/float128.hpp	/^inline void eval_convert_to(R* result, const float128_backend& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(R* result, const float128_backend& val)
boost::multiprecision::backends::eval_convert_to	multiprecision/logged_adaptor.hpp	/^inline void eval_convert_to(R* result, const logged_adaptor<Backend>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(R* result, const logged_adaptor<Backend>& val)
boost::multiprecision::backends::eval_convert_to	multiprecision/mpfr.hpp	/^inline void eval_convert_to(long long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(long long* result, const mpfr_float_backend<digits10, AllocationType>& val)
boost::multiprecision::backends::eval_convert_to	multiprecision/mpfr.hpp	/^inline void eval_convert_to(long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(long* result, const mpfr_float_backend<digits10, AllocationType>& val)
boost::multiprecision::backends::eval_convert_to	multiprecision/mpfr.hpp	/^inline void eval_convert_to(unsigned long long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned long long* result, const mpfr_float_backend<digits10, AllocationType>& val)
boost::multiprecision::backends::eval_convert_to	multiprecision/mpfr.hpp	/^inline void eval_convert_to(unsigned long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned long* result, const mpfr_float_backend<digits10, AllocationType>& val)
boost::multiprecision::backends::eval_convert_to	multiprecision/rational_adaptor.hpp	/^inline void eval_convert_to(R* result, const rational_adaptor<IntBackend>& backend)$/;"	f	namespace:boost::multiprecision::backends	signature:(R* result, const rational_adaptor<IntBackend>& backend)
boost::multiprecision::backends::eval_convert_to	multiprecision/tommath.hpp	/^inline void eval_convert_to(A* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(A* result, const tommath_int& val)
boost::multiprecision::backends::eval_convert_to	multiprecision/tommath.hpp	/^inline void eval_convert_to(char* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(char* result, const tommath_int& val)
boost::multiprecision::backends::eval_convert_to	multiprecision/tommath.hpp	/^inline void eval_convert_to(signed char* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(signed char* result, const tommath_int& val)
boost::multiprecision::backends::eval_convert_to	multiprecision/tommath.hpp	/^inline void eval_convert_to(unsigned char* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned char* result, const tommath_int& val)
boost::multiprecision::backends::eval_cos	multiprecision/float128.hpp	/^inline void eval_cos(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_cosh	multiprecision/float128.hpp	/^inline void eval_cosh(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_decrement	multiprecision/float128.hpp	/^inline void eval_decrement(float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& arg)
boost::multiprecision::backends::eval_divide	multiprecision/cpp_dec_float.hpp	/^inline void eval_divide(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
boost::multiprecision::backends::eval_divide	multiprecision/cpp_dec_float.hpp	/^inline void eval_divide(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
boost::multiprecision::backends::eval_divide	multiprecision/cpp_dec_float.hpp	/^inline void eval_divide(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
boost::multiprecision::backends::eval_divide	multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o)
boost::multiprecision::backends::eval_divide	multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b)
boost::multiprecision::backends::eval_divide	multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, limb_type& b)
boost::multiprecision::backends::eval_divide	multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, signed_limb_type& b)
boost::multiprecision::backends::eval_divide	multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& b)
boost::multiprecision::backends::eval_divide	multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, limb_type b)
boost::multiprecision::backends::eval_divide	multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, signed_limb_type b)
boost::multiprecision::backends::eval_divide	multiprecision/float128.hpp	/^inline void eval_divide(float128_backend& result, const A& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const A& a)
boost::multiprecision::backends::eval_divide	multiprecision/float128.hpp	/^inline void eval_divide(float128_backend& result, const float128_backend& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a)
boost::multiprecision::backends::eval_divide	multiprecision/float128.hpp	/^inline void eval_divide(float128_backend& result, const float128_backend& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const float128_backend& b)
boost::multiprecision::backends::eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
boost::multiprecision::backends::eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
boost::multiprecision::backends::eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
boost::multiprecision::backends::eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
boost::multiprecision::backends::eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
boost::multiprecision::backends::eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
boost::multiprecision::backends::eval_divide	multiprecision/rational_adaptor.hpp	/^inline void eval_divide(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)
boost::multiprecision::backends::eval_divide	multiprecision/tommath.hpp	/^inline void eval_divide(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
boost::multiprecision::backends::eval_divide	multiprecision/tommath.hpp	/^inline void eval_divide(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
boost::multiprecision::backends::eval_exp	multiprecision/float128.hpp	/^inline void eval_exp(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_fabs	multiprecision/cpp_dec_float.hpp	/^inline void eval_fabs(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x) $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
boost::multiprecision::backends::eval_fabs	multiprecision/float128.hpp	/^inline void eval_fabs(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_fabs	multiprecision/mpfr.hpp	/^inline void eval_fabs(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
boost::multiprecision::backends::eval_floor	multiprecision/cpp_dec_float.hpp	/^inline void eval_floor(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
boost::multiprecision::backends::eval_floor	multiprecision/float128.hpp	/^inline void eval_floor(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_floor	multiprecision/mpfr.hpp	/^inline void eval_floor(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
boost::multiprecision::backends::eval_fmod	multiprecision/float128.hpp	/^inline void eval_fmod(float128_backend& result, const float128_backend& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const float128_backend& b)
boost::multiprecision::backends::eval_fpclassify	multiprecision/cpp_dec_float.hpp	/^inline int eval_fpclassify(const cpp_dec_float<Digits10, ExponentType, Allocator>& x) $/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
boost::multiprecision::backends::eval_fpclassify	multiprecision/debug_adaptor.hpp	/^inline int eval_fpclassify(const debug_adaptor<Backend>& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg)
boost::multiprecision::backends::eval_fpclassify	multiprecision/float128.hpp	/^inline int eval_fpclassify(const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(const float128_backend& arg)
boost::multiprecision::backends::eval_fpclassify	multiprecision/logged_adaptor.hpp	/^inline int eval_fpclassify(const logged_adaptor<Backend>& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg)
boost::multiprecision::backends::eval_frexp	multiprecision/cpp_dec_float.hpp	/^inline typename disable_if<is_same<ExponentType, int> >::type eval_frexp(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, int* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, int* e)
boost::multiprecision::backends::eval_frexp	multiprecision/cpp_dec_float.hpp	/^inline void eval_frexp(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ExponentType* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ExponentType* e)
boost::multiprecision::backends::eval_frexp	multiprecision/debug_adaptor.hpp	/^inline void eval_frexp(debug_adaptor<Backend>& result, const debug_adaptor<Backend>& arg, Exp* exp)$/;"	f	namespace:boost::multiprecision::backends	signature:(debug_adaptor<Backend>& result, const debug_adaptor<Backend>& arg, Exp* exp)
boost::multiprecision::backends::eval_frexp	multiprecision/float128.hpp	/^inline void eval_frexp(float128_backend& result, const float128_backend& arg, int* exp)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg, int* exp)
boost::multiprecision::backends::eval_frexp	multiprecision/logged_adaptor.hpp	/^inline void eval_frexp(logged_adaptor<Backend>& result, const logged_adaptor<Backend>& arg, Exp* exp)$/;"	f	namespace:boost::multiprecision::backends	signature:(logged_adaptor<Backend>& result, const logged_adaptor<Backend>& arg, Exp* exp)
boost::multiprecision::backends::eval_frexp	multiprecision/mpfr.hpp	/^inline void eval_frexp(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, int* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, int* e)
boost::multiprecision::backends::eval_frexp	multiprecision/mpfr.hpp	/^inline void eval_frexp(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long* e)
boost::multiprecision::backends::eval_gcd	multiprecision/cpp_int/misc.hpp	/^   eval_gcd($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a, limb_type v)
boost::multiprecision::backends::eval_gcd	multiprecision/tommath.hpp	/^inline void eval_gcd(tommath_int& result, const tommath_int& a, const tommath_int& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& a, const tommath_int& b)
boost::multiprecision::backends::eval_get_sign	multiprecision/cpp_dec_float.hpp	/^inline int eval_get_sign(const cpp_dec_float<Digits10, ExponentType, Allocator>& val) $/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
boost::multiprecision::backends::eval_get_sign	multiprecision/rational_adaptor.hpp	/^inline int eval_get_sign(const rational_adaptor<IntBackend>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const rational_adaptor<IntBackend>& val)
boost::multiprecision::backends::eval_get_sign	multiprecision/tommath.hpp	/^inline int eval_get_sign(const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
boost::multiprecision::backends::eval_get_sign	multiprecision/tommath.hpp	/^int eval_get_sign(const tommath_int& val);$/;"	p	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
boost::multiprecision::backends::eval_increment	multiprecision/float128.hpp	/^inline void eval_increment(float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& arg)
boost::multiprecision::backends::eval_integer_modulus	multiprecision/cpp_int/misc.hpp	/^   eval_integer_modulus(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& x, Integer val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& x, Integer val)
boost::multiprecision::backends::eval_integer_modulus	multiprecision/debug_adaptor.hpp	/^inline unsigned eval_integer_modulus(const debug_adaptor<Backend>& arg, const T& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg, const T& a)
boost::multiprecision::backends::eval_integer_modulus	multiprecision/logged_adaptor.hpp	/^inline unsigned eval_integer_modulus(const logged_adaptor<Backend>& arg, const T& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg, const T& a)
boost::multiprecision::backends::eval_integer_modulus	multiprecision/tommath.hpp	/^inline typename enable_if<is_signed<Integer>, Integer>::type eval_integer_modulus(const tommath_int& x, Integer val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& x, Integer val)
boost::multiprecision::backends::eval_integer_modulus	multiprecision/tommath.hpp	/^inline typename enable_if<is_unsigned<Integer>, Integer>::type eval_integer_modulus(const tommath_int& x, Integer val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& x, Integer val)
boost::multiprecision::backends::eval_is_zero	multiprecision/cpp_dec_float.hpp	/^inline bool eval_is_zero(const cpp_dec_float<Digits10, ExponentType, Allocator>& val) $/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
boost::multiprecision::backends::eval_is_zero	multiprecision/rational_adaptor.hpp	/^inline bool eval_is_zero(const rational_adaptor<IntBackend>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const rational_adaptor<IntBackend>& val)
boost::multiprecision::backends::eval_is_zero	multiprecision/tommath.hpp	/^inline bool eval_is_zero(const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
boost::multiprecision::backends::eval_lcm	multiprecision/tommath.hpp	/^inline void eval_lcm(tommath_int& result, const tommath_int& a, const tommath_int& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& a, const tommath_int& b)
boost::multiprecision::backends::eval_ldexp	multiprecision/cpp_dec_float.hpp	/^inline void eval_ldexp(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ArgType e)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ArgType e)
boost::multiprecision::backends::eval_ldexp	multiprecision/debug_adaptor.hpp	/^inline void eval_ldexp(debug_adaptor<Backend>& result, const debug_adaptor<Backend>& arg, Exp exp)$/;"	f	namespace:boost::multiprecision::backends	signature:(debug_adaptor<Backend>& result, const debug_adaptor<Backend>& arg, Exp exp)
boost::multiprecision::backends::eval_ldexp	multiprecision/float128.hpp	/^inline void eval_ldexp(float128_backend& result, const float128_backend& arg, int exp)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg, int exp)
boost::multiprecision::backends::eval_ldexp	multiprecision/logged_adaptor.hpp	/^inline void eval_ldexp(logged_adaptor<Backend>& result, const logged_adaptor<Backend>& arg, Exp exp)$/;"	f	namespace:boost::multiprecision::backends	signature:(logged_adaptor<Backend>& result, const logged_adaptor<Backend>& arg, Exp exp)
boost::multiprecision::backends::eval_ldexp	multiprecision/mpfr.hpp	/^inline void eval_ldexp(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long e)
boost::multiprecision::backends::eval_left_shift	multiprecision/debug_adaptor.hpp	/^inline void eval_left_shift(debug_adaptor<Backend>& arg, const debug_adaptor<Backend>& a, unsigned b)$/;"	f	namespace:boost::multiprecision::backends	signature:(debug_adaptor<Backend>& arg, const debug_adaptor<Backend>& a, unsigned b)
boost::multiprecision::backends::eval_left_shift	multiprecision/debug_adaptor.hpp	/^inline void eval_left_shift(debug_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(debug_adaptor<Backend>& arg, unsigned a)
boost::multiprecision::backends::eval_left_shift	multiprecision/logged_adaptor.hpp	/^inline void eval_left_shift(logged_adaptor<Backend>& arg, const logged_adaptor<Backend>& a, unsigned b)$/;"	f	namespace:boost::multiprecision::backends	signature:(logged_adaptor<Backend>& arg, const logged_adaptor<Backend>& a, unsigned b)
boost::multiprecision::backends::eval_left_shift	multiprecision/logged_adaptor.hpp	/^inline void eval_left_shift(logged_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(logged_adaptor<Backend>& arg, unsigned a)
boost::multiprecision::backends::eval_left_shift	multiprecision/tommath.hpp	/^inline void eval_left_shift(tommath_int& t, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, UI i)
boost::multiprecision::backends::eval_left_shift	multiprecision/tommath.hpp	/^inline void eval_left_shift(tommath_int& t, const tommath_int& v, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& v, UI i)
boost::multiprecision::backends::eval_log	multiprecision/float128.hpp	/^inline void eval_log(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_log10	multiprecision/float128.hpp	/^inline void eval_log10(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_lsb	multiprecision/cpp_int/misc.hpp	/^   eval_lsb(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)
boost::multiprecision::backends::eval_lsb	multiprecision/debug_adaptor.hpp	/^inline unsigned eval_lsb(const debug_adaptor<Backend>& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg)
boost::multiprecision::backends::eval_lsb	multiprecision/logged_adaptor.hpp	/^inline unsigned eval_lsb(const logged_adaptor<Backend>& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg)
boost::multiprecision::backends::eval_lsb	multiprecision/tommath.hpp	/^inline unsigned eval_lsb(const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
boost::multiprecision::backends::eval_modulus	multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o)
boost::multiprecision::backends::eval_modulus	multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b)
boost::multiprecision::backends::eval_modulus	multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, limb_type b)
boost::multiprecision::backends::eval_modulus	multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, signed_limb_type b)
boost::multiprecision::backends::eval_modulus	multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& b)
boost::multiprecision::backends::eval_modulus	multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, limb_type b)
boost::multiprecision::backends::eval_modulus	multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, signed_limb_type b)
boost::multiprecision::backends::eval_modulus	multiprecision/tommath.hpp	/^inline void eval_modulus(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
boost::multiprecision::backends::eval_modulus	multiprecision/tommath.hpp	/^inline void eval_modulus(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
boost::multiprecision::backends::eval_msb	multiprecision/cpp_int/misc.hpp	/^   eval_msb(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)
boost::multiprecision::backends::eval_msb	multiprecision/debug_adaptor.hpp	/^inline unsigned eval_msb(const debug_adaptor<Backend>& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg)
boost::multiprecision::backends::eval_msb	multiprecision/logged_adaptor.hpp	/^inline unsigned eval_msb(const logged_adaptor<Backend>& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg)
boost::multiprecision::backends::eval_msb	multiprecision/tommath.hpp	/^inline unsigned eval_msb(const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
boost::multiprecision::backends::eval_multiply	multiprecision/cpp_dec_float.hpp	/^inline void eval_multiply(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
boost::multiprecision::backends::eval_multiply	multiprecision/cpp_dec_float.hpp	/^inline void eval_multiply(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
boost::multiprecision::backends::eval_multiply	multiprecision/cpp_dec_float.hpp	/^inline void eval_multiply(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
boost::multiprecision::backends::eval_multiply	multiprecision/cpp_int/multiply.hpp	/^   eval_multiply($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> const& a, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> const& b)
boost::multiprecision::backends::eval_multiply	multiprecision/cpp_int/multiply.hpp	/^   eval_multiply($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, double_limb_type a, double_limb_type b)
boost::multiprecision::backends::eval_multiply	multiprecision/cpp_int/multiply.hpp	/^   eval_multiply($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, signed_double_limb_type a, signed_double_limb_type b)
boost::multiprecision::backends::eval_multiply	multiprecision/float128.hpp	/^inline void eval_multiply(float128_backend& result, const A& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const A& a)
boost::multiprecision::backends::eval_multiply	multiprecision/float128.hpp	/^inline void eval_multiply(float128_backend& result, const float128_backend& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a)
boost::multiprecision::backends::eval_multiply	multiprecision/float128.hpp	/^inline void eval_multiply(float128_backend& result, const float128_backend& a, const A& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const A& b)
boost::multiprecision::backends::eval_multiply	multiprecision/float128.hpp	/^inline void eval_multiply(float128_backend& result, const float128_backend& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const float128_backend& b)
boost::multiprecision::backends::eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
boost::multiprecision::backends::eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
boost::multiprecision::backends::eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
boost::multiprecision::backends::eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
boost::multiprecision::backends::eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
boost::multiprecision::backends::eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
boost::multiprecision::backends::eval_multiply	multiprecision/rational_adaptor.hpp	/^inline void eval_multiply(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)
boost::multiprecision::backends::eval_multiply	multiprecision/tommath.hpp	/^inline void eval_multiply(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
boost::multiprecision::backends::eval_multiply	multiprecision/tommath.hpp	/^inline void eval_multiply(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
boost::multiprecision::backends::eval_multiply	multiprecision/tommath.hpp	/^void eval_multiply(tommath_int& t, const tommath_int& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
boost::multiprecision::backends::eval_pow	multiprecision/float128.hpp	/^inline void eval_pow(float128_backend& result, const float128_backend& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const float128_backend& b)
boost::multiprecision::backends::eval_pow	multiprecision/mpfr.hpp	/^inline void eval_pow(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& b, const mpfr_float_backend<Digits10, AllocateType>& e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& b, const mpfr_float_backend<Digits10, AllocateType>& e)
boost::multiprecision::backends::eval_powm	multiprecision/tommath.hpp	/^inline void eval_powm(tommath_int& result, const tommath_int& base, const tommath_int& p, const tommath_int& m)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& base, const tommath_int& p, const tommath_int& m)
boost::multiprecision::backends::eval_qr	multiprecision/tommath.hpp	/^inline void eval_qr(const tommath_int& x, const tommath_int& y, $/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& x, const tommath_int& y, tommath_int& q, tommath_int& r)
boost::multiprecision::backends::eval_right_shift	multiprecision/debug_adaptor.hpp	/^inline void eval_right_shift(debug_adaptor<Backend>& arg, const debug_adaptor<Backend>& a, unsigned b)$/;"	f	namespace:boost::multiprecision::backends	signature:(debug_adaptor<Backend>& arg, const debug_adaptor<Backend>& a, unsigned b)
boost::multiprecision::backends::eval_right_shift	multiprecision/debug_adaptor.hpp	/^inline void eval_right_shift(debug_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(debug_adaptor<Backend>& arg, unsigned a)
boost::multiprecision::backends::eval_right_shift	multiprecision/logged_adaptor.hpp	/^inline void eval_right_shift(logged_adaptor<Backend>& arg, const logged_adaptor<Backend>& a, unsigned b)$/;"	f	namespace:boost::multiprecision::backends	signature:(logged_adaptor<Backend>& arg, const logged_adaptor<Backend>& a, unsigned b)
boost::multiprecision::backends::eval_right_shift	multiprecision/logged_adaptor.hpp	/^inline void eval_right_shift(logged_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(logged_adaptor<Backend>& arg, unsigned a)
boost::multiprecision::backends::eval_right_shift	multiprecision/tommath.hpp	/^inline void eval_right_shift(tommath_int& t, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, UI i)
boost::multiprecision::backends::eval_right_shift	multiprecision/tommath.hpp	/^inline void eval_right_shift(tommath_int& t, const tommath_int& v, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& v, UI i)
boost::multiprecision::backends::eval_sin	multiprecision/float128.hpp	/^inline void eval_sin(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_sinh	multiprecision/float128.hpp	/^inline void eval_sinh(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_sqrt	multiprecision/cpp_dec_float.hpp	/^inline void eval_sqrt(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
boost::multiprecision::backends::eval_sqrt	multiprecision/float128.hpp	/^inline void eval_sqrt(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_sqrt	multiprecision/mpfr.hpp	/^inline void eval_sqrt(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
boost::multiprecision::backends::eval_subtract	multiprecision/cpp_dec_float.hpp	/^inline void eval_subtract(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
boost::multiprecision::backends::eval_subtract	multiprecision/cpp_dec_float.hpp	/^inline void eval_subtract(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
boost::multiprecision::backends::eval_subtract	multiprecision/cpp_dec_float.hpp	/^inline void eval_subtract(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
boost::multiprecision::backends::eval_subtract	multiprecision/float128.hpp	/^inline void eval_subtract(float128_backend& result, const A& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const A& a)
boost::multiprecision::backends::eval_subtract	multiprecision/float128.hpp	/^inline void eval_subtract(float128_backend& result, const A& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const A& a, const float128_backend& b)
boost::multiprecision::backends::eval_subtract	multiprecision/float128.hpp	/^inline void eval_subtract(float128_backend& result, const float128_backend& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a)
boost::multiprecision::backends::eval_subtract	multiprecision/float128.hpp	/^inline void eval_subtract(float128_backend& result, const float128_backend& a, const A& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const A& b)
boost::multiprecision::backends::eval_subtract	multiprecision/float128.hpp	/^inline void eval_subtract(float128_backend& result, const float128_backend& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const float128_backend& b)
boost::multiprecision::backends::eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
boost::multiprecision::backends::eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
boost::multiprecision::backends::eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
boost::multiprecision::backends::eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
boost::multiprecision::backends::eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
boost::multiprecision::backends::eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
boost::multiprecision::backends::eval_subtract	multiprecision/rational_adaptor.hpp	/^inline void eval_subtract(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)
boost::multiprecision::backends::eval_subtract	multiprecision/tommath.hpp	/^inline void eval_subtract(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
boost::multiprecision::backends::eval_subtract	multiprecision/tommath.hpp	/^inline void eval_subtract(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
boost::multiprecision::backends::eval_tan	multiprecision/float128.hpp	/^inline void eval_tan(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_tanh	multiprecision/float128.hpp	/^inline void eval_tanh(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_trunc	multiprecision/cpp_dec_float.hpp	/^inline void eval_trunc(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
boost::multiprecision::backends::eval_trunc	multiprecision/float128.hpp	/^inline void eval_trunc(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
boost::multiprecision::backends::eval_trunc	multiprecision/mpfr.hpp	/^inline void eval_trunc(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
boost::multiprecision::backends::extract_exponent_type	multiprecision/traits/extract_exponent_type.hpp	/^struct extract_exponent_type$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::extract_exponent_type	multiprecision/traits/extract_exponent_type.hpp	/^struct extract_exponent_type<Backend, number_kind_floating_point>$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::extract_exponent_type::type	multiprecision/traits/extract_exponent_type.hpp	/^   typedef int type;$/;"	t	struct:boost::multiprecision::backends::extract_exponent_type	access:public
boost::multiprecision::backends::extract_exponent_type::type	multiprecision/traits/extract_exponent_type.hpp	/^   typedef typename Backend::exponent_type type;$/;"	t	struct:boost::multiprecision::backends::extract_exponent_type	access:public
boost::multiprecision::backends::float128_backend	multiprecision/float128.hpp	/^struct float128_backend$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::float128_backend::compare	multiprecision/float128.hpp	/^   int compare(const T& i)const$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(const T& i) const
boost::multiprecision::backends::float128_backend::compare	multiprecision/float128.hpp	/^   int compare(const float128_backend& o)const$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(const float128_backend& o) const
boost::multiprecision::backends::float128_backend::exponent_type	multiprecision/float128.hpp	/^   typedef int                                                   exponent_type;$/;"	t	struct:boost::multiprecision::backends::float128_backend	access:public
boost::multiprecision::backends::float128_backend::float128_backend	multiprecision/float128.hpp	/^   BOOST_CONSTEXPR float128_backend() : m_value(0) {}$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:()
boost::multiprecision::backends::float128_backend::float128_backend	multiprecision/float128.hpp	/^   BOOST_CONSTEXPR float128_backend(const T& i, const typename enable_if_c<is_convertible<T, float128_type>::value>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(const T& i, const typename enable_if_c<is_convertible<T, float128_type>::value>::type* = 0)
boost::multiprecision::backends::float128_backend::float128_backend	multiprecision/float128.hpp	/^   BOOST_CONSTEXPR float128_backend(const float128_backend& o) : m_value(o.m_value) {}$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(const float128_backend& o)
boost::multiprecision::backends::float128_backend::float_types	multiprecision/float128.hpp	/^   typedef mpl::list<float, double, long double>                 float_types;$/;"	t	struct:boost::multiprecision::backends::float128_backend	access:public
boost::multiprecision::backends::float128_backend::m_value	multiprecision/float128.hpp	/^   float128_type m_value;$/;"	m	struct:boost::multiprecision::backends::float128_backend	access:private
boost::multiprecision::backends::float128_backend::negate	multiprecision/float128.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:()
boost::multiprecision::backends::float128_backend::operator =	multiprecision/float128.hpp	/^   float128_backend& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(const char* s)
boost::multiprecision::backends::float128_backend::operator =	multiprecision/float128.hpp	/^   float128_backend& operator = (const float128_backend& o) $/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(const float128_backend& o)
boost::multiprecision::backends::float128_backend::operator =	multiprecision/float128.hpp	/^   typename enable_if_c<is_arithmetic<T>::value || is_convertible<T, float128_type>::value, float128_backend&>::type operator = (const T& i)$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(const T& i)
boost::multiprecision::backends::float128_backend::signed_types	multiprecision/float128.hpp	/^   typedef mpl::list<signed char, short, int, long, long long>   signed_types;$/;"	t	struct:boost::multiprecision::backends::float128_backend	access:public
boost::multiprecision::backends::float128_backend::str	multiprecision/float128.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
boost::multiprecision::backends::float128_backend::swap	multiprecision/float128.hpp	/^   void swap(float128_backend& o)$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(float128_backend& o)
boost::multiprecision::backends::float128_backend::unsigned_types	multiprecision/float128.hpp	/^      unsigned int, unsigned long, unsigned long long>           unsigned_types;$/;"	t	struct:boost::multiprecision::backends::float128_backend	access:public
boost::multiprecision::backends::float128_backend::value	multiprecision/float128.hpp	/^   const float128_type& value()const$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:() const
boost::multiprecision::backends::float128_backend::value	multiprecision/float128.hpp	/^   float128_type& value()$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:()
boost::multiprecision::backends::gmp_float	multiprecision/gmp.hpp	/^struct gmp_float : public detail::gmp_float_imp<digits10>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::gmp_float_imp
boost::multiprecision::backends::gmp_float::BOOST_NOEXCEPT	multiprecision/gmp.hpp	/^   gmp_float(gmp_float&& o) BOOST_NOEXCEPT : detail::gmp_float_imp<digits10>(static_cast<detail::gmp_float_imp<digits10>&&>(o)) {}$/;"	m	struct:boost::multiprecision::backends::gmp_float	access:public
boost::multiprecision::backends::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   explicit gmp_float(const gmp_float<D>& o, typename disable_if_c<D <= digits10>::type* = 0);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_float<D>& o, typename disable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float()$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:()
boost::multiprecision::backends::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_float& o) : detail::gmp_float_imp<digits10>(o) {}$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_float& o)
boost::multiprecision::backends::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_float<D>& o, typename enable_if_c<D <= digits10>::type* = 0);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_float<D>& o, typename enable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_int& o);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_int& o)
boost::multiprecision::backends::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_rational& o)
boost::multiprecision::backends::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const mpf_t val)$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const mpf_t val)
boost::multiprecision::backends::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const mpq_t val)$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const mpq_t val)
boost::multiprecision::backends::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const mpz_t val)$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const mpz_t val)
boost::multiprecision::backends::integer_gcd_reduce	multiprecision/cpp_int/misc.hpp	/^inline double_limb_type integer_gcd_reduce(double_limb_type u, double_limb_type v)$/;"	f	namespace:boost::multiprecision::backends	signature:(double_limb_type u, double_limb_type v)
boost::multiprecision::backends::integer_gcd_reduce	multiprecision/cpp_int/misc.hpp	/^inline limb_type integer_gcd_reduce(limb_type u, limb_type v)$/;"	f	namespace:boost::multiprecision::backends	signature:(limb_type u, limb_type v)
boost::multiprecision::backends::is_fixed_precision	multiprecision/cpp_int.hpp	/^struct is_fixed_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends	inherits:mpl::bool_
boost::multiprecision::backends::is_implicit_cpp_int_conversion	multiprecision/cpp_int.hpp	/^struct is_implicit_cpp_int_conversion<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::is_implicit_cpp_int_conversion::t1	multiprecision/cpp_int.hpp	/^   typedef cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> t1;$/;"	t	struct:boost::multiprecision::backends::is_implicit_cpp_int_conversion	access:public
boost::multiprecision::backends::is_implicit_cpp_int_conversion::t2	multiprecision/cpp_int.hpp	/^   typedef cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> t2;$/;"	t	struct:boost::multiprecision::backends::is_implicit_cpp_int_conversion	access:public
boost::multiprecision::backends::is_implicit_cpp_int_conversion::value	multiprecision/cpp_int.hpp	/^   static const bool value =$/;"	m	struct:boost::multiprecision::backends::is_implicit_cpp_int_conversion	access:public
boost::multiprecision::backends::is_non_throwing_cpp_int	multiprecision/cpp_int.hpp	/^struct is_non_throwing_cpp_int : public mpl::false_{};$/;"	s	namespace:boost::multiprecision::backends	inherits:mpl::false_
boost::multiprecision::backends::is_non_throwing_cpp_int	multiprecision/cpp_int.hpp	/^struct is_non_throwing_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, unchecked, void> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision::backends	inherits:mpl::true_
boost::multiprecision::backends::is_trivial_cpp_int	multiprecision/cpp_int.hpp	/^struct is_trivial_cpp_int$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::is_trivial_cpp_int	multiprecision/cpp_int.hpp	/^struct is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::is_trivial_cpp_int	multiprecision/cpp_int.hpp	/^struct is_trivial_cpp_int<cpp_int_base<MinBits, MaxBits, SignType, Checked, Allocator, true> >$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::is_trivial_cpp_int::self	multiprecision/cpp_int.hpp	/^   typedef cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> self;$/;"	t	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
boost::multiprecision::backends::is_trivial_cpp_int::value	multiprecision/cpp_int.hpp	/^   static const bool value = false;$/;"	m	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
boost::multiprecision::backends::is_trivial_cpp_int::value	multiprecision/cpp_int.hpp	/^   static const bool value = is_void<Allocator>::value && (max_precision<self>::value <= (sizeof(double_limb_type) * CHAR_BIT) - (SignType == signed_packed ? 1 : 0));$/;"	m	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
boost::multiprecision::backends::is_trivial_cpp_int::value	multiprecision/cpp_int.hpp	/^   static const bool value = true;$/;"	m	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
boost::multiprecision::backends::is_valid_bitwise_op	multiprecision/cpp_int/bitwise.hpp	/^void is_valid_bitwise_op($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::int_<checked>&)
boost::multiprecision::backends::is_valid_bitwise_op	multiprecision/cpp_int/bitwise.hpp	/^void is_valid_bitwise_op($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>&, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& , const mpl::int_<unchecked>&)
boost::multiprecision::backends::logged_adaptor	multiprecision/logged_adaptor.hpp	/^struct logged_adaptor$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::logged_adaptor::compare	multiprecision/logged_adaptor.hpp	/^   int compare(const T& i)const$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(const T& i) const
boost::multiprecision::backends::logged_adaptor::compare	multiprecision/logged_adaptor.hpp	/^   int compare(const logged_adaptor& o)const$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(const logged_adaptor& o) const
boost::multiprecision::backends::logged_adaptor::exponent_type	multiprecision/logged_adaptor.hpp	/^      Backend, number_category<Backend>::value>::type  exponent_type;$/;"	t	struct:boost::multiprecision::backends::logged_adaptor	access:public
boost::multiprecision::backends::logged_adaptor::float_types	multiprecision/logged_adaptor.hpp	/^   typedef typename Backend::float_types               float_types;$/;"	t	struct:boost::multiprecision::backends::logged_adaptor	access:public
boost::multiprecision::backends::logged_adaptor::logged_adaptor	multiprecision/logged_adaptor.hpp	/^   logged_adaptor()$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:()
boost::multiprecision::backends::logged_adaptor::logged_adaptor	multiprecision/logged_adaptor.hpp	/^   logged_adaptor(const T& i, const typename enable_if_c<is_convertible<T, Backend>::value>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(const T& i, const typename enable_if_c<is_convertible<T, Backend>::value>::type* = 0)
boost::multiprecision::backends::logged_adaptor::logged_adaptor	multiprecision/logged_adaptor.hpp	/^   logged_adaptor(const logged_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(const logged_adaptor& o)
boost::multiprecision::backends::logged_adaptor::m_value	multiprecision/logged_adaptor.hpp	/^   Backend m_value;$/;"	m	struct:boost::multiprecision::backends::logged_adaptor	access:private
boost::multiprecision::backends::logged_adaptor::negate	multiprecision/logged_adaptor.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:()
boost::multiprecision::backends::logged_adaptor::operator =	multiprecision/logged_adaptor.hpp	/^   logged_adaptor& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(const char* s)
boost::multiprecision::backends::logged_adaptor::operator =	multiprecision/logged_adaptor.hpp	/^   logged_adaptor& operator = (const logged_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(const logged_adaptor& o)
boost::multiprecision::backends::logged_adaptor::operator =	multiprecision/logged_adaptor.hpp	/^   typename enable_if_c<is_arithmetic<T>::value || is_convertible<T, Backend>::value, logged_adaptor&>::type operator = (const T& i)$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(const T& i)
boost::multiprecision::backends::logged_adaptor::serialize	multiprecision/logged_adaptor.hpp	/^   void serialize(Archive& ar, const unsigned int \/*version*\/)$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(Archive& ar, const unsigned int )
boost::multiprecision::backends::logged_adaptor::signed_types	multiprecision/logged_adaptor.hpp	/^   typedef typename Backend::signed_types              signed_types;$/;"	t	struct:boost::multiprecision::backends::logged_adaptor	access:public
boost::multiprecision::backends::logged_adaptor::str	multiprecision/logged_adaptor.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
boost::multiprecision::backends::logged_adaptor::swap	multiprecision/logged_adaptor.hpp	/^   void swap(logged_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(logged_adaptor& o)
boost::multiprecision::backends::logged_adaptor::unsigned_types	multiprecision/logged_adaptor.hpp	/^   typedef typename Backend::unsigned_types            unsigned_types;$/;"	t	struct:boost::multiprecision::backends::logged_adaptor	access:public
boost::multiprecision::backends::logged_adaptor::value	multiprecision/logged_adaptor.hpp	/^   Backend& value()$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:()
boost::multiprecision::backends::logged_adaptor::value	multiprecision/logged_adaptor.hpp	/^   const Backend& value()const$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:() const
boost::multiprecision::backends::m_data	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base() BOOST_NOEXCEPT : m_data(), m_limbs(1), m_sign(false), m_internal(true) {}$/;"	p	namespace:boost::multiprecision::backends	signature:()
boost::multiprecision::backends::m_internal	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base() BOOST_NOEXCEPT : m_data(), m_limbs(1), m_sign(false), m_internal(true) {}$/;"	f	namespace:boost::multiprecision::backends	signature:(true)
boost::multiprecision::backends::m_sign	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base() BOOST_NOEXCEPT : m_data(), m_limbs(1), m_sign(false), m_internal(true) {}$/;"	p	namespace:boost::multiprecision::backends	signature:(false)
boost::multiprecision::backends::max_precision	multiprecision/cpp_int.hpp	/^struct max_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::max_precision::value	multiprecision/cpp_int.hpp	/^   static const unsigned value = is_void<Allocator>::value ?$/;"	m	struct:boost::multiprecision::backends::max_precision	access:public
boost::multiprecision::backends::min_precision	multiprecision/cpp_int.hpp	/^struct min_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::min_precision::value	multiprecision/cpp_int.hpp	/^   static const unsigned value = (is_void<Allocator>::value ? static_unsigned_max<MinBits, MaxBits>::value : MinBits);$/;"	m	struct:boost::multiprecision::backends::min_precision	access:public
boost::multiprecision::backends::mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend(const mpfi_float_backend<D>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpfi_float_backend<D>& val)
boost::multiprecision::backends::mpfi_float_backend	multiprecision/mpfi.hpp	/^struct mpfi_float_backend : public detail::mpfi_float_imp<digits10>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::mpfi_float_imp
boost::multiprecision::backends::mpfi_float_backend	multiprecision/mpfi.hpp	/^struct mpfi_float_backend<0> : public detail::mpfi_float_imp<0>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::mpfi_float_imp
boost::multiprecision::backends::mpfi_float_backend::BOOST_NOEXCEPT	multiprecision/mpfi.hpp	/^   mpfi_float_backend(mpfi_float_backend&& o) BOOST_NOEXCEPT : detail::mpfi_float_imp<0>(static_cast<detail::mpfi_float_imp<0>&&>(o)) {}$/;"	m	struct:boost::multiprecision::backends::mpfi_float_backend	access:public
boost::multiprecision::backends::mpfi_float_backend::digits10	multiprecision/mpfi.hpp	/^   mpfi_float_backend(const mpfi_float_backend& o, unsigned digits10)$/;"	m	struct:boost::multiprecision::backends::mpfi_float_backend	access:public
boost::multiprecision::backends::mpfi_float_backend::mpfi_float_backend	multiprecision/mpfi.hpp	/^   explicit mpfi_float_backend(const mpfi_float_backend<D>& val, typename disable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_float_backend<D>& val, typename disable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::mpfi_float_backend::mpfi_float_backend	multiprecision/mpfi.hpp	/^   explicit mpfi_float_backend(const mpfr_float_backend<D>& val, typename disable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfr_float_backend<D>& val, typename disable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::mpfi_float_backend::mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend() : detail::mpfi_float_imp<0>() {}$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:()
boost::multiprecision::backends::mpfi_float_backend::mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend() : detail::mpfi_float_imp<digits10>() {}$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:()
boost::multiprecision::backends::mpfi_float_backend::mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend(const mpfi_float_backend& o) : detail::mpfi_float_imp<0>(o) {}$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_float_backend& o)
boost::multiprecision::backends::mpfi_float_backend::mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend(const mpfi_float_backend& o) : detail::mpfi_float_imp<digits10>(o) {}$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_float_backend& o)
boost::multiprecision::backends::mpfi_float_backend::mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend(const mpfi_float_backend<D>& val, typename enable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_float_backend<D>& val, typename enable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::mpfi_float_backend::mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend(const mpfi_t val)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_t val)
boost::multiprecision::backends::mpfi_float_backend::mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend(const mpfr_float_backend<D>& val, typename enable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfr_float_backend<D>& val, typename enable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::mpfi_float_backend::mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend(mpfi_float_backend&& o) : detail::mpfi_float_imp<digits10>(static_cast<detail::mpfi_float_imp<digits10>&&>(o)) {}$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(mpfi_float_backend&& o)
boost::multiprecision::backends::mpfi_float_backend::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const V& v)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const V& v)
boost::multiprecision::backends::mpfi_float_backend::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const mpfi_float_backend& o)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_float_backend& o)
boost::multiprecision::backends::mpfi_float_backend::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const mpfi_float_backend<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_float_backend<D>& val)
boost::multiprecision::backends::mpfi_float_backend::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const mpfi_t val)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_t val)
boost::multiprecision::backends::mpfi_float_backend::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const mpfr_float_backend<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfr_float_backend<D>& val)
boost::multiprecision::backends::mpfr_float_backend	multiprecision/mpfr.hpp	/^struct mpfr_float_backend : public detail::mpfr_float_imp<digits10, AllocationType>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::mpfr_float_imp
boost::multiprecision::backends::mpfr_float_backend	multiprecision/mpfr.hpp	/^struct mpfr_float_backend<0, allocate_dynamic> : public detail::mpfr_float_imp<0, allocate_dynamic>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::mpfr_float_imp
boost::multiprecision::backends::mpfr_float_backend::BOOST_NOEXCEPT	multiprecision/mpfr.hpp	/^   mpfr_float_backend(mpfr_float_backend&& o) BOOST_NOEXCEPT : detail::mpfr_float_imp<0, allocate_dynamic>(static_cast<detail::mpfr_float_imp<0, allocate_dynamic>&&>(o)) {}$/;"	m	struct:boost::multiprecision::backends::mpfr_float_backend	access:public
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   explicit mpfr_float_backend(const mpfr_float_backend<D, AT>& val, typename disable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D, AT>& val, typename disable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend() : detail::mpfr_float_imp<0, allocate_dynamic>() {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:()
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend() : detail::mpfr_float_imp<digits10, AllocationType>() {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:()
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_float<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_float<D>& val, typename disable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val, typename disable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_float<D>& val, typename enable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val, typename enable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_int& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_int& val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_rational& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_rational& val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpf_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpf_t val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend& o) : detail::mpfr_float_imp<0, allocate_dynamic>(o) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend& o) : detail::mpfr_float_imp<digits10, AllocationType>(o) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend& o, unsigned digits10)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o, unsigned digits10)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend<D, AT>& val, typename enable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D, AT>& val, typename enable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D>& val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_t val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpq_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpq_t val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpz_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpz_t val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(mpfr_float_backend&& o) : detail::mpfr_float_imp<digits10, AllocationType>(static_cast<detail::mpfr_float_imp<digits10, AllocationType>&&>(o)) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(mpfr_float_backend&& o)
boost::multiprecision::backends::mpfr_float_backend::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const V& v)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const V& v)
boost::multiprecision::backends::mpfr_float_backend::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const gmp_float<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val)
boost::multiprecision::backends::mpfr_float_backend::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const gmp_int& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_int& val)
boost::multiprecision::backends::mpfr_float_backend::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const gmp_rational& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_rational& val)
boost::multiprecision::backends::mpfr_float_backend::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpf_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpf_t val)
boost::multiprecision::backends::mpfr_float_backend::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_float_backend& o)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o)
boost::multiprecision::backends::mpfr_float_backend::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_float_backend<D, AT>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D, AT>& val)
boost::multiprecision::backends::mpfr_float_backend::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_float_backend<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D>& val)
boost::multiprecision::backends::mpfr_float_backend::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_t val)
boost::multiprecision::backends::mpfr_float_backend::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpq_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpq_t val)
boost::multiprecision::backends::mpfr_float_backend::operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpz_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpz_t val)
boost::multiprecision::backends::mpfr_float_backend::static_cast	multiprecision/mpfr.hpp	/^   mpfr_float_backend(mpfr_float_backend&& o) BOOST_NOEXCEPT : detail::mpfr_float_imp<0, allocate_dynamic>(static_cast<detail::mpfr_float_imp<0, allocate_dynamic>&&>(o)) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(o)
boost::multiprecision::backends::operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const V& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(const V& v)
boost::multiprecision::backends::operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_float<D>& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(const gmp_float<D>& o)
boost::multiprecision::backends::operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_int& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(const gmp_int& o)
boost::multiprecision::backends::operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_rational& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(const gmp_rational& o)
boost::multiprecision::backends::operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpf_t val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpf_t val)
boost::multiprecision::backends::operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpq_t val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpq_t val)
boost::multiprecision::backends::operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpz_t val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpz_t val)
boost::multiprecision::backends::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const V& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(const V& v)
boost::multiprecision::backends::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const mpfi_float_backend& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpfi_float_backend& o)
boost::multiprecision::backends::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const mpfi_float_backend<D>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpfi_float_backend<D>& val)
boost::multiprecision::backends::operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const mpfi_t val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpfi_t val)
boost::multiprecision::backends::rational_adaptor	multiprecision/rational_adaptor.hpp	/^struct rational_adaptor$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::rational_adaptor::compare	multiprecision/rational_adaptor.hpp	/^   int compare(const rational_adaptor& o)const$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const rational_adaptor& o) const
boost::multiprecision::backends::rational_adaptor::compare	multiprecision/rational_adaptor.hpp	/^   typename enable_if<is_arithmetic<Arithmatic>, int>::type compare(Arithmatic i)const$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(Arithmatic i) const
boost::multiprecision::backends::rational_adaptor::data	multiprecision/rational_adaptor.hpp	/^   const rational_type& data()const { return m_value; }$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:() const
boost::multiprecision::backends::rational_adaptor::data	multiprecision/rational_adaptor.hpp	/^   rational_type& data() { return m_value; }$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:()
boost::multiprecision::backends::rational_adaptor::float_types	multiprecision/rational_adaptor.hpp	/^   typedef typename IntBackend::float_types     float_types;$/;"	t	struct:boost::multiprecision::backends::rational_adaptor	access:public
boost::multiprecision::backends::rational_adaptor::integer_type	multiprecision/rational_adaptor.hpp	/^   typedef number<IntBackend>                integer_type;$/;"	t	struct:boost::multiprecision::backends::rational_adaptor	access:public
boost::multiprecision::backends::rational_adaptor::m_value	multiprecision/rational_adaptor.hpp	/^   rational_type m_value;$/;"	m	struct:boost::multiprecision::backends::rational_adaptor	access:private
boost::multiprecision::backends::rational_adaptor::negate	multiprecision/rational_adaptor.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:()
boost::multiprecision::backends::rational_adaptor::operator =	multiprecision/rational_adaptor.hpp	/^   rational_adaptor& operator = (const IntBackend& o)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const IntBackend& o)
boost::multiprecision::backends::rational_adaptor::operator =	multiprecision/rational_adaptor.hpp	/^   rational_adaptor& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const char* s)
boost::multiprecision::backends::rational_adaptor::operator =	multiprecision/rational_adaptor.hpp	/^   rational_adaptor& operator = (const rational_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const rational_adaptor& o)
boost::multiprecision::backends::rational_adaptor::operator =	multiprecision/rational_adaptor.hpp	/^   rational_adaptor& operator = (rational_adaptor&& o)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(rational_adaptor&& o)
boost::multiprecision::backends::rational_adaptor::operator =	multiprecision/rational_adaptor.hpp	/^   typename enable_if<is_floating_point<Float>, rational_adaptor&>::type operator = (Float i)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(Float i)
boost::multiprecision::backends::rational_adaptor::operator =	multiprecision/rational_adaptor.hpp	/^   typename enable_if<is_integral<Int>, rational_adaptor&>::type operator = (Int i)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(Int i)
boost::multiprecision::backends::rational_adaptor::operator =	multiprecision/rational_adaptor.hpp	/^   typename enable_if_c<(boost::multiprecision::detail::is_explicitly_convertible<U, IntBackend>::value && !is_arithmetic<U>::value), rational_adaptor&>::type operator = (const U& u) $/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const U& u)
boost::multiprecision::backends::rational_adaptor::rational_adaptor	multiprecision/rational_adaptor.hpp	/^   explicit rational_adaptor(const U& u, $/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const U& u, typename enable_if_c< boost::multiprecision::detail::is_explicitly_convertible<U, IntBackend>::value && !is_convertible<U, IntBackend>::value >::type* = 0)
boost::multiprecision::backends::rational_adaptor::rational_adaptor	multiprecision/rational_adaptor.hpp	/^   rational_adaptor(){}$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:()
boost::multiprecision::backends::rational_adaptor::rational_adaptor	multiprecision/rational_adaptor.hpp	/^   rational_adaptor(IntBackend&& o) : m_value(o) {}$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(IntBackend&& o)
boost::multiprecision::backends::rational_adaptor::rational_adaptor	multiprecision/rational_adaptor.hpp	/^   rational_adaptor(const IntBackend& o) : m_value(o) {}$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const IntBackend& o)
boost::multiprecision::backends::rational_adaptor::rational_adaptor	multiprecision/rational_adaptor.hpp	/^   rational_adaptor(const U& u, typename enable_if_c<is_convertible<U, IntBackend>::value>::type* = 0) $/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const U& u, typename enable_if_c<is_convertible<U, IntBackend>::value>::type* = 0)
boost::multiprecision::backends::rational_adaptor::rational_adaptor	multiprecision/rational_adaptor.hpp	/^   rational_adaptor(const rational_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const rational_adaptor& o)
boost::multiprecision::backends::rational_adaptor::rational_adaptor	multiprecision/rational_adaptor.hpp	/^   rational_adaptor(rational_adaptor&& o) : m_value(o.m_value) {}$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(rational_adaptor&& o)
boost::multiprecision::backends::rational_adaptor::rational_type	multiprecision/rational_adaptor.hpp	/^   typedef boost::rational<integer_type>        rational_type;$/;"	t	struct:boost::multiprecision::backends::rational_adaptor	access:public
boost::multiprecision::backends::rational_adaptor::serialize	multiprecision/rational_adaptor.hpp	/^   void serialize(Archive& ar, const mpl::false_&)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(Archive& ar, const mpl::false_&)
boost::multiprecision::backends::rational_adaptor::serialize	multiprecision/rational_adaptor.hpp	/^   void serialize(Archive& ar, const mpl::true_&)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(Archive& ar, const mpl::true_&)
boost::multiprecision::backends::rational_adaptor::serialize	multiprecision/rational_adaptor.hpp	/^   void serialize(Archive& ar, const unsigned int \/*version*\/)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(Archive& ar, const unsigned int )
boost::multiprecision::backends::rational_adaptor::signed_types	multiprecision/rational_adaptor.hpp	/^   typedef typename IntBackend::signed_types    signed_types;$/;"	t	struct:boost::multiprecision::backends::rational_adaptor	access:public
boost::multiprecision::backends::rational_adaptor::str	multiprecision/rational_adaptor.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
boost::multiprecision::backends::rational_adaptor::swap	multiprecision/rational_adaptor.hpp	/^   void swap(rational_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(rational_adaptor& o)
boost::multiprecision::backends::rational_adaptor::unsigned_types	multiprecision/rational_adaptor.hpp	/^   typedef typename IntBackend::unsigned_types  unsigned_types;$/;"	t	struct:boost::multiprecision::backends::rational_adaptor	access:public
boost::multiprecision::backends::resize_for_carry	multiprecision/cpp_int/multiply.hpp	/^inline void resize_for_carry(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& \/*result*\/, unsigned \/*required*\/){}$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& , unsigned )
boost::multiprecision::backends::resize_for_carry	multiprecision/cpp_int/multiply.hpp	/^inline void resize_for_carry(cpp_int_backend<MinBits1, MaxBits1, SignType1, checked, void>& result, unsigned required)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, checked, void>& result, unsigned required)
boost::multiprecision::backends::tommath_int	multiprecision/tommath.hpp	/^struct tommath_int$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::tommath_int::compare	multiprecision/tommath.hpp	/^   int compare(V v)const$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(V v) const
boost::multiprecision::backends::tommath_int::compare	multiprecision/tommath.hpp	/^   int compare(const tommath_int& o)const$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const tommath_int& o) const
boost::multiprecision::backends::tommath_int::data	multiprecision/tommath.hpp	/^   ::mp_int& data() $/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
boost::multiprecision::backends::tommath_int::data	multiprecision/tommath.hpp	/^   const ::mp_int& data()const $/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:() const
boost::multiprecision::backends::tommath_int::float_types	multiprecision/tommath.hpp	/^   typedef mpl::list<long double>                           float_types;$/;"	t	struct:boost::multiprecision::backends::tommath_int	access:public
boost::multiprecision::backends::tommath_int::m_data	multiprecision/tommath.hpp	/^   ::mp_int m_data;$/;"	m	struct:boost::multiprecision::backends::tommath_int	access:protected
boost::multiprecision::backends::tommath_int::negate	multiprecision/tommath.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
boost::multiprecision::backends::tommath_int::operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (boost::int32_t i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(boost::int32_t i)
boost::multiprecision::backends::tommath_int::operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (boost::uint32_t i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(boost::uint32_t i)
boost::multiprecision::backends::tommath_int::operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const char* s)
boost::multiprecision::backends::tommath_int::operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (const tommath_int& o)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const tommath_int& o)
boost::multiprecision::backends::tommath_int::operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (long double a)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(long double a)
boost::multiprecision::backends::tommath_int::operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (long long i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(long long i)
boost::multiprecision::backends::tommath_int::operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (tommath_int&& o)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(tommath_int&& o)
boost::multiprecision::backends::tommath_int::operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(unsigned long long i)
boost::multiprecision::backends::tommath_int::signed_types	multiprecision/tommath.hpp	/^   typedef mpl::list<boost::int32_t, long long>             signed_types;$/;"	t	struct:boost::multiprecision::backends::tommath_int	access:public
boost::multiprecision::backends::tommath_int::str	multiprecision/tommath.hpp	/^   std::string str(std::streamsize \/*digits*\/, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(std::streamsize , std::ios_base::fmtflags f) const
boost::multiprecision::backends::tommath_int::tommath_int	multiprecision/tommath.hpp	/^   tommath_int()$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
boost::multiprecision::backends::tommath_int::tommath_int	multiprecision/tommath.hpp	/^   tommath_int(const tommath_int& o)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const tommath_int& o)
boost::multiprecision::backends::tommath_int::unsigned_types	multiprecision/tommath.hpp	/^   typedef mpl::list<boost::uint32_t, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::backends::tommath_int	access:public
boost::multiprecision::backends::tommath_int::~tommath_int	multiprecision/tommath.hpp	/^   ~tommath_int()$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
boost::multiprecision::backends::unwrap_debug_type	multiprecision/debug_adaptor.hpp	/^inline Backend const& unwrap_debug_type(debug_adaptor<Backend> const& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(debug_adaptor<Backend> const& val)
boost::multiprecision::backends::unwrap_debug_type	multiprecision/debug_adaptor.hpp	/^inline const T& unwrap_debug_type(const T& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const T& val)
boost::multiprecision::backends::unwrap_logged_type	multiprecision/logged_adaptor.hpp	/^inline const Backend& unwrap_logged_type(const logged_adaptor<Backend>& a) { return a.value(); }$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& a)
boost::multiprecision::backends::unwrap_logged_type	multiprecision/logged_adaptor.hpp	/^inline const T& unwrap_logged_type(const T& a) { return a; }$/;"	f	namespace:boost::multiprecision::backends	signature:(const T& a)
boost::multiprecision::bit_flip	multiprecision/detail/integer_ops.hpp	/^   bit_flip(number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& x, unsigned index)
boost::multiprecision::bit_flip	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer&>::type bit_flip(Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(Integer& val, unsigned index)
boost::multiprecision::bit_set	multiprecision/detail/integer_ops.hpp	/^   bit_set(number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& x, unsigned index)
boost::multiprecision::bit_set	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer&>::type bit_set(Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(Integer& val, unsigned index)
boost::multiprecision::bit_test	multiprecision/detail/integer_ops.hpp	/^   bit_test(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, unsigned index)
boost::multiprecision::bit_test	multiprecision/detail/integer_ops.hpp	/^   bit_test(const number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, unsigned index)
boost::multiprecision::bit_test	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, bool>::type bit_test(const Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& val, unsigned index)
boost::multiprecision::bit_unset	multiprecision/detail/integer_ops.hpp	/^   bit_unset(number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& x, unsigned index)
boost::multiprecision::bit_unset	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer&>::type bit_unset(Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(Integer& val, unsigned index)
boost::multiprecision::bits_per_limb	multiprecision/cpp_int/cpp_int_config.hpp	/^static const unsigned bits_per_limb = sizeof(limb_type) * CHAR_BIT;$/;"	m	namespace:boost::multiprecision
boost::multiprecision::block_multiplier	multiprecision/cpp_int/cpp_int_config.hpp	/^inline limb_type block_multiplier(unsigned count)$/;"	f	namespace:boost::multiprecision	signature:(unsigned count)
boost::multiprecision::checked	multiprecision/cpp_int/cpp_int_config.hpp	/^   checked = 1,$/;"	e	enum:boost::multiprecision::cpp_int_check_type
boost::multiprecision::compare	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE typename boost::enable_if<is_arithmetic<Arithmetic>, int>::type compare(Arithmetic i)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(Arithmetic i) const
boost::multiprecision::compare_imp	multiprecision/cpp_int.hpp	/^   int compare_imp(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::false_&, const mpl::true_&)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::false_&, const mpl::true_&) const
boost::multiprecision::compare_imp	multiprecision/cpp_int.hpp	/^   int compare_imp(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::true_&, const mpl::false_&)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::true_&, const mpl::false_&) const
boost::multiprecision::component_type	multiprecision/detail/number_base.hpp	/^struct component_type<detail::expression<tag, A1, A2, A3, A4> > : public component_type<typename detail::expression<tag, A1, A2, A3, A4>::result_type>{};$/;"	s	namespace:boost::multiprecision	inherits:component_type
boost::multiprecision::component_type	multiprecision/detail/number_base.hpp	/^struct component_type<number<T, ExpressionTemplates> > : public component_type<T>{};$/;"	s	namespace:boost::multiprecision	inherits:component_type
boost::multiprecision::component_type	multiprecision/rational_adaptor.hpp	/^struct component_type<rational_adaptor<T> >$/;"	s	namespace:boost::multiprecision
boost::multiprecision::component_type::type	multiprecision/rational_adaptor.hpp	/^   typedef number<T> type;$/;"	t	struct:boost::multiprecision::component_type	access:public
boost::multiprecision::concepts	multiprecision/concepts/mp_number_archetypes.hpp	/^namespace concepts{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::concepts::eval_add	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_add(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
boost::multiprecision::concepts::eval_ceil	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_ceil(number_backend_float_architype& result, const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg)
boost::multiprecision::concepts::eval_convert_to	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_convert_to(long double* result, number_backend_float_architype& val)$/;"	f	namespace:boost::multiprecision::concepts	signature:(long double* result, number_backend_float_architype& val)
boost::multiprecision::concepts::eval_convert_to	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_convert_to(long long* result, const number_backend_float_architype& val)$/;"	f	namespace:boost::multiprecision::concepts	signature:(long long* result, const number_backend_float_architype& val)
boost::multiprecision::concepts::eval_convert_to	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_convert_to(unsigned long long* result, const number_backend_float_architype& val)$/;"	f	namespace:boost::multiprecision::concepts	signature:(unsigned long long* result, const number_backend_float_architype& val)
boost::multiprecision::concepts::eval_divide	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_divide(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
boost::multiprecision::concepts::eval_floor	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_floor(number_backend_float_architype& result, const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg)
boost::multiprecision::concepts::eval_fpclassify	multiprecision/concepts/mp_number_archetypes.hpp	/^inline int eval_fpclassify(const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(const number_backend_float_architype& arg)
boost::multiprecision::concepts::eval_frexp	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_frexp(number_backend_float_architype& result, const number_backend_float_architype& arg, int* exp)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg, int* exp)
boost::multiprecision::concepts::eval_ldexp	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_ldexp(number_backend_float_architype& result, const number_backend_float_architype& arg, int exp)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg, int exp)
boost::multiprecision::concepts::eval_multiply	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_multiply(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
boost::multiprecision::concepts::eval_sqrt	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_sqrt(number_backend_float_architype& result, const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg)
boost::multiprecision::concepts::eval_subtract	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_subtract(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
boost::multiprecision::concepts::mp_number_float_architype	multiprecision/concepts/mp_number_archetypes.hpp	/^typedef boost::multiprecision::number<number_backend_float_architype> mp_number_float_architype;$/;"	t	namespace:boost::multiprecision::concepts
boost::multiprecision::concepts::number_backend_float_architype	multiprecision/concepts/mp_number_archetypes.hpp	/^struct number_backend_float_architype$/;"	s	namespace:boost::multiprecision::concepts
boost::multiprecision::concepts::number_backend_float_architype::compare	multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(const number_backend_float_architype& o)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const number_backend_float_architype& o) const
boost::multiprecision::concepts::number_backend_float_architype::compare	multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(long double d)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long double d) const
boost::multiprecision::concepts::number_backend_float_architype::compare	multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(long long i)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long long i) const
boost::multiprecision::concepts::number_backend_float_architype::compare	multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(unsigned long long i)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(unsigned long long i) const
boost::multiprecision::concepts::number_backend_float_architype::exponent_type	multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef int                                  exponent_type;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
boost::multiprecision::concepts::number_backend_float_architype::float_types	multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef mpl::list<long double>               float_types;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
boost::multiprecision::concepts::number_backend_float_architype::m_value	multiprecision/concepts/mp_number_archetypes.hpp	/^   long double m_value;$/;"	m	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
boost::multiprecision::concepts::number_backend_float_architype::negate	multiprecision/concepts/mp_number_archetypes.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:()
boost::multiprecision::concepts::number_backend_float_architype::number_backend_float_architype	multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype()$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:()
boost::multiprecision::concepts::number_backend_float_architype::number_backend_float_architype	multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype(const number_backend_float_architype& o)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const number_backend_float_architype& o)
boost::multiprecision::concepts::number_backend_float_architype::operator =	multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (const char* s)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const char* s)
boost::multiprecision::concepts::number_backend_float_architype::operator =	multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (const number_backend_float_architype& o)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const number_backend_float_architype& o)
boost::multiprecision::concepts::number_backend_float_architype::operator =	multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (long double d)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long double d)
boost::multiprecision::concepts::number_backend_float_architype::operator =	multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (long long i)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long long i)
boost::multiprecision::concepts::number_backend_float_architype::operator =	multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(unsigned long long i)
boost::multiprecision::concepts::number_backend_float_architype::signed_types	multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef mpl::list<long long>                 signed_types;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
boost::multiprecision::concepts::number_backend_float_architype::str	multiprecision/concepts/mp_number_archetypes.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
boost::multiprecision::concepts::number_backend_float_architype::swap	multiprecision/concepts/mp_number_archetypes.hpp	/^   void swap(number_backend_float_architype& o)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(number_backend_float_architype& o)
boost::multiprecision::concepts::number_backend_float_architype::unsigned_types	multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef mpl::list<unsigned long long>        unsigned_types;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
boost::multiprecision::cpp_dec_float_100	multiprecision/cpp_dec_float.hpp	/^typedef number<cpp_dec_float<100> > cpp_dec_float_100;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::cpp_dec_float_50	multiprecision/cpp_dec_float.hpp	/^typedef number<cpp_dec_float<50> > cpp_dec_float_50;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::cpp_int_base	multiprecision/cpp_int.hpp	/^struct cpp_int_base<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator, false> : private Allocator::template rebind<limb_type>::other$/;"	s	namespace:boost::multiprecision	inherits:Allocator::,rebind::other
boost::multiprecision::cpp_int_base	multiprecision/cpp_int.hpp	/^struct cpp_int_base<MinBits, MinBits, signed_magnitude, Checked, void, false>$/;"	s	namespace:boost::multiprecision
boost::multiprecision::cpp_int_base::BOOST_NOEXCEPT	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::cpp_int_base	access:public
boost::multiprecision::cpp_int_base::BOOST_NOEXCEPT	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_double_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::cpp_int_base	access:public
boost::multiprecision::cpp_int_base::BOOST_NOEXCEPT	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::cpp_int_base	access:public
boost::multiprecision::cpp_int_base::BOOST_STATIC_ASSERT_MSG	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_ASSERT_MSG(((sizeof(Allocator) == 0) && !is_void<Allocator>::value), "There is curently no support for unsigned arbitrary precision integers.");$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:((sizeof(Allocator) == 0) && !is_void<Allocator>::value), Ó
boost::multiprecision::cpp_int_base::BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(bool, variable = false);$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(bool, variable = false)
boost::multiprecision::cpp_int_base::BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, max_limb_value = ~static_cast<limb_type>(0u));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(limb_type, max_limb_value = ~static_cast<limb_type>(0u))
boost::multiprecision::cpp_int_base::BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, sign_bit_mask = 1u << (limb_bits - 1));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(limb_type, sign_bit_mask = 1u << (limb_bits - 1))
boost::multiprecision::cpp_int_base::BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, upper_limb_mask = MinBits % limb_bits ? (limb_type(1) << (MinBits % limb_bits)) -1 : (~limb_type(0)));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(limb_type, upper_limb_mask = MinBits % limb_bits ? (limb_type(1) << (MinBits % limb_bits)) -1 : (~limb_type(0)))
boost::multiprecision::cpp_int_base::BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, internal_limb_count = MinBits \/ limb_bits + (MinBits % limb_bits ? 1 : 0));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(unsigned, internal_limb_count = MinBits / limb_bits + (MinBits % limb_bits ? 1 : 0))
boost::multiprecision::cpp_int_base::BOOST_STATIC_CONSTANT	multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT);$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT)
boost::multiprecision::cpp_int_base::checked_type	multiprecision/cpp_int.hpp	/^   typedef mpl::int_<Checked>              checked_type;$/;"	t	struct:boost::multiprecision::cpp_int_base	access:public
boost::multiprecision::cpp_int_base::const_limb_pointer	multiprecision/cpp_int.hpp	/^   typedef const limb_type*                const_limb_pointer;$/;"	t	struct:boost::multiprecision::cpp_int_base	access:public
boost::multiprecision::cpp_int_base::data_type	multiprecision/cpp_int.hpp	/^   union data_type{$/;"	u	struct:boost::multiprecision::cpp_int_base	access:private
boost::multiprecision::cpp_int_base::data_type::data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type() : m_first_limb(0) {}$/;"	f	union:boost::multiprecision::cpp_int_base::data_type	access:public	signature:()
boost::multiprecision::cpp_int_base::data_type::data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(double_limb_type i) : m_double_first_limb(i) {}$/;"	f	union:boost::multiprecision::cpp_int_base::data_type	access:public	signature:(double_limb_type i)
boost::multiprecision::cpp_int_base::data_type::data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(limb_type i) : m_first_limb(i) {}$/;"	f	union:boost::multiprecision::cpp_int_base::data_type	access:public	signature:(limb_type i)
boost::multiprecision::cpp_int_base::data_type::data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(literals::detail::value_pack<VALUES...>) : m_data{ VALUES... } {}$/;"	f	union:boost::multiprecision::cpp_int_base::data_type	access:public	signature:(literals::detail::value_pack<VALUES...>)
boost::multiprecision::cpp_int_base::data_type::m_data	multiprecision/cpp_int.hpp	/^      limb_type          m_data[internal_limb_count];$/;"	m	union:boost::multiprecision::cpp_int_base::data_type	access:public
boost::multiprecision::cpp_int_base::data_type::m_double_first_limb	multiprecision/cpp_int.hpp	/^      double_limb_type   m_double_first_limb;$/;"	m	union:boost::multiprecision::cpp_int_base::data_type	access:public
boost::multiprecision::cpp_int_base::data_type::m_first_limb	multiprecision/cpp_int.hpp	/^      limb_type          m_first_limb;$/;"	m	union:boost::multiprecision::cpp_int_base::data_type	access:public
boost::multiprecision::cpp_int_base::internal_limb_count	multiprecision/cpp_int.hpp	/^const unsigned cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::internal_limb_count;$/;"	m	class:boost::multiprecision::cpp_int_base
boost::multiprecision::cpp_int_base::limb_bits	multiprecision/cpp_int.hpp	/^const unsigned cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::limb_bits;$/;"	m	class:boost::multiprecision::cpp_int_base
boost::multiprecision::cpp_int_base::limb_pointer	multiprecision/cpp_int.hpp	/^   typedef limb_type*                      limb_pointer;$/;"	t	struct:boost::multiprecision::cpp_int_base	access:public
boost::multiprecision::cpp_int_base::m_limbs	multiprecision/cpp_int.hpp	/^   boost::uint16_t    m_limbs;$/;"	m	struct:boost::multiprecision::cpp_int_base	access:private
boost::multiprecision::cpp_int_base::m_sign	multiprecision/cpp_int.hpp	/^      : m_wrapper(i), m_limbs(1), m_sign(false) {}$/;"	f	struct:boost::multiprecision::cpp_int_base	access:public	signature:(false)
boost::multiprecision::cpp_int_base::m_sign	multiprecision/cpp_int.hpp	/^      : m_wrapper(i), m_limbs(i > max_limb_value ? 2 : 1), m_sign(false) {}$/;"	f	struct:boost::multiprecision::cpp_int_base	access:public	signature:(false)
boost::multiprecision::cpp_int_base::m_sign	multiprecision/cpp_int.hpp	/^   bool               m_sign;$/;"	m	struct:boost::multiprecision::cpp_int_base	access:private
boost::multiprecision::cpp_int_base::m_wrapper	multiprecision/cpp_int.hpp	/^   } m_wrapper;$/;"	m	struct:boost::multiprecision::cpp_int_base	typeref:union:boost::multiprecision::cpp_int_base::data_type	access:private
boost::multiprecision::cpp_int_base::max_limb_value	multiprecision/cpp_int.hpp	/^const limb_type cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::max_limb_value;$/;"	m	class:boost::multiprecision::cpp_int_base
boost::multiprecision::cpp_int_base::sign	multiprecision/cpp_int.hpp	/^      this->sign(false);$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(false)
boost::multiprecision::cpp_int_base::sign_bit_mask	multiprecision/cpp_int.hpp	/^const limb_type cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::sign_bit_mask;$/;"	m	class:boost::multiprecision::cpp_int_base
boost::multiprecision::cpp_int_base::variable	multiprecision/cpp_int.hpp	/^const bool cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::variable;$/;"	m	class:boost::multiprecision::cpp_int_base
boost::multiprecision::cpp_int_check_type	multiprecision/cpp_int/cpp_int_config.hpp	/^enum cpp_int_check_type$/;"	g	namespace:boost::multiprecision
boost::multiprecision::cpp_integer_type	multiprecision/cpp_int/cpp_int_config.hpp	/^enum cpp_integer_type$/;"	g	namespace:boost::multiprecision
boost::multiprecision::default_ops	multiprecision/detail/default_ops.hpp	/^namespace boost{ namespace multiprecision{ namespace default_ops{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::default_ops	multiprecision/detail/integer_ops.hpp	/^namespace default_ops$/;"	n	namespace:boost::multiprecision
boost::multiprecision::default_ops	multiprecision/detail/integer_ops.hpp	/^namespace default_ops{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::default_ops	multiprecision/detail/number_compare.hpp	/^namespace default_ops{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::default_ops::assign_components	multiprecision/detail/default_ops.hpp	/^inline void assign_components(T& result, const V& v1, const V& v2)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const V& v1, const V& v2)
boost::multiprecision::default_ops::assign_components_imp	multiprecision/detail/default_ops.hpp	/^inline void assign_components_imp(T& result, const V& v1, const V& v2, const mpl::int_<number_kind_rational>&)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const V& v1, const V& v2, const mpl::int_<number_kind_rational>&)
boost::multiprecision::default_ops::calculate_next_larger_type	multiprecision/detail/default_ops.hpp	/^struct calculate_next_larger_type$/;"	s	namespace:boost::multiprecision::default_ops
boost::multiprecision::default_ops::calculate_next_larger_type::iter_type	multiprecision/detail/default_ops.hpp	/^   >::type iter_type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
boost::multiprecision::default_ops::calculate_next_larger_type::list_type	multiprecision/detail/default_ops.hpp	/^   >::type list_type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
boost::multiprecision::default_ops::calculate_next_larger_type::pred_type	multiprecision/detail/default_ops.hpp	/^   typedef typename has_enough_bits<R, std::numeric_limits<R>::digits>::template type<mpl::_> pred_type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
boost::multiprecision::default_ops::calculate_next_larger_type::range	multiprecision/detail/default_ops.hpp	/^   typedef mpl::iterator_range<start_seq, typename mpl::end<list_type>::type> range;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
boost::multiprecision::default_ops::calculate_next_larger_type::start_last	multiprecision/detail/default_ops.hpp	/^   >::type start_last;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
boost::multiprecision::default_ops::calculate_next_larger_type::start_seq	multiprecision/detail/default_ops.hpp	/^   typedef typename mpl::if_<is_same<start_last, typename mpl::end<list_type>::type>, typename mpl::begin<list_type>::type, start_last>::type start_seq;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
boost::multiprecision::default_ops::calculate_next_larger_type::type	multiprecision/detail/default_ops.hpp	/^      >::type type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
boost::multiprecision::default_ops::check_in_range	multiprecision/detail/default_ops.hpp	/^inline bool check_in_range(const T& t)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& t)
boost::multiprecision::default_ops::check_in_range	multiprecision/detail/default_ops.hpp	/^inline bool check_in_range(const terminal<T>&)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const terminal<T>&)
boost::multiprecision::default_ops::double_precision_type	multiprecision/detail/integer_ops.hpp	/^struct double_precision_type$/;"	s	namespace:boost::multiprecision::default_ops
boost::multiprecision::default_ops::double_precision_type::type	multiprecision/detail/integer_ops.hpp	/^   typedef Backend type;$/;"	t	struct:boost::multiprecision::default_ops::double_precision_type	access:public
boost::multiprecision::default_ops::eval_abs	multiprecision/detail/default_ops.hpp	/^void eval_abs(T& result, const T& arg)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg)
boost::multiprecision::default_ops::eval_add	multiprecision/detail/default_ops.hpp	/^   eval_add(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_add	multiprecision/detail/default_ops.hpp	/^inline void eval_add(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_add	multiprecision/detail/default_ops.hpp	/^void eval_add(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_add_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_add_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_add_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_add_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_add_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_add_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_add_default	multiprecision/detail/default_ops.hpp	/^inline void eval_add_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_add_default	multiprecision/detail/default_ops.hpp	/^inline void eval_add_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bit_flip	multiprecision/detail/default_ops.hpp	/^inline void eval_bit_flip(T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val, unsigned index)
boost::multiprecision::default_ops::eval_bit_set	multiprecision/detail/default_ops.hpp	/^inline void eval_bit_set(T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val, unsigned index)
boost::multiprecision::default_ops::eval_bit_test	multiprecision/detail/default_ops.hpp	/^inline bool eval_bit_test(const T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val, unsigned index)
boost::multiprecision::default_ops::eval_bit_unset	multiprecision/detail/default_ops.hpp	/^inline void eval_bit_unset(T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val, unsigned index)
boost::multiprecision::default_ops::eval_bitwise_and	multiprecision/detail/default_ops.hpp	/^   eval_bitwise_and(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_bitwise_and	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_and(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_and	multiprecision/detail/default_ops.hpp	/^void eval_bitwise_and(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_and_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_bitwise_and_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_bitwise_and_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_bitwise_and_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_bitwise_and_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_bitwise_and_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_bitwise_and_default	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_and_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_bitwise_and_default	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_and_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_or	multiprecision/detail/default_ops.hpp	/^   eval_bitwise_or(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_bitwise_or	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_or(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_or	multiprecision/detail/default_ops.hpp	/^void eval_bitwise_or(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_or_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_bitwise_or_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_bitwise_or_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_bitwise_or_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_bitwise_or_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_bitwise_or_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_bitwise_or_default	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_or_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_bitwise_or_default	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_or_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_xor	multiprecision/detail/default_ops.hpp	/^   eval_bitwise_xor(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_bitwise_xor	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_xor(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_xor	multiprecision/detail/default_ops.hpp	/^void eval_bitwise_xor(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_xor_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_bitwise_xor_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_bitwise_xor_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_bitwise_xor_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_bitwise_xor_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_bitwise_xor_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_bitwise_xor_default	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_xor_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_bitwise_xor_default	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_xor_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_ceil	multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_ceil();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
boost::multiprecision::default_ops::eval_complement	multiprecision/detail/default_ops.hpp	/^   eval_complement(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_convert_to	multiprecision/detail/default_ops.hpp	/^inline void eval_convert_to(R* result, const B& backend)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(R* result, const B& backend)
boost::multiprecision::default_ops::eval_convert_to	multiprecision/detail/default_ops.hpp	/^inline void eval_convert_to(std::string* result, const B& backend)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(std::string* result, const B& backend)
boost::multiprecision::default_ops::eval_convert_to	multiprecision/detail/default_ops.hpp	/^inline void eval_convert_to(terminal<R>* result, const B& backend)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(terminal<R>* result, const B& backend)
boost::multiprecision::default_ops::eval_decrement	multiprecision/detail/default_ops.hpp	/^inline void eval_decrement(T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val)
boost::multiprecision::default_ops::eval_divide	multiprecision/detail/default_ops.hpp	/^   eval_divide(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_divide	multiprecision/detail/default_ops.hpp	/^inline void eval_divide(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_divide	multiprecision/detail/default_ops.hpp	/^void eval_divide(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_divide_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_divide_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_divide_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_divide_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_divide_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_divide_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_divide_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_divide_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_divide_default	multiprecision/detail/default_ops.hpp	/^inline void eval_divide_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_divide_default	multiprecision/detail/default_ops.hpp	/^inline void eval_divide_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_eq	multiprecision/detail/number_compare.hpp	/^inline bool eval_eq(const B& a, const A& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const A& b)
boost::multiprecision::default_ops::eval_eq	multiprecision/detail/number_compare.hpp	/^inline bool eval_eq(const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const B& b)
boost::multiprecision::default_ops::eval_fabs	multiprecision/detail/default_ops.hpp	/^void eval_fabs(T& result, const T& arg)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg)
boost::multiprecision::default_ops::eval_floor	multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_floor();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
boost::multiprecision::default_ops::eval_fmod	multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_arithmetic<A>, void>::type eval_fmod(T& result, const A& x, const T& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const A& x, const T& a)
boost::multiprecision::default_ops::eval_fmod	multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_arithmetic<A>, void>::type eval_fmod(T& result, const T& x, const A& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& x, const A& a)
boost::multiprecision::default_ops::eval_fmod	multiprecision/detail/default_ops.hpp	/^inline void eval_fmod(T& result, const T& a, const T& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a, const T& b)
boost::multiprecision::default_ops::eval_fpclassify	multiprecision/detail/default_ops.hpp	/^inline int eval_fpclassify(const Backend& arg)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const Backend& arg)
boost::multiprecision::default_ops::eval_frexp	multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_frexp();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
boost::multiprecision::default_ops::eval_gcd	multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_gcd(T& result, const Arithmetic& a, const T& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const Arithmetic& a, const T& b)
boost::multiprecision::default_ops::eval_gcd	multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_gcd(T& result, const T& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a, const Arithmetic& b)
boost::multiprecision::default_ops::eval_gcd	multiprecision/detail/default_ops.hpp	/^void eval_gcd(B& result, const B& a, const B& b);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
boost::multiprecision::default_ops::eval_gcd	multiprecision/detail/integer_ops.hpp	/^inline void eval_gcd(B& result, const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
boost::multiprecision::default_ops::eval_get_sign	multiprecision/detail/default_ops.hpp	/^inline int eval_get_sign(const T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val)
boost::multiprecision::default_ops::eval_gt	multiprecision/detail/number_compare.hpp	/^inline bool eval_gt(const B& a, const A& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const A& b)
boost::multiprecision::default_ops::eval_gt	multiprecision/detail/number_compare.hpp	/^inline bool eval_gt(const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const B& b)
boost::multiprecision::default_ops::eval_increment	multiprecision/detail/default_ops.hpp	/^inline void eval_increment(T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val)
boost::multiprecision::default_ops::eval_integer_modulus	multiprecision/detail/integer_ops.hpp	/^inline Integer eval_integer_modulus(const Backend& x, Integer val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const Backend& x, Integer val)
boost::multiprecision::default_ops::eval_integer_sqrt	multiprecision/detail/default_ops.hpp	/^void eval_integer_sqrt(B& s, B& r, const B& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(B& s, B& r, const B& x)
boost::multiprecision::default_ops::eval_is_zero	multiprecision/detail/default_ops.hpp	/^inline bool eval_is_zero(const T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val)
boost::multiprecision::default_ops::eval_lcm	multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_lcm(T& result, const Arithmetic& a, const T& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const Arithmetic& a, const T& b)
boost::multiprecision::default_ops::eval_lcm	multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_lcm(T& result, const T& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a, const Arithmetic& b)
boost::multiprecision::default_ops::eval_lcm	multiprecision/detail/default_ops.hpp	/^void eval_lcm(B& result, const B& a, const B& b);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
boost::multiprecision::default_ops::eval_lcm	multiprecision/detail/integer_ops.hpp	/^inline void eval_lcm(B& result, const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
boost::multiprecision::default_ops::eval_ldexp	multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_ldexp();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
boost::multiprecision::default_ops::eval_left_shift	multiprecision/detail/default_ops.hpp	/^inline void eval_left_shift(T& result, const T& arg, const V val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg, const V val)
boost::multiprecision::default_ops::eval_lsb	multiprecision/detail/default_ops.hpp	/^inline unsigned eval_lsb(const T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val)
boost::multiprecision::default_ops::eval_lt	multiprecision/detail/number_compare.hpp	/^inline bool eval_lt(const B& a, const A& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const A& b)
boost::multiprecision::default_ops::eval_lt	multiprecision/detail/number_compare.hpp	/^inline bool eval_lt(const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const B& b)
boost::multiprecision::default_ops::eval_modulus	multiprecision/detail/default_ops.hpp	/^   eval_modulus(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_modulus	multiprecision/detail/default_ops.hpp	/^inline void eval_modulus(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_modulus	multiprecision/detail/default_ops.hpp	/^void eval_modulus(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_modulus_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_modulus_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_modulus_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_modulus_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_modulus_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_modulus_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_modulus_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_modulus_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_modulus_default	multiprecision/detail/default_ops.hpp	/^inline void eval_modulus_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_modulus_default	multiprecision/detail/default_ops.hpp	/^inline void eval_modulus_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_msb	multiprecision/detail/default_ops.hpp	/^inline int eval_msb(const T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val)
boost::multiprecision::default_ops::eval_multiply	multiprecision/detail/default_ops.hpp	/^   eval_multiply(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_multiply	multiprecision/detail/default_ops.hpp	/^inline void eval_multiply(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_multiply	multiprecision/detail/default_ops.hpp	/^void eval_multiply(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_multiply_add	multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_multiply_add	multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
boost::multiprecision::default_ops::eval_multiply_add	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_multiply_add	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
boost::multiprecision::default_ops::eval_multiply_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_multiply_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_multiply_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_multiply_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_multiply_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_multiply_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_multiply_default	multiprecision/detail/default_ops.hpp	/^inline void eval_multiply_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_multiply_default	multiprecision/detail/default_ops.hpp	/^inline void eval_multiply_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_multiply_subtract	multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_multiply_subtract	multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
boost::multiprecision::default_ops::eval_multiply_subtract	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_multiply_subtract	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
boost::multiprecision::default_ops::eval_powm	multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_signed<Integer1> >::type eval_powm(Backend& result, const Backend& a, Integer1 b, Integer2 c)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(Backend& result, const Backend& a, Integer1 b, Integer2 c)
boost::multiprecision::default_ops::eval_powm	multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_signed<Integer> >::type eval_powm(Backend& result, const Backend& a, Integer b, const Backend& c)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(Backend& result, const Backend& a, Integer b, const Backend& c)
boost::multiprecision::default_ops::eval_powm	multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_unsigned<Integer1> >::type eval_powm(Backend& result, const Backend& a, Integer1 b, Integer2 c)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(Backend& result, const Backend& a, Integer1 b, Integer2 c)
boost::multiprecision::default_ops::eval_powm	multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_unsigned<Integer> >::type eval_powm(Backend& result, const Backend& a, Integer b, const Backend& c)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(Backend& result, const Backend& a, Integer b, const Backend& c)
boost::multiprecision::default_ops::eval_powm	multiprecision/detail/integer_ops.hpp	/^void eval_powm(Backend& result, const Backend& a, const Backend& p, Integer c)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(Backend& result, const Backend& a, const Backend& p, Integer c)
boost::multiprecision::default_ops::eval_powm	multiprecision/detail/integer_ops.hpp	/^void eval_powm(Backend& result, const Backend& a, const Backend& p, const Backend& c)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(Backend& result, const Backend& a, const Backend& p, const Backend& c)
boost::multiprecision::default_ops::eval_qr	multiprecision/detail/integer_ops.hpp	/^inline void eval_qr(const Backend& x, const Backend& y, Backend& q, Backend& r)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const Backend& x, const Backend& y, Backend& q, Backend& r)
boost::multiprecision::default_ops::eval_right_shift	multiprecision/detail/default_ops.hpp	/^inline void eval_right_shift(T& result, const T& arg, const V val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg, const V val)
boost::multiprecision::default_ops::eval_round	multiprecision/detail/default_ops.hpp	/^inline void eval_round(T& result, const T& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a)
boost::multiprecision::default_ops::eval_sqrt	multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_sqrt();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
boost::multiprecision::default_ops::eval_subtract	multiprecision/detail/default_ops.hpp	/^   eval_subtract(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_subtract	multiprecision/detail/default_ops.hpp	/^inline void eval_subtract(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_subtract	multiprecision/detail/default_ops.hpp	/^void eval_subtract(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_subtract_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_subtract_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_subtract_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_subtract_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_subtract_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_signed_number<T>::value>::type eval_subtract_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_subtract_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_unsigned_number<T>::value>::type eval_subtract_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_subtract_default	multiprecision/detail/default_ops.hpp	/^inline void eval_subtract_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_subtract_default	multiprecision/detail/default_ops.hpp	/^inline void eval_subtract_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_trunc	multiprecision/detail/default_ops.hpp	/^inline void eval_trunc(T& result, const T& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a)
boost::multiprecision::default_ops::eval_trunc	multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_trunc();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
boost::multiprecision::default_ops::has_enough_bits	multiprecision/detail/default_ops.hpp	/^struct has_enough_bits$/;"	s	namespace:boost::multiprecision::default_ops
boost::multiprecision::default_ops::has_enough_bits::type	multiprecision/detail/default_ops.hpp	/^   struct type : public mpl::and_<mpl::not_<is_same<R, T> >, mpl::bool_<std::numeric_limits<T>::digits >= b> >{};$/;"	s	struct:boost::multiprecision::default_ops::has_enough_bits	inherits:mpl::and_	access:public
boost::multiprecision::default_ops::powm_func	multiprecision/detail/integer_ops.hpp	/^struct powm_func$/;"	s	namespace:boost::multiprecision::default_ops
boost::multiprecision::default_ops::powm_func::operator ()	multiprecision/detail/integer_ops.hpp	/^   void operator()(T& result, const T& b, const U& p, const V& m)const$/;"	f	struct:boost::multiprecision::default_ops::powm_func	access:public	signature:(T& result, const T& b, const U& p, const V& m) const
boost::multiprecision::default_ops::terminal	multiprecision/detail/default_ops.hpp	/^struct terminal$/;"	s	namespace:boost::multiprecision::default_ops
boost::multiprecision::default_ops::terminal::operator =	multiprecision/detail/default_ops.hpp	/^   terminal& operator = (R val) {  value = val;  }$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:(R val)
boost::multiprecision::default_ops::terminal::operator R	multiprecision/detail/default_ops.hpp	/^   operator R()const {  return value;  }$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:() const
boost::multiprecision::default_ops::terminal::terminal	multiprecision/detail/default_ops.hpp	/^   terminal(){}$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:()
boost::multiprecision::default_ops::terminal::terminal	multiprecision/detail/default_ops.hpp	/^   terminal(const R& v) : value(v){}$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:(const R& v)
boost::multiprecision::default_ops::terminal::value	multiprecision/detail/default_ops.hpp	/^   R value;$/;"	m	struct:boost::multiprecision::default_ops::terminal	access:public
boost::multiprecision::denominator	multiprecision/rational_adaptor.hpp	/^inline number<IntBackend, ET> denominator(const number<rational_adaptor<IntBackend>, ET>& val)$/;"	f	namespace:boost::multiprecision	signature:(const number<rational_adaptor<IntBackend>, ET>& val)
boost::multiprecision::detail	multiprecision/cpp_dec_float.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	multiprecision/cpp_int/cpp_int_config.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	multiprecision/detail/bitscan.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	multiprecision/detail/default_ops.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	multiprecision/detail/digits.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	multiprecision/detail/float_string_cvt.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	multiprecision/detail/generic_interconvert.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	multiprecision/detail/number_base.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	multiprecision/detail/number_compare.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	multiprecision/detail/utype_helper.hpp	/^  namespace detail$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	multiprecision/integer.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	multiprecision/miller_rabin.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	multiprecision/number.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	multiprecision/rational_adaptor.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	multiprecision/traits/explicit_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	multiprecision/traits/is_restricted_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail::abs_funct	multiprecision/detail/default_ops.hpp	/^struct abs_funct$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::abs_funct::operator ()	multiprecision/detail/default_ops.hpp	/^   void operator()(Backend& result, const Backend& arg)const$/;"	f	struct:boost::multiprecision::detail::abs_funct	access:public	signature:(Backend& result, const Backend& arg) const
boost::multiprecision::detail::add_immediates	multiprecision/detail/number_base.hpp	/^struct add_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::arg_type	multiprecision/detail/number_base.hpp	/^struct arg_type$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::arg_type	multiprecision/detail/number_base.hpp	/^struct arg_type<expression<Tag, Arg1, Arg2, Arg3, Arg4> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::arg_type::type	multiprecision/detail/number_base.hpp	/^   typedef expression<Tag, Arg1, Arg2, Arg3, Arg4> type;$/;"	t	struct:boost::multiprecision::detail::arg_type	access:public
boost::multiprecision::detail::arg_type::type	multiprecision/detail/number_base.hpp	/^   typedef expression<terminal, T> type;$/;"	t	struct:boost::multiprecision::detail::arg_type	access:public
boost::multiprecision::detail::backend_type	multiprecision/detail/number_base.hpp	/^struct backend_type<expression<tag, A1, A2, A3, A4> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::backend_type	multiprecision/detail/number_base.hpp	/^struct backend_type<number<T, ExpressionTemplates> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::backend_type::type	multiprecision/detail/number_base.hpp	/^   typedef T type;$/;"	t	struct:boost::multiprecision::detail::backend_type	access:public
boost::multiprecision::detail::backend_type::type	multiprecision/detail/number_base.hpp	/^   typedef typename backend_type<typename expression<tag, A1, A2, A3, A4>::result_type>::type type;$/;"	t	struct:boost::multiprecision::detail::backend_type	access:public
boost::multiprecision::detail::bits_of	multiprecision/detail/number_base.hpp	/^struct bits_of$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::bits_of::value	multiprecision/detail/number_base.hpp	/^   static const unsigned value =$/;"	m	struct:boost::multiprecision::detail::bits_of	access:public
boost::multiprecision::detail::bitwise_and	multiprecision/detail/number_base.hpp	/^struct bitwise_and{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::bitwise_and_immediates	multiprecision/detail/number_base.hpp	/^struct bitwise_and_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::bitwise_complement	multiprecision/detail/number_base.hpp	/^struct bitwise_complement{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::bitwise_or	multiprecision/detail/number_base.hpp	/^struct bitwise_or{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::bitwise_or_immediates	multiprecision/detail/number_base.hpp	/^struct bitwise_or_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::bitwise_xor	multiprecision/detail/number_base.hpp	/^struct bitwise_xor{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::bitwise_xor_immediates	multiprecision/detail/number_base.hpp	/^struct bitwise_xor_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical	multiprecision/detail/number_base.hpp	/^struct canonical$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical::tag_type	multiprecision/detail/number_base.hpp	/^   >::type tag_type;$/;"	t	struct:boost::multiprecision::detail::canonical	access:public
boost::multiprecision::detail::canonical::type	multiprecision/detail/number_base.hpp	/^   typedef typename canonical_imp<Val, Backend, tag_type>::type type;$/;"	t	struct:boost::multiprecision::detail::canonical	access:public
boost::multiprecision::detail::canonical_imp	multiprecision/detail/number_base.hpp	/^struct canonical_imp$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical_imp	multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<0> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical_imp	multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<1> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical_imp	multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<2> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical_imp	multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<3> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical_imp	multiprecision/detail/number_base.hpp	/^struct canonical_imp<number<B, et_off>, Backend, Tag>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical_imp	multiprecision/detail/number_base.hpp	/^struct canonical_imp<number<B, et_on>, Backend, Tag>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical_imp::iter_type	multiprecision/detail/number_base.hpp	/^   >::type iter_type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
boost::multiprecision::detail::canonical_imp::pred_type	multiprecision/detail/number_base.hpp	/^   typedef typename has_enough_bits<bits_of<Val>::value>::template type<mpl::_> pred_type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
boost::multiprecision::detail::canonical_imp::type	multiprecision/detail/number_base.hpp	/^   typedef B type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
boost::multiprecision::detail::canonical_imp::type	multiprecision/detail/number_base.hpp	/^   typedef const char* type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
boost::multiprecision::detail::canonical_imp::type	multiprecision/detail/number_base.hpp	/^   typedef typename mpl::deref<iter_type>::type type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
boost::multiprecision::detail::canonical_imp::type	multiprecision/detail/number_base.hpp	/^   typedef typename remove_cv<typename decay<const Val>::type>::type type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
boost::multiprecision::detail::cast_to_unsigned	multiprecision/miller_rabin.hpp	/^   cast_to_unsigned(const I& val)$/;"	f	namespace:boost::multiprecision::detail	signature:(const I& val)
boost::multiprecision::detail::check_shift_range	multiprecision/detail/number_base.hpp	/^void check_shift_range(V val, const mpl::false_&, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::detail	signature:(V val, const mpl::false_&, const mpl::true_&)
boost::multiprecision::detail::check_shift_range	multiprecision/detail/number_base.hpp	/^void check_shift_range(V val, const mpl::true_&, const mpl::false_&)$/;"	f	namespace:boost::multiprecision::detail	signature:(V val, const mpl::true_&, const mpl::false_&)
boost::multiprecision::detail::check_shift_range	multiprecision/detail/number_base.hpp	/^void check_shift_range(V val, const mpl::true_&, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::detail	signature:(V val, const mpl::true_&, const mpl::true_&)
boost::multiprecision::detail::check_small_factors	multiprecision/miller_rabin.hpp	/^bool check_small_factors(const I& n)$/;"	f	namespace:boost::multiprecision::detail	signature:(const I& n)
boost::multiprecision::detail::combine_expression	multiprecision/detail/number_base.hpp	/^struct combine_expression$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::combine_expression	multiprecision/detail/number_base.hpp	/^struct combine_expression<T1, number<T2, ExpressionTemplates> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::combine_expression	multiprecision/detail/number_base.hpp	/^struct combine_expression<number<T, ExpressionTemplates>, number<T, ExpressionTemplates> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::combine_expression	multiprecision/detail/number_base.hpp	/^struct combine_expression<number<T1, ExpressionTemplates1>, number<T2, ExpressionTemplates2> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::combine_expression	multiprecision/detail/number_base.hpp	/^struct combine_expression<number<T1, ExpressionTemplates>, T2>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::combine_expression::type	multiprecision/detail/number_base.hpp	/^      >::type type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
boost::multiprecision::detail::combine_expression::type	multiprecision/detail/number_base.hpp	/^   typedef number<T, ExpressionTemplates> type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
boost::multiprecision::detail::combine_expression::type	multiprecision/detail/number_base.hpp	/^   typedef number<T1, ExpressionTemplates> type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
boost::multiprecision::detail::combine_expression::type	multiprecision/detail/number_base.hpp	/^   typedef number<T2, ExpressionTemplates> type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
boost::multiprecision::detail::combine_expression::type	multiprecision/detail/number_base.hpp	/^   typedef typename mpl::if_c<(sizeof(T1() + T2()) == sizeof(T1)), T1, T2>::type type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
boost::multiprecision::detail::complement_immediates	multiprecision/detail/number_base.hpp	/^struct complement_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::convert_from_string	multiprecision/detail/float_string_cvt.hpp	/^void convert_from_string(Backend& b, const char* p)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend& b, const char* p)
boost::multiprecision::detail::convert_to_string	multiprecision/detail/float_string_cvt.hpp	/^std::string convert_to_string(Backend b, std::streamsize digits, std::ios_base::fmtflags f)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend b, std::streamsize digits, std::ios_base::fmtflags f)
boost::multiprecision::detail::digits10_2_2	multiprecision/detail/digits.hpp	/^inline unsigned long digits10_2_2(unsigned long d10)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long d10)
boost::multiprecision::detail::digits2	multiprecision/detail/number_base.hpp	/^struct digits2$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::digits2::BOOST_STATIC_ASSERT	multiprecision/detail/number_base.hpp	/^   BOOST_STATIC_ASSERT((std::numeric_limits<T>::radix == 2) || (std::numeric_limits<T>::radix == 10));$/;"	p	struct:boost::multiprecision::detail::digits2	access:public	signature:(std::numeric_limits<T>::radix == 2) || (std::numeric_limits<T>::radix == 10)
boost::multiprecision::detail::digits2::BOOST_STATIC_ASSERT	multiprecision/detail/number_base.hpp	/^   BOOST_STATIC_ASSERT(std::numeric_limits<T>::is_specialized);$/;"	p	struct:boost::multiprecision::detail::digits2	access:public	signature:(std::numeric_limits<T>::is_specialized)
boost::multiprecision::detail::digits2::value	multiprecision/detail/number_base.hpp	/^   static const long value = std::numeric_limits<T>::radix == 10 ?  (((std::numeric_limits<T>::digits + 1) * 1000L) \/ 301L) : std::numeric_limits<T>::digits;$/;"	m	struct:boost::multiprecision::detail::digits2	access:public
boost::multiprecision::detail::digits2_2_10	multiprecision/detail/digits.hpp	/^inline unsigned long digits2_2_10(unsigned long d2)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long d2)
boost::multiprecision::detail::divide_immediates	multiprecision/detail/number_base.hpp	/^struct divide_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::divides	multiprecision/detail/number_base.hpp	/^struct divides{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::double_integer	multiprecision/integer.hpp	/^struct double_integer$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::double_integer::int_t_digits	multiprecision/integer.hpp	/^   static const unsigned int_t_digits =$/;"	m	struct:boost::multiprecision::detail::double_integer	access:public
boost::multiprecision::detail::double_integer::mpl::if_c	multiprecision/integer.hpp	/^   typedef typename mpl::if_c<$/;"	t	class:boost::multiprecision::detail::double_integer::mpl	access:public
boost::multiprecision::detail::dummy_size	multiprecision/traits/explicit_conversion.hpp	/^struct dummy_size{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression	multiprecision/detail/number_base.hpp	/^struct expression$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression	multiprecision/detail/number_base.hpp	/^struct expression<tag, Arg1, Arg2, Arg3, void>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression	multiprecision/detail/number_base.hpp	/^struct expression<tag, Arg1, Arg2, void, void>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression	multiprecision/detail/number_base.hpp	/^struct expression<tag, Arg1, void, void, void>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression	multiprecision/detail/number_base.hpp	/^struct expression<terminal, Arg1, void, void, void>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression::arg	multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg1>::type arg;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
boost::multiprecision::detail::expression::arg1	multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg1>::type arg1;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
boost::multiprecision::detail::expression::arg2	multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg2>::type arg2;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
boost::multiprecision::detail::expression::arg3	multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg3>::type arg3;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
boost::multiprecision::detail::expression::arg4	multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg4>::type arg4;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
boost::multiprecision::detail::expression::arity	multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<0> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::arity	multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<1> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::arity	multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<2> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::arity	multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<3> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::arity	multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<4> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::depth	multiprecision/detail/number_base.hpp	/^   static const unsigned depth = 0;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::depth	multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_depth > right_depth ? (left_depth > middle_depth ? left_depth : middle_depth) : (right_depth > middle_depth ? right_depth : middle_depth);$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::depth	multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_depth > right_depth ? left_depth : right_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::depth	multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_max_depth > right_max_depth ? left_max_depth : right_max_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::depth	multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::expression	multiprecision/detail/number_base.hpp	/^   explicit expression(const Arg1& a) : arg(a) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a)
boost::multiprecision::detail::expression::expression	multiprecision/detail/number_base.hpp	/^   expression(const Arg1& a1, const Arg2& a2) : arg1(a1), arg2(a2) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a1, const Arg2& a2)
boost::multiprecision::detail::expression::expression	multiprecision/detail/number_base.hpp	/^   expression(const Arg1& a1, const Arg2& a2, const Arg3& a3) : arg1(a1), arg2(a2), arg3(a3) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a1, const Arg2& a2, const Arg3& a3)
boost::multiprecision::detail::expression::expression	multiprecision/detail/number_base.hpp	/^   expression(const Arg1& a1, const Arg2& a2, const Arg3& a3, const Arg4& a4) : arg1(a1), arg2(a2), arg3(a3), arg4(a4) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a1, const Arg2& a2, const Arg3& a3, const Arg4& a4)
boost::multiprecision::detail::expression::left	multiprecision/detail/number_base.hpp	/^   left_type left()const { return left_type(arg); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::left	multiprecision/detail/number_base.hpp	/^   left_type left()const { return left_type(arg1); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::left_depth	multiprecision/detail/number_base.hpp	/^   static const unsigned left_depth = left_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::left_max_depth	multiprecision/detail/number_base.hpp	/^   static const unsigned left_max_depth = left_depth > left_middle_depth ? left_depth : left_middle_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::left_middle	multiprecision/detail/number_base.hpp	/^   left_middle_type left_middle()const { return left_middle_type(arg2); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::left_middle_depth	multiprecision/detail/number_base.hpp	/^   static const unsigned left_middle_depth = left_middle_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::left_middle_result_type	multiprecision/detail/number_base.hpp	/^   typedef typename left_middle_type::result_type left_middle_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::left_middle_type	multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg2>::type left_middle_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::left_result_type	multiprecision/detail/number_base.hpp	/^   typedef typename left_type::result_type left_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::left_type	multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg1>::type left_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::middle	multiprecision/detail/number_base.hpp	/^   middle_type middle()const { return middle_type(arg2); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::middle_depth	multiprecision/detail/number_base.hpp	/^   static const unsigned middle_depth = middle_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::middle_result_type	multiprecision/detail/number_base.hpp	/^   typedef typename middle_type::result_type middle_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::middle_type	multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg2>::type middle_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::operator =	multiprecision/detail/number_base.hpp	/^   expression& operator=(const expression&);$/;"	p	struct:boost::multiprecision::detail::expression	access:private	signature:(const expression&)
boost::multiprecision::detail::expression::operator bool	multiprecision/detail/number_base.hpp	/^   explicit operator bool()const$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::operator unmentionable_type	multiprecision/detail/number_base.hpp	/^   operator unmentionable_type()const$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::result_type	multiprecision/detail/number_base.hpp	/^   >::type result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::result_type	multiprecision/detail/number_base.hpp	/^   typedef Arg1 result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::result_type	multiprecision/detail/number_base.hpp	/^   typedef typename combine_expression<left_result_type, right_result_type>::type result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::result_type	multiprecision/detail/number_base.hpp	/^   typedef typename left_type::result_type result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right	multiprecision/detail/number_base.hpp	/^   right_type right()const { return right_type(arg2); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::right	multiprecision/detail/number_base.hpp	/^   right_type right()const { return right_type(arg3); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::right	multiprecision/detail/number_base.hpp	/^   right_type right()const { return right_type(arg4); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::right_depth	multiprecision/detail/number_base.hpp	/^   static const unsigned right_depth = right_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_max_depth	multiprecision/detail/number_base.hpp	/^   static const unsigned right_max_depth = right_depth > right_middle_depth ? right_depth : right_middle_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_middle	multiprecision/detail/number_base.hpp	/^   right_middle_type right_middle()const { return right_middle_type(arg3); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::right_middle_depth	multiprecision/detail/number_base.hpp	/^   static const unsigned right_middle_depth = right_middle_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_middle_result_type	multiprecision/detail/number_base.hpp	/^   typedef typename right_middle_type::result_type right_middle_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_middle_type	multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg3>::type right_middle_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_result_type	multiprecision/detail/number_base.hpp	/^   typedef typename right_type::result_type right_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_type	multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg2>::type right_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_type	multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg3>::type right_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_type	multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg4>::type right_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::tag_type	multiprecision/detail/number_base.hpp	/^   typedef tag tag_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::tag_type	multiprecision/detail/number_base.hpp	/^   typedef terminal tag_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression_storage	multiprecision/detail/number_base.hpp	/^struct expression_storage$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression_storage	multiprecision/detail/number_base.hpp	/^struct expression_storage<T*>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression_storage	multiprecision/detail/number_base.hpp	/^struct expression_storage<const T*>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression_storage	multiprecision/detail/number_base.hpp	/^struct expression_storage<expression<tag, A1, A2, A3, A4> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression_storage::type	multiprecision/detail/number_base.hpp	/^   typedef T* type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
boost::multiprecision::detail::expression_storage::type	multiprecision/detail/number_base.hpp	/^   typedef const T& type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
boost::multiprecision::detail::expression_storage::type	multiprecision/detail/number_base.hpp	/^   typedef const T* type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
boost::multiprecision::detail::expression_storage::type	multiprecision/detail/number_base.hpp	/^   typedef expression<tag, A1, A2, A3, A4> type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
boost::multiprecision::detail::find_lsb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(Unsigned mask)$/;"	f	namespace:boost::multiprecision::detail	signature:(Unsigned mask)
boost::multiprecision::detail::find_lsb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(unsigned __int64 mask, const mpl::int_<2>&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned __int64 mask, const mpl::int_<2>&)
boost::multiprecision::detail::find_lsb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(unsigned long long mask, mpl::int_<3> const&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long long mask, mpl::int_<3> const&)
boost::multiprecision::detail::find_lsb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(unsigned long mask, const mpl::int_<1>&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long mask, const mpl::int_<1>&)
boost::multiprecision::detail::find_lsb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(unsigned long mask, mpl::int_<2> const&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long mask, mpl::int_<2> const&)
boost::multiprecision::detail::find_lsb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(unsigned mask, mpl::int_<1> const&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned mask, mpl::int_<1> const&)
boost::multiprecision::detail::find_lsb	multiprecision/detail/bitscan.hpp	/^inline unsigned find_lsb(Unsigned mask, const mpl::int_<0>&)$/;"	f	namespace:boost::multiprecision::detail	signature:(Unsigned mask, const mpl::int_<0>&)
boost::multiprecision::detail::find_msb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_msb(Unsigned mask)$/;"	f	namespace:boost::multiprecision::detail	signature:(Unsigned mask)
boost::multiprecision::detail::find_msb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_msb(Unsigned mask, const mpl::int_<2>&)$/;"	f	namespace:boost::multiprecision::detail	signature:(Unsigned mask, const mpl::int_<2>&)
boost::multiprecision::detail::find_msb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_msb(unsigned long long mask, mpl::int_<3> const&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long long mask, mpl::int_<3> const&)
boost::multiprecision::detail::find_msb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_msb(unsigned long mask, const mpl::int_<1>&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long mask, const mpl::int_<1>&)
boost::multiprecision::detail::find_msb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_msb(unsigned long mask, mpl::int_<2> const&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long mask, mpl::int_<2> const&)
boost::multiprecision::detail::find_msb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_msb(unsigned mask, mpl::int_<1> const&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned mask, mpl::int_<1> const&)
boost::multiprecision::detail::find_msb	multiprecision/detail/bitscan.hpp	/^inline unsigned find_msb(Unsigned mask, const mpl::int_<0>&)$/;"	f	namespace:boost::multiprecision::detail	signature:(Unsigned mask, const mpl::int_<0>&)
boost::multiprecision::detail::format_float_string	multiprecision/detail/number_base.hpp	/^void format_float_string(S& str, boost::intmax_t my_exp, boost::intmax_t digits, std::ios_base::fmtflags f, bool iszero)$/;"	f	namespace:boost::multiprecision::detail	signature:(S& str, boost::intmax_t my_exp, boost::intmax_t digits, std::ios_base::fmtflags f, bool iszero)
boost::multiprecision::detail::function	multiprecision/detail/number_base.hpp	/^struct function{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::generic_interconvert	multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& \/*to_type*\/, const mpl::int_<number_kind_floating_point>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_floating_point>& )
boost::multiprecision::detail::generic_interconvert	multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& \/*to_type*\/, const mpl::int_<number_kind_integer>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_integer>& )
boost::multiprecision::detail::generic_interconvert	multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& \/*to_type*\/, const mpl::int_<number_kind_rational>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_rational>& )
boost::multiprecision::detail::generic_interconvert	multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_integer>& \/*to_type*\/, const mpl::int_<number_kind_integer>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_integer>& , const mpl::int_<number_kind_integer>& )
boost::multiprecision::detail::generic_interconvert	multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_rational>& \/*to_type*\/, const mpl::int_<number_kind_integer>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_rational>& , const mpl::int_<number_kind_integer>& )
boost::multiprecision::detail::generic_interconvert	multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_rational>& \/*to_type*\/, const mpl::int_<number_kind_rational>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_rational>& , const mpl::int_<number_kind_rational>& )
boost::multiprecision::detail::has_enough_bits	multiprecision/detail/number_base.hpp	/^struct has_enough_bits$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::has_enough_bits::type	multiprecision/detail/number_base.hpp	/^   struct type : public mpl::bool_<bits_of<T>::value>= b>{};$/;"	s	struct:boost::multiprecision::detail::has_enough_bits	inherits:mpl::bool_,b	access:public
boost::multiprecision::detail::has_generic_interconversion	multiprecision/traits/explicit_conversion.hpp	/^struct has_generic_interconversion$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::has_generic_interconversion::type	multiprecision/traits/explicit_conversion.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::has_generic_interconversion	access:public
boost::multiprecision::detail::is_explicitly_convertible	multiprecision/cpp_dec_float.hpp	/^struct is_explicitly_convertible<cpp_dec_float<D1, E1, A1>, cpp_dec_float<D2, E2, A2> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::true_
boost::multiprecision::detail::is_explicitly_convertible	multiprecision/rational_adaptor.hpp	/^struct is_explicitly_convertible<U, rational_adaptor<IntBackend> > : public is_explicitly_convertible<U, IntBackend> {};$/;"	s	namespace:boost::multiprecision::detail	inherits:is_explicitly_convertible
boost::multiprecision::detail::is_explicitly_convertible	multiprecision/traits/explicit_conversion.hpp	/^struct is_explicitly_convertible : public is_explicitly_convertible_imp<From, To>::type$/;"	s	namespace:boost::multiprecision::detail	inherits:is_explicitly_convertible_imp::type
boost::multiprecision::detail::is_explicitly_convertible_imp	multiprecision/traits/explicit_conversion.hpp	/^struct is_explicitly_convertible_imp$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::is_explicitly_convertible_imp::selector	multiprecision/traits/explicit_conversion.hpp	/^   static type_traits::no_type selector(...);$/;"	p	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public	signature:(....)
boost::multiprecision::detail::is_explicitly_convertible_imp::selector	multiprecision/traits/explicit_conversion.hpp	/^   static type_traits::yes_type selector(dummy_size<sizeof(static_cast<T1>(declval<S1>()))>*);$/;"	p	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public	signature:(dummy_size<sizeof(static_cast<T1>(declval<S1>()))>*)
boost::multiprecision::detail::is_explicitly_convertible_imp::type	multiprecision/traits/explicit_conversion.hpp	/^   typedef boost::integral_constant<bool,value> type;$/;"	t	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public
boost::multiprecision::detail::is_explicitly_convertible_imp::value	multiprecision/traits/explicit_conversion.hpp	/^   static const bool value = sizeof(selector<S,T>(0)) == sizeof(type_traits::yes_type);$/;"	m	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public
boost::multiprecision::detail::is_lossy_conversion	multiprecision/traits/is_restricted_conversion.hpp	/^struct is_lossy_conversion$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::is_lossy_conversion::type	multiprecision/traits/is_restricted_conversion.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::is_lossy_conversion	access:public
boost::multiprecision::detail::is_lossy_conversion::value	multiprecision/traits/is_restricted_conversion.hpp	/^   static const bool value = type::value;$/;"	m	struct:boost::multiprecision::detail::is_lossy_conversion	access:public
boost::multiprecision::detail::is_restricted_conversion	multiprecision/traits/is_restricted_conversion.hpp	/^struct is_restricted_conversion$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::is_restricted_conversion::type	multiprecision/traits/is_restricted_conversion.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::is_restricted_conversion	access:public
boost::multiprecision::detail::is_restricted_conversion::value	multiprecision/traits/is_restricted_conversion.hpp	/^   static const bool value = type::value;$/;"	m	struct:boost::multiprecision::detail::is_restricted_conversion	access:public
boost::multiprecision::detail::is_small_prime	multiprecision/miller_rabin.hpp	/^inline bool is_small_prime(unsigned n)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned n)
boost::multiprecision::detail::is_valid_mixed_compare	multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::false_
boost::multiprecision::detail::is_valid_mixed_compare	multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, ET> > $/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::bool_
boost::multiprecision::detail::is_valid_mixed_compare	multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<number<B, ET>, Val> : public is_convertible<Val, number<B, ET> > {};$/;"	s	namespace:boost::multiprecision::detail	inherits:is_convertible
boost::multiprecision::detail::is_valid_mixed_compare	multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<number<B, ET>, expression<tag, Arg1, Arg2, Arg3, Arg4> > $/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::bool_
boost::multiprecision::detail::is_valid_mixed_compare	multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<number<B, ET>, number<B, ET> > : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::false_
boost::multiprecision::detail::largest_signed_type	multiprecision/cpp_int/cpp_int_config.hpp	/^struct largest_signed_type$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::largest_signed_type::type	multiprecision/cpp_int/cpp_int_config.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::largest_signed_type	access:public
boost::multiprecision::detail::largest_unsigned_type	multiprecision/cpp_int/cpp_int_config.hpp	/^struct largest_unsigned_type$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::largest_unsigned_type::type	multiprecision/cpp_int/cpp_int_config.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::largest_unsigned_type	access:public
boost::multiprecision::detail::minus	multiprecision/detail/number_base.hpp	/^struct minus{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::modulus	multiprecision/detail/number_base.hpp	/^struct modulus{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::modulus_immediates	multiprecision/detail/number_base.hpp	/^struct modulus_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::multiplies	multiprecision/detail/number_base.hpp	/^struct multiplies{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::multiply_add	multiprecision/detail/number_base.hpp	/^struct multiply_add{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::multiply_immediates	multiprecision/detail/number_base.hpp	/^struct multiply_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::multiply_subtract	multiprecision/detail/number_base.hpp	/^struct multiply_subtract{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::negate	multiprecision/detail/number_base.hpp	/^struct negate{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::operator <<	multiprecision/number.hpp	/^inline std::ostream& operator << (std::ostream& os, const expression<tag, A1, A2, A3, A4>& r)$/;"	f	namespace:boost::multiprecision::detail	signature:(std::ostream& os, const expression<tag, A1, A2, A3, A4>& r)
boost::multiprecision::detail::plus	multiprecision/detail/number_base.hpp	/^struct plus{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::round_string_up_at	multiprecision/detail/float_string_cvt.hpp	/^inline void round_string_up_at(std::string& s, int pos, int& expon)$/;"	f	namespace:boost::multiprecision::detail	signature:(std::string& s, int pos, int& expon)
boost::multiprecision::detail::shift_left	multiprecision/detail/number_base.hpp	/^struct shift_left{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::shift_right	multiprecision/detail/number_base.hpp	/^struct shift_right{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::subtract_immediates	multiprecision/detail/number_base.hpp	/^struct subtract_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::terminal	multiprecision/detail/number_base.hpp	/^struct terminal{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::unmentionable	multiprecision/detail/number_base.hpp	/^struct unmentionable$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::unmentionable::proc	multiprecision/detail/number_base.hpp	/^   unmentionable* proc(){ return 0; }$/;"	f	struct:boost::multiprecision::detail::unmentionable	access:public	signature:()
boost::multiprecision::detail::unmentionable_type	multiprecision/detail/number_base.hpp	/^typedef unmentionable* (unmentionable::*unmentionable_type)();$/;"	t	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<0U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<10U> { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<11U> { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<12U> { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<13U> { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<14U> { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<15U> { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<16U> { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<17U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<18U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<19U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<1U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<20U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<21U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<22U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<23U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<24U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<25U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<26U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<27U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<28U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<29U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<2U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<30U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<31U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<32U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<33U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<34U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<35U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<36U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<37U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<38U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<39U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<3U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<40U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<41U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<42U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<43U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<44U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<45U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<46U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<47U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<48U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<49U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<4U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<50U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<51U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<52U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<53U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<54U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<55U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<56U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<57U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<58U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<59U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<5U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<60U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<61U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<62U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<63U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<64U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<6U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<7U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<8U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<9U>  { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<const unsigned> struct utype_helper { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<0U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<10U> { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<11U> { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<12U> { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<13U> { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<14U> { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<15U> { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<16U> { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<17U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<18U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<19U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<1U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<20U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<21U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<22U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<23U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<24U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<25U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<26U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<27U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<28U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<29U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<2U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<30U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<31U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<32U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<33U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<34U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<35U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<36U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<37U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<38U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<39U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<3U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<40U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<41U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<42U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<43U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<44U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<45U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<46U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<47U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<48U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<49U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<4U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<50U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<51U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<52U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<53U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<54U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<55U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<56U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<57U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<58U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<59U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<5U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<60U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<61U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<62U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<63U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<64U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<6U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<7U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<8U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<9U>  { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_helper::exact	multiprecision/detail/utype_helper.hpp	/^  template<const unsigned> struct utype_helper { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
boost::multiprecision::detail::utype_prior	multiprecision/detail/utype_helper.hpp	/^  int utype_prior(unsigned_type ui)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned_type ui)
boost::multiprecision::digits_per_block_10	multiprecision/cpp_int/cpp_int_config.hpp	/^static const limb_type digits_per_block_10 = 18;$/;"	m	namespace:boost::multiprecision
boost::multiprecision::divide_qr	multiprecision/detail/integer_ops.hpp	/^   divide_qr(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>& y,$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
boost::multiprecision::divide_qr	multiprecision/detail/integer_ops.hpp	/^   divide_qr(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const number<Backend, ExpressionTemplates>& y,$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const number<Backend, ExpressionTemplates>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
boost::multiprecision::divide_qr	multiprecision/detail/integer_ops.hpp	/^   divide_qr(const number<Backend, ExpressionTemplates>& x, const multiprecision::detail::expression<tag, A1, A2, A3, A4>& y,$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, const multiprecision::detail::expression<tag, A1, A2, A3, A4>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
boost::multiprecision::divide_qr	multiprecision/detail/integer_ops.hpp	/^   divide_qr(const number<Backend, ExpressionTemplates>& x, const number<Backend, ExpressionTemplates>& y,$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, const number<Backend, ExpressionTemplates>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
boost::multiprecision::divide_qr	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value>::type divide_qr(const Integer& x, const Integer& y, Integer& q, Integer& r)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& x, const Integer& y, Integer& q, Integer& r)
boost::multiprecision::do_assign_arithmetic	multiprecision/cpp_int.hpp	/^   void do_assign_arithmetic(double_limb_type i, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	signature:(double_limb_type i, const mpl::false_&)
boost::multiprecision::do_assign_arithmetic	multiprecision/cpp_int.hpp	/^   void do_assign_arithmetic(long double a, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	signature:(long double a, const mpl::false_&)
boost::multiprecision::do_assign_arithmetic	multiprecision/cpp_int.hpp	/^   void do_assign_arithmetic(signed_double_limb_type i, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	signature:(signed_double_limb_type i, const mpl::false_&)
boost::multiprecision::do_assign_string	multiprecision/cpp_int.hpp	/^   void do_assign_string(const char* s, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(const char* s, const mpl::false_&)
boost::multiprecision::do_assign_string	multiprecision/cpp_int.hpp	/^   void do_assign_string(const char* s, const mpl::true_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(const char* s, const mpl::true_&)
boost::multiprecision::do_get_string	multiprecision/cpp_int.hpp	/^   std::string do_get_string(std::ios_base::fmtflags f, const mpl::false_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::false_&) const
boost::multiprecision::do_get_string	multiprecision/cpp_int.hpp	/^   std::string do_get_string(std::ios_base::fmtflags f, const mpl::true_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::true_&) const
boost::multiprecision::do_get_trivial_string	multiprecision/cpp_int.hpp	/^   std::string do_get_trivial_string(std::ios_base::fmtflags f, const mpl::false_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::false_&) const
boost::multiprecision::do_get_trivial_string	multiprecision/cpp_int.hpp	/^   std::string do_get_trivial_string(std::ios_base::fmtflags f, const mpl::true_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::true_&) const
boost::multiprecision::double_limb_type	multiprecision/cpp_int/cpp_int_config.hpp	/^typedef boost::uint128_type double_limb_type;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::et_off	multiprecision/detail/number_base.hpp	/^   et_off  = 0,$/;"	e	enum:boost::multiprecision::expression_template_option
boost::multiprecision::et_on	multiprecision/detail/number_base.hpp	/^   et_on   = 1$/;"	e	enum:boost::multiprecision::expression_template_option
boost::multiprecision::eval_abs	multiprecision/gmp.hpp	/^inline void eval_abs(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
boost::multiprecision::eval_abs	multiprecision/gmp.hpp	/^inline void eval_abs(gmp_int& result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& val)
boost::multiprecision::eval_abs	multiprecision/mpfi.hpp	/^inline void eval_abs(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)
boost::multiprecision::eval_acos	multiprecision/mpfi.hpp	/^inline void eval_acos(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
boost::multiprecision::eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
boost::multiprecision::eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
boost::multiprecision::eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
boost::multiprecision::eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
boost::multiprecision::eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
boost::multiprecision::eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
boost::multiprecision::eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
boost::multiprecision::eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
boost::multiprecision::eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
boost::multiprecision::eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
boost::multiprecision::eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
boost::multiprecision::eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
boost::multiprecision::eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
boost::multiprecision::eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
boost::multiprecision::eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)
boost::multiprecision::eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)
boost::multiprecision::eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)
boost::multiprecision::eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)
boost::multiprecision::eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)
boost::multiprecision::eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)
boost::multiprecision::eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, long i)
boost::multiprecision::eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, unsigned long i)
boost::multiprecision::eval_asin	multiprecision/mpfi.hpp	/^inline void eval_asin(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
boost::multiprecision::eval_atan	multiprecision/mpfi.hpp	/^inline void eval_atan(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
boost::multiprecision::eval_atan2	multiprecision/mpfi.hpp	/^inline void eval_atan2(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg1, const mpfi_float_backend<Digits10>& arg2)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg1, const mpfi_float_backend<Digits10>& arg2)
boost::multiprecision::eval_bitwise_and	multiprecision/gmp.hpp	/^inline void eval_bitwise_and(gmp_int& result, const gmp_int& u, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u, const gmp_int& v)
boost::multiprecision::eval_bitwise_and	multiprecision/gmp.hpp	/^inline void eval_bitwise_and(gmp_int& result, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& v)
boost::multiprecision::eval_bitwise_or	multiprecision/gmp.hpp	/^inline void eval_bitwise_or(gmp_int& result, const gmp_int& u, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u, const gmp_int& v)
boost::multiprecision::eval_bitwise_or	multiprecision/gmp.hpp	/^inline void eval_bitwise_or(gmp_int& result, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& v)
boost::multiprecision::eval_bitwise_xor	multiprecision/gmp.hpp	/^inline void eval_bitwise_xor(gmp_int& result, const gmp_int& u, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u, const gmp_int& v)
boost::multiprecision::eval_bitwise_xor	multiprecision/gmp.hpp	/^inline void eval_bitwise_xor(gmp_int& result, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& v)
boost::multiprecision::eval_ceil	multiprecision/gmp.hpp	/^inline void eval_ceil(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
boost::multiprecision::eval_ceil	multiprecision/mpfi.hpp	/^inline void eval_ceil(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)
boost::multiprecision::eval_complement	multiprecision/gmp.hpp	/^inline void eval_complement(gmp_int& result, const gmp_int& u)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u)
boost::multiprecision::eval_convert_to	multiprecision/gmp.hpp	/^inline void eval_convert_to(double* result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(double* result, const gmp_int& val)
boost::multiprecision::eval_convert_to	multiprecision/gmp.hpp	/^inline void eval_convert_to(long long* result, const gmp_float<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(long long* result, const gmp_float<digits10>& val)
boost::multiprecision::eval_convert_to	multiprecision/gmp.hpp	/^inline void eval_convert_to(long* result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(long* result, const gmp_int& val)
boost::multiprecision::eval_convert_to	multiprecision/gmp.hpp	/^inline void eval_convert_to(unsigned long long* result, const gmp_float<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(unsigned long long* result, const gmp_float<digits10>& val)
boost::multiprecision::eval_convert_to	multiprecision/gmp.hpp	/^inline void eval_convert_to(unsigned long* result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(unsigned long* result, const gmp_int& val)
boost::multiprecision::eval_convert_to	multiprecision/mpfi.hpp	/^inline void eval_convert_to(long long* result, const mpfi_float_backend<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(long long* result, const mpfi_float_backend<digits10>& val)
boost::multiprecision::eval_convert_to	multiprecision/mpfi.hpp	/^inline void eval_convert_to(long* result, const mpfi_float_backend<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(long* result, const mpfi_float_backend<digits10>& val)
boost::multiprecision::eval_convert_to	multiprecision/mpfi.hpp	/^inline void eval_convert_to(unsigned long long* result, const mpfi_float_backend<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(unsigned long long* result, const mpfi_float_backend<digits10>& val)
boost::multiprecision::eval_convert_to	multiprecision/mpfi.hpp	/^inline void eval_convert_to(unsigned long* result, const mpfi_float_backend<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(unsigned long* result, const mpfi_float_backend<digits10>& val)
boost::multiprecision::eval_cos	multiprecision/mpfi.hpp	/^inline void eval_cos(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
boost::multiprecision::eval_cosh	multiprecision/mpfi.hpp	/^inline void eval_cosh(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
boost::multiprecision::eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
boost::multiprecision::eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
boost::multiprecision::eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
boost::multiprecision::eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
boost::multiprecision::eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
boost::multiprecision::eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
boost::multiprecision::eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
boost::multiprecision::eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
boost::multiprecision::eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
boost::multiprecision::eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
boost::multiprecision::eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
boost::multiprecision::eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
boost::multiprecision::eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
boost::multiprecision::eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
boost::multiprecision::eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)
boost::multiprecision::eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)
boost::multiprecision::eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)
boost::multiprecision::eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)
boost::multiprecision::eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)
boost::multiprecision::eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)
boost::multiprecision::eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, long i)
boost::multiprecision::eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, unsigned long i)
boost::multiprecision::eval_eq	multiprecision/gmp.hpp	/^inline typename enable_if<is_arithmetic<T>, bool>::type eval_eq(const gmp_int& a, const T& b)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& a, const T& b)
boost::multiprecision::eval_exp	multiprecision/mpfi.hpp	/^inline void eval_exp(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
boost::multiprecision::eval_fabs	multiprecision/gmp.hpp	/^inline void eval_fabs(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
boost::multiprecision::eval_fabs	multiprecision/mpfi.hpp	/^inline void eval_fabs(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)
boost::multiprecision::eval_floor	multiprecision/gmp.hpp	/^inline void eval_floor(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
boost::multiprecision::eval_floor	multiprecision/mpfi.hpp	/^inline void eval_floor(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)
boost::multiprecision::eval_frexp	multiprecision/gmp.hpp	/^inline void eval_frexp(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, int* e)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, int* e)
boost::multiprecision::eval_frexp	multiprecision/gmp.hpp	/^inline void eval_frexp(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long* e)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long* e)
boost::multiprecision::eval_frexp	multiprecision/mpfi.hpp	/^inline void eval_frexp(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val, int* e)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val, int* e)
boost::multiprecision::eval_frexp	multiprecision/mpfi.hpp	/^inline void eval_frexp(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val, long* e)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val, long* e)
boost::multiprecision::eval_gcd	multiprecision/gmp.hpp	/^inline void eval_gcd(gmp_int& result, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& a, const gmp_int& b)
boost::multiprecision::eval_get_sign	multiprecision/gmp.hpp	/^inline int eval_get_sign(const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& val)
boost::multiprecision::eval_get_sign	multiprecision/mpfi.hpp	/^inline int eval_get_sign(const mpfi_float_backend<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(const mpfi_float_backend<digits10>& val)
boost::multiprecision::eval_gt	multiprecision/gmp.hpp	/^inline typename enable_if<is_arithmetic<T>, bool>::type eval_gt(const gmp_int& a, const T& b)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& a, const T& b)
boost::multiprecision::eval_is_zero	multiprecision/gmp.hpp	/^inline bool eval_is_zero(const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& val)
boost::multiprecision::eval_lcm	multiprecision/gmp.hpp	/^inline void eval_lcm(gmp_int& result, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& a, const gmp_int& b)
boost::multiprecision::eval_ldexp	multiprecision/gmp.hpp	/^inline void eval_ldexp(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long e)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long e)
boost::multiprecision::eval_ldexp	multiprecision/mpfi.hpp	/^inline void eval_ldexp(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val, long e)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val, long e)
boost::multiprecision::eval_left_shift	multiprecision/gmp.hpp	/^inline void eval_left_shift(gmp_int& t, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, UI i)
boost::multiprecision::eval_left_shift	multiprecision/gmp.hpp	/^inline void eval_left_shift(gmp_int& t, const gmp_int& v, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& v, UI i)
boost::multiprecision::eval_log	multiprecision/mpfi.hpp	/^inline void eval_log(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
boost::multiprecision::eval_log10	multiprecision/mpfi.hpp	/^inline void eval_log10(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
boost::multiprecision::eval_lt	multiprecision/gmp.hpp	/^inline typename enable_if<is_arithmetic<T>, bool>::type eval_lt(const gmp_int& a, const T& b)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& a, const T& b)
boost::multiprecision::eval_modulus	multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
boost::multiprecision::eval_modulus	multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
boost::multiprecision::eval_modulus	multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
boost::multiprecision::eval_modulus	multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
boost::multiprecision::eval_modulus	multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
boost::multiprecision::eval_modulus	multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
boost::multiprecision::eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
boost::multiprecision::eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
boost::multiprecision::eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
boost::multiprecision::eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
boost::multiprecision::eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
boost::multiprecision::eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
boost::multiprecision::eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
boost::multiprecision::eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
boost::multiprecision::eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
boost::multiprecision::eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
boost::multiprecision::eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
boost::multiprecision::eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
boost::multiprecision::eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
boost::multiprecision::eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
boost::multiprecision::eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)
boost::multiprecision::eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)
boost::multiprecision::eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)
boost::multiprecision::eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)
boost::multiprecision::eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)
boost::multiprecision::eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)
boost::multiprecision::eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, long i)
boost::multiprecision::eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, unsigned long i)
boost::multiprecision::eval_multiply_add	multiprecision/gmp.hpp	/^inline void eval_multiply_add(gmp_int& t, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, const gmp_int& b)
boost::multiprecision::eval_multiply_add	multiprecision/gmp.hpp	/^inline void eval_multiply_add(gmp_int& t, const gmp_int& a, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, long i)
boost::multiprecision::eval_multiply_add	multiprecision/gmp.hpp	/^inline void eval_multiply_add(gmp_int& t, const gmp_int& a, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, unsigned long i)
boost::multiprecision::eval_multiply_subtract	multiprecision/gmp.hpp	/^inline void eval_multiply_subtract(gmp_int& t, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, const gmp_int& b)
boost::multiprecision::eval_multiply_subtract	multiprecision/gmp.hpp	/^inline void eval_multiply_subtract(gmp_int& t, const gmp_int& a, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, long i)
boost::multiprecision::eval_multiply_subtract	multiprecision/gmp.hpp	/^inline void eval_multiply_subtract(gmp_int& t, const gmp_int& a, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, unsigned long i)
boost::multiprecision::eval_pow	multiprecision/mpfi.hpp	/^inline void eval_pow(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& b, const mpfi_float_backend<Digits10>& e)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& b, const mpfi_float_backend<Digits10>& e)
boost::multiprecision::eval_right_shift	multiprecision/gmp.hpp	/^inline void eval_right_shift(gmp_int& t, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, UI i)
boost::multiprecision::eval_right_shift	multiprecision/gmp.hpp	/^inline void eval_right_shift(gmp_int& t, const gmp_int& v, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& v, UI i)
boost::multiprecision::eval_sin	multiprecision/mpfi.hpp	/^inline void eval_sin(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
boost::multiprecision::eval_sinh	multiprecision/mpfi.hpp	/^inline void eval_sinh(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
boost::multiprecision::eval_sqrt	multiprecision/gmp.hpp	/^inline void eval_sqrt(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
boost::multiprecision::eval_sqrt	multiprecision/mpfi.hpp	/^inline void eval_sqrt(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)
boost::multiprecision::eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
boost::multiprecision::eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
boost::multiprecision::eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
boost::multiprecision::eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
boost::multiprecision::eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
boost::multiprecision::eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
boost::multiprecision::eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
boost::multiprecision::eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
boost::multiprecision::eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
boost::multiprecision::eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
boost::multiprecision::eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
boost::multiprecision::eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
boost::multiprecision::eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
boost::multiprecision::eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
boost::multiprecision::eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)
boost::multiprecision::eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)
boost::multiprecision::eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)
boost::multiprecision::eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)
boost::multiprecision::eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)
boost::multiprecision::eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)
boost::multiprecision::eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, long i)
boost::multiprecision::eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, unsigned long i)
boost::multiprecision::eval_tan	multiprecision/mpfi.hpp	/^inline void eval_tan(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
boost::multiprecision::eval_tanh	multiprecision/mpfi.hpp	/^inline void eval_tanh(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
boost::multiprecision::eval_trunc	multiprecision/gmp.hpp	/^inline void eval_trunc(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
boost::multiprecision::expression_template_default	multiprecision/detail/number_base.hpp	/^struct expression_template_default$/;"	s	namespace:boost::multiprecision
boost::multiprecision::expression_template_default	multiprecision/rational_adaptor.hpp	/^struct expression_template_default<backends::rational_adaptor<IntBackend> > : public expression_template_default<IntBackend> {};$/;"	s	namespace:boost::multiprecision	inherits:expression_template_default
boost::multiprecision::expression_template_default::value	multiprecision/detail/number_base.hpp	/^   static const expression_template_option value = et_on;$/;"	m	struct:boost::multiprecision::expression_template_default	access:public
boost::multiprecision::expression_template_option	multiprecision/detail/number_base.hpp	/^enum expression_template_option$/;"	g	namespace:boost::multiprecision
boost::multiprecision::float128	multiprecision/float128.hpp	/^typedef number<float128_backend, et_off> float128;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::gmp_float	multiprecision/gmp.hpp	/^struct gmp_float<0> : public detail::gmp_float_imp<0>$/;"	s	namespace:boost::multiprecision	inherits:detail::gmp_float_imp
boost::multiprecision::gmp_float::BOOST_NOEXCEPT	multiprecision/gmp.hpp	/^   gmp_float(gmp_float&& o) BOOST_NOEXCEPT : detail::gmp_float_imp<0>(static_cast<detail::gmp_float_imp<0>&&>(o)) {}$/;"	m	struct:boost::multiprecision::gmp_float	access:public
boost::multiprecision::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float()$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:()
boost::multiprecision::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_float& o) : detail::gmp_float_imp<0>(o) {}$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float& o)
boost::multiprecision::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_float& o, unsigned digits10)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float& o, unsigned digits10)
boost::multiprecision::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_float<D>& o)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float<D>& o)
boost::multiprecision::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_rational& o)
boost::multiprecision::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpf_t val)
boost::multiprecision::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpq_t val)
boost::multiprecision::gmp_float::gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpz_t val)
boost::multiprecision::gmp_float::operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const V& v)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const V& v)
boost::multiprecision::gmp_float::operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_float& o)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float& o)
boost::multiprecision::gmp_float::operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_float<D>& o)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float<D>& o)
boost::multiprecision::gmp_float::operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_int& o);$/;"	p	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_int& o)
boost::multiprecision::gmp_float::operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_rational& o)
boost::multiprecision::gmp_float::operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpf_t val)
boost::multiprecision::gmp_float::operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpq_t val)
boost::multiprecision::gmp_float::operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpz_t val)
boost::multiprecision::gmp_int	multiprecision/gmp.hpp	/^struct gmp_int$/;"	s	namespace:boost::multiprecision
boost::multiprecision::gmp_int::compare	multiprecision/gmp.hpp	/^   int compare(V v)const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(V v) const
boost::multiprecision::gmp_int::float_types	multiprecision/gmp.hpp	/^   typedef mpl::list<double, long double>                 float_types;$/;"	t	struct:boost::multiprecision::gmp_int	access:public
boost::multiprecision::gmp_int::gmp_int	multiprecision/gmp.hpp	/^   explicit gmp_int(const gmp_float<Digits10>& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_float<Digits10>& o)
boost::multiprecision::gmp_int::gmp_int	multiprecision/gmp.hpp	/^   explicit gmp_int(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_rational& o)
boost::multiprecision::gmp_int::gmp_int	multiprecision/gmp.hpp	/^   explicit gmp_int(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpf_t val)
boost::multiprecision::gmp_int::gmp_int	multiprecision/gmp.hpp	/^   explicit gmp_int(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpq_t val)
boost::multiprecision::gmp_int::gmp_int	multiprecision/gmp.hpp	/^   gmp_int()$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:()
boost::multiprecision::gmp_int::gmp_int	multiprecision/gmp.hpp	/^   gmp_int(const gmp_int& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_int& o)
boost::multiprecision::gmp_int::gmp_int	multiprecision/gmp.hpp	/^   gmp_int(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpz_t val)
boost::multiprecision::gmp_int::m_data	multiprecision/gmp.hpp	/^   mpz_t m_data;$/;"	m	struct:boost::multiprecision::gmp_int	access:protected
boost::multiprecision::gmp_int::operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (const char* s)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const char* s)
boost::multiprecision::gmp_int::operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (const gmp_int& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_int& o)
boost::multiprecision::gmp_int::operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (double d)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(double d)
boost::multiprecision::gmp_int::operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (long double a)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(long double a)
boost::multiprecision::gmp_int::operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(long i)
boost::multiprecision::gmp_int::operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (long long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(long long i)
boost::multiprecision::gmp_int::operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (unsigned long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(unsigned long i)
boost::multiprecision::gmp_int::operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(unsigned long long i)
boost::multiprecision::gmp_int::operator =	multiprecision/gmp.hpp	/^   gmp_int& operator=(const gmp_float<Digits10>& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_float<Digits10>& o)
boost::multiprecision::gmp_int::operator =	multiprecision/gmp.hpp	/^   gmp_int& operator=(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_rational& o)
boost::multiprecision::gmp_int::operator =	multiprecision/gmp.hpp	/^   gmp_int& operator=(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpf_t val)
boost::multiprecision::gmp_int::operator =	multiprecision/gmp.hpp	/^   gmp_int& operator=(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpq_t val)
boost::multiprecision::gmp_int::operator =	multiprecision/gmp.hpp	/^   gmp_int& operator=(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpz_t val)
boost::multiprecision::gmp_int::signed_types	multiprecision/gmp.hpp	/^   typedef mpl::list<long, long long>                     signed_types;$/;"	t	struct:boost::multiprecision::gmp_int	access:public
boost::multiprecision::gmp_int::str	multiprecision/gmp.hpp	/^   std::string str(std::streamsize \/*digits*\/, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(std::streamsize , std::ios_base::fmtflags f) const
boost::multiprecision::gmp_int::swap	multiprecision/gmp.hpp	/^   void swap(gmp_int& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(gmp_int& o)
boost::multiprecision::gmp_int::unsigned_types	multiprecision/gmp.hpp	/^   typedef mpl::list<unsigned long, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::gmp_int	access:public
boost::multiprecision::integer_modulus	multiprecision/detail/integer_ops.hpp	/^   integer_modulus(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, Integer val)$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, Integer val)
boost::multiprecision::integer_modulus	multiprecision/detail/integer_ops.hpp	/^   integer_modulus(const number<Backend, ExpressionTemplates>& x, Integer val)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, Integer val)
boost::multiprecision::integer_modulus	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<I1>::value && is_integral<I2>::value, I2>::type integer_modulus(const I1& x, I2 val)$/;"	f	namespace:boost::multiprecision	signature:(const I1& x, I2 val)
boost::multiprecision::interval_error	multiprecision/mpfi.hpp	/^struct interval_error : public std::runtime_error$/;"	s	namespace:boost::multiprecision	inherits:std::runtime_error
boost::multiprecision::interval_error::interval_error	multiprecision/mpfi.hpp	/^   interval_error(const std::string& s) : std::runtime_error(s) {}$/;"	f	struct:boost::multiprecision::interval_error	access:public	signature:(const std::string& s)
boost::multiprecision::iround	multiprecision/detail/default_ops.hpp	/^inline int iround(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
boost::multiprecision::iround	multiprecision/detail/default_ops.hpp	/^inline int iround(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::iround	multiprecision/detail/default_ops.hpp	/^inline int iround(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
boost::multiprecision::iround	multiprecision/detail/default_ops.hpp	/^inline int iround(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
boost::multiprecision::is_compatible_arithmetic_type	multiprecision/detail/number_base.hpp	/^struct is_compatible_arithmetic_type$/;"	s	namespace:boost::multiprecision	inherits:mpl::bool_
boost::multiprecision::is_interval_number	multiprecision/detail/number_base.hpp	/^struct is_interval_number : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::false_
boost::multiprecision::is_interval_number	multiprecision/detail/number_base.hpp	/^struct is_interval_number<number<Backend, ExpressionTemplates> > : public is_interval_number<Backend>{};$/;"	s	namespace:boost::multiprecision	inherits:is_interval_number
boost::multiprecision::is_number	multiprecision/detail/number_base.hpp	/^struct is_number : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::false_
boost::multiprecision::is_number	multiprecision/detail/number_base.hpp	/^struct is_number<number<Backend, ExpressionTemplates> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::true_
boost::multiprecision::is_number_expression	multiprecision/detail/number_base.hpp	/^struct is_number_expression : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::false_
boost::multiprecision::is_number_expression	multiprecision/detail/number_base.hpp	/^struct is_number_expression<detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::true_
boost::multiprecision::is_signed_number	multiprecision/detail/number_base.hpp	/^struct is_signed_number : public mpl::bool_<!is_unsigned_number<T>::value> {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::bool_
boost::multiprecision::is_unsigned_number	multiprecision/cpp_int.hpp	/^struct is_unsigned_number<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision	inherits:mpl::bool_
boost::multiprecision::is_unsigned_number	multiprecision/detail/number_base.hpp	/^struct is_unsigned_number : public mpl::false_{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::false_
boost::multiprecision::is_unsigned_number	multiprecision/detail/number_base.hpp	/^struct is_unsigned_number<number<Backend, ExpressionTemplates> > : public is_unsigned_number<Backend> {};$/;"	s	namespace:boost::multiprecision	inherits:is_unsigned_number
boost::multiprecision::itrunc	multiprecision/detail/default_ops.hpp	/^inline int itrunc(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
boost::multiprecision::itrunc	multiprecision/detail/default_ops.hpp	/^inline int itrunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::itrunc	multiprecision/detail/default_ops.hpp	/^inline int itrunc(const number<Backend, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& v)
boost::multiprecision::itrunc	multiprecision/detail/default_ops.hpp	/^inline int itrunc(const number<Backend, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& v, const Policy& pol)
boost::multiprecision::limb_type	multiprecision/cpp_int/cpp_int_config.hpp	/^typedef detail::largest_unsigned_type<64>::type limb_type;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::literals	multiprecision/cpp_int/literals.hpp	/^namespace literals{ namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::literals	multiprecision/cpp_int/value_pack.hpp	/^namespace literals{ namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::literals::_cppi	multiprecision/cpp_int/literals.hpp	/^constexpr typename boost::multiprecision::literals::detail::signed_cpp_int_literal_result_type<(sizeof...(STR)) - 2>::number_type operator "" _cppi()$/;"	f	namespace:boost::multiprecision::literals	signature:()
boost::multiprecision::literals::_cppui	multiprecision/cpp_int/literals.hpp	/^constexpr typename boost::multiprecision::literals::detail::unsigned_cpp_int_literal_result_type<(sizeof...(STR)) - 2>::number_type operator "" _cppui()$/;"	f	namespace:boost::multiprecision::literals	signature:()
boost::multiprecision::literals::detail	multiprecision/cpp_int/literals.hpp	/^namespace literals{ namespace detail{$/;"	n	namespace:boost::multiprecision::literals
boost::multiprecision::literals::detail	multiprecision/cpp_int/value_pack.hpp	/^namespace literals{ namespace detail{$/;"	n	namespace:boost::multiprecision::literals
boost::multiprecision::literals::detail::append_value_to_pack	multiprecision/cpp_int/literals.hpp	/^struct append_value_to_pack<v, value_pack<PACK...> >$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::append_value_to_pack::type	multiprecision/cpp_int/literals.hpp	/^   typedef value_pack<PACK..., v> type;$/;"	t	struct:boost::multiprecision::literals::detail::append_value_to_pack	access:public
boost::multiprecision::literals::detail::combine_value_to_pack	multiprecision/cpp_int/literals.hpp	/^struct combine_value_to_pack<value_pack<first, ARGS...>, value>$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::combine_value_to_pack::type	multiprecision/cpp_int/literals.hpp	/^   typedef value_pack<first | value, ARGS...> type;$/;"	t	struct:boost::multiprecision::literals::detail::combine_value_to_pack	access:public
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'0'> { static constexpr limb_type value = 0; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'1'> { static constexpr limb_type value = 1; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'2'> { static constexpr limb_type value = 2; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'3'> { static constexpr limb_type value = 3; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'4'> { static constexpr limb_type value = 4; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'5'> { static constexpr limb_type value = 5; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'6'> { static constexpr limb_type value = 6; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'7'> { static constexpr limb_type value = 7; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'8'> { static constexpr limb_type value = 8; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'9'> { static constexpr limb_type value = 9; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'A'> { static constexpr limb_type value = 10; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'B'> { static constexpr limb_type value = 11; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'C'> { static constexpr limb_type value = 12; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'D'> { static constexpr limb_type value = 13; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'E'> { static constexpr limb_type value = 14; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'F'> { static constexpr limb_type value = 15; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'a'> { static constexpr limb_type value = 10; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'b'> { static constexpr limb_type value = 11; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'c'> { static constexpr limb_type value = 12; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'d'> { static constexpr limb_type value = 13; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'e'> { static constexpr limb_type value = 14; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'f'> { static constexpr limb_type value = 15; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'0'> { static constexpr limb_type value = 0; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'1'> { static constexpr limb_type value = 1; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'2'> { static constexpr limb_type value = 2; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'3'> { static constexpr limb_type value = 3; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'4'> { static constexpr limb_type value = 4; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'5'> { static constexpr limb_type value = 5; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'6'> { static constexpr limb_type value = 6; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'7'> { static constexpr limb_type value = 7; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'8'> { static constexpr limb_type value = 8; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'9'> { static constexpr limb_type value = 9; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'A'> { static constexpr limb_type value = 10; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'B'> { static constexpr limb_type value = 11; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'C'> { static constexpr limb_type value = 12; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'D'> { static constexpr limb_type value = 13; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'E'> { static constexpr limb_type value = 14; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'F'> { static constexpr limb_type value = 15; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'a'> { static constexpr limb_type value = 10; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'b'> { static constexpr limb_type value = 11; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'c'> { static constexpr limb_type value = 12; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'d'> { static constexpr limb_type value = 13; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'e'> { static constexpr limb_type value = 14; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::hex_value::value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'f'> { static constexpr limb_type value = 15; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
boost::multiprecision::literals::detail::is_value_pack	multiprecision/cpp_int/value_pack.hpp	/^struct is_value_pack<value_pack<VALUES...> >{ static constexpr bool value = true; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::is_value_pack	multiprecision/cpp_int/value_pack.hpp	/^struct is_value_pack{ static constexpr bool value = false; };$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::is_value_pack::value	multiprecision/cpp_int/value_pack.hpp	/^struct is_value_pack<value_pack<VALUES...> >{ static constexpr bool value = true; };$/;"	m	struct:boost::multiprecision::literals::detail::is_value_pack	access:public
boost::multiprecision::literals::detail::is_value_pack::value	multiprecision/cpp_int/value_pack.hpp	/^struct is_value_pack{ static constexpr bool value = false; };$/;"	m	struct:boost::multiprecision::literals::detail::is_value_pack	access:public
boost::multiprecision::literals::detail::make_backend_from_pack	multiprecision/cpp_int/literals.hpp	/^struct make_backend_from_pack$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::make_backend_from_pack::p	multiprecision/cpp_int/literals.hpp	/^   static constexpr Pack p = {};$/;"	m	struct:boost::multiprecision::literals::detail::make_backend_from_pack	access:public
boost::multiprecision::literals::detail::make_backend_from_pack::value	multiprecision/cpp_int/literals.hpp	/^   static constexpr B value = p;$/;"	m	struct:boost::multiprecision::literals::detail::make_backend_from_pack	access:public
boost::multiprecision::literals::detail::make_backend_from_pack::value	multiprecision/cpp_int/literals.hpp	/^constexpr B make_backend_from_pack<Pack, B>::value;$/;"	m	class:boost::multiprecision::literals::detail::make_backend_from_pack
boost::multiprecision::literals::detail::make_negate_tag	multiprecision/cpp_int/value_pack.hpp	/^constexpr negate_tag make_negate_tag()$/;"	f	namespace:boost::multiprecision::literals::detail	signature:()
boost::multiprecision::literals::detail::make_packed_value_from_str	multiprecision/cpp_int/literals.hpp	/^struct make_packed_value_from_str$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::make_packed_value_from_str::BOOST_STATIC_ASSERT_MSG	multiprecision/cpp_int/literals.hpp	/^   BOOST_STATIC_ASSERT_MSG((l2 == 'X') || (l2 == 'x'), "Multi-precision integer literals must be in hexadecimal notation.");$/;"	p	struct:boost::multiprecision::literals::detail::make_packed_value_from_str	access:public	signature:(l2 == Ã) || (l2 == Ã), Ó
boost::multiprecision::literals::detail::make_packed_value_from_str::BOOST_STATIC_ASSERT_MSG	multiprecision/cpp_int/literals.hpp	/^   BOOST_STATIC_ASSERT_MSG(l1 == '0', "Multi-precision integer literals must be in hexadecimal notation.");$/;"	p	struct:boost::multiprecision::literals::detail::make_packed_value_from_str	access:public	signature:(l1 == Ã, Ó)
boost::multiprecision::literals::detail::make_packed_value_from_str::packed_type	multiprecision/cpp_int/literals.hpp	/^   typedef typename pack_values<STR...>::type packed_type;$/;"	t	struct:boost::multiprecision::literals::detail::make_packed_value_from_str	access:public
boost::multiprecision::literals::detail::make_packed_value_from_str::stripped_type	multiprecision/cpp_int/literals.hpp	/^   typedef typename strip_leading_zeros_from_pack<packed_type>::type stripped_type;$/;"	t	struct:boost::multiprecision::literals::detail::make_packed_value_from_str	access:public
boost::multiprecision::literals::detail::make_packed_value_from_str::type	multiprecision/cpp_int/literals.hpp	/^   typedef typename reverse_value_pack<stripped_type>::type type;$/;"	t	struct:boost::multiprecision::literals::detail::make_packed_value_from_str	access:public
boost::multiprecision::literals::detail::negate_tag	multiprecision/cpp_int/value_pack.hpp	/^struct negate_tag{};$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::pack_values	multiprecision/cpp_int/literals.hpp	/^struct pack_values$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::pack_values	multiprecision/cpp_int/literals.hpp	/^struct pack_values<NextChar>$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::pack_values::chars_per_limb	multiprecision/cpp_int/literals.hpp	/^   static constexpr unsigned chars_per_limb = sizeof(limb_type) * CHAR_BIT \/ 4;$/;"	m	struct:boost::multiprecision::literals::detail::pack_values	access:public
boost::multiprecision::literals::detail::pack_values::pack_type	multiprecision/cpp_int/literals.hpp	/^      recursive_packed_type>::type pack_type;$/;"	t	struct:boost::multiprecision::literals::detail::pack_values	access:public
boost::multiprecision::literals::detail::pack_values::recursive_packed_type	multiprecision/cpp_int/literals.hpp	/^   typedef typename pack_values<CHARS...>::type recursive_packed_type;$/;"	t	struct:boost::multiprecision::literals::detail::pack_values	access:public
boost::multiprecision::literals::detail::pack_values::shift	multiprecision/cpp_int/literals.hpp	/^   static constexpr unsigned shift = ((sizeof...(CHARS)) % chars_per_limb) * 4;$/;"	m	struct:boost::multiprecision::literals::detail::pack_values	access:public
boost::multiprecision::literals::detail::pack_values::type	multiprecision/cpp_int/literals.hpp	/^   typedef typename combine_value_to_pack<pack_type, value_to_add>::type type;$/;"	t	struct:boost::multiprecision::literals::detail::pack_values	access:public
boost::multiprecision::literals::detail::pack_values::type	multiprecision/cpp_int/literals.hpp	/^   typedef value_pack<value_to_add> type;$/;"	t	struct:boost::multiprecision::literals::detail::pack_values	access:public
boost::multiprecision::literals::detail::pack_values::value_to_add	multiprecision/cpp_int/literals.hpp	/^   static constexpr limb_type value_to_add = hex_value<NextChar>::value;$/;"	m	struct:boost::multiprecision::literals::detail::pack_values	access:public
boost::multiprecision::literals::detail::pack_values::value_to_add	multiprecision/cpp_int/literals.hpp	/^   static constexpr limb_type value_to_add = shift ? hex_value<NextChar>::value << shift : hex_value<NextChar>::value;$/;"	m	struct:boost::multiprecision::literals::detail::pack_values	access:public
boost::multiprecision::literals::detail::reverse_value_pack	multiprecision/cpp_int/literals.hpp	/^struct reverse_value_pack<value_pack<> >$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::reverse_value_pack	multiprecision/cpp_int/literals.hpp	/^struct reverse_value_pack<value_pack<v, VALUES...> >$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::reverse_value_pack	multiprecision/cpp_int/literals.hpp	/^struct reverse_value_pack<value_pack<v> >$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::reverse_value_pack::lead_values	multiprecision/cpp_int/literals.hpp	/^   typedef typename reverse_value_pack<value_pack<VALUES...> >::type lead_values;$/;"	t	struct:boost::multiprecision::literals::detail::reverse_value_pack	access:public
boost::multiprecision::literals::detail::reverse_value_pack::type	multiprecision/cpp_int/literals.hpp	/^   typedef typename append_value_to_pack<v, lead_values>::type type;$/;"	t	struct:boost::multiprecision::literals::detail::reverse_value_pack	access:public
boost::multiprecision::literals::detail::reverse_value_pack::type	multiprecision/cpp_int/literals.hpp	/^   typedef value_pack<> type;$/;"	t	struct:boost::multiprecision::literals::detail::reverse_value_pack	access:public
boost::multiprecision::literals::detail::reverse_value_pack::type	multiprecision/cpp_int/literals.hpp	/^   typedef value_pack<v> type;$/;"	t	struct:boost::multiprecision::literals::detail::reverse_value_pack	access:public
boost::multiprecision::literals::detail::signed_cpp_int_literal_result_type	multiprecision/cpp_int/literals.hpp	/^struct signed_cpp_int_literal_result_type$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::signed_cpp_int_literal_result_type::backend_type	multiprecision/cpp_int/literals.hpp	/^   typedef boost::multiprecision::backends::cpp_int_backend<bits, bits, signed_magnitude, unchecked, void> backend_type;$/;"	t	struct:boost::multiprecision::literals::detail::signed_cpp_int_literal_result_type	access:public
boost::multiprecision::literals::detail::signed_cpp_int_literal_result_type::bits	multiprecision/cpp_int/literals.hpp	/^   static constexpr unsigned bits = Digits * 4;$/;"	m	struct:boost::multiprecision::literals::detail::signed_cpp_int_literal_result_type	access:public
boost::multiprecision::literals::detail::signed_cpp_int_literal_result_type::number_type	multiprecision/cpp_int/literals.hpp	/^   typedef number<backend_type, et_off> number_type;$/;"	t	struct:boost::multiprecision::literals::detail::signed_cpp_int_literal_result_type	access:public
boost::multiprecision::literals::detail::strip_leading_zeros_from_pack	multiprecision/cpp_int/literals.hpp	/^struct strip_leading_zeros_from_pack<value_pack<0u, PACK...> >$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::strip_leading_zeros_from_pack	multiprecision/cpp_int/literals.hpp	/^struct strip_leading_zeros_from_pack<value_pack<PACK...> >$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::strip_leading_zeros_from_pack::type	multiprecision/cpp_int/literals.hpp	/^   typedef typename strip_leading_zeros_from_pack<value_pack<PACK...> >::type type;$/;"	t	struct:boost::multiprecision::literals::detail::strip_leading_zeros_from_pack	access:public
boost::multiprecision::literals::detail::strip_leading_zeros_from_pack::type	multiprecision/cpp_int/literals.hpp	/^   typedef value_pack<PACK...> type;$/;"	t	struct:boost::multiprecision::literals::detail::strip_leading_zeros_from_pack	access:public
boost::multiprecision::literals::detail::unsigned_cpp_int_literal_result_type	multiprecision/cpp_int/literals.hpp	/^struct unsigned_cpp_int_literal_result_type$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::unsigned_cpp_int_literal_result_type::backend_type	multiprecision/cpp_int/literals.hpp	/^   typedef boost::multiprecision::backends::cpp_int_backend<bits, bits, unsigned_magnitude, unchecked, void> backend_type;$/;"	t	struct:boost::multiprecision::literals::detail::unsigned_cpp_int_literal_result_type	access:public
boost::multiprecision::literals::detail::unsigned_cpp_int_literal_result_type::bits	multiprecision/cpp_int/literals.hpp	/^   static constexpr unsigned bits = Digits * 4;$/;"	m	struct:boost::multiprecision::literals::detail::unsigned_cpp_int_literal_result_type	access:public
boost::multiprecision::literals::detail::unsigned_cpp_int_literal_result_type::number_type	multiprecision/cpp_int/literals.hpp	/^   typedef number<backend_type, et_off> number_type;$/;"	t	struct:boost::multiprecision::literals::detail::unsigned_cpp_int_literal_result_type	access:public
boost::multiprecision::literals::detail::value_pack	multiprecision/cpp_int/value_pack.hpp	/^struct value_pack$/;"	s	namespace:boost::multiprecision::literals::detail
boost::multiprecision::literals::detail::value_pack::next_type	multiprecision/cpp_int/value_pack.hpp	/^   typedef value_pack<0, VALUES...> next_type;$/;"	t	struct:boost::multiprecision::literals::detail::value_pack	access:public
boost::multiprecision::literals::detail::value_pack::value_pack	multiprecision/cpp_int/value_pack.hpp	/^   constexpr value_pack(){}$/;"	f	struct:boost::multiprecision::literals::detail::value_pack	access:public	signature:()
boost::multiprecision::llround	multiprecision/detail/default_ops.hpp	/^inline long long llround(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
boost::multiprecision::llround	multiprecision/detail/default_ops.hpp	/^inline long long llround(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::llround	multiprecision/detail/default_ops.hpp	/^inline long long llround(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
boost::multiprecision::llround	multiprecision/detail/default_ops.hpp	/^inline long long llround(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
boost::multiprecision::lltrunc	multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
boost::multiprecision::lltrunc	multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::lltrunc	multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
boost::multiprecision::lltrunc	multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
boost::multiprecision::log_postfix_event	multiprecision/logged_adaptor.hpp	/^inline void log_postfix_event(const Backend&, const T&, const char* \/*event_description*\/)$/;"	f	namespace:boost::multiprecision	signature:(const Backend&, const T&, const char* )
boost::multiprecision::log_postfix_event	multiprecision/logged_adaptor.hpp	/^inline void log_postfix_event(const Backend&, const char* \/*event_description*\/)$/;"	f	namespace:boost::multiprecision	signature:(const Backend&, const char* )
boost::multiprecision::log_prefix_event	multiprecision/logged_adaptor.hpp	/^inline void log_prefix_event(const Backend&, const T&, const U&, const V&, const char* \/*event_description*\/)$/;"	f	namespace:boost::multiprecision	signature:(const Backend&, const T&, const U&, const V&, const char* )
boost::multiprecision::log_prefix_event	multiprecision/logged_adaptor.hpp	/^inline void log_prefix_event(const Backend&, const T&, const U&, const char* \/*event_description*\/)$/;"	f	namespace:boost::multiprecision	signature:(const Backend&, const T&, const U&, const char* )
boost::multiprecision::log_prefix_event	multiprecision/logged_adaptor.hpp	/^inline void log_prefix_event(const Backend&, const T&, const char* \/*event_description*\/)$/;"	f	namespace:boost::multiprecision	signature:(const Backend&, const T&, const char* )
boost::multiprecision::log_prefix_event	multiprecision/logged_adaptor.hpp	/^inline void log_prefix_event(const Backend&, const char* \/*event_description*\/)$/;"	f	namespace:boost::multiprecision	signature:(const Backend&, const char* )
boost::multiprecision::lround	multiprecision/detail/default_ops.hpp	/^inline long lround(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
boost::multiprecision::lround	multiprecision/detail/default_ops.hpp	/^inline long lround(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::lround	multiprecision/detail/default_ops.hpp	/^inline long lround(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
boost::multiprecision::lround	multiprecision/detail/default_ops.hpp	/^inline long lround(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
boost::multiprecision::lsb	multiprecision/detail/integer_ops.hpp	/^   lsb(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x)$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x)
boost::multiprecision::lsb	multiprecision/detail/integer_ops.hpp	/^   lsb(const number<Backend, ExpressionTemplates>& x)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x)
boost::multiprecision::lsb	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, unsigned>::type lsb(const Integer& val)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& val)
boost::multiprecision::ltrunc	multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
boost::multiprecision::ltrunc	multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::ltrunc	multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
boost::multiprecision::ltrunc	multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
boost::multiprecision::m_data	multiprecision/gmp.hpp	/^      mpf_init2(this->m_data, multiprecision::detail::digits10_2_2(Digits10 ? Digits10 : this->get_default_precision()));$/;"	m	namespace:boost::multiprecision
boost::multiprecision::max_block_10	multiprecision/cpp_int/cpp_int_config.hpp	/^static const limb_type max_block_10 = 1000000000000000000uLL;$/;"	m	namespace:boost::multiprecision
boost::multiprecision::miller_rabin_test	multiprecision/miller_rabin.hpp	/^   miller_rabin_test(const I& n, unsigned trials, Engine& gen)$/;"	f	namespace:boost::multiprecision	signature:(const I& n, unsigned trials, Engine& gen)
boost::multiprecision::miller_rabin_test	multiprecision/miller_rabin.hpp	/^   miller_rabin_test(const I& x, unsigned trials)$/;"	f	namespace:boost::multiprecision	signature:(const I& x, unsigned trials)
boost::multiprecision::miller_rabin_test	multiprecision/miller_rabin.hpp	/^bool miller_rabin_test(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials)
boost::multiprecision::miller_rabin_test	multiprecision/miller_rabin.hpp	/^bool miller_rabin_test(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials, Engine& gen)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials, Engine& gen)
boost::multiprecision::minmax	multiprecision/cpp_int/cpp_int_config.hpp	/^inline void minmax(const T& a, const T& b, T& aa, T& bb)$/;"	f	namespace:boost::multiprecision	signature:(const T& a, const T& b, T& aa, T& bb)
boost::multiprecision::mpf_set	multiprecision/gmp.hpp	/^   mpf_set(this->m_data, o.data());$/;"	p	namespace:boost::multiprecision	signature:(this->m_data, o.data())
boost::multiprecision::mpfr_allocation_type	multiprecision/mpfr.hpp	/^enum mpfr_allocation_type$/;"	g	namespace:boost::multiprecision
boost::multiprecision::msb	multiprecision/detail/integer_ops.hpp	/^   msb(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x)$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x)
boost::multiprecision::msb	multiprecision/detail/integer_ops.hpp	/^   msb(const number<Backend, ExpressionTemplates>& x)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x)
boost::multiprecision::msb	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, unsigned>::type msb(Integer val)$/;"	f	namespace:boost::multiprecision	signature:(Integer val)
boost::multiprecision::multiply	multiprecision/detail/default_ops.hpp	/^   multiply(number<B, ET>& result, const I& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, ET>& result, const I& a, const I& b)
boost::multiprecision::multiply	multiprecision/detail/default_ops.hpp	/^inline number<B1, ET1>& multiply(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)
boost::multiprecision::multiply	multiprecision/integer.hpp	/^   multiply(Integer& result, const I2& a, const I2& b)$/;"	f	namespace:boost::multiprecision	signature:(Integer& result, const I2& a, const I2& b)
boost::multiprecision::number	multiprecision/number.hpp	/^class number$/;"	c	namespace:boost::multiprecision
boost::multiprecision::number::assign	multiprecision/number.hpp	/^   number& assign(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
boost::multiprecision::number::backend_type	multiprecision/number.hpp	/^   typedef Backend backend_type;$/;"	t	class:boost::multiprecision::number	access:public
boost::multiprecision::number::noexcept	multiprecision/number.hpp	/^         >::type* = 0) BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Other&>(std::declval<Other>()))))$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
boost::multiprecision::number::noexcept	multiprecision/number.hpp	/^      BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Backend&>(std::declval<Backend>())))) : m_backend(val.backend()) {}$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
boost::multiprecision::number::noexcept	multiprecision/number.hpp	/^      BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Other&>(std::declval<Other>()))))$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
boost::multiprecision::number::noexcept	multiprecision/number.hpp	/^      BOOST_NOEXCEPT_IF(noexcept(std::declval<Backend>() = static_cast<const Backend&>(std::declval<Backend>())))$/;"	p	class:boost::multiprecision::number	access:public	signature:(std::declval<Backend>(
boost::multiprecision::number::noexcept	multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number() BOOST_NOEXCEPT_IF(noexcept(Backend())) {}$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
boost::multiprecision::number::noexcept	multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const number& e) BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Backend&>(std::declval<Backend>())))) : m_backend(e.m_backend){}$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
boost::multiprecision::number::number	multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const V& v, typename boost::enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename boost::enable_if_c< is_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && !detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value >::type* = 0)
boost::multiprecision::number::number	multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const number& e, unsigned digits10)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const number& e, unsigned digits10)
boost::multiprecision::number::number	multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE number(V v1, V v2, typename boost::enable_if<mpl::or_<boost::is_arithmetic<V>, is_same<std::string, V>, is_convertible<V, const char*> > >::type* = 0)$/;"	f	class:boost::multiprecision::number	access:public	signature:(V v1, V v2, typename boost::enable_if<mpl::or_<boost::is_arithmetic<V>, is_same<std::string, V>, is_convertible<V, const char*> > >::type* = 0)
boost::multiprecision::number::number	multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE number(const V& v, typename boost::enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename boost::enable_if_c< (boost::is_arithmetic<V>::value || is_same<std::string, V>::value || is_convertible<V, const char*>::value) && !is_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && !detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value >::type* = 0)
boost::multiprecision::number::number	multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE number(const number<Other, ET>& v1, const number<Other, ET>& v2, typename boost::enable_if<boost::is_convertible<Other, Backend> >::type* = 0)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const number<Other, ET>& v1, const number<Other, ET>& v2, typename boost::enable_if<boost::is_convertible<Other, Backend> >::type* = 0)
boost::multiprecision::number::number	multiprecision/number.hpp	/^   explicit BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const V& v, typename boost::enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename boost::enable_if_c< detail::is_explicitly_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && (detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value || !is_convertible<typename detail::canonical<V, Backend>::type, Backend>::value) >::type* = 0)
boost::multiprecision::number::number	multiprecision/number.hpp	/^   explicit BOOST_MP_FORCEINLINE number(const V& v, typename boost::enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename boost::enable_if_c< (boost::is_arithmetic<V>::value || is_same<std::string, V>::value || is_convertible<V, const char*>::value) && !detail::is_explicitly_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value >::type* = 0)
boost::multiprecision::number::number	multiprecision/number.hpp	/^   explicit number(const number<Other, ET>& val, typename boost::enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const number<Other, ET>& val, typename boost::enable_if_c< (!detail::is_explicitly_convertible<Other, Backend>::value) >::type* = 0)
boost::multiprecision::number::operator =	multiprecision/number.hpp	/^   typename boost::enable_if<is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>, number&>::type operator=(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
boost::multiprecision::number::self_type	multiprecision/number.hpp	/^   typedef number<Backend, ExpressionTemplates> self_type;$/;"	t	class:boost::multiprecision::number	access:private
boost::multiprecision::number_category	multiprecision/concepts/mp_number_archetypes.hpp	/^struct number_category<concepts::number_backend_float_architype> : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	multiprecision/cpp_dec_float.hpp	/^struct number_category<backends::cpp_dec_float<Digits10, ExponentType, Allocator> > : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	multiprecision/debug_adaptor.hpp	/^struct number_category<backends::debug_adaptor<Backend> > : public number_category<Backend> {};$/;"	s	namespace:boost::multiprecision	inherits:number_category
boost::multiprecision::number_category	multiprecision/detail/number_base.hpp	/^struct number_category : public mpl::int_<std::numeric_limits<Num>::is_integer ? number_kind_integer : (std::numeric_limits<Num>::max_exponent ? number_kind_floating_point : number_kind_unknown)> {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	multiprecision/detail/number_base.hpp	/^struct number_category<detail::expression<tag, A1, A2, A3, A4> > : public number_category<typename detail::expression<tag, A1, A2, A3, A4>::result_type>{};$/;"	s	namespace:boost::multiprecision	inherits:number_category
boost::multiprecision::number_category	multiprecision/detail/number_base.hpp	/^struct number_category<number<Backend, ExpressionTemplates> > : public number_category<Backend>{};$/;"	s	namespace:boost::multiprecision	inherits:number_category
boost::multiprecision::number_category	multiprecision/float128.hpp	/^struct number_category<backends::float128_backend> : public mpl::int_<number_kind_floating_point> {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	multiprecision/float128.hpp	/^struct number_category<float128_type> : public mpl::int_<number_kind_floating_point> {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	multiprecision/gmp.hpp	/^struct number_category<backends::gmp_float<digits10> > : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	multiprecision/gmp.hpp	/^struct number_category<backends::gmp_int> : public mpl::int_<number_kind_integer>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	multiprecision/gmp.hpp	/^struct number_category<backends::gmp_rational> : public mpl::int_<number_kind_rational>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	multiprecision/logged_adaptor.hpp	/^struct number_category<backends::logged_adaptor<Backend> > : public number_category<Backend> {};$/;"	s	namespace:boost::multiprecision	inherits:number_category
boost::multiprecision::number_category	multiprecision/mpfi.hpp	/^struct number_category<backends::mpfi_float_backend<digits10> > : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	multiprecision/mpfr.hpp	/^struct number_category<backends::mpfr_float_backend<digits10, AllocationType> > : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	multiprecision/rational_adaptor.hpp	/^struct number_category<backends::rational_adaptor<IntBackend> > : public mpl::int_<number_kind_rational>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	multiprecision/tommath.hpp	/^struct number_category<tommath_int> : public mpl::int_<number_kind_integer>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category_type	multiprecision/detail/number_base.hpp	/^enum number_category_type$/;"	g	namespace:boost::multiprecision
boost::multiprecision::number_kind_fixed_point	multiprecision/detail/number_base.hpp	/^   number_kind_fixed_point = 3$/;"	e	enum:boost::multiprecision::number_category_type
boost::multiprecision::number_kind_floating_point	multiprecision/detail/number_base.hpp	/^   number_kind_floating_point = 1,$/;"	e	enum:boost::multiprecision::number_category_type
boost::multiprecision::number_kind_integer	multiprecision/detail/number_base.hpp	/^   number_kind_integer = 0,$/;"	e	enum:boost::multiprecision::number_category_type
boost::multiprecision::number_kind_rational	multiprecision/detail/number_base.hpp	/^   number_kind_rational = 2,$/;"	e	enum:boost::multiprecision::number_category_type
boost::multiprecision::number_kind_unknown	multiprecision/detail/number_base.hpp	/^   number_kind_unknown = -1,$/;"	e	enum:boost::multiprecision::number_category_type
boost::multiprecision::numerator	multiprecision/rational_adaptor.hpp	/^inline number<IntBackend, ET> numerator(const number<rational_adaptor<IntBackend>, ET>& val)$/;"	f	namespace:boost::multiprecision	signature:(const number<rational_adaptor<IntBackend>, ET>& val)
boost::multiprecision::operator !=	multiprecision/detail/number_compare.hpp	/^   operator != (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
boost::multiprecision::operator !=	multiprecision/detail/number_compare.hpp	/^   operator != (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator !=	multiprecision/detail/number_compare.hpp	/^   operator != (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
boost::multiprecision::operator !=	multiprecision/detail/number_compare.hpp	/^   operator != (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
boost::multiprecision::operator !=	multiprecision/detail/number_compare.hpp	/^   operator != (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
boost::multiprecision::operator !=	multiprecision/detail/number_compare.hpp	/^inline bool operator != (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator %	multiprecision/detail/et_ops.hpp	/^      operator % (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator %	multiprecision/detail/et_ops.hpp	/^      operator % (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator %	multiprecision/detail/et_ops.hpp	/^      operator % (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator %	multiprecision/detail/et_ops.hpp	/^      operator % (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator %	multiprecision/detail/et_ops.hpp	/^      operator % (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
boost::multiprecision::operator %	multiprecision/detail/et_ops.hpp	/^      operator % (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator %	multiprecision/detail/et_ops.hpp	/^      operator % (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator %	multiprecision/detail/et_ops.hpp	/^   operator % (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator %	multiprecision/detail/no_et_ops.hpp	/^   operator % (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator %	multiprecision/detail/no_et_ops.hpp	/^   operator % (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator %	multiprecision/detail/no_et_ops.hpp	/^   operator % (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator %	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator % (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator %	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator % (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
boost::multiprecision::operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator &	multiprecision/detail/no_et_ops.hpp	/^   operator & (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator &	multiprecision/detail/no_et_ops.hpp	/^   operator & (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
boost::multiprecision::operator &	multiprecision/detail/no_et_ops.hpp	/^   operator & (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator &	multiprecision/detail/no_et_ops.hpp	/^   operator & (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator &	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator & (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator &	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator & (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
boost::multiprecision::operator &	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator & (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator &	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator & (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator *	multiprecision/detail/no_et_ops.hpp	/^   operator * (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator *	multiprecision/detail/no_et_ops.hpp	/^   operator * (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
boost::multiprecision::operator *	multiprecision/detail/no_et_ops.hpp	/^   operator * (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator *	multiprecision/detail/no_et_ops.hpp	/^   operator * (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator *	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator *	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
boost::multiprecision::operator *	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator *	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^inline BOOST_CONSTEXPR const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v) { return v; }$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v)
boost::multiprecision::operator +	multiprecision/detail/et_ops.hpp	/^inline BOOST_CONSTEXPR const number<B, ExpressionTemplates> operator + (const number<B, ExpressionTemplates>& v) { return v; }$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ExpressionTemplates>& v)
boost::multiprecision::operator +	multiprecision/detail/no_et_ops.hpp	/^   operator + (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator +	multiprecision/detail/no_et_ops.hpp	/^   operator + (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
boost::multiprecision::operator +	multiprecision/detail/no_et_ops.hpp	/^   operator + (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator +	multiprecision/detail/no_et_ops.hpp	/^   operator + (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator +	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator +	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
boost::multiprecision::operator +	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator +	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
boost::multiprecision::operator -	multiprecision/cpp_int/literals.hpp	/^   operator - (const number<cpp_int_backend<MinBits, MinBits, signed_magnitude, Checked, void>, et_off>& a)$/;"	f	namespace:boost::multiprecision	signature:(const number<cpp_int_backend<MinBits, MinBits, signed_magnitude, Checked, void>, et_off>& a)
boost::multiprecision::operator -	multiprecision/cpp_int/literals.hpp	/^   operator - (number<cpp_int_backend<MinBits, MinBits, signed_magnitude, Checked, void>, et_off>&& a)$/;"	f	namespace:boost::multiprecision	signature:(number<cpp_int_backend<MinBits, MinBits, signed_magnitude, Checked, void>, et_off>&& a)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^inline detail::expression<detail::negate, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v)
boost::multiprecision::operator -	multiprecision/detail/et_ops.hpp	/^inline detail::expression<detail::negate, number<B, et_on> > operator - (const number<B, et_on>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& v)
boost::multiprecision::operator -	multiprecision/detail/no_et_ops.hpp	/^   operator - (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator -	multiprecision/detail/no_et_ops.hpp	/^   operator - (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
boost::multiprecision::operator -	multiprecision/detail/no_et_ops.hpp	/^   operator - (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator -	multiprecision/detail/no_et_ops.hpp	/^   operator - (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator -	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator -	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (const number<B, et_off>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& v)
boost::multiprecision::operator -	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator -	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
boost::multiprecision::operator -	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (number<B, et_off>&& v)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& v)
boost::multiprecision::operator -	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if<is_signed_number<B>, number<B, et_off> >::type operator - (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator /	multiprecision/detail/no_et_ops.hpp	/^   operator \/ (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator /	multiprecision/detail/no_et_ops.hpp	/^   operator \/ (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator /	multiprecision/detail/no_et_ops.hpp	/^   operator \/ (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator /	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator \/ (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator /	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator \/ (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator <	multiprecision/detail/number_compare.hpp	/^   operator < (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
boost::multiprecision::operator <	multiprecision/detail/number_compare.hpp	/^   operator < (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator <	multiprecision/detail/number_compare.hpp	/^   operator < (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
boost::multiprecision::operator <	multiprecision/detail/number_compare.hpp	/^   operator < (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
boost::multiprecision::operator <	multiprecision/detail/number_compare.hpp	/^   operator < (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
boost::multiprecision::operator <	multiprecision/detail/number_compare.hpp	/^inline bool operator < (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator <<	multiprecision/detail/et_ops.hpp	/^      operator << (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)
boost::multiprecision::operator <<	multiprecision/detail/et_ops.hpp	/^   operator << (const number<B, et_on>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const I& b)
boost::multiprecision::operator <<	multiprecision/detail/no_et_ops.hpp	/^   operator << (const number<B, et_off>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const I& b)
boost::multiprecision::operator <<	multiprecision/detail/no_et_ops.hpp	/^   operator << (number<B, et_off>&& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const I& b)
boost::multiprecision::operator <<	multiprecision/number.hpp	/^inline std::ostream& operator << (std::ostream& os, const number<Backend, ExpressionTemplates>& r)$/;"	f	namespace:boost::multiprecision	signature:(std::ostream& os, const number<Backend, ExpressionTemplates>& r)
boost::multiprecision::operator <=	multiprecision/detail/number_compare.hpp	/^   operator <= (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
boost::multiprecision::operator <=	multiprecision/detail/number_compare.hpp	/^   operator <= (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator <=	multiprecision/detail/number_compare.hpp	/^   operator <= (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
boost::multiprecision::operator <=	multiprecision/detail/number_compare.hpp	/^   operator <= (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
boost::multiprecision::operator <=	multiprecision/detail/number_compare.hpp	/^   operator <= (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
boost::multiprecision::operator <=	multiprecision/detail/number_compare.hpp	/^inline bool operator <= (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator =	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE cpp_int_backend& operator = (Arithmetic val)$/;"	f	namespace:boost::multiprecision	access:public	signature:(Arithmetic val)
boost::multiprecision::operator =	multiprecision/cpp_int.hpp	/^   cpp_int_backend& operator = (const char* s)$/;"	f	namespace:boost::multiprecision	access:public	signature:(const char* s)
boost::multiprecision::operator ==	multiprecision/detail/number_compare.hpp	/^   operator == (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
boost::multiprecision::operator ==	multiprecision/detail/number_compare.hpp	/^   operator == (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator ==	multiprecision/detail/number_compare.hpp	/^   operator == (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
boost::multiprecision::operator ==	multiprecision/detail/number_compare.hpp	/^   operator == (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
boost::multiprecision::operator ==	multiprecision/detail/number_compare.hpp	/^   operator == (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
boost::multiprecision::operator ==	multiprecision/detail/number_compare.hpp	/^inline bool operator == (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator >	multiprecision/detail/number_compare.hpp	/^   operator > (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
boost::multiprecision::operator >	multiprecision/detail/number_compare.hpp	/^   operator > (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator >	multiprecision/detail/number_compare.hpp	/^   operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
boost::multiprecision::operator >	multiprecision/detail/number_compare.hpp	/^   operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
boost::multiprecision::operator >	multiprecision/detail/number_compare.hpp	/^   operator > (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
boost::multiprecision::operator >	multiprecision/detail/number_compare.hpp	/^inline bool operator > (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator >=	multiprecision/detail/number_compare.hpp	/^   operator >= (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
boost::multiprecision::operator >=	multiprecision/detail/number_compare.hpp	/^   operator >= (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator >=	multiprecision/detail/number_compare.hpp	/^   operator >= (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
boost::multiprecision::operator >=	multiprecision/detail/number_compare.hpp	/^   operator >= (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
boost::multiprecision::operator >=	multiprecision/detail/number_compare.hpp	/^   operator >= (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
boost::multiprecision::operator >=	multiprecision/detail/number_compare.hpp	/^inline bool operator >= (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator >>	multiprecision/detail/et_ops.hpp	/^      operator >> (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)
boost::multiprecision::operator >>	multiprecision/detail/et_ops.hpp	/^      operator >> (const number<B, et_on>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const I& b)
boost::multiprecision::operator >>	multiprecision/detail/no_et_ops.hpp	/^   operator >> (const number<B, et_off>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const I& b)
boost::multiprecision::operator >>	multiprecision/detail/no_et_ops.hpp	/^   operator >> (number<B, et_off>&& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const I& b)
boost::multiprecision::operator >>	multiprecision/number.hpp	/^inline std::istream& operator >> (std::istream& is, number<Backend, ExpressionTemplates>& r)$/;"	f	namespace:boost::multiprecision	signature:(std::istream& is, number<Backend, ExpressionTemplates>& r)
boost::multiprecision::operator ^	multiprecision/detail/et_ops.hpp	/^      operator^ (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator ^	multiprecision/detail/et_ops.hpp	/^      operator^ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator ^	multiprecision/detail/et_ops.hpp	/^      operator^ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator ^	multiprecision/detail/et_ops.hpp	/^      operator^ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
boost::multiprecision::operator ^	multiprecision/detail/et_ops.hpp	/^      operator^ (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator ^	multiprecision/detail/et_ops.hpp	/^      operator^ (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator ^	multiprecision/detail/et_ops.hpp	/^      operator^ (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator ^	multiprecision/detail/et_ops.hpp	/^   operator^ (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator ^	multiprecision/detail/no_et_ops.hpp	/^   operator ^ (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator ^	multiprecision/detail/no_et_ops.hpp	/^   operator ^ (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
boost::multiprecision::operator ^	multiprecision/detail/no_et_ops.hpp	/^   operator ^ (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator ^	multiprecision/detail/no_et_ops.hpp	/^   operator ^ (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator ^	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator ^ (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator ^	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator ^ (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
boost::multiprecision::operator ^	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator ^ (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator ^	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator ^ (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
boost::multiprecision::operator |	multiprecision/detail/et_ops.hpp	/^      operator| (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator |	multiprecision/detail/et_ops.hpp	/^      operator| (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator |	multiprecision/detail/et_ops.hpp	/^      operator| (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator |	multiprecision/detail/et_ops.hpp	/^      operator| (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator |	multiprecision/detail/et_ops.hpp	/^      operator| (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
boost::multiprecision::operator |	multiprecision/detail/et_ops.hpp	/^      operator| (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator |	multiprecision/detail/et_ops.hpp	/^      operator| (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator |	multiprecision/detail/et_ops.hpp	/^   operator| (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator |	multiprecision/detail/no_et_ops.hpp	/^   operator | (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator |	multiprecision/detail/no_et_ops.hpp	/^   operator | (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
boost::multiprecision::operator |	multiprecision/detail/no_et_ops.hpp	/^   operator | (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator |	multiprecision/detail/no_et_ops.hpp	/^   operator | (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator |	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator | (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator |	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator | (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
boost::multiprecision::operator |	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator | (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator |	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator | (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
boost::multiprecision::operator ~	multiprecision/detail/et_ops.hpp	/^      operator ~ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v) { return detail::expression<detail::bitwise_complement, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(v); }$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v)
boost::multiprecision::operator ~	multiprecision/detail/et_ops.hpp	/^      operator ~ (const number<B, et_on>& v) { return detail::expression<detail::complement_immediates, number<B, et_on> >(v); }$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& v)
boost::multiprecision::operator ~	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator ~ (const number<B, et_off>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& v)
boost::multiprecision::operator ~	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator ~ (number<B, et_off>&& v)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& v)
boost::multiprecision::powm	multiprecision/detail/integer_ops.hpp	/^   powm(const T& b, const U& p, const V& mod)$/;"	f	namespace:boost::multiprecision	signature:(const T& b, const U& p, const V& mod)
boost::multiprecision::round	multiprecision/detail/default_ops.hpp	/^inline number<T, ExpressionTemplates> round(const number<T, ExpressionTemplates>& v, const Policy&)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy&)
boost::multiprecision::round	multiprecision/detail/default_ops.hpp	/^inline typename detail::expression<tag, A1, A2, A3, A4>::result_type round(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::signed_double_limb_type	multiprecision/cpp_int/cpp_int_config.hpp	/^typedef boost::int128_type signed_double_limb_type;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::signed_limb_type	multiprecision/cpp_int/cpp_int_config.hpp	/^typedef detail::largest_signed_type<64>::type signed_limb_type;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::signed_magnitude	multiprecision/cpp_int/cpp_int_config.hpp	/^   signed_magnitude = 1,$/;"	e	enum:boost::multiprecision::cpp_integer_type
boost::multiprecision::signed_packed	multiprecision/cpp_int/cpp_int_config.hpp	/^   signed_packed = 3,$/;"	e	enum:boost::multiprecision::cpp_integer_type
boost::multiprecision::sqrt	multiprecision/detail/default_ops.hpp	/^   sqrt(const number<B, ExpressionTemplates>& x)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ExpressionTemplates>& x)
boost::multiprecision::sqrt	multiprecision/detail/default_ops.hpp	/^   sqrt(const number<B, ExpressionTemplates>& x, number<B, ExpressionTemplates>& r)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ExpressionTemplates>& x, number<B, ExpressionTemplates>& r)
boost::multiprecision::sqrt	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer>::type sqrt(const Integer& x)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& x)
boost::multiprecision::sqrt	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer>::type sqrt(const Integer& x, Integer& r)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& x, Integer& r)
boost::multiprecision::str	multiprecision/cpp_int.hpp	/^   std::string str(std::streamsize \/*digits*\/, std::ios_base::fmtflags f)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(std::streamsize , std::ios_base::fmtflags f) const
boost::multiprecision::subtract	multiprecision/detail/default_ops.hpp	/^   subtract(number<B, ET>& result, const I& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, ET>& result, const I& a, const I& b)
boost::multiprecision::subtract	multiprecision/detail/default_ops.hpp	/^inline number<B1, ET1>& subtract(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)
boost::multiprecision::subtract	multiprecision/integer.hpp	/^   subtract(Integer& result, const I2& a, const I2& b)$/;"	f	namespace:boost::multiprecision	signature:(Integer& result, const I2& a, const I2& b)
boost::multiprecision::swap	multiprecision/number.hpp	/^BOOST_MP_FORCEINLINE void swap(number<Backend, ExpressionTemplates>& a, number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& a, number<Backend, ExpressionTemplates>& b)
boost::multiprecision::tom_int	multiprecision/tommath.hpp	/^typedef number<tommath_int >                     tom_int;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::tom_rational	multiprecision/tommath.hpp	/^typedef number<tommath_rational>                 tom_rational;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::tommath_rational	multiprecision/tommath.hpp	/^typedef rational_adaptor<tommath_int>               tommath_rational;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::trunc	multiprecision/detail/default_ops.hpp	/^inline number<Backend, ExpressionTemplates> trunc(const number<Backend, ExpressionTemplates>& v, const Policy&)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& v, const Policy&)
boost::multiprecision::trunc	multiprecision/detail/default_ops.hpp	/^inline typename detail::expression<tag, A1, A2, A3, A4>::result_type trunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::unchecked	multiprecision/cpp_int/cpp_int_config.hpp	/^   unchecked = 0$/;"	e	enum:boost::multiprecision::cpp_int_check_type
boost::multiprecision::unsigned_magnitude	multiprecision/cpp_int/cpp_int_config.hpp	/^   unsigned_magnitude = 0,$/;"	e	enum:boost::multiprecision::cpp_integer_type
boost::multiprecision::unsigned_packed	multiprecision/cpp_int/cpp_int_config.hpp	/^   unsigned_packed = 2$/;"	e	enum:boost::multiprecision::cpp_integer_type
boost::number_category	multiprecision/mpfi.hpp	/^struct number_category<detail::canonical<mpfi_t, backends::mpfi_float_backend<0> >::type> : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost	inherits:mpl::int_
boost::numerator	multiprecision/number.hpp	/^inline multiprecision::number<T, ExpressionTemplates> numerator(const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a)
boost::numeric	multiprecision/detail/ublas_interop.hpp	/^namespace boost { namespace numeric { namespace ublas {$/;"	n	namespace:boost
boost::numeric::ublas	multiprecision/detail/ublas_interop.hpp	/^namespace boost { namespace numeric { namespace ublas {$/;"	n	namespace:boost::numeric
boost::numeric::ublas::operator ==	multiprecision/detail/ublas_interop.hpp	/^inline bool operator == (const sparse_vector_element<V>& a, const ::boost::multiprecision::number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::numeric::ublas	signature:(const sparse_vector_element<V>& a, const ::boost::multiprecision::number<Backend, ExpressionTemplates>& b)
boost::numeric::ublas::promote_traits	multiprecision/detail/ublas_interop.hpp	/^struct promote_traits<boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::detail::expression<tagb, Arg1b, Arg2b, Arg3b, Arg4b> >$/;"	s	namespace:boost::numeric::ublas
boost::numeric::ublas::promote_traits	multiprecision/detail/ublas_interop.hpp	/^struct promote_traits<boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::number<Backend1, ExpressionTemplates1> >$/;"	s	namespace:boost::numeric::ublas
boost::numeric::ublas::promote_traits	multiprecision/detail/ublas_interop.hpp	/^struct promote_traits<boost::multiprecision::number<Backend1, ExpressionTemplates1>, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >$/;"	s	namespace:boost::numeric::ublas
boost::numeric::ublas::promote_traits	multiprecision/detail/ublas_interop.hpp	/^struct promote_traits<boost::multiprecision::number<Backend1, ExpressionTemplates1>, boost::multiprecision::number<Backend2, ExpressionTemplates2> >$/;"	s	namespace:boost::numeric::ublas
boost::numeric::ublas::promote_traits::expression1_t	multiprecision/detail/ublas_interop.hpp	/^   typedef boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4> expression1_t;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
boost::numeric::ublas::promote_traits::expression2_t	multiprecision/detail/ublas_interop.hpp	/^   typedef boost::multiprecision::detail::expression<tagb, Arg1b, Arg2b, Arg3b, Arg4b> expression2_t;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
boost::numeric::ublas::promote_traits::expression_type	multiprecision/detail/ublas_interop.hpp	/^   typedef boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4> expression_type;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
boost::numeric::ublas::promote_traits::number1_t	multiprecision/detail/ublas_interop.hpp	/^   typedef boost::multiprecision::number<Backend1, ExpressionTemplates1> number1_t;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
boost::numeric::ublas::promote_traits::number1_t	multiprecision/detail/ublas_interop.hpp	/^   typedef typename expression1_t::result_type number1_t;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
boost::numeric::ublas::promote_traits::number2_t	multiprecision/detail/ublas_interop.hpp	/^   typedef boost::multiprecision::number<Backend2, ExpressionTemplates2> number2_t;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
boost::numeric::ublas::promote_traits::number2_t	multiprecision/detail/ublas_interop.hpp	/^   typedef typename expression2_t::result_type number2_t;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
boost::numeric::ublas::promote_traits::number2_t	multiprecision/detail/ublas_interop.hpp	/^   typedef typename expression_type::result_type number2_t;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
boost::numeric::ublas::promote_traits::promote_type	multiprecision/detail/ublas_interop.hpp	/^   >::type promote_type;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
boost::numeric::ublas::promote_traits::promote_type	multiprecision/detail/ublas_interop.hpp	/^   typedef typename promote_traits<number1_t, number2_t>::promote_type promote_type;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
boost::operator !=	multiprecision/number.hpp	/^typename boost::enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator != (const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)
boost::operator !=	multiprecision/number.hpp	/^typename boost::enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator != (const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)
boost::operator ==	multiprecision/number.hpp	/^typename boost::enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator == (const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)
boost::operator ==	multiprecision/number.hpp	/^typename boost::enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator == (const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)
boost::operator >>	multiprecision/number.hpp	/^inline std::istream& operator >> (std::istream& is, rational<multiprecision::number<Backend, ExpressionTemplates> >& r)$/;"	f	namespace:boost	signature:(std::istream& is, rational<multiprecision::number<Backend, ExpressionTemplates> >& r)
boost::overlap	multiprecision/mpfi.hpp	/^inline bool overlap(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  b)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& b)
boost::proper_subset	multiprecision/mpfi.hpp	/^inline bool proper_subset(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  b)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& b)
boost::random	multiprecision/random.hpp	/^namespace boost{ namespace random{ namespace detail{$/;"	n	namespace:boost
boost::random	multiprecision/random.hpp	/^namespace random{$/;"	n	namespace:boost
boost::random::detail	multiprecision/random.hpp	/^namespace boost{ namespace random{ namespace detail{$/;"	n	namespace:boost::random
boost::random::detail	multiprecision/random.hpp	/^namespace detail{$/;"	n	namespace:boost::random
boost::random::detail::generate_uniform_int	multiprecision/random.hpp	/^   generate_uniform_int($/;"	f	namespace:boost::random::detail	signature:( Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value, boost::mpl::true_ )
boost::random::detail::generate_uniform_int	multiprecision/random.hpp	/^   generate_uniform_int(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value)$/;"	f	namespace:boost::random::detail	signature:(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value)
boost::random::detail::generate_uniform_int	multiprecision/random.hpp	/^   generate_uniform_int(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value);$/;"	p	namespace:boost::random::detail	signature:(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value)
boost::random::detail::select_uniform_01	multiprecision/random.hpp	/^struct select_uniform_01<boost::multiprecision::number<Backend, ExpressionTemplates> >$/;"	s	namespace:boost::random::detail
boost::random::detail::select_uniform_01::apply	multiprecision/random.hpp	/^  struct apply$/;"	s	struct:boost::random::detail::select_uniform_01	access:public
boost::random::detail::select_uniform_01::apply::type	multiprecision/random.hpp	/^    typedef new_uniform_01<boost::multiprecision::number<Backend, ExpressionTemplates> > type;$/;"	t	struct:boost::random::detail::select_uniform_01::apply	access:public
boost::random::detail::subtract	multiprecision/random.hpp	/^struct subtract<boost::multiprecision::number<Backend, ExpressionTemplates>, true> $/;"	s	namespace:boost::random::detail
boost::random::detail::subtract::operator ()	multiprecision/random.hpp	/^  result_type operator()(result_type const& x, result_type const& y) { return x - y; }$/;"	f	struct:boost::random::detail::subtract	access:public	signature:(result_type const& x, result_type const& y)
boost::random::detail::subtract::result_type	multiprecision/random.hpp	/^  typedef boost::multiprecision::number<Backend, ExpressionTemplates> result_type;$/;"	t	struct:boost::random::detail::subtract	access:public
boost::random::independent_bits_engine	multiprecision/random.hpp	/^class independent_bits_engine<Engine, w, boost::multiprecision::number<Backend, ExpressionTemplates> >$/;"	c	namespace:boost::random
boost::random::independent_bits_engine::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/random.hpp	/^    static result_type max BOOST_PREVENT_MACRO_SUBSTITUTION ()$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
boost::random::independent_bits_engine::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/random.hpp	/^    static result_type min BOOST_PREVENT_MACRO_SUBSTITUTION ()$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
boost::random::independent_bits_engine::BOOST_RANDOM_DETAIL_ARITHMETIC_CONSTRUCTOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ARITHMETIC_CONSTRUCTOR(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, result_type, seed_arg)
boost::random::independent_bits_engine::BOOST_RANDOM_DETAIL_ARITHMETIC_SEED	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ARITHMETIC_SEED(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, result_type, seed_arg)
boost::random::independent_bits_engine::BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(independent_bits_engine, x, y)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, x, y)
boost::random::independent_bits_engine::BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, independent_bits_engine, r)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(is, independent_bits_engine, r)
boost::random::independent_bits_engine::BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, independent_bits_engine, r)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(os, independent_bits_engine, r)
boost::random::independent_bits_engine::BOOST_RANDOM_DETAIL_SEED_SEQ_CONSTRUCTOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_SEED_SEQ_CONSTRUCTOR(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, SeedSeq, seq)
boost::random::independent_bits_engine::BOOST_RANDOM_DETAIL_SEED_SEQ_SEED	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_SEED_SEQ_SEED(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, SeedSeq, seq)
boost::random::independent_bits_engine::_base	multiprecision/random.hpp	/^    Engine _base;$/;"	m	class:boost::random::independent_bits_engine	access:private
boost::random::independent_bits_engine::base	multiprecision/random.hpp	/^    const base_type& base() const { return _base; }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:() const
boost::random::independent_bits_engine::base_result	multiprecision/random.hpp	/^    typedef typename base_type::result_type base_result;$/;"	t	class:boost::random::independent_bits_engine	access:private
boost::random::independent_bits_engine::base_type	multiprecision/random.hpp	/^    typedef Engine base_type;$/;"	t	class:boost::random::independent_bits_engine	access:public
boost::random::independent_bits_engine::base_unsigned	multiprecision/random.hpp	/^    typedef typename make_unsigned<base_result>::type base_unsigned;$/;"	t	class:boost::random::independent_bits_engine	access:private
boost::random::independent_bits_engine::calc_params	multiprecision/random.hpp	/^    void calc_params($/;"	f	class:boost::random::independent_bits_engine	access:private	signature:( std::size_t n, base_unsigned range, std::size_t& w0, std::size_t& n0, base_unsigned& y0, base_unsigned& y1, base_unsigned& y0_mask, base_unsigned& y1_mask)
boost::random::independent_bits_engine::discard	multiprecision/random.hpp	/^    void discard(boost::uintmax_t z)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(boost::uintmax_t z)
boost::random::independent_bits_engine::generate	multiprecision/random.hpp	/^    void generate(Iter first, Iter last)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(Iter first, Iter last)
boost::random::independent_bits_engine::independent_bits_engine	multiprecision/random.hpp	/^    independent_bits_engine() { }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
boost::random::independent_bits_engine::independent_bits_engine	multiprecision/random.hpp	/^    independent_bits_engine(It& first, It last) : _base(first, last) { }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(It& first, It last)
boost::random::independent_bits_engine::independent_bits_engine	multiprecision/random.hpp	/^    independent_bits_engine(const base_type& base_arg) : _base(base_arg) {}$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(const base_type& base_arg)
boost::random::independent_bits_engine::operator ()	multiprecision/random.hpp	/^    result_type operator()()$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
boost::random::independent_bits_engine::result_type	multiprecision/random.hpp	/^    typedef boost::multiprecision::number<Backend, ExpressionTemplates> result_type;$/;"	t	class:boost::random::independent_bits_engine	access:public
boost::random::independent_bits_engine::seed	multiprecision/random.hpp	/^    template<class It> void seed(It& first, It last)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(It& first, It last)
boost::random::independent_bits_engine::seed	multiprecision/random.hpp	/^    void seed() { _base.seed(); }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
boost::random::uniform_smallint	multiprecision/random.hpp	/^class uniform_smallint<boost::multiprecision::number<Backend, ExpressionTemplates> >$/;"	c	namespace:boost::random
boost::random::uniform_smallint::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/random.hpp	/^    result_type max BOOST_PREVENT_MACRO_SUBSTITUTION () const { return _max; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
boost::random::uniform_smallint::BOOST_PREVENT_MACRO_SUBSTITUTION	multiprecision/random.hpp	/^    result_type min BOOST_PREVENT_MACRO_SUBSTITUTION () const { return _min; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
boost::random::uniform_smallint::BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(uniform_smallint, lhs, rhs)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(uniform_smallint, lhs, rhs)
boost::random::uniform_smallint::BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, uniform_smallint, ud)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(is, uniform_smallint, ud)
boost::random::uniform_smallint::BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR	multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, uniform_smallint, ud)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(os, uniform_smallint, ud)
boost::random::uniform_smallint::_max	multiprecision/random.hpp	/^    result_type _max;$/;"	m	class:boost::random::uniform_smallint	access:private
boost::random::uniform_smallint::_min	multiprecision/random.hpp	/^    result_type _min;$/;"	m	class:boost::random::uniform_smallint	access:private
boost::random::uniform_smallint::a	multiprecision/random.hpp	/^    result_type a() const { return _min; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
boost::random::uniform_smallint::b	multiprecision/random.hpp	/^    result_type b() const { return _max; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
boost::random::uniform_smallint::generate	multiprecision/random.hpp	/^    result_type generate(Engine& eng, boost::mpl::false_) const$/;"	f	class:boost::random::uniform_smallint	access:private	signature:(Engine& eng, boost::mpl::false_) const
boost::random::uniform_smallint::generate	multiprecision/random.hpp	/^    result_type generate(Engine& eng, boost::mpl::true_) const$/;"	f	class:boost::random::uniform_smallint	access:private	signature:(Engine& eng, boost::mpl::true_) const
boost::random::uniform_smallint::input_type	multiprecision/random.hpp	/^    typedef boost::multiprecision::number<Backend, ExpressionTemplates> input_type;$/;"	t	class:boost::random::uniform_smallint	access:public
boost::random::uniform_smallint::operator ()	multiprecision/random.hpp	/^    result_type operator()(Engine& eng) const$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(Engine& eng) const
boost::random::uniform_smallint::operator ()	multiprecision/random.hpp	/^    result_type operator()(Engine& eng, const param_type& parm) const$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(Engine& eng, const param_type& parm) const
boost::random::uniform_smallint::param	multiprecision/random.hpp	/^    param_type param() const { return param_type(_min, _max); }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
boost::random::uniform_smallint::param	multiprecision/random.hpp	/^    void param(const param_type& parm)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(const param_type& parm)
boost::random::uniform_smallint::param_type	multiprecision/random.hpp	/^    class param_type$/;"	c	class:boost::random::uniform_smallint	access:public
boost::random::uniform_smallint::param_type::BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR	multiprecision/random.hpp	/^        BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(param_type, lhs, rhs)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(param_type, lhs, rhs)
boost::random::uniform_smallint::param_type::BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR	multiprecision/random.hpp	/^        BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, param_type, parm)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(is, param_type, parm)
boost::random::uniform_smallint::param_type::BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR	multiprecision/random.hpp	/^        BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, param_type, parm)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(os, param_type, parm)
boost::random::uniform_smallint::param_type::_max	multiprecision/random.hpp	/^        result_type _max;$/;"	m	class:boost::random::uniform_smallint::param_type	access:private
boost::random::uniform_smallint::param_type::_min	multiprecision/random.hpp	/^        result_type _min;$/;"	m	class:boost::random::uniform_smallint::param_type	access:private
boost::random::uniform_smallint::param_type::a	multiprecision/random.hpp	/^        result_type a() const { return _min; }$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:() const
boost::random::uniform_smallint::param_type::b	multiprecision/random.hpp	/^        result_type b() const { return _max; }$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:() const
boost::random::uniform_smallint::param_type::distribution_type	multiprecision/random.hpp	/^        typedef uniform_smallint distribution_type;$/;"	t	class:boost::random::uniform_smallint::param_type	access:public
boost::random::uniform_smallint::param_type::param_type	multiprecision/random.hpp	/^        param_type(result_type const& min_arg = 0, result_type const& max_arg = 9)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(result_type const& min_arg = 0, result_type const& max_arg = 9)
boost::random::uniform_smallint::reset	multiprecision/random.hpp	/^    void reset() { }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:()
boost::random::uniform_smallint::result_type	multiprecision/random.hpp	/^    typedef boost::multiprecision::number<Backend, ExpressionTemplates> result_type;$/;"	t	class:boost::random::uniform_smallint	access:public
boost::random::uniform_smallint::uniform_smallint	multiprecision/random.hpp	/^    explicit uniform_smallint(const param_type& parm)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(const param_type& parm)
boost::random::uniform_smallint::uniform_smallint	multiprecision/random.hpp	/^    explicit uniform_smallint(result_type const& min_arg = 0, result_type const& max_arg = 9)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(result_type const& min_arg = 0, result_type const& max_arg = 9)
boost::serialization	multiprecision/cpp_int/serialize.hpp	/^namespace serialization {$/;"	n	namespace:boost
boost::serialization	multiprecision/float128.hpp	/^namespace serialization{ namespace float128_detail{$/;"	n	namespace:boost
boost::serialization::cpp_int_detail	multiprecision/cpp_int/serialize.hpp	/^namespace cpp_int_detail{$/;"	n	namespace:boost::serialization
boost::serialization::cpp_int_detail::do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::false_ const&, mpl::false_ const&, mpl::false_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::false_ const&, mpl::false_ const&, mpl::false_ const&)
boost::serialization::cpp_int_detail::do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::false_ const&, mpl::false_ const&, mpl::true_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::false_ const&, mpl::false_ const&, mpl::true_ const&)
boost::serialization::cpp_int_detail::do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::false_ const&, mpl::true_ const&, mpl::false_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::false_ const&, mpl::true_ const&, mpl::false_ const&)
boost::serialization::cpp_int_detail::do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::false_ const&, mpl::true_ const&, mpl::true_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::false_ const&, mpl::true_ const&, mpl::true_ const&)
boost::serialization::cpp_int_detail::do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::true_ const&, mpl::false_ const&, mpl::false_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::true_ const&, mpl::false_ const&, mpl::false_ const&)
boost::serialization::cpp_int_detail::do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::true_ const&, mpl::false_ const&, mpl::true_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::true_ const&, mpl::false_ const&, mpl::true_ const&)
boost::serialization::cpp_int_detail::do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::true_ const&, mpl::true_ const&, mpl::false_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::true_ const&, mpl::true_ const&, mpl::false_ const&)
boost::serialization::cpp_int_detail::do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::true_ const&, mpl::true_ const&, mpl::true_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::true_ const&, mpl::true_ const&, mpl::true_ const&)
boost::serialization::cpp_int_detail::is_binary_archive	multiprecision/cpp_int/serialize.hpp	/^struct is_binary_archive : public mpl::false_ {};$/;"	s	namespace:boost::serialization::cpp_int_detail	inherits:mpl::false_
boost::serialization::cpp_int_detail::is_binary_archive	multiprecision/cpp_int/serialize.hpp	/^struct is_binary_archive<boost::archive::binary_iarchive> : public mpl::true_ {};$/;"	s	namespace:boost::serialization::cpp_int_detail	inherits:mpl::true_
boost::serialization::cpp_int_detail::is_binary_archive	multiprecision/cpp_int/serialize.hpp	/^struct is_binary_archive<boost::archive::binary_oarchive> : public mpl::true_ {};$/;"	s	namespace:boost::serialization::cpp_int_detail	inherits:mpl::true_
boost::serialization::float128_detail	multiprecision/float128.hpp	/^namespace serialization{ namespace float128_detail{$/;"	n	namespace:boost::serialization
boost::serialization::float128_detail::do_serialize	multiprecision/float128.hpp	/^void do_serialize(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::false_&, const mpl::false_&)$/;"	f	namespace:boost::serialization::float128_detail	signature:(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::false_&, const mpl::false_&)
boost::serialization::float128_detail::do_serialize	multiprecision/float128.hpp	/^void do_serialize(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::false_&, const mpl::true_&)$/;"	f	namespace:boost::serialization::float128_detail	signature:(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::false_&, const mpl::true_&)
boost::serialization::float128_detail::do_serialize	multiprecision/float128.hpp	/^void do_serialize(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::true_&, const mpl::false_&)$/;"	f	namespace:boost::serialization::float128_detail	signature:(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::true_&, const mpl::false_&)
boost::serialization::float128_detail::do_serialize	multiprecision/float128.hpp	/^void do_serialize(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::true_&, const mpl::true_&)$/;"	f	namespace:boost::serialization::float128_detail	signature:(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::true_&, const mpl::true_&)
boost::serialization::serialize	multiprecision/cpp_int/serialize.hpp	/^void serialize(Archive & ar, mp::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>& val, const unsigned int \/*version*\/)$/;"	f	namespace:boost::serialization	signature:(Archive & ar, mp::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>& val, const unsigned int )
boost::serialization::serialize	multiprecision/float128.hpp	/^void serialize(Archive& ar, boost::multiprecision::backends::float128_backend& val, unsigned int \/*version*\/)$/;"	f	namespace:boost::serialization	signature:(Archive& ar, boost::multiprecision::backends::float128_backend& val, unsigned int )
boost::singleton	multiprecision/mpfi.hpp	/^inline bool singleton(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  a)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a)
boost::subset	multiprecision/mpfi.hpp	/^inline bool subset(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  b)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& b)
boost::upper	multiprecision/mpfi.hpp	/^inline number<mpfr_float_backend<Digits10>, ExpressionTemplates> upper(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)
boost::width	multiprecision/mpfi.hpp	/^inline number<mpfr_float_backend<Digits10>, ExpressionTemplates> width(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)
boost::zero_in	multiprecision/mpfi.hpp	/^inline bool zero_in(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  a)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a)
calc_e	multiprecision/detail/functions/constants.hpp	/^void calc_e(T& result, unsigned digits)$/;"	f	signature:(T& result, unsigned digits)
calc_log2	multiprecision/detail/functions/constants.hpp	/^void calc_log2(T& num, unsigned digits)$/;"	f	signature:(T& num, unsigned digits)
calc_params	multiprecision/random.hpp	/^    void calc_params($/;"	f	class:boost::random::independent_bits_engine	access:private	signature:( std::size_t n, base_unsigned range, std::size_t& w0, std::size_t& n0, base_unsigned& y0, base_unsigned& y1, base_unsigned& y0_mask, base_unsigned& y1_mask)
calc_pi	multiprecision/detail/functions/constants.hpp	/^void calc_pi(T& result, unsigned digits)$/;"	f	signature:(T& result, unsigned digits)
calculate_inv	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& calculate_inv (void)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
calculate_inv	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::calculate_inv()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:()
calculate_next_larger_type	multiprecision/detail/default_ops.hpp	/^struct calculate_next_larger_type$/;"	s	namespace:boost::multiprecision::default_ops
calculate_sqrt	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& calculate_sqrt(void)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
calculate_sqrt	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::calculate_sqrt(void)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void)
canonical	multiprecision/detail/number_base.hpp	/^struct canonical$/;"	s	namespace:boost::multiprecision::detail
canonical_imp	multiprecision/detail/number_base.hpp	/^struct canonical_imp$/;"	s	namespace:boost::multiprecision::detail
canonical_imp	multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<0> >$/;"	s	namespace:boost::multiprecision::detail
canonical_imp	multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<1> >$/;"	s	namespace:boost::multiprecision::detail
canonical_imp	multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<2> >$/;"	s	namespace:boost::multiprecision::detail
canonical_imp	multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<3> >$/;"	s	namespace:boost::multiprecision::detail
canonical_imp	multiprecision/detail/number_base.hpp	/^struct canonical_imp<number<B, et_off>, Backend, Tag>$/;"	s	namespace:boost::multiprecision::detail
canonical_imp	multiprecision/detail/number_base.hpp	/^struct canonical_imp<number<B, et_on>, Backend, Tag>$/;"	s	namespace:boost::multiprecision::detail
cap	multiprecision/cpp_int.hpp	/^      unsigned cap = capacity();$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
capacity	multiprecision/cpp_int.hpp	/^      unsigned capacity;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base::limb_data	access:public
cast_to_unsigned	multiprecision/miller_rabin.hpp	/^   cast_to_unsigned(const I& val)$/;"	f	namespace:boost::multiprecision::detail	signature:(const I& val)
ceilq	multiprecision/float128.hpp	78;"	d
char_is_nonzero_predicate	multiprecision/cpp_dec_float.hpp	/^   static bool char_is_nonzero_predicate(const char& c)  { return (c != static_cast<char>('0')); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const char& c)
chars_per_limb	multiprecision/cpp_int/literals.hpp	/^   static constexpr unsigned chars_per_limb = sizeof(limb_type) * CHAR_BIT \/ 4;$/;"	m	struct:boost::multiprecision::literals::detail::pack_values	access:public
check_in_range	multiprecision/cpp_int/misc.hpp	/^void check_in_range(const CppInt& val, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends	signature:(const CppInt& val, const mpl::int_<checked>&)
check_in_range	multiprecision/detail/default_ops.hpp	/^inline bool check_in_range(const T& t)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& t)
check_in_range	multiprecision/detail/default_ops.hpp	/^inline bool check_in_range(const terminal<T>&)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const terminal<T>&)
check_is_negative	multiprecision/cpp_int/misc.hpp	/^inline void check_is_negative(const mpl::false_&)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpl::false_&)
check_shift_range	multiprecision/detail/number_base.hpp	/^void check_shift_range(V val, const mpl::false_&, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::detail	signature:(V val, const mpl::false_&, const mpl::true_&)
check_shift_range	multiprecision/detail/number_base.hpp	/^void check_shift_range(V val, const mpl::true_&, const mpl::false_&)$/;"	f	namespace:boost::multiprecision::detail	signature:(V val, const mpl::true_&, const mpl::false_&)
check_shift_range	multiprecision/detail/number_base.hpp	/^void check_shift_range(V val, const mpl::true_&, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::detail	signature:(V val, const mpl::true_&, const mpl::true_&)
check_small_factors	multiprecision/miller_rabin.hpp	/^bool check_small_factors(const I& n)$/;"	f	namespace:boost::multiprecision::detail	signature:(const I& n)
check_tommath_result	multiprecision/tommath.hpp	/^inline void check_tommath_result(unsigned v)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(unsigned v)
checked	multiprecision/cpp_int/cpp_int_config.hpp	/^   checked = 1,$/;"	e	enum:boost::multiprecision::cpp_int_check_type
checked_add	multiprecision/cpp_int/checked.hpp	/^inline A checked_add(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
checked_add	multiprecision/cpp_int/checked.hpp	/^inline A checked_add(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
checked_add_imp	multiprecision/cpp_int/checked.hpp	/^inline A checked_add_imp(A a, A b, const mpl::false_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::false_&)
checked_add_imp	multiprecision/cpp_int/checked.hpp	/^inline A checked_add_imp(A a, A b, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::true_&)
checked_cpp_int	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<0, 0, signed_magnitude, checked> >  checked_cpp_int;$/;"	t
checked_cpp_rational	multiprecision/cpp_int.hpp	/^typedef number<cpp_rational_backend>                 checked_cpp_rational;$/;"	t
checked_cpp_rational_backend	multiprecision/cpp_int.hpp	/^typedef rational_adaptor<cpp_int_backend<0, 0, signed_magnitude, checked> >  checked_cpp_rational_backend;$/;"	t
checked_divide	multiprecision/cpp_int/checked.hpp	/^inline A checked_divide(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
checked_divide	multiprecision/cpp_int/checked.hpp	/^inline A checked_divide(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
checked_int1024_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<1024, 1024, signed_magnitude, checked, void> >  checked_int1024_t;$/;"	t
checked_int128_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<128, 128, signed_magnitude, checked, void> >    checked_int128_t;$/;"	t
checked_int256_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<256, 256, signed_magnitude, checked, void> >    checked_int256_t;$/;"	t
checked_int512_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<512, 512, signed_magnitude, checked, void> >    checked_int512_t;$/;"	t
checked_left_shift	multiprecision/cpp_int/checked.hpp	/^inline A checked_left_shift(A a, unsigned long long shift, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, unsigned long long shift, const mpl::int_<checked>&)
checked_left_shift	multiprecision/cpp_int/checked.hpp	/^inline A checked_left_shift(A a, unsigned long long shift, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, unsigned long long shift, const mpl::int_<unchecked>&)
checked_multiply	multiprecision/cpp_int/checked.hpp	/^inline A checked_multiply(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
checked_multiply	multiprecision/cpp_int/checked.hpp	/^inline A checked_multiply(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
checked_subtract	multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
checked_subtract	multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
checked_subtract_imp	multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract_imp(A a, A b, const mpl::false_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::false_&)
checked_subtract_imp	multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract_imp(A a, A b, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::true_&)
checked_type	multiprecision/cpp_int.hpp	/^   typedef mpl::int_<Checked>                                    checked_type;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
checked_type	multiprecision/cpp_int.hpp	/^   typedef mpl::int_<Checked>              checked_type;$/;"	t	struct:boost::multiprecision::cpp_int_base	access:public
checked_uint1024_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<1024, 1024, unsigned_magnitude, checked, void> > checked_uint1024_t;$/;"	t
checked_uint128_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<128, 128, unsigned_magnitude, checked, void> >   checked_uint128_t;$/;"	t
checked_uint256_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<256, 256, unsigned_magnitude, checked, void> >   checked_uint256_t;$/;"	t
checked_uint512_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<512, 512, unsigned_magnitude, checked, void> >   checked_uint512_t;$/;"	t
cmp_data	multiprecision/cpp_dec_float.hpp	/^   int cmp_data(const array_type& vd) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const array_type& vd) const
cmp_data	multiprecision/cpp_dec_float.hpp	/^int cpp_dec_float<Digits10, ExponentType, Allocator>::cmp_data(const array_type& vd) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const array_type& vd) const
combine_expression	multiprecision/detail/number_base.hpp	/^struct combine_expression$/;"	s	namespace:boost::multiprecision::detail
combine_expression	multiprecision/detail/number_base.hpp	/^struct combine_expression<T1, number<T2, ExpressionTemplates> >$/;"	s	namespace:boost::multiprecision::detail
combine_expression	multiprecision/detail/number_base.hpp	/^struct combine_expression<number<T, ExpressionTemplates>, number<T, ExpressionTemplates> >$/;"	s	namespace:boost::multiprecision::detail
combine_expression	multiprecision/detail/number_base.hpp	/^struct combine_expression<number<T1, ExpressionTemplates1>, number<T2, ExpressionTemplates2> >$/;"	s	namespace:boost::multiprecision::detail
combine_expression	multiprecision/detail/number_base.hpp	/^struct combine_expression<number<T1, ExpressionTemplates>, T2>$/;"	s	namespace:boost::multiprecision::detail
combine_value_to_pack	multiprecision/cpp_int/literals.hpp	/^struct combine_value_to_pack<value_pack<first, ARGS...>, value>$/;"	s	namespace:boost::multiprecision::literals::detail
compare	multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(const number_backend_float_architype& o)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const number_backend_float_architype& o) const
compare	multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(long double d)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long double d) const
compare	multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(long long i)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long long i) const
compare	multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(unsigned long long i)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(unsigned long long i) const
compare	multiprecision/cpp_dec_float.hpp	/^   int compare(const V& v)const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const V& v) const
compare	multiprecision/cpp_dec_float.hpp	/^   int compare(const cpp_dec_float& v)const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v) const
compare	multiprecision/cpp_dec_float.hpp	/^int cpp_dec_float<Digits10, ExponentType, Allocator>::compare(const cpp_dec_float& v) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float& v) const
compare	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE typename boost::enable_if<is_arithmetic<Arithmetic>, int>::type compare(Arithmetic i)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(Arithmetic i) const
compare	multiprecision/debug_adaptor.hpp	/^   int compare(const T& i)const$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const T& i) const
compare	multiprecision/debug_adaptor.hpp	/^   int compare(const debug_adaptor& o)const$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const debug_adaptor& o) const
compare	multiprecision/float128.hpp	/^   int compare(const T& i)const$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(const T& i) const
compare	multiprecision/float128.hpp	/^   int compare(const float128_backend& o)const$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(const float128_backend& o) const
compare	multiprecision/gmp.hpp	/^   int compare(V v)const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(V v) const
compare	multiprecision/gmp.hpp	/^   typename enable_if<is_arithmetic<V>, int>::type compare(V v)const$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(V v) const
compare	multiprecision/logged_adaptor.hpp	/^   int compare(const T& i)const$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(const T& i) const
compare	multiprecision/logged_adaptor.hpp	/^   int compare(const logged_adaptor& o)const$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(const logged_adaptor& o) const
compare	multiprecision/rational_adaptor.hpp	/^   int compare(const rational_adaptor& o)const$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const rational_adaptor& o) const
compare	multiprecision/rational_adaptor.hpp	/^   typename enable_if<is_arithmetic<Arithmatic>, int>::type compare(Arithmatic i)const$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(Arithmatic i) const
compare	multiprecision/tommath.hpp	/^   int compare(V v)const$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(V v) const
compare	multiprecision/tommath.hpp	/^   int compare(const tommath_int& o)const$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const tommath_int& o) const
compare_imp	multiprecision/cpp_int.hpp	/^   int compare_imp(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::false_&, const mpl::true_&)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::false_&, const mpl::true_&) const
compare_imp	multiprecision/cpp_int.hpp	/^   int compare_imp(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::true_&, const mpl::false_&)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::true_&, const mpl::false_&) const
complement_immediates	multiprecision/detail/number_base.hpp	/^struct complement_immediates{};$/;"	s	namespace:boost::multiprecision::detail
component_type	multiprecision/detail/number_base.hpp	/^struct component_type<detail::expression<tag, A1, A2, A3, A4> > : public component_type<typename detail::expression<tag, A1, A2, A3, A4>::result_type>{};$/;"	s	namespace:boost::multiprecision	inherits:component_type
component_type	multiprecision/detail/number_base.hpp	/^struct component_type<number<T, ExpressionTemplates> > : public component_type<T>{};$/;"	s	namespace:boost::multiprecision	inherits:component_type
component_type	multiprecision/gmp.hpp	/^struct component_type<number<gmp_rational> >$/;"	s
component_type	multiprecision/mpfi.hpp	/^struct component_type<number<mpfi_float_backend<Digits10>, ExpressionTemplates> >$/;"	s	namespace:boost
component_type	multiprecision/rational_adaptor.hpp	/^struct component_type<rational_adaptor<T> >$/;"	s	namespace:boost::multiprecision
component_type::type	multiprecision/gmp.hpp	/^   typedef number<gmp_int> type;$/;"	t	struct:component_type	access:public
concepts	multiprecision/concepts/mp_number_archetypes.hpp	/^namespace concepts{$/;"	n	namespace:boost::multiprecision
const_limb_pointer	multiprecision/cpp_int.hpp	/^   typedef const limb_type*                const_limb_pointer;$/;"	t	struct:boost::multiprecision::cpp_int_base	access:public
const_limb_pointer	multiprecision/cpp_int.hpp	/^   typedef typename allocator_type::const_pointer                const_limb_pointer;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
constant_catalan	multiprecision/mpfi.hpp	/^struct constant_catalan<boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> >$/;"	s	namespace:math::constants::detail
constant_euler	multiprecision/mpfi.hpp	/^struct constant_euler<boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> >$/;"	s	namespace:math::constants::detail
constant_initializer	multiprecision/detail/functions/constants.hpp	/^struct constant_initializer$/;"	s
constant_initializer::constant_initializer::init	multiprecision/detail/functions/constants.hpp	/^typename constant_initializer<T, F>::initializer const constant_initializer<T, F>::init;$/;"	m	class:constant_initializer::constant_initializer
constant_initializer::do_nothing	multiprecision/detail/functions/constants.hpp	/^   static void do_nothing()$/;"	f	struct:constant_initializer	access:public	signature:()
constant_initializer::init	multiprecision/detail/functions/constants.hpp	/^   static const initializer init;$/;"	m	struct:constant_initializer	access:private
constant_initializer::initializer	multiprecision/detail/functions/constants.hpp	/^   struct initializer$/;"	s	struct:constant_initializer	access:private
constant_initializer::initializer::do_nothing	multiprecision/detail/functions/constants.hpp	/^      void do_nothing()const{}$/;"	f	struct:constant_initializer::initializer	access:public	signature:() const
constant_initializer::initializer::initializer	multiprecision/detail/functions/constants.hpp	/^      initializer()$/;"	f	struct:constant_initializer::initializer	access:public	signature:()
constant_ln_two	multiprecision/mpfi.hpp	/^struct constant_ln_two<boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> >$/;"	s	namespace:math::constants::detail
constant_pi	multiprecision/mpfi.hpp	/^struct constant_pi<boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> >$/;"	s	namespace:math::constants::detail
constants	multiprecision/mpfi.hpp	/^namespace constants{ namespace detail{$/;"	n	namespace:math
convert_from_string	multiprecision/detail/float_string_cvt.hpp	/^void convert_from_string(Backend& b, const char* p)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend& b, const char* p)
convert_to_string	multiprecision/detail/float_string_cvt.hpp	/^std::string convert_to_string(Backend b, std::streamsize digits, std::ios_base::fmtflags f)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend b, std::streamsize digits, std::ios_base::fmtflags f)
coshq	multiprecision/float128.hpp	92;"	d
cosq	multiprecision/float128.hpp	86;"	d
cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float()   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(I i, typename enable_if<is_signed<I> >::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(I i, typename enable_if<is_signed<I> >::type* = 0)
cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(I i, typename enable_if<is_unsigned<I> >::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(I i, typename enable_if<is_unsigned<I> >::type* = 0)
cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const F val, typename enable_if<is_floating_point<F> >::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const F val, typename enable_if<is_floating_point<F> >::type* = 0)
cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const char* s) : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const char* s)
cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const cpp_dec_float& f)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& f)
cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const cpp_dec_float<D, ET, A>& f, typename enable_if_c<D <= Digits10>::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float<D, ET, A>& f, typename enable_if_c<D <= Digits10>::type* = 0)
cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const double val, ExponentType exponent);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const double val, ExponentType exponent)
cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(fpclass_type c)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(fpclass_type c)
cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^   explicit cpp_dec_float(const cpp_dec_float<D, ET, A>& f, typename disable_if_c<D <= Digits10>::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float<D, ET, A>& f, typename disable_if_c<D <= Digits10>::type* = 0)
cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^class cpp_dec_float$/;"	c	namespace:boost::multiprecision::backends
cpp_dec_float	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float(const double mantissa, const ExponentType exponent)   $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const double mantissa, const ExponentType exponent)
cpp_dec_float_100	multiprecision/cpp_dec_float.hpp	/^typedef number<cpp_dec_float<100> > cpp_dec_float_100;$/;"	t	namespace:boost::multiprecision
cpp_dec_float_50	multiprecision/cpp_dec_float.hpp	/^typedef number<cpp_dec_float<50> > cpp_dec_float_50;$/;"	t	namespace:boost::multiprecision
cpp_dec_float_NaN	multiprecision/cpp_dec_float.hpp	/^      cpp_dec_float_NaN$/;"	e	enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type
cpp_dec_float_digits10	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10          = ((cpp_dec_float_digits10_setting < cpp_dec_float_digits10_limit_lo) ? cpp_dec_float_digits10_limit_lo : ((cpp_dec_float_digits10_setting > cpp_dec_float_digits10_limit_hi) ? cpp_dec_float_digits10_limit_hi : cpp_dec_float_digits10_setting));$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_digits10	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10 = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	struct:boost::math::policies::precision	access:public
cpp_dec_float_digits10	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_digits10_limit_hi	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10_limit_hi = boost::integer_traits<boost::int32_t>::const_max - 100;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_digits10_limit_hi	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10_limit_hi;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_digits10_limit_lo	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10_limit_lo = 9L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_digits10_limit_lo	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10_limit_lo;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_digits10_setting	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10_setting = Digits10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
cpp_dec_float_digits10_setting	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10_setting;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_elem_digits10	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_digits10 = 8L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
cpp_dec_float_elem_digits10	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_digits10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_elem_mask	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_mask     = 100000000L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
cpp_dec_float_elem_mask	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_mask;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_elem_number	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_number = static_cast<boost::int32_t>(((cpp_dec_float_elem_number_request < 2L) ? 2L : cpp_dec_float_elem_number_request) + 3L);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
cpp_dec_float_elem_number	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_number;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_elem_number_request	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_number_request = static_cast<boost::int32_t>((cpp_dec_float_digits10 \/ cpp_dec_float_elem_digits10) + (((cpp_dec_float_digits10 % cpp_dec_float_elem_digits10) != 0) ? 1 : 0));$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
cpp_dec_float_elem_number_request	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_number_request;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_finite	multiprecision/cpp_dec_float.hpp	/^      cpp_dec_float_finite,$/;"	e	enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type
cpp_dec_float_inf	multiprecision/cpp_dec_float.hpp	/^      cpp_dec_float_inf,$/;"	e	enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type
cpp_dec_float_max_exp	multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_max_exp           = static_cast<ExponentType>((cpp_dec_float_max_exp10 \/ 301LL) * 1000LL);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_max_exp	multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_max_exp10	multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_max_exp10         = (static_cast<ExponentType>(1) << (std::numeric_limits<ExponentType>::digits - 5));$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_max_exp10	multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_min_exp	multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_min_exp           = static_cast<ExponentType>((cpp_dec_float_min_exp10 \/ 301LL) * 1000LL);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_min_exp	multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_min_exp10	multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_min_exp10         = -cpp_dec_float_max_exp10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_min_exp10	multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_radix	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_radix             = 10L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_radix	multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_radix;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_total_digits10	multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_total_digits10 = static_cast<boost::int32_t>(cpp_dec_float_elem_number * cpp_dec_float_elem_digits10);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_int	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<> >                   cpp_int;$/;"	t
cpp_int_base	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE cpp_int_base(const cpp_int_base& o) : allocator_type(o), m_limbs(0), m_internal(true)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_base& o)
cpp_int_base	multiprecision/cpp_int.hpp	/^   cpp_int_base(cpp_int_base&& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_base&& o)
cpp_int_base	multiprecision/cpp_int.hpp	/^struct cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false> : private Allocator::template rebind<limb_type>::other$/;"	s	namespace:boost::multiprecision::backends	inherits:Allocator::,rebind::other
cpp_int_base	multiprecision/cpp_int.hpp	/^struct cpp_int_base<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator, false> : private Allocator::template rebind<limb_type>::other$/;"	s	namespace:boost::multiprecision	inherits:Allocator::,rebind::other
cpp_int_base	multiprecision/cpp_int.hpp	/^struct cpp_int_base<MinBits, MinBits, signed_magnitude, Checked, void, false>$/;"	s	namespace:boost::multiprecision
cpp_int_check_type	multiprecision/cpp_int/cpp_int_config.hpp	/^enum cpp_int_check_type$/;"	g	namespace:boost::multiprecision
cpp_int_detail	multiprecision/cpp_int/serialize.hpp	/^namespace cpp_int_detail{$/;"	n	namespace:boost::serialization
cpp_integer_type	multiprecision/cpp_int/cpp_int_config.hpp	/^enum cpp_integer_type$/;"	g	namespace:boost::multiprecision
cpp_rational	multiprecision/cpp_int.hpp	/^typedef number<cpp_rational_backend>                 cpp_rational;$/;"	t
cpp_rational_backend	multiprecision/cpp_int.hpp	/^typedef rational_adaptor<cpp_int_backend<> >         cpp_rational_backend;$/;"	t
data	multiprecision/cpp_dec_float.hpp	/^   array_type      data;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
data	multiprecision/cpp_int.hpp	/^      limb_pointer data;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base::limb_data	access:public
data	multiprecision/detail/dynamic_array.hpp	/^             value_type* data()       { return &(*(this->begin())); }$/;"	f	struct:boost::multiprecision::backends::detail::dynamic_array	access:public	signature:()
data	multiprecision/detail/dynamic_array.hpp	/^       const value_type* data() const { return &(*(this->begin())); }$/;"	f	struct:boost::multiprecision::backends::detail::dynamic_array	access:public	signature:() const
data	multiprecision/rational_adaptor.hpp	/^   const rational_type& data()const { return m_value; }$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:() const
data	multiprecision/rational_adaptor.hpp	/^   rational_type& data() { return m_value; }$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:()
data	multiprecision/tommath.hpp	/^   ::mp_int& data() $/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
data	multiprecision/tommath.hpp	/^   const ::mp_int& data()const $/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:() const
data_elem_is_non_nine_predicate	multiprecision/cpp_dec_float.hpp	/^   static bool data_elem_is_non_nine_predicate(const boost::uint32_t& d)  { return (d != static_cast<boost::uint32_t>(cpp_dec_float::cpp_dec_float_elem_mask - 1)); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const boost::uint32_t& d)
data_elem_is_non_zero_predicate	multiprecision/cpp_dec_float.hpp	/^   static bool data_elem_is_non_zero_predicate(const boost::uint32_t& d)  { return (d != static_cast<boost::uint32_t>(0u)); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const boost::uint32_t& d)
data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type() : first(0) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:()
data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type() : m_first_limb(0) {}$/;"	f	union:boost::multiprecision::cpp_int_base::data_type	access:public	signature:()
data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(double_limb_type i) : double_first(i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(double_limb_type i)
data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(double_limb_type i) : m_double_first_limb(i) {}$/;"	f	union:boost::multiprecision::cpp_int_base::data_type	access:public	signature:(double_limb_type i)
data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(limb_type i) : first(i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(limb_type i)
data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(limb_type i) : m_first_limb(i) {}$/;"	f	union:boost::multiprecision::cpp_int_base::data_type	access:public	signature:(limb_type i)
data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(literals::detail::value_pack<VALUES...>) : m_data{ VALUES... } {}$/;"	f	union:boost::multiprecision::cpp_int_base::data_type	access:public	signature:(literals::detail::value_pack<VALUES...>)
data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(signed_double_limb_type i) : double_first(i < 0 ? -i : i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(signed_double_limb_type i)
data_type	multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(signed_limb_type i) : first(i < 0 ? -i : i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(signed_limb_type i)
data_type	multiprecision/cpp_int.hpp	/^   union data_type$/;"	u	struct:boost::multiprecision::backends::cpp_int_base	access:private
data_type	multiprecision/cpp_int.hpp	/^   union data_type{$/;"	u	struct:boost::multiprecision::cpp_int_base	access:private
debug_adaptor	multiprecision/debug_adaptor.hpp	/^   debug_adaptor()$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:()
debug_adaptor	multiprecision/debug_adaptor.hpp	/^   debug_adaptor(const T& i, const T& j)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const T& i, const T& j)
debug_adaptor	multiprecision/debug_adaptor.hpp	/^   debug_adaptor(const T& i, const typename enable_if_c<is_convertible<T, Backend>::value>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const T& i, const typename enable_if_c<is_convertible<T, Backend>::value>::type* = 0)
debug_adaptor	multiprecision/debug_adaptor.hpp	/^   debug_adaptor(const debug_adaptor& o) : debug_value(o.debug_value), m_value(o.m_value)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const debug_adaptor& o)
debug_adaptor	multiprecision/debug_adaptor.hpp	/^struct debug_adaptor$/;"	s	namespace:boost::multiprecision::backends
debug_value	multiprecision/debug_adaptor.hpp	/^   std::string debug_value;$/;"	m	struct:boost::multiprecision::backends::debug_adaptor	access:private
default_ops	multiprecision/cpp_int.hpp	/^namespace default_ops{$/;"	n
default_ops	multiprecision/detail/default_ops.hpp	/^namespace boost{ namespace multiprecision{ namespace default_ops{$/;"	n	namespace:boost::multiprecision
default_ops	multiprecision/detail/integer_ops.hpp	/^namespace default_ops$/;"	n	namespace:boost::multiprecision
default_ops	multiprecision/detail/integer_ops.hpp	/^namespace default_ops{$/;"	n	namespace:boost::multiprecision
default_ops	multiprecision/detail/number_compare.hpp	/^namespace default_ops{$/;"	n	namespace:boost::multiprecision
default_ops::double_precision_type	multiprecision/cpp_int.hpp	/^struct double_precision_type<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:default_ops
default_ops::double_precision_type::type	multiprecision/cpp_int.hpp	/^   >::type type;$/;"	t	struct:default_ops::double_precision_type	access:public
denominator	multiprecision/gmp.hpp	/^inline number<gmp_int, ET> denominator(const number<gmp_rational, ET>& val)$/;"	f	signature:(const number<gmp_rational, ET>& val)
denominator	multiprecision/number.hpp	/^inline multiprecision::number<T, ExpressionTemplates> denominator(const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a)
denominator	multiprecision/rational_adaptor.hpp	/^inline number<IntBackend, ET> denominator(const number<rational_adaptor<IntBackend>, ET>& val)$/;"	f	namespace:boost::multiprecision	signature:(const number<rational_adaptor<IntBackend>, ET>& val)
denorm_min	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> denorm_min   (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::zero(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
denorm_min	multiprecision/cpp_int/limits.hpp	/^   static number_type denorm_min() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
denorm_min	multiprecision/float128.hpp	/^   static number_type denorm_min() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
denorm_min	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type denorm_min() { return base_type::denorm_min(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
denorm_min	multiprecision/tommath.hpp	/^   static number_type denorm_min() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
depth	multiprecision/detail/number_base.hpp	/^   static const unsigned depth = 0;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
depth	multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_depth > right_depth ? (left_depth > middle_depth ? left_depth : middle_depth) : (right_depth > middle_depth ? right_depth : middle_depth);$/;"	m	struct:boost::multiprecision::detail::expression	access:public
depth	multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_depth > right_depth ? left_depth : right_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
depth	multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_max_depth > right_max_depth ? left_max_depth : right_max_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
depth	multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
detail	multiprecision/cpp_dec_float.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	multiprecision/cpp_int.hpp	/^namespace detail{$/;"	n
detail	multiprecision/cpp_int.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
detail	multiprecision/cpp_int/checked.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{ namespace detail{$/;"	n	namespace:boost::multiprecision::backends
detail	multiprecision/cpp_int/cpp_int_config.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	multiprecision/cpp_int/limits.hpp	/^namespace detail{$/;"	n	namespace:std
detail	multiprecision/cpp_int/literals.hpp	/^namespace literals{ namespace detail{$/;"	n	namespace:boost::multiprecision::literals
detail	multiprecision/cpp_int/value_pack.hpp	/^namespace literals{ namespace detail{$/;"	n	namespace:boost::multiprecision::literals
detail	multiprecision/detail/bitscan.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
detail	multiprecision/detail/default_ops.hpp	/^namespace detail{$/;"	n	namespace:boost::math
detail	multiprecision/detail/default_ops.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	multiprecision/detail/digits.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
detail	multiprecision/detail/dynamic_array.hpp	/^  namespace boost { namespace multiprecision { namespace backends { namespace detail$/;"	n	namespace:boost::multiprecision::backends
detail	multiprecision/detail/float_string_cvt.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
detail	multiprecision/detail/functions/pow.hpp	/^namespace detail{$/;"	n
detail	multiprecision/detail/generic_interconvert.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
detail	multiprecision/detail/number_base.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	multiprecision/detail/number_compare.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	multiprecision/detail/rebind.hpp	/^  namespace boost { namespace multiprecision { namespace backends { namespace detail$/;"	n	namespace:boost::multiprecision::backends
detail	multiprecision/detail/utype_helper.hpp	/^  namespace detail$/;"	n	namespace:boost::multiprecision
detail	multiprecision/gmp.hpp	/^namespace detail{$/;"	n
detail	multiprecision/gmp.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
detail	multiprecision/integer.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	multiprecision/miller_rabin.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	multiprecision/mpfi.hpp	/^namespace constants{ namespace detail{$/;"	n	namespace:math::constants
detail	multiprecision/mpfi.hpp	/^namespace detail{$/;"	n	namespace:boost
detail	multiprecision/mpfi.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
detail	multiprecision/mpfr.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
detail	multiprecision/number.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	multiprecision/random.hpp	/^namespace boost{ namespace random{ namespace detail{$/;"	n	namespace:boost::random
detail	multiprecision/random.hpp	/^namespace detail{$/;"	n	namespace:boost::random
detail	multiprecision/rational_adaptor.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	multiprecision/tommath.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
detail	multiprecision/traits/explicit_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
detail	multiprecision/traits/is_restricted_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
detail::is_explicitly_convertible	multiprecision/cpp_int.hpp	/^struct is_explicitly_convertible<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> > : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
detail::is_explicitly_convertible	multiprecision/gmp.hpp	/^struct is_explicitly_convertible<canonical<mpf_t, gmp_int>::type, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
detail::is_explicitly_convertible	multiprecision/gmp.hpp	/^struct is_explicitly_convertible<canonical<mpq_t, gmp_int>::type, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
detail::is_explicitly_convertible	multiprecision/gmp.hpp	/^struct is_explicitly_convertible<gmp_float<D1>, gmp_float<D2> > : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
detail::is_explicitly_convertible	multiprecision/gmp.hpp	/^struct is_explicitly_convertible<gmp_float<Digits10>, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
detail::is_explicitly_convertible	multiprecision/gmp.hpp	/^struct is_explicitly_convertible<gmp_rational, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
detail::pow_imp	multiprecision/detail/functions/pow.hpp	/^inline void pow_imp(T& result, const T& t, const U& p, const mpl::false_&)$/;"	f	namespace:detail	signature:(T& result, const T& t, const U& p, const mpl::false_&)
detail::pow_imp	multiprecision/detail/functions/pow.hpp	/^inline void pow_imp(T& result, const T& t, const U& p, const mpl::true_&)$/;"	f	namespace:detail	signature:(T& result, const T& t, const U& p, const mpl::true_&)
detail::sinhcosh	multiprecision/detail/functions/pow.hpp	/^   void sinhcosh(const T& x, T* p_sinh, T* p_cosh)$/;"	f	namespace:detail	signature:(const T& x, T* p_sinh, T* p_cosh)
detail::small_sinh_series	multiprecision/detail/functions/pow.hpp	/^   void small_sinh_series(T x, T& result)$/;"	f	namespace:detail	signature:(T x, T& result)
digits	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     digits            = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	class:std::numeric_limits	access:public
digits	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::digits;$/;"	m	class:std::numeric_limits
digits	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int digits = boost::multiprecision::backends::max_precision<backend_type>::value == UINT_MAX ? INT_MAX : boost::multiprecision::backends::max_precision<backend_type>::value;$/;"	m	class:std::numeric_limits	access:public
digits	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::digits;$/;"	m	class:std::numeric_limits
digits	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int digits = 113;$/;"	m	class:std::numeric_limits	access:public
digits	multiprecision/mpfi.hpp	/^inline int digits<boost::multiprecision::mpfi_float>()$/;"	f	namespace:math::tools	signature:()
digits	multiprecision/mpfi.hpp	/^inline int digits<boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<0>, boost::multiprecision::et_off> >()$/;"	f	namespace:math::tools	signature:()
digits	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int digits = INT_MAX;$/;"	m	class:std::numeric_limits	access:public
digits	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::digits;$/;"	m	class:std::numeric_limits
digits10	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     digits10          = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	class:std::numeric_limits	access:public
digits10	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::digits10;$/;"	m	class:std::numeric_limits
digits10	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int digits10 = (digits > INT_MAX \/ 301) ? (digits \/ 1000) * 301L : (digits * 301) \/ 1000;$/;"	m	class:std::numeric_limits	access:public
digits10	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::digits10;$/;"	m	class:std::numeric_limits
digits10	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int digits10 = 34;$/;"	m	class:std::numeric_limits	access:public
digits10	multiprecision/mpfi.hpp	/^   mpfi_float_backend(const mpfi_float_backend& o, unsigned digits10)$/;"	m	struct:boost::multiprecision::backends::mpfi_float_backend	access:public
digits10	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int digits10 = (INT_MAX \/ 1000) * 301L;$/;"	m	class:std::numeric_limits	access:public
digits10	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::digits10;$/;"	m	class:std::numeric_limits
digits10_2_2	multiprecision/detail/digits.hpp	/^inline unsigned long digits10_2_2(unsigned long d10)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long d10)
digits2	multiprecision/detail/number_base.hpp	/^struct digits2$/;"	s	namespace:boost::multiprecision::detail
digits2	multiprecision/mpfr.hpp	/^   static const unsigned digits2 = (digits10 * 1000uL) \/ 301uL + ((digits10 * 1000uL) % 301 ? 2u : 1u);$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
digits2_2_10	multiprecision/detail/digits.hpp	/^inline unsigned long digits2_2_10(unsigned long d2)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long d2)
digits_2	multiprecision/cpp_dec_float.hpp	/^   typedef digits2<((cpp_dec_float_digits10 + 1LL) * 1000LL) \/ 301LL> digits_2;$/;"	t	struct:boost::math::policies::precision	access:public
digits_per_block_10	multiprecision/cpp_int/cpp_int_config.hpp	/^static const limb_type digits_per_block_10 = 18;$/;"	m	namespace:boost::multiprecision
discard	multiprecision/random.hpp	/^    void discard(boost::uintmax_t z)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(boost::uintmax_t z)
distribution_type	multiprecision/random.hpp	/^        typedef uniform_smallint distribution_type;$/;"	t	class:boost::random::uniform_smallint::param_type	access:public
div_loop_n	multiprecision/cpp_dec_float.hpp	/^   static boost::uint32_t div_loop_n (boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
div_loop_n	multiprecision/cpp_dec_float.hpp	/^boost::uint32_t cpp_dec_float<Digits10, ExponentType, Allocator>::div_loop_n(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
div_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& div_unsigned_long_long(const unsigned long long n);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
div_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::div_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const unsigned long long n)
divide_immediates	multiprecision/detail/number_base.hpp	/^struct divide_immediates{};$/;"	s	namespace:boost::multiprecision::detail
divide_qr	multiprecision/detail/integer_ops.hpp	/^   divide_qr(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>& y,$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
divide_qr	multiprecision/detail/integer_ops.hpp	/^   divide_qr(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const number<Backend, ExpressionTemplates>& y,$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const number<Backend, ExpressionTemplates>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
divide_qr	multiprecision/detail/integer_ops.hpp	/^   divide_qr(const number<Backend, ExpressionTemplates>& x, const multiprecision::detail::expression<tag, A1, A2, A3, A4>& y,$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, const multiprecision::detail::expression<tag, A1, A2, A3, A4>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
divide_qr	multiprecision/detail/integer_ops.hpp	/^   divide_qr(const number<Backend, ExpressionTemplates>& x, const number<Backend, ExpressionTemplates>& y,$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, const number<Backend, ExpressionTemplates>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
divide_qr	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value>::type divide_qr(const Integer& x, const Integer& y, Integer& q, Integer& r)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& x, const Integer& y, Integer& q, Integer& r)
divide_unsigned_helper	multiprecision/cpp_int/divide.hpp	/^void divide_unsigned_helper($/;"	f	namespace:boost::multiprecision::backends	signature:( CppInt1* result, const CppInt2& x, const CppInt3& y, CppInt1& r)
divide_unsigned_helper	multiprecision/cpp_int/divide.hpp	/^void divide_unsigned_helper($/;"	f	namespace:boost::multiprecision::backends	signature:( CppInt1* result, const CppInt2& x, limb_type y, CppInt1& r)
divides	multiprecision/detail/number_base.hpp	/^struct divides{};$/;"	s	namespace:boost::multiprecision::detail
do_assign_arithmetic	multiprecision/cpp_int.hpp	/^   void do_assign_arithmetic(double_limb_type i, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	signature:(double_limb_type i, const mpl::false_&)
do_assign_arithmetic	multiprecision/cpp_int.hpp	/^   void do_assign_arithmetic(long double a, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	signature:(long double a, const mpl::false_&)
do_assign_arithmetic	multiprecision/cpp_int.hpp	/^   void do_assign_arithmetic(signed_double_limb_type i, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	signature:(signed_double_limb_type i, const mpl::false_&)
do_assign_string	multiprecision/cpp_int.hpp	/^   void do_assign_string(const char* s, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(const char* s, const mpl::false_&)
do_assign_string	multiprecision/cpp_int.hpp	/^   void do_assign_string(const char* s, const mpl::true_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(const char* s, const mpl::true_&)
do_get_string	multiprecision/cpp_int.hpp	/^   std::string do_get_string(std::ios_base::fmtflags f, const mpl::false_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::false_&) const
do_get_string	multiprecision/cpp_int.hpp	/^   std::string do_get_string(std::ios_base::fmtflags f, const mpl::true_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::true_&) const
do_get_trivial_string	multiprecision/cpp_int.hpp	/^   std::string do_get_trivial_string(std::ios_base::fmtflags f, const mpl::false_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::false_&) const
do_get_trivial_string	multiprecision/cpp_int.hpp	/^   std::string do_get_trivial_string(std::ios_base::fmtflags f, const mpl::true_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::true_&) const
do_nothing	multiprecision/cpp_dec_float.hpp	/^         void do_nothing(){}$/;"	f	struct:boost::multiprecision::backends::cpp_dec_float::initializer	access:public	signature:()
do_nothing	multiprecision/cpp_int/limits.hpp	/^      void do_nothing()const{}$/;"	f	struct:std::numeric_limits::inititializer	access:public	signature:() const
do_nothing	multiprecision/detail/functions/constants.hpp	/^      void do_nothing()const{}$/;"	f	struct:constant_initializer::initializer	access:public	signature:() const
do_nothing	multiprecision/detail/functions/constants.hpp	/^   static void do_nothing()$/;"	f	struct:constant_initializer	access:public	signature:()
do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::false_ const&, mpl::false_ const&, mpl::false_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::false_ const&, mpl::false_ const&, mpl::false_ const&)
do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::false_ const&, mpl::false_ const&, mpl::true_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::false_ const&, mpl::false_ const&, mpl::true_ const&)
do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::false_ const&, mpl::true_ const&, mpl::false_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::false_ const&, mpl::true_ const&, mpl::false_ const&)
do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::false_ const&, mpl::true_ const&, mpl::true_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::false_ const&, mpl::true_ const&, mpl::true_ const&)
do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::true_ const&, mpl::false_ const&, mpl::false_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::true_ const&, mpl::false_ const&, mpl::false_ const&)
do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::true_ const&, mpl::false_ const&, mpl::true_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::true_ const&, mpl::false_ const&, mpl::true_ const&)
do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::true_ const&, mpl::true_ const&, mpl::false_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::true_ const&, mpl::true_ const&, mpl::false_ const&)
do_serialize	multiprecision/cpp_int/serialize.hpp	/^void do_serialize(Archive& ar, Int& val, mpl::true_ const&, mpl::true_ const&, mpl::true_ const&)$/;"	f	namespace:boost::serialization::cpp_int_detail	signature:(Archive& ar, Int& val, mpl::true_ const&, mpl::true_ const&, mpl::true_ const&)
do_serialize	multiprecision/float128.hpp	/^void do_serialize(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::false_&, const mpl::false_&)$/;"	f	namespace:boost::serialization::float128_detail	signature:(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::false_&, const mpl::false_&)
do_serialize	multiprecision/float128.hpp	/^void do_serialize(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::false_&, const mpl::true_&)$/;"	f	namespace:boost::serialization::float128_detail	signature:(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::false_&, const mpl::true_&)
do_serialize	multiprecision/float128.hpp	/^void do_serialize(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::true_&, const mpl::false_&)$/;"	f	namespace:boost::serialization::float128_detail	signature:(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::true_&, const mpl::false_&)
do_serialize	multiprecision/float128.hpp	/^void do_serialize(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::true_&, const mpl::true_&)$/;"	f	namespace:boost::serialization::float128_detail	signature:(Archive& ar, boost::multiprecision::backends::float128_backend& val, const mpl::true_&, const mpl::true_&)
double_first	multiprecision/cpp_int.hpp	/^      double_limb_type double_first;$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
double_integer	multiprecision/integer.hpp	/^struct double_integer$/;"	s	namespace:boost::multiprecision::detail
double_limb_type	multiprecision/cpp_int/cpp_int_config.hpp	/^typedef boost::uint128_type double_limb_type;$/;"	t	namespace:boost::multiprecision
double_max	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& double_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
double_min	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& double_min()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
double_precision_type	multiprecision/cpp_int.hpp	/^struct double_precision_type<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:default_ops
double_precision_type	multiprecision/detail/integer_ops.hpp	/^struct double_precision_type$/;"	s	namespace:boost::multiprecision::default_ops
dummy_size	multiprecision/traits/explicit_conversion.hpp	/^struct dummy_size{};$/;"	s	namespace:boost::multiprecision::detail
dynamic_array	multiprecision/detail/dynamic_array.hpp	/^       dynamic_array() :$/;"	f	struct:boost::multiprecision::backends::detail::dynamic_array	access:public	signature:()
dynamic_array	multiprecision/detail/dynamic_array.hpp	/^    struct dynamic_array : public std::vector<value_type, typename rebind<value_type, my_allocator>::type>$/;"	s	namespace:boost::multiprecision::backends::detail	inherits:std::vector
empty	multiprecision/mpfi.hpp	/^inline bool empty(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  a)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a)
enum_fpclass_type	multiprecision/cpp_dec_float.hpp	/^   typedef enum enum_fpclass_type$/;"	g	class:boost::multiprecision::backends::cpp_dec_float	access:private
eps	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& eps()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
epsilon	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> epsilon      (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::eps(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
epsilon	multiprecision/cpp_int/limits.hpp	/^   static number_type epsilon() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
epsilon	multiprecision/float128.hpp	/^   static number_type epsilon() { return 1.92592994438723585305597794258492732e-34Q; }$/;"	f	class:std::numeric_limits	access:public	signature:()
epsilon	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type epsilon() { return base_type::epsilon(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
epsilon	multiprecision/tommath.hpp	/^   static number_type epsilon() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
et_off	multiprecision/detail/number_base.hpp	/^   et_off  = 0,$/;"	e	enum:boost::multiprecision::expression_template_option
et_on	multiprecision/detail/number_base.hpp	/^   et_on   = 1$/;"	e	enum:boost::multiprecision::expression_template_option
eval_abs	multiprecision/cpp_dec_float.hpp	/^inline void eval_abs(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x) $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
eval_abs	multiprecision/detail/default_ops.hpp	/^void eval_abs(T& result, const T& arg)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg)
eval_abs	multiprecision/float128.hpp	/^inline void eval_abs(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_abs	multiprecision/gmp.hpp	/^inline void eval_abs(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
eval_abs	multiprecision/gmp.hpp	/^inline void eval_abs(gmp_int& result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& val)
eval_abs	multiprecision/mpfi.hpp	/^inline void eval_abs(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)
eval_abs	multiprecision/mpfr.hpp	/^inline void eval_abs(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
eval_abs	multiprecision/tommath.hpp	/^inline void eval_abs(tommath_int& result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& val)
eval_acos	multiprecision/detail/functions/trig.hpp	/^inline void eval_acos(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_acos	multiprecision/float128.hpp	/^inline void eval_acos(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_acos	multiprecision/mpfi.hpp	/^inline void eval_acos(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
eval_add	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_add(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
eval_add	multiprecision/cpp_dec_float.hpp	/^inline void eval_add(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
eval_add	multiprecision/cpp_dec_float.hpp	/^inline void eval_add(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
eval_add	multiprecision/cpp_dec_float.hpp	/^inline void eval_add(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
eval_add	multiprecision/detail/default_ops.hpp	/^   eval_add(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_add	multiprecision/detail/default_ops.hpp	/^inline void eval_add(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_add	multiprecision/detail/default_ops.hpp	/^void eval_add(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_add	multiprecision/float128.hpp	/^inline void eval_add(float128_backend& result, const A& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const A& a)
eval_add	multiprecision/float128.hpp	/^inline void eval_add(float128_backend& result, const float128_backend& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a)
eval_add	multiprecision/float128.hpp	/^inline void eval_add(float128_backend& result, const float128_backend& a, const A& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const A& b)
eval_add	multiprecision/float128.hpp	/^inline void eval_add(float128_backend& result, const float128_backend& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const float128_backend& b)
eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
eval_add	multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)
eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)
eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)
eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)
eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)
eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)
eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, long i)
eval_add	multiprecision/mpfi.hpp	/^inline void eval_add(mpfi_float_backend<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, unsigned long i)
eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
eval_add	multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
eval_add	multiprecision/rational_adaptor.hpp	/^inline void eval_add(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)
eval_add	multiprecision/tommath.hpp	/^inline void eval_add(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
eval_add	multiprecision/tommath.hpp	/^inline void eval_add(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
eval_add	multiprecision/tommath.hpp	/^void eval_add(tommath_int& t, const tommath_int& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
eval_add_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_add_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_add_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_add_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_add_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_add_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_add_default	multiprecision/detail/default_ops.hpp	/^inline void eval_add_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_add_default	multiprecision/detail/default_ops.hpp	/^inline void eval_add_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_asin	multiprecision/detail/functions/trig.hpp	/^void eval_asin(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_asin	multiprecision/float128.hpp	/^inline void eval_asin(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_asin	multiprecision/mpfi.hpp	/^inline void eval_asin(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
eval_atan	multiprecision/detail/functions/trig.hpp	/^void eval_atan(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_atan	multiprecision/float128.hpp	/^inline void eval_atan(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_atan	multiprecision/mpfi.hpp	/^inline void eval_atan(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
eval_atan2	multiprecision/detail/functions/trig.hpp	/^inline typename enable_if<is_arithmetic<A>, void>::type eval_atan2(T& result, const A& x, const T& a)$/;"	f	signature:(T& result, const A& x, const T& a)
eval_atan2	multiprecision/detail/functions/trig.hpp	/^inline typename enable_if<is_arithmetic<A>, void>::type eval_atan2(T& result, const T& x, const A& a)$/;"	f	signature:(T& result, const T& x, const A& a)
eval_atan2	multiprecision/detail/functions/trig.hpp	/^void eval_atan2(T& result, const T& y, const T& x)$/;"	f	signature:(T& result, const T& y, const T& x)
eval_atan2	multiprecision/float128.hpp	/^inline void eval_atan2(float128_backend& result, const float128_backend& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const float128_backend& b)
eval_atan2	multiprecision/mpfi.hpp	/^inline void eval_atan2(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg1, const mpfi_float_backend<Digits10>& arg2)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg1, const mpfi_float_backend<Digits10>& arg2)
eval_bit_flip	multiprecision/cpp_int/misc.hpp	/^   eval_bit_flip(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)
eval_bit_flip	multiprecision/debug_adaptor.hpp	/^inline void eval_bit_flip(const debug_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg, unsigned a)
eval_bit_flip	multiprecision/detail/default_ops.hpp	/^inline void eval_bit_flip(T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val, unsigned index)
eval_bit_flip	multiprecision/logged_adaptor.hpp	/^inline void eval_bit_flip(const logged_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg, unsigned a)
eval_bit_set	multiprecision/cpp_int/misc.hpp	/^   eval_bit_set(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)
eval_bit_set	multiprecision/debug_adaptor.hpp	/^inline void eval_bit_set(const debug_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg, unsigned a)
eval_bit_set	multiprecision/detail/default_ops.hpp	/^inline void eval_bit_set(T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val, unsigned index)
eval_bit_set	multiprecision/logged_adaptor.hpp	/^inline void eval_bit_set(const logged_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg, unsigned a)
eval_bit_test	multiprecision/debug_adaptor.hpp	/^inline bool eval_bit_test(const debug_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg, unsigned a)
eval_bit_test	multiprecision/detail/default_ops.hpp	/^inline bool eval_bit_test(const T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val, unsigned index)
eval_bit_test	multiprecision/logged_adaptor.hpp	/^inline bool eval_bit_test(const logged_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg, unsigned a)
eval_bit_unset	multiprecision/debug_adaptor.hpp	/^inline void eval_bit_unset(const debug_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg, unsigned a)
eval_bit_unset	multiprecision/detail/default_ops.hpp	/^inline void eval_bit_unset(T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val, unsigned index)
eval_bit_unset	multiprecision/logged_adaptor.hpp	/^inline void eval_bit_unset(const logged_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg, unsigned a)
eval_bitwise_and	multiprecision/detail/default_ops.hpp	/^   eval_bitwise_and(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_bitwise_and	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_and(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_and	multiprecision/detail/default_ops.hpp	/^void eval_bitwise_and(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_and	multiprecision/gmp.hpp	/^inline void eval_bitwise_and(gmp_int& result, const gmp_int& u, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u, const gmp_int& v)
eval_bitwise_and	multiprecision/gmp.hpp	/^inline void eval_bitwise_and(gmp_int& result, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& v)
eval_bitwise_and	multiprecision/tommath.hpp	/^inline void eval_bitwise_and(tommath_int& result, const tommath_int& u, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& u, const tommath_int& v)
eval_bitwise_and	multiprecision/tommath.hpp	/^inline void eval_bitwise_and(tommath_int& result, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& v)
eval_bitwise_and_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_bitwise_and_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_bitwise_and_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_bitwise_and_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_bitwise_and_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_bitwise_and_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_bitwise_and_default	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_and_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_bitwise_and_default	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_and_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_or	multiprecision/detail/default_ops.hpp	/^   eval_bitwise_or(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_bitwise_or	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_or(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_or	multiprecision/detail/default_ops.hpp	/^void eval_bitwise_or(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_or	multiprecision/gmp.hpp	/^inline void eval_bitwise_or(gmp_int& result, const gmp_int& u, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u, const gmp_int& v)
eval_bitwise_or	multiprecision/gmp.hpp	/^inline void eval_bitwise_or(gmp_int& result, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& v)
eval_bitwise_or	multiprecision/tommath.hpp	/^inline void eval_bitwise_or(tommath_int& result, const tommath_int& u, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& u, const tommath_int& v)
eval_bitwise_or	multiprecision/tommath.hpp	/^inline void eval_bitwise_or(tommath_int& result, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& v)
eval_bitwise_or_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_bitwise_or_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_bitwise_or_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_bitwise_or_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_bitwise_or_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_bitwise_or_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_bitwise_or_default	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_or_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_bitwise_or_default	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_or_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_xor	multiprecision/detail/default_ops.hpp	/^   eval_bitwise_xor(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_bitwise_xor	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_xor(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_xor	multiprecision/detail/default_ops.hpp	/^void eval_bitwise_xor(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_xor	multiprecision/gmp.hpp	/^inline void eval_bitwise_xor(gmp_int& result, const gmp_int& u, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u, const gmp_int& v)
eval_bitwise_xor	multiprecision/gmp.hpp	/^inline void eval_bitwise_xor(gmp_int& result, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& v)
eval_bitwise_xor	multiprecision/tommath.hpp	/^inline void eval_bitwise_xor(tommath_int& result, const tommath_int& u, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& u, const tommath_int& v)
eval_bitwise_xor	multiprecision/tommath.hpp	/^inline void eval_bitwise_xor(tommath_int& result, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& v)
eval_bitwise_xor_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_bitwise_xor_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_bitwise_xor_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_bitwise_xor_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_bitwise_xor_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_bitwise_xor_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_bitwise_xor_default	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_xor_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_bitwise_xor_default	multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_xor_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_ceil	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_ceil(number_backend_float_architype& result, const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg)
eval_ceil	multiprecision/cpp_dec_float.hpp	/^inline void eval_ceil(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
eval_ceil	multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_ceil();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
eval_ceil	multiprecision/float128.hpp	/^inline void eval_ceil(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_ceil	multiprecision/gmp.hpp	/^inline void eval_ceil(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
eval_ceil	multiprecision/mpfi.hpp	/^inline void eval_ceil(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)
eval_ceil	multiprecision/mpfr.hpp	/^inline void eval_ceil(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
eval_complement	multiprecision/detail/default_ops.hpp	/^   eval_complement(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_complement	multiprecision/gmp.hpp	/^inline void eval_complement(gmp_int& result, const gmp_int& u)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u)
eval_convert_to	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_convert_to(long double* result, number_backend_float_architype& val)$/;"	f	namespace:boost::multiprecision::concepts	signature:(long double* result, number_backend_float_architype& val)
eval_convert_to	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_convert_to(long long* result, const number_backend_float_architype& val)$/;"	f	namespace:boost::multiprecision::concepts	signature:(long long* result, const number_backend_float_architype& val)
eval_convert_to	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_convert_to(unsigned long long* result, const number_backend_float_architype& val)$/;"	f	namespace:boost::multiprecision::concepts	signature:(unsigned long long* result, const number_backend_float_architype& val)
eval_convert_to	multiprecision/cpp_dec_float.hpp	/^inline void eval_convert_to(long double* result, cpp_dec_float<Digits10, ExponentType, Allocator>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(long double* result, cpp_dec_float<Digits10, ExponentType, Allocator>& val)
eval_convert_to	multiprecision/cpp_dec_float.hpp	/^inline void eval_convert_to(long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)  $/;"	f	namespace:boost::multiprecision::backends	signature:(long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
eval_convert_to	multiprecision/cpp_dec_float.hpp	/^inline void eval_convert_to(unsigned long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)  $/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
eval_convert_to	multiprecision/debug_adaptor.hpp	/^inline void eval_convert_to(R* result, const debug_adaptor<Backend>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(R* result, const debug_adaptor<Backend>& val)
eval_convert_to	multiprecision/detail/default_ops.hpp	/^inline void eval_convert_to(R* result, const B& backend)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(R* result, const B& backend)
eval_convert_to	multiprecision/detail/default_ops.hpp	/^inline void eval_convert_to(std::string* result, const B& backend)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(std::string* result, const B& backend)
eval_convert_to	multiprecision/detail/default_ops.hpp	/^inline void eval_convert_to(terminal<R>* result, const B& backend)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(terminal<R>* result, const B& backend)
eval_convert_to	multiprecision/float128.hpp	/^inline void eval_convert_to(R* result, const float128_backend& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(R* result, const float128_backend& val)
eval_convert_to	multiprecision/gmp.hpp	/^inline void eval_convert_to(double* result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(double* result, const gmp_int& val)
eval_convert_to	multiprecision/gmp.hpp	/^inline void eval_convert_to(long long* result, const gmp_float<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(long long* result, const gmp_float<digits10>& val)
eval_convert_to	multiprecision/gmp.hpp	/^inline void eval_convert_to(long* result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(long* result, const gmp_int& val)
eval_convert_to	multiprecision/gmp.hpp	/^inline void eval_convert_to(unsigned long long* result, const gmp_float<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(unsigned long long* result, const gmp_float<digits10>& val)
eval_convert_to	multiprecision/gmp.hpp	/^inline void eval_convert_to(unsigned long* result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(unsigned long* result, const gmp_int& val)
eval_convert_to	multiprecision/logged_adaptor.hpp	/^inline void eval_convert_to(R* result, const logged_adaptor<Backend>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(R* result, const logged_adaptor<Backend>& val)
eval_convert_to	multiprecision/mpfi.hpp	/^inline void eval_convert_to(long long* result, const mpfi_float_backend<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(long long* result, const mpfi_float_backend<digits10>& val)
eval_convert_to	multiprecision/mpfi.hpp	/^inline void eval_convert_to(long* result, const mpfi_float_backend<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(long* result, const mpfi_float_backend<digits10>& val)
eval_convert_to	multiprecision/mpfi.hpp	/^inline void eval_convert_to(unsigned long long* result, const mpfi_float_backend<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(unsigned long long* result, const mpfi_float_backend<digits10>& val)
eval_convert_to	multiprecision/mpfi.hpp	/^inline void eval_convert_to(unsigned long* result, const mpfi_float_backend<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(unsigned long* result, const mpfi_float_backend<digits10>& val)
eval_convert_to	multiprecision/mpfr.hpp	/^inline void eval_convert_to(long long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(long long* result, const mpfr_float_backend<digits10, AllocationType>& val)
eval_convert_to	multiprecision/mpfr.hpp	/^inline void eval_convert_to(long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(long* result, const mpfr_float_backend<digits10, AllocationType>& val)
eval_convert_to	multiprecision/mpfr.hpp	/^inline void eval_convert_to(unsigned long long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned long long* result, const mpfr_float_backend<digits10, AllocationType>& val)
eval_convert_to	multiprecision/mpfr.hpp	/^inline void eval_convert_to(unsigned long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned long* result, const mpfr_float_backend<digits10, AllocationType>& val)
eval_convert_to	multiprecision/rational_adaptor.hpp	/^inline void eval_convert_to(R* result, const rational_adaptor<IntBackend>& backend)$/;"	f	namespace:boost::multiprecision::backends	signature:(R* result, const rational_adaptor<IntBackend>& backend)
eval_convert_to	multiprecision/tommath.hpp	/^inline void eval_convert_to(A* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(A* result, const tommath_int& val)
eval_convert_to	multiprecision/tommath.hpp	/^inline void eval_convert_to(char* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(char* result, const tommath_int& val)
eval_convert_to	multiprecision/tommath.hpp	/^inline void eval_convert_to(signed char* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(signed char* result, const tommath_int& val)
eval_convert_to	multiprecision/tommath.hpp	/^inline void eval_convert_to(unsigned char* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned char* result, const tommath_int& val)
eval_cos	multiprecision/detail/functions/trig.hpp	/^void eval_cos(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_cos	multiprecision/float128.hpp	/^inline void eval_cos(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_cos	multiprecision/mpfi.hpp	/^inline void eval_cos(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
eval_cosh	multiprecision/detail/functions/pow.hpp	/^inline void eval_cosh(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_cosh	multiprecision/float128.hpp	/^inline void eval_cosh(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_cosh	multiprecision/mpfi.hpp	/^inline void eval_cosh(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
eval_decrement	multiprecision/detail/default_ops.hpp	/^inline void eval_decrement(T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val)
eval_decrement	multiprecision/float128.hpp	/^inline void eval_decrement(float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& arg)
eval_divide	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_divide(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
eval_divide	multiprecision/cpp_dec_float.hpp	/^inline void eval_divide(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
eval_divide	multiprecision/cpp_dec_float.hpp	/^inline void eval_divide(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
eval_divide	multiprecision/cpp_dec_float.hpp	/^inline void eval_divide(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
eval_divide	multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o)
eval_divide	multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b)
eval_divide	multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, limb_type& b)
eval_divide	multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, signed_limb_type& b)
eval_divide	multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& b)
eval_divide	multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, limb_type b)
eval_divide	multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, signed_limb_type b)
eval_divide	multiprecision/detail/default_ops.hpp	/^   eval_divide(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_divide	multiprecision/detail/default_ops.hpp	/^inline void eval_divide(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_divide	multiprecision/detail/default_ops.hpp	/^void eval_divide(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_divide	multiprecision/float128.hpp	/^inline void eval_divide(float128_backend& result, const A& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const A& a)
eval_divide	multiprecision/float128.hpp	/^inline void eval_divide(float128_backend& result, const float128_backend& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a)
eval_divide	multiprecision/float128.hpp	/^inline void eval_divide(float128_backend& result, const float128_backend& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const float128_backend& b)
eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
eval_divide	multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)
eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)
eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)
eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)
eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)
eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)
eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, long i)
eval_divide	multiprecision/mpfi.hpp	/^inline void eval_divide(mpfi_float_backend<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, unsigned long i)
eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
eval_divide	multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
eval_divide	multiprecision/rational_adaptor.hpp	/^inline void eval_divide(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)
eval_divide	multiprecision/tommath.hpp	/^inline void eval_divide(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
eval_divide	multiprecision/tommath.hpp	/^inline void eval_divide(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
eval_divide_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_divide_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_divide_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_divide_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_divide_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_divide_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_divide_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_divide_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_divide_default	multiprecision/detail/default_ops.hpp	/^inline void eval_divide_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_divide_default	multiprecision/detail/default_ops.hpp	/^inline void eval_divide_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_eq	multiprecision/detail/number_compare.hpp	/^inline bool eval_eq(const B& a, const A& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const A& b)
eval_eq	multiprecision/detail/number_compare.hpp	/^inline bool eval_eq(const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const B& b)
eval_eq	multiprecision/gmp.hpp	/^inline typename enable_if<is_arithmetic<T>, bool>::type eval_eq(const gmp_int& a, const T& b)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& a, const T& b)
eval_exp	multiprecision/detail/functions/pow.hpp	/^void eval_exp(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_exp	multiprecision/float128.hpp	/^inline void eval_exp(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_exp	multiprecision/mpfi.hpp	/^inline void eval_exp(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
eval_fabs	multiprecision/cpp_dec_float.hpp	/^inline void eval_fabs(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x) $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
eval_fabs	multiprecision/detail/default_ops.hpp	/^void eval_fabs(T& result, const T& arg)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg)
eval_fabs	multiprecision/float128.hpp	/^inline void eval_fabs(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_fabs	multiprecision/gmp.hpp	/^inline void eval_fabs(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
eval_fabs	multiprecision/mpfi.hpp	/^inline void eval_fabs(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)
eval_fabs	multiprecision/mpfr.hpp	/^inline void eval_fabs(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
eval_floor	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_floor(number_backend_float_architype& result, const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg)
eval_floor	multiprecision/cpp_dec_float.hpp	/^inline void eval_floor(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
eval_floor	multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_floor();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
eval_floor	multiprecision/float128.hpp	/^inline void eval_floor(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_floor	multiprecision/gmp.hpp	/^inline void eval_floor(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
eval_floor	multiprecision/mpfi.hpp	/^inline void eval_floor(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)
eval_floor	multiprecision/mpfr.hpp	/^inline void eval_floor(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
eval_fmod	multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_arithmetic<A>, void>::type eval_fmod(T& result, const A& x, const T& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const A& x, const T& a)
eval_fmod	multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_arithmetic<A>, void>::type eval_fmod(T& result, const T& x, const A& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& x, const A& a)
eval_fmod	multiprecision/detail/default_ops.hpp	/^inline void eval_fmod(T& result, const T& a, const T& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a, const T& b)
eval_fmod	multiprecision/float128.hpp	/^inline void eval_fmod(float128_backend& result, const float128_backend& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const float128_backend& b)
eval_fpclassify	multiprecision/concepts/mp_number_archetypes.hpp	/^inline int eval_fpclassify(const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(const number_backend_float_architype& arg)
eval_fpclassify	multiprecision/cpp_dec_float.hpp	/^inline int eval_fpclassify(const cpp_dec_float<Digits10, ExponentType, Allocator>& x) $/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
eval_fpclassify	multiprecision/debug_adaptor.hpp	/^inline int eval_fpclassify(const debug_adaptor<Backend>& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg)
eval_fpclassify	multiprecision/detail/default_ops.hpp	/^inline int eval_fpclassify(const Backend& arg)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const Backend& arg)
eval_fpclassify	multiprecision/float128.hpp	/^inline int eval_fpclassify(const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(const float128_backend& arg)
eval_fpclassify	multiprecision/logged_adaptor.hpp	/^inline int eval_fpclassify(const logged_adaptor<Backend>& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg)
eval_frexp	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_frexp(number_backend_float_architype& result, const number_backend_float_architype& arg, int* exp)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg, int* exp)
eval_frexp	multiprecision/cpp_dec_float.hpp	/^inline typename disable_if<is_same<ExponentType, int> >::type eval_frexp(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, int* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, int* e)
eval_frexp	multiprecision/cpp_dec_float.hpp	/^inline void eval_frexp(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ExponentType* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ExponentType* e)
eval_frexp	multiprecision/debug_adaptor.hpp	/^inline void eval_frexp(debug_adaptor<Backend>& result, const debug_adaptor<Backend>& arg, Exp* exp)$/;"	f	namespace:boost::multiprecision::backends	signature:(debug_adaptor<Backend>& result, const debug_adaptor<Backend>& arg, Exp* exp)
eval_frexp	multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_frexp();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
eval_frexp	multiprecision/float128.hpp	/^inline void eval_frexp(float128_backend& result, const float128_backend& arg, int* exp)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg, int* exp)
eval_frexp	multiprecision/gmp.hpp	/^inline void eval_frexp(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, int* e)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, int* e)
eval_frexp	multiprecision/gmp.hpp	/^inline void eval_frexp(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long* e)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long* e)
eval_frexp	multiprecision/logged_adaptor.hpp	/^inline void eval_frexp(logged_adaptor<Backend>& result, const logged_adaptor<Backend>& arg, Exp* exp)$/;"	f	namespace:boost::multiprecision::backends	signature:(logged_adaptor<Backend>& result, const logged_adaptor<Backend>& arg, Exp* exp)
eval_frexp	multiprecision/mpfi.hpp	/^inline void eval_frexp(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val, int* e)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val, int* e)
eval_frexp	multiprecision/mpfi.hpp	/^inline void eval_frexp(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val, long* e)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val, long* e)
eval_frexp	multiprecision/mpfr.hpp	/^inline void eval_frexp(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, int* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, int* e)
eval_frexp	multiprecision/mpfr.hpp	/^inline void eval_frexp(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long* e)
eval_gcd	multiprecision/cpp_int/misc.hpp	/^   eval_gcd($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a, limb_type v)
eval_gcd	multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_gcd(T& result, const Arithmetic& a, const T& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const Arithmetic& a, const T& b)
eval_gcd	multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_gcd(T& result, const T& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a, const Arithmetic& b)
eval_gcd	multiprecision/detail/default_ops.hpp	/^void eval_gcd(B& result, const B& a, const B& b);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
eval_gcd	multiprecision/detail/integer_ops.hpp	/^inline void eval_gcd(B& result, const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
eval_gcd	multiprecision/gmp.hpp	/^inline void eval_gcd(gmp_int& result, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& a, const gmp_int& b)
eval_gcd	multiprecision/tommath.hpp	/^inline void eval_gcd(tommath_int& result, const tommath_int& a, const tommath_int& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& a, const tommath_int& b)
eval_get_sign	multiprecision/cpp_dec_float.hpp	/^inline int eval_get_sign(const cpp_dec_float<Digits10, ExponentType, Allocator>& val) $/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
eval_get_sign	multiprecision/detail/default_ops.hpp	/^inline int eval_get_sign(const T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val)
eval_get_sign	multiprecision/gmp.hpp	/^inline int eval_get_sign(const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& val)
eval_get_sign	multiprecision/mpfi.hpp	/^inline int eval_get_sign(const mpfi_float_backend<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(const mpfi_float_backend<digits10>& val)
eval_get_sign	multiprecision/rational_adaptor.hpp	/^inline int eval_get_sign(const rational_adaptor<IntBackend>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const rational_adaptor<IntBackend>& val)
eval_get_sign	multiprecision/tommath.hpp	/^inline int eval_get_sign(const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
eval_get_sign	multiprecision/tommath.hpp	/^int eval_get_sign(const tommath_int& val);$/;"	p	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
eval_gt	multiprecision/detail/number_compare.hpp	/^inline bool eval_gt(const B& a, const A& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const A& b)
eval_gt	multiprecision/detail/number_compare.hpp	/^inline bool eval_gt(const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const B& b)
eval_gt	multiprecision/gmp.hpp	/^inline typename enable_if<is_arithmetic<T>, bool>::type eval_gt(const gmp_int& a, const T& b)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& a, const T& b)
eval_increment	multiprecision/detail/default_ops.hpp	/^inline void eval_increment(T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val)
eval_increment	multiprecision/float128.hpp	/^inline void eval_increment(float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& arg)
eval_integer_modulus	multiprecision/cpp_int/misc.hpp	/^   eval_integer_modulus(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& x, Integer val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& x, Integer val)
eval_integer_modulus	multiprecision/debug_adaptor.hpp	/^inline unsigned eval_integer_modulus(const debug_adaptor<Backend>& arg, const T& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg, const T& a)
eval_integer_modulus	multiprecision/detail/integer_ops.hpp	/^inline Integer eval_integer_modulus(const Backend& x, Integer val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const Backend& x, Integer val)
eval_integer_modulus	multiprecision/logged_adaptor.hpp	/^inline unsigned eval_integer_modulus(const logged_adaptor<Backend>& arg, const T& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg, const T& a)
eval_integer_modulus	multiprecision/tommath.hpp	/^inline typename enable_if<is_signed<Integer>, Integer>::type eval_integer_modulus(const tommath_int& x, Integer val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& x, Integer val)
eval_integer_modulus	multiprecision/tommath.hpp	/^inline typename enable_if<is_unsigned<Integer>, Integer>::type eval_integer_modulus(const tommath_int& x, Integer val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& x, Integer val)
eval_integer_sqrt	multiprecision/detail/default_ops.hpp	/^void eval_integer_sqrt(B& s, B& r, const B& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(B& s, B& r, const B& x)
eval_is_zero	multiprecision/cpp_dec_float.hpp	/^inline bool eval_is_zero(const cpp_dec_float<Digits10, ExponentType, Allocator>& val) $/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
eval_is_zero	multiprecision/detail/default_ops.hpp	/^inline bool eval_is_zero(const T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val)
eval_is_zero	multiprecision/gmp.hpp	/^inline bool eval_is_zero(const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& val)
eval_is_zero	multiprecision/rational_adaptor.hpp	/^inline bool eval_is_zero(const rational_adaptor<IntBackend>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const rational_adaptor<IntBackend>& val)
eval_is_zero	multiprecision/tommath.hpp	/^inline bool eval_is_zero(const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
eval_lcm	multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_lcm(T& result, const Arithmetic& a, const T& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const Arithmetic& a, const T& b)
eval_lcm	multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_lcm(T& result, const T& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a, const Arithmetic& b)
eval_lcm	multiprecision/detail/default_ops.hpp	/^void eval_lcm(B& result, const B& a, const B& b);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
eval_lcm	multiprecision/detail/integer_ops.hpp	/^inline void eval_lcm(B& result, const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
eval_lcm	multiprecision/gmp.hpp	/^inline void eval_lcm(gmp_int& result, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& a, const gmp_int& b)
eval_lcm	multiprecision/tommath.hpp	/^inline void eval_lcm(tommath_int& result, const tommath_int& a, const tommath_int& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& a, const tommath_int& b)
eval_ldexp	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_ldexp(number_backend_float_architype& result, const number_backend_float_architype& arg, int exp)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg, int exp)
eval_ldexp	multiprecision/cpp_dec_float.hpp	/^inline void eval_ldexp(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ArgType e)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ArgType e)
eval_ldexp	multiprecision/debug_adaptor.hpp	/^inline void eval_ldexp(debug_adaptor<Backend>& result, const debug_adaptor<Backend>& arg, Exp exp)$/;"	f	namespace:boost::multiprecision::backends	signature:(debug_adaptor<Backend>& result, const debug_adaptor<Backend>& arg, Exp exp)
eval_ldexp	multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_ldexp();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
eval_ldexp	multiprecision/float128.hpp	/^inline void eval_ldexp(float128_backend& result, const float128_backend& arg, int exp)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg, int exp)
eval_ldexp	multiprecision/gmp.hpp	/^inline void eval_ldexp(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long e)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long e)
eval_ldexp	multiprecision/logged_adaptor.hpp	/^inline void eval_ldexp(logged_adaptor<Backend>& result, const logged_adaptor<Backend>& arg, Exp exp)$/;"	f	namespace:boost::multiprecision::backends	signature:(logged_adaptor<Backend>& result, const logged_adaptor<Backend>& arg, Exp exp)
eval_ldexp	multiprecision/mpfi.hpp	/^inline void eval_ldexp(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val, long e)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val, long e)
eval_ldexp	multiprecision/mpfr.hpp	/^inline void eval_ldexp(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long e)
eval_left_shift	multiprecision/debug_adaptor.hpp	/^inline void eval_left_shift(debug_adaptor<Backend>& arg, const debug_adaptor<Backend>& a, unsigned b)$/;"	f	namespace:boost::multiprecision::backends	signature:(debug_adaptor<Backend>& arg, const debug_adaptor<Backend>& a, unsigned b)
eval_left_shift	multiprecision/debug_adaptor.hpp	/^inline void eval_left_shift(debug_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(debug_adaptor<Backend>& arg, unsigned a)
eval_left_shift	multiprecision/detail/default_ops.hpp	/^inline void eval_left_shift(T& result, const T& arg, const V val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg, const V val)
eval_left_shift	multiprecision/gmp.hpp	/^inline void eval_left_shift(gmp_int& t, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, UI i)
eval_left_shift	multiprecision/gmp.hpp	/^inline void eval_left_shift(gmp_int& t, const gmp_int& v, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& v, UI i)
eval_left_shift	multiprecision/logged_adaptor.hpp	/^inline void eval_left_shift(logged_adaptor<Backend>& arg, const logged_adaptor<Backend>& a, unsigned b)$/;"	f	namespace:boost::multiprecision::backends	signature:(logged_adaptor<Backend>& arg, const logged_adaptor<Backend>& a, unsigned b)
eval_left_shift	multiprecision/logged_adaptor.hpp	/^inline void eval_left_shift(logged_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(logged_adaptor<Backend>& arg, unsigned a)
eval_left_shift	multiprecision/tommath.hpp	/^inline void eval_left_shift(tommath_int& t, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, UI i)
eval_left_shift	multiprecision/tommath.hpp	/^inline void eval_left_shift(tommath_int& t, const tommath_int& v, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& v, UI i)
eval_log	multiprecision/detail/functions/pow.hpp	/^void eval_log(T& result, const T& arg)$/;"	f	signature:(T& result, const T& arg)
eval_log	multiprecision/float128.hpp	/^inline void eval_log(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_log	multiprecision/mpfi.hpp	/^inline void eval_log(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
eval_log10	multiprecision/detail/functions/pow.hpp	/^void eval_log10(T& result, const T& arg)$/;"	f	signature:(T& result, const T& arg)
eval_log10	multiprecision/float128.hpp	/^inline void eval_log10(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_log10	multiprecision/mpfi.hpp	/^inline void eval_log10(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
eval_lsb	multiprecision/cpp_int/misc.hpp	/^   eval_lsb(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)
eval_lsb	multiprecision/debug_adaptor.hpp	/^inline unsigned eval_lsb(const debug_adaptor<Backend>& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg)
eval_lsb	multiprecision/detail/default_ops.hpp	/^inline unsigned eval_lsb(const T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val)
eval_lsb	multiprecision/logged_adaptor.hpp	/^inline unsigned eval_lsb(const logged_adaptor<Backend>& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg)
eval_lsb	multiprecision/tommath.hpp	/^inline unsigned eval_lsb(const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
eval_lt	multiprecision/detail/number_compare.hpp	/^inline bool eval_lt(const B& a, const A& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const A& b)
eval_lt	multiprecision/detail/number_compare.hpp	/^inline bool eval_lt(const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const B& b)
eval_lt	multiprecision/gmp.hpp	/^inline typename enable_if<is_arithmetic<T>, bool>::type eval_lt(const gmp_int& a, const T& b)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& a, const T& b)
eval_modulus	multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o)
eval_modulus	multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b)
eval_modulus	multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, limb_type b)
eval_modulus	multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, signed_limb_type b)
eval_modulus	multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& b)
eval_modulus	multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, limb_type b)
eval_modulus	multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, signed_limb_type b)
eval_modulus	multiprecision/detail/default_ops.hpp	/^   eval_modulus(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_modulus	multiprecision/detail/default_ops.hpp	/^inline void eval_modulus(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_modulus	multiprecision/detail/default_ops.hpp	/^void eval_modulus(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_modulus	multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
eval_modulus	multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
eval_modulus	multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
eval_modulus	multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
eval_modulus	multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
eval_modulus	multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
eval_modulus	multiprecision/tommath.hpp	/^inline void eval_modulus(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
eval_modulus	multiprecision/tommath.hpp	/^inline void eval_modulus(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
eval_modulus_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_modulus_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_modulus_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_modulus_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_modulus_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_modulus_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_modulus_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_modulus_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_modulus_default	multiprecision/detail/default_ops.hpp	/^inline void eval_modulus_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_modulus_default	multiprecision/detail/default_ops.hpp	/^inline void eval_modulus_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_msb	multiprecision/cpp_int/misc.hpp	/^   eval_msb(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)
eval_msb	multiprecision/debug_adaptor.hpp	/^inline unsigned eval_msb(const debug_adaptor<Backend>& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(const debug_adaptor<Backend>& arg)
eval_msb	multiprecision/detail/default_ops.hpp	/^inline int eval_msb(const T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val)
eval_msb	multiprecision/logged_adaptor.hpp	/^inline unsigned eval_msb(const logged_adaptor<Backend>& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& arg)
eval_msb	multiprecision/tommath.hpp	/^inline unsigned eval_msb(const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
eval_multiply	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_multiply(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
eval_multiply	multiprecision/cpp_dec_float.hpp	/^inline void eval_multiply(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
eval_multiply	multiprecision/cpp_dec_float.hpp	/^inline void eval_multiply(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
eval_multiply	multiprecision/cpp_dec_float.hpp	/^inline void eval_multiply(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
eval_multiply	multiprecision/cpp_int/multiply.hpp	/^   eval_multiply($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> const& a, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> const& b)
eval_multiply	multiprecision/cpp_int/multiply.hpp	/^   eval_multiply($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, double_limb_type a, double_limb_type b)
eval_multiply	multiprecision/cpp_int/multiply.hpp	/^   eval_multiply($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, signed_double_limb_type a, signed_double_limb_type b)
eval_multiply	multiprecision/detail/default_ops.hpp	/^   eval_multiply(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_multiply	multiprecision/detail/default_ops.hpp	/^inline void eval_multiply(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_multiply	multiprecision/detail/default_ops.hpp	/^void eval_multiply(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_multiply	multiprecision/float128.hpp	/^inline void eval_multiply(float128_backend& result, const A& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const A& a)
eval_multiply	multiprecision/float128.hpp	/^inline void eval_multiply(float128_backend& result, const float128_backend& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a)
eval_multiply	multiprecision/float128.hpp	/^inline void eval_multiply(float128_backend& result, const float128_backend& a, const A& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const A& b)
eval_multiply	multiprecision/float128.hpp	/^inline void eval_multiply(float128_backend& result, const float128_backend& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const float128_backend& b)
eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
eval_multiply	multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)
eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)
eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)
eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)
eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)
eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)
eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, long i)
eval_multiply	multiprecision/mpfi.hpp	/^inline void eval_multiply(mpfi_float_backend<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, unsigned long i)
eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
eval_multiply	multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
eval_multiply	multiprecision/rational_adaptor.hpp	/^inline void eval_multiply(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)
eval_multiply	multiprecision/tommath.hpp	/^inline void eval_multiply(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
eval_multiply	multiprecision/tommath.hpp	/^inline void eval_multiply(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
eval_multiply	multiprecision/tommath.hpp	/^void eval_multiply(tommath_int& t, const tommath_int& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
eval_multiply_add	multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_multiply_add	multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
eval_multiply_add	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_multiply_add	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
eval_multiply_add	multiprecision/gmp.hpp	/^inline void eval_multiply_add(gmp_int& t, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, const gmp_int& b)
eval_multiply_add	multiprecision/gmp.hpp	/^inline void eval_multiply_add(gmp_int& t, const gmp_int& a, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, long i)
eval_multiply_add	multiprecision/gmp.hpp	/^inline void eval_multiply_add(gmp_int& t, const gmp_int& a, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, unsigned long i)
eval_multiply_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_multiply_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_multiply_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_multiply_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_multiply_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_multiply_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_multiply_default	multiprecision/detail/default_ops.hpp	/^inline void eval_multiply_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_multiply_default	multiprecision/detail/default_ops.hpp	/^inline void eval_multiply_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_multiply_subtract	multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_multiply_subtract	multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
eval_multiply_subtract	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_multiply_subtract	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
eval_multiply_subtract	multiprecision/gmp.hpp	/^inline void eval_multiply_subtract(gmp_int& t, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, const gmp_int& b)
eval_multiply_subtract	multiprecision/gmp.hpp	/^inline void eval_multiply_subtract(gmp_int& t, const gmp_int& a, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, long i)
eval_multiply_subtract	multiprecision/gmp.hpp	/^inline void eval_multiply_subtract(gmp_int& t, const gmp_int& a, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, unsigned long i)
eval_pow	multiprecision/detail/functions/pow.hpp	/^inline typename enable_if<is_arithmetic<A>, void>::type eval_pow(T& result, const A& x, const T& a)$/;"	f	signature:(T& result, const A& x, const T& a)
eval_pow	multiprecision/detail/functions/pow.hpp	/^inline typename enable_if<is_floating_point<A>, void>::type eval_pow(T& result, const T& x, const A& a)$/;"	f	signature:(T& result, const T& x, const A& a)
eval_pow	multiprecision/detail/functions/pow.hpp	/^inline typename enable_if<is_integral<U> >::type eval_pow(T& result, const T& t, const U& p)$/;"	f	signature:(T& result, const T& t, const U& p)
eval_pow	multiprecision/detail/functions/pow.hpp	/^inline void eval_pow(T& result, const T& x, const T& a)$/;"	f	signature:(T& result, const T& x, const T& a)
eval_pow	multiprecision/float128.hpp	/^inline void eval_pow(float128_backend& result, const float128_backend& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const float128_backend& b)
eval_pow	multiprecision/mpfi.hpp	/^inline void eval_pow(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& b, const mpfi_float_backend<Digits10>& e)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& b, const mpfi_float_backend<Digits10>& e)
eval_pow	multiprecision/mpfr.hpp	/^inline void eval_pow(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& b, const mpfr_float_backend<Digits10, AllocateType>& e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& b, const mpfr_float_backend<Digits10, AllocateType>& e)
eval_powm	multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_signed<Integer1> >::type eval_powm(Backend& result, const Backend& a, Integer1 b, Integer2 c)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(Backend& result, const Backend& a, Integer1 b, Integer2 c)
eval_powm	multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_signed<Integer> >::type eval_powm(Backend& result, const Backend& a, Integer b, const Backend& c)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(Backend& result, const Backend& a, Integer b, const Backend& c)
eval_powm	multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_unsigned<Integer1> >::type eval_powm(Backend& result, const Backend& a, Integer1 b, Integer2 c)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(Backend& result, const Backend& a, Integer1 b, Integer2 c)
eval_powm	multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_unsigned<Integer> >::type eval_powm(Backend& result, const Backend& a, Integer b, const Backend& c)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(Backend& result, const Backend& a, Integer b, const Backend& c)
eval_powm	multiprecision/detail/integer_ops.hpp	/^void eval_powm(Backend& result, const Backend& a, const Backend& p, Integer c)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(Backend& result, const Backend& a, const Backend& p, Integer c)
eval_powm	multiprecision/detail/integer_ops.hpp	/^void eval_powm(Backend& result, const Backend& a, const Backend& p, const Backend& c)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(Backend& result, const Backend& a, const Backend& p, const Backend& c)
eval_powm	multiprecision/tommath.hpp	/^inline void eval_powm(tommath_int& result, const tommath_int& base, const tommath_int& p, const tommath_int& m)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& base, const tommath_int& p, const tommath_int& m)
eval_qr	multiprecision/detail/integer_ops.hpp	/^inline void eval_qr(const Backend& x, const Backend& y, Backend& q, Backend& r)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const Backend& x, const Backend& y, Backend& q, Backend& r)
eval_qr	multiprecision/tommath.hpp	/^inline void eval_qr(const tommath_int& x, const tommath_int& y, $/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& x, const tommath_int& y, tommath_int& q, tommath_int& r)
eval_right_shift	multiprecision/debug_adaptor.hpp	/^inline void eval_right_shift(debug_adaptor<Backend>& arg, const debug_adaptor<Backend>& a, unsigned b)$/;"	f	namespace:boost::multiprecision::backends	signature:(debug_adaptor<Backend>& arg, const debug_adaptor<Backend>& a, unsigned b)
eval_right_shift	multiprecision/debug_adaptor.hpp	/^inline void eval_right_shift(debug_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(debug_adaptor<Backend>& arg, unsigned a)
eval_right_shift	multiprecision/detail/default_ops.hpp	/^inline void eval_right_shift(T& result, const T& arg, const V val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg, const V val)
eval_right_shift	multiprecision/gmp.hpp	/^inline void eval_right_shift(gmp_int& t, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, UI i)
eval_right_shift	multiprecision/gmp.hpp	/^inline void eval_right_shift(gmp_int& t, const gmp_int& v, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& v, UI i)
eval_right_shift	multiprecision/logged_adaptor.hpp	/^inline void eval_right_shift(logged_adaptor<Backend>& arg, const logged_adaptor<Backend>& a, unsigned b)$/;"	f	namespace:boost::multiprecision::backends	signature:(logged_adaptor<Backend>& arg, const logged_adaptor<Backend>& a, unsigned b)
eval_right_shift	multiprecision/logged_adaptor.hpp	/^inline void eval_right_shift(logged_adaptor<Backend>& arg, unsigned a)$/;"	f	namespace:boost::multiprecision::backends	signature:(logged_adaptor<Backend>& arg, unsigned a)
eval_right_shift	multiprecision/tommath.hpp	/^inline void eval_right_shift(tommath_int& t, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, UI i)
eval_right_shift	multiprecision/tommath.hpp	/^inline void eval_right_shift(tommath_int& t, const tommath_int& v, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& v, UI i)
eval_round	multiprecision/detail/default_ops.hpp	/^inline void eval_round(T& result, const T& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a)
eval_sin	multiprecision/detail/functions/trig.hpp	/^void eval_sin(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_sin	multiprecision/float128.hpp	/^inline void eval_sin(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_sin	multiprecision/mpfi.hpp	/^inline void eval_sin(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
eval_sinh	multiprecision/detail/functions/pow.hpp	/^inline void eval_sinh(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_sinh	multiprecision/float128.hpp	/^inline void eval_sinh(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_sinh	multiprecision/mpfi.hpp	/^inline void eval_sinh(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
eval_sqrt	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_sqrt(number_backend_float_architype& result, const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg)
eval_sqrt	multiprecision/cpp_dec_float.hpp	/^inline void eval_sqrt(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
eval_sqrt	multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_sqrt();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
eval_sqrt	multiprecision/float128.hpp	/^inline void eval_sqrt(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_sqrt	multiprecision/gmp.hpp	/^inline void eval_sqrt(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
eval_sqrt	multiprecision/mpfi.hpp	/^inline void eval_sqrt(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& val)
eval_sqrt	multiprecision/mpfr.hpp	/^inline void eval_sqrt(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
eval_subtract	multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_subtract(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
eval_subtract	multiprecision/cpp_dec_float.hpp	/^inline void eval_subtract(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
eval_subtract	multiprecision/cpp_dec_float.hpp	/^inline void eval_subtract(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
eval_subtract	multiprecision/cpp_dec_float.hpp	/^inline void eval_subtract(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
eval_subtract	multiprecision/detail/default_ops.hpp	/^   eval_subtract(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_subtract	multiprecision/detail/default_ops.hpp	/^inline void eval_subtract(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_subtract	multiprecision/detail/default_ops.hpp	/^void eval_subtract(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_subtract	multiprecision/float128.hpp	/^inline void eval_subtract(float128_backend& result, const A& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const A& a)
eval_subtract	multiprecision/float128.hpp	/^inline void eval_subtract(float128_backend& result, const A& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const A& a, const float128_backend& b)
eval_subtract	multiprecision/float128.hpp	/^inline void eval_subtract(float128_backend& result, const float128_backend& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a)
eval_subtract	multiprecision/float128.hpp	/^inline void eval_subtract(float128_backend& result, const float128_backend& a, const A& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const A& b)
eval_subtract	multiprecision/float128.hpp	/^inline void eval_subtract(float128_backend& result, const float128_backend& a, const float128_backend& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& a, const float128_backend& b)
eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
eval_subtract	multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, const mpfi_float_backend<D3>& y)
eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, long y)
eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, const mpfi_float_backend<D2>& x, unsigned long y)
eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, long x, const mpfi_float_backend<D2>& y)
eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& a, unsigned long x, const mpfi_float_backend<D2>& y)
eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<D1>& result, const mpfi_float_backend<D2>& o)
eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, long i)
eval_subtract	multiprecision/mpfi.hpp	/^inline void eval_subtract(mpfi_float_backend<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<digits10>& result, unsigned long i)
eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
eval_subtract	multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
eval_subtract	multiprecision/rational_adaptor.hpp	/^inline void eval_subtract(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adaptor<IntBackend>& result, const rational_adaptor<IntBackend>& o)
eval_subtract	multiprecision/tommath.hpp	/^inline void eval_subtract(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
eval_subtract	multiprecision/tommath.hpp	/^inline void eval_subtract(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
eval_subtract_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_subtract_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_subtract_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_subtract_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_subtract_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_signed_number<T>::value>::type eval_subtract_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_subtract_default	multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_unsigned_number<T>::value>::type eval_subtract_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_subtract_default	multiprecision/detail/default_ops.hpp	/^inline void eval_subtract_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_subtract_default	multiprecision/detail/default_ops.hpp	/^inline void eval_subtract_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_tan	multiprecision/detail/functions/trig.hpp	/^void eval_tan(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_tan	multiprecision/float128.hpp	/^inline void eval_tan(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_tan	multiprecision/mpfi.hpp	/^inline void eval_tan(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
eval_tanh	multiprecision/detail/functions/pow.hpp	/^inline void eval_tanh(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_tanh	multiprecision/float128.hpp	/^inline void eval_tanh(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_tanh	multiprecision/mpfi.hpp	/^inline void eval_tanh(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)$/;"	f	namespace:boost::multiprecision	signature:(mpfi_float_backend<Digits10>& result, const mpfi_float_backend<Digits10>& arg)
eval_trunc	multiprecision/cpp_dec_float.hpp	/^inline void eval_trunc(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
eval_trunc	multiprecision/detail/default_ops.hpp	/^inline void eval_trunc(T& result, const T& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a)
eval_trunc	multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_trunc();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
eval_trunc	multiprecision/float128.hpp	/^inline void eval_trunc(float128_backend& result, const float128_backend& arg)$/;"	f	namespace:boost::multiprecision::backends	signature:(float128_backend& result, const float128_backend& arg)
eval_trunc	multiprecision/gmp.hpp	/^inline void eval_trunc(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
eval_trunc	multiprecision/mpfr.hpp	/^inline void eval_trunc(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<0U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<10U> { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<11U> { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<12U> { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<13U> { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<14U> { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<15U> { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<16U> { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<17U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<18U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<19U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<1U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<20U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<21U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<22U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<23U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<24U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<25U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<26U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<27U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<28U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<29U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<2U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<30U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<31U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<32U> { typedef boost::uint32_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<33U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<34U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<35U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<36U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<37U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<38U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<39U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<3U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<40U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<41U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<42U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<43U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<44U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<45U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<46U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<47U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<48U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<49U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<4U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<50U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<51U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<52U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<53U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<54U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<55U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<56U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<57U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<58U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<59U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<5U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<60U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<61U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<62U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<63U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<64U> { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<6U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<7U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<8U> { typedef boost::uint8_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<9U>  { typedef boost::uint16_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exact	multiprecision/detail/utype_helper.hpp	/^  template<const unsigned> struct utype_helper { typedef boost::uint64_t exact; };$/;"	t	struct:boost::multiprecision::detail::utype_helper	access:public
exp	multiprecision/cpp_dec_float.hpp	/^   ExponentType    exp;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
exponent_type	multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef int                                  exponent_type;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
exponent_type	multiprecision/cpp_dec_float.hpp	/^   typedef ExponentType                   exponent_type;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
exponent_type	multiprecision/debug_adaptor.hpp	/^      Backend, number_category<Backend>::value>::type  exponent_type;$/;"	t	struct:boost::multiprecision::backends::debug_adaptor	access:public
exponent_type	multiprecision/float128.hpp	/^   typedef int                                                   exponent_type;$/;"	t	struct:boost::multiprecision::backends::float128_backend	access:public
exponent_type	multiprecision/gmp.hpp	/^   typedef long                                      exponent_type;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
exponent_type	multiprecision/logged_adaptor.hpp	/^      Backend, number_category<Backend>::value>::type  exponent_type;$/;"	t	struct:boost::multiprecision::backends::logged_adaptor	access:public
exponent_type	multiprecision/mpfi.hpp	/^   typedef long                                           exponent_type;$/;"	t	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public
exponent_type	multiprecision/mpfr.hpp	/^   typedef long                                           exponent_type;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
expq	multiprecision/float128.hpp	81;"	d
expression	multiprecision/detail/number_base.hpp	/^   explicit expression(const Arg1& a) : arg(a) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a)
expression	multiprecision/detail/number_base.hpp	/^   expression(const Arg1& a1, const Arg2& a2) : arg1(a1), arg2(a2) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a1, const Arg2& a2)
expression	multiprecision/detail/number_base.hpp	/^   expression(const Arg1& a1, const Arg2& a2, const Arg3& a3) : arg1(a1), arg2(a2), arg3(a3) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a1, const Arg2& a2, const Arg3& a3)
expression	multiprecision/detail/number_base.hpp	/^   expression(const Arg1& a1, const Arg2& a2, const Arg3& a3, const Arg4& a4) : arg1(a1), arg2(a2), arg3(a3), arg4(a4) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a1, const Arg2& a2, const Arg3& a3, const Arg4& a4)
expression	multiprecision/detail/number_base.hpp	/^struct expression$/;"	s	namespace:boost::multiprecision::detail
expression	multiprecision/detail/number_base.hpp	/^struct expression<tag, Arg1, Arg2, Arg3, void>$/;"	s	namespace:boost::multiprecision::detail
expression	multiprecision/detail/number_base.hpp	/^struct expression<tag, Arg1, Arg2, void, void>$/;"	s	namespace:boost::multiprecision::detail
expression	multiprecision/detail/number_base.hpp	/^struct expression<tag, Arg1, void, void, void>$/;"	s	namespace:boost::multiprecision::detail
expression	multiprecision/detail/number_base.hpp	/^struct expression<terminal, Arg1, void, void, void>$/;"	s	namespace:boost::multiprecision::detail
expression1_t	multiprecision/detail/ublas_interop.hpp	/^   typedef boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4> expression1_t;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
expression2_t	multiprecision/detail/ublas_interop.hpp	/^   typedef boost::multiprecision::detail::expression<tagb, Arg1b, Arg2b, Arg3b, Arg4b> expression2_t;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
expression_storage	multiprecision/detail/number_base.hpp	/^struct expression_storage$/;"	s	namespace:boost::multiprecision::detail
expression_storage	multiprecision/detail/number_base.hpp	/^struct expression_storage<T*>$/;"	s	namespace:boost::multiprecision::detail
expression_storage	multiprecision/detail/number_base.hpp	/^struct expression_storage<const T*>$/;"	s	namespace:boost::multiprecision::detail
expression_storage	multiprecision/detail/number_base.hpp	/^struct expression_storage<expression<tag, A1, A2, A3, A4> >$/;"	s	namespace:boost::multiprecision::detail
expression_template_default	multiprecision/cpp_int.hpp	/^struct expression_template_default<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, void> >$/;"	s
expression_template_default	multiprecision/detail/number_base.hpp	/^struct expression_template_default$/;"	s	namespace:boost::multiprecision
expression_template_default	multiprecision/rational_adaptor.hpp	/^struct expression_template_default<backends::rational_adaptor<IntBackend> > : public expression_template_default<IntBackend> {};$/;"	s	namespace:boost::multiprecision	inherits:expression_template_default
expression_template_default::value	multiprecision/cpp_int.hpp	/^   static const expression_template_option value = et_off;$/;"	m	struct:expression_template_default	access:public
expression_template_option	multiprecision/detail/number_base.hpp	/^enum expression_template_option$/;"	g	namespace:boost::multiprecision
expression_type	multiprecision/detail/ublas_interop.hpp	/^   typedef boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4> expression_type;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
extract_double	multiprecision/cpp_dec_float.hpp	/^   double             extract_double            (void) const;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
extract_double	multiprecision/cpp_dec_float.hpp	/^double cpp_dec_float<Digits10, ExponentType, Allocator>::extract_double(void) const$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
extract_exponent_type	multiprecision/traits/extract_exponent_type.hpp	/^struct extract_exponent_type$/;"	s	namespace:boost::multiprecision::backends
extract_exponent_type	multiprecision/traits/extract_exponent_type.hpp	/^struct extract_exponent_type<Backend, number_kind_floating_point>$/;"	s	namespace:boost::multiprecision::backends
extract_integer_part	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float      extract_integer_part      (void) const  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
extract_integer_part	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator> cpp_dec_float<Digits10, ExponentType, Allocator>::extract_integer_part(void) const  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
extract_long_double	multiprecision/cpp_dec_float.hpp	/^   long double        extract_long_double       (void) const;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
extract_long_double	multiprecision/cpp_dec_float.hpp	/^long double cpp_dec_float<Digits10, ExponentType, Allocator>::extract_long_double(void) const$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
extract_parts	multiprecision/cpp_dec_float.hpp	/^   void               extract_parts             (double& mantissa, ExponentType& exponent) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(double& mantissa, ExponentType& exponent) const
extract_parts	multiprecision/cpp_dec_float.hpp	/^void cpp_dec_float<Digits10, ExponentType, Allocator>::extract_parts(double& mantissa, ExponentType& exponent) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(double& mantissa, ExponentType& exponent) const
extract_signed_long_long	multiprecision/cpp_dec_float.hpp	/^   signed long long   extract_signed_long_long  (void) const  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
extract_signed_long_long	multiprecision/cpp_dec_float.hpp	/^signed long long cpp_dec_float<Digits10, ExponentType, Allocator>::extract_signed_long_long(void) const  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
extract_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^   unsigned long long extract_unsigned_long_long(void) const  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
extract_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^unsigned long long cpp_dec_float<Digits10, ExponentType, Allocator>::extract_unsigned_long_long(void) const  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
fabsq	multiprecision/float128.hpp	76;"	d
find_lsb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(Unsigned mask)$/;"	f	namespace:boost::multiprecision::detail	signature:(Unsigned mask)
find_lsb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(unsigned __int64 mask, const mpl::int_<2>&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned __int64 mask, const mpl::int_<2>&)
find_lsb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(unsigned long long mask, mpl::int_<3> const&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long long mask, mpl::int_<3> const&)
find_lsb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(unsigned long mask, const mpl::int_<1>&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long mask, const mpl::int_<1>&)
find_lsb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(unsigned long mask, mpl::int_<2> const&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long mask, mpl::int_<2> const&)
find_lsb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(unsigned mask, mpl::int_<1> const&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned mask, mpl::int_<1> const&)
find_lsb	multiprecision/detail/bitscan.hpp	/^inline unsigned find_lsb(Unsigned mask, const mpl::int_<0>&)$/;"	f	namespace:boost::multiprecision::detail	signature:(Unsigned mask, const mpl::int_<0>&)
find_msb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_msb(Unsigned mask)$/;"	f	namespace:boost::multiprecision::detail	signature:(Unsigned mask)
find_msb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_msb(Unsigned mask, const mpl::int_<2>&)$/;"	f	namespace:boost::multiprecision::detail	signature:(Unsigned mask, const mpl::int_<2>&)
find_msb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_msb(unsigned long long mask, mpl::int_<3> const&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long long mask, mpl::int_<3> const&)
find_msb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_msb(unsigned long mask, const mpl::int_<1>&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long mask, const mpl::int_<1>&)
find_msb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_msb(unsigned long mask, mpl::int_<2> const&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long mask, mpl::int_<2> const&)
find_msb	multiprecision/detail/bitscan.hpp	/^BOOST_FORCEINLINE unsigned find_msb(unsigned mask, mpl::int_<1> const&)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned mask, mpl::int_<1> const&)
find_msb	multiprecision/detail/bitscan.hpp	/^inline unsigned find_msb(Unsigned mask, const mpl::int_<0>&)$/;"	f	namespace:boost::multiprecision::detail	signature:(Unsigned mask, const mpl::int_<0>&)
first	multiprecision/cpp_int.hpp	/^      limb_type first;$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
float128	multiprecision/float128.hpp	/^typedef number<float128_backend, et_off> float128;$/;"	t	namespace:boost::multiprecision
float128_backend	multiprecision/float128.hpp	/^   BOOST_CONSTEXPR float128_backend() : m_value(0) {}$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:()
float128_backend	multiprecision/float128.hpp	/^   BOOST_CONSTEXPR float128_backend(const T& i, const typename enable_if_c<is_convertible<T, float128_type>::value>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(const T& i, const typename enable_if_c<is_convertible<T, float128_type>::value>::type* = 0)
float128_backend	multiprecision/float128.hpp	/^   BOOST_CONSTEXPR float128_backend(const float128_backend& o) : m_value(o.m_value) {}$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(const float128_backend& o)
float128_backend	multiprecision/float128.hpp	/^struct float128_backend$/;"	s	namespace:boost::multiprecision::backends
float128_detail	multiprecision/float128.hpp	/^namespace serialization{ namespace float128_detail{$/;"	n	namespace:boost::serialization
float128_type	multiprecision/float128.hpp	/^typedef _Quad float128_type;$/;"	t
float128_type	multiprecision/float128.hpp	/^typedef __float128 float128_type;$/;"	t
float_types	multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef mpl::list<long double>               float_types;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
float_types	multiprecision/cpp_dec_float.hpp	/^   typedef mpl::list<long double>         float_types;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
float_types	multiprecision/debug_adaptor.hpp	/^   typedef typename Backend::float_types               float_types;$/;"	t	struct:boost::multiprecision::backends::debug_adaptor	access:public
float_types	multiprecision/float128.hpp	/^   typedef mpl::list<float, double, long double>                 float_types;$/;"	t	struct:boost::multiprecision::backends::float128_backend	access:public
float_types	multiprecision/gmp.hpp	/^   typedef mpl::list<double, long double>                 float_types;$/;"	t	struct:boost::multiprecision::gmp_int	access:public
float_types	multiprecision/gmp.hpp	/^   typedef mpl::list<double, long double>            float_types;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
float_types	multiprecision/logged_adaptor.hpp	/^   typedef typename Backend::float_types               float_types;$/;"	t	struct:boost::multiprecision::backends::logged_adaptor	access:public
float_types	multiprecision/mpfi.hpp	/^   typedef mpl::list<double, long double>                 float_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public
float_types	multiprecision/mpfr.hpp	/^   typedef mpl::list<double, long double>                 float_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
float_types	multiprecision/rational_adaptor.hpp	/^   typedef typename IntBackend::float_types     float_types;$/;"	t	struct:boost::multiprecision::backends::rational_adaptor	access:public
float_types	multiprecision/tommath.hpp	/^   typedef mpl::list<long double>                           float_types;$/;"	t	struct:boost::multiprecision::backends::tommath_int	access:public
floorq	multiprecision/float128.hpp	77;"	d
fmodq	multiprecision/float128.hpp	94;"	d
force_instantiate	multiprecision/mpfi.hpp	/^      void force_instantiate()const{}$/;"	f	struct:math::constants::detail::mpfi_initializer::init	access:public	signature:() const
force_instantiate	multiprecision/mpfi.hpp	/^   static void force_instantiate()$/;"	f	struct:math::constants::detail::mpfi_initializer	access:public	signature:()
force_instantiate	multiprecision/mpfr.hpp	/^      void force_instantiate()const {}$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_cleanup::initializer	access:public	signature:() const
force_instantiate	multiprecision/mpfr.hpp	/^   static void force_instantiate() { init.force_instantiate(); }$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_cleanup	access:public	signature:()
format_float_string	multiprecision/detail/number_base.hpp	/^void format_float_string(S& str, boost::intmax_t my_exp, boost::intmax_t digits, std::ios_base::fmtflags f, bool iszero)$/;"	f	namespace:boost::multiprecision::detail	signature:(S& str, boost::intmax_t my_exp, boost::intmax_t digits, std::ios_base::fmtflags f, bool iszero)
fpclass	multiprecision/cpp_dec_float.hpp	/^   fpclass_type    fpclass;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
fpclass_type	multiprecision/cpp_dec_float.hpp	/^   fpclass_type;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	typeref:enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type	access:private
frexpq	multiprecision/float128.hpp	75;"	d
from_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^   void from_unsigned_long_long(const unsigned long long u) ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const unsigned long long u)
from_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^void cpp_dec_float<Digits10, ExponentType, Allocator>::from_unsigned_long_long(const unsigned long long u) $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const unsigned long long u)
function	multiprecision/detail/number_base.hpp	/^struct function{};$/;"	s	namespace:boost::multiprecision::detail
generate	multiprecision/random.hpp	/^    result_type generate(Engine& eng, boost::mpl::false_) const$/;"	f	class:boost::random::uniform_smallint	access:private	signature:(Engine& eng, boost::mpl::false_) const
generate	multiprecision/random.hpp	/^    result_type generate(Engine& eng, boost::mpl::true_) const$/;"	f	class:boost::random::uniform_smallint	access:private	signature:(Engine& eng, boost::mpl::true_) const
generate	multiprecision/random.hpp	/^    void generate(Iter first, Iter last)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(Iter first, Iter last)
generate_uniform_int	multiprecision/random.hpp	/^   generate_uniform_int($/;"	f	namespace:boost::random::detail	signature:( Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value, boost::mpl::true_ )
generate_uniform_int	multiprecision/random.hpp	/^   generate_uniform_int(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value)$/;"	f	namespace:boost::random::detail	signature:(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value)
generate_uniform_int	multiprecision/random.hpp	/^   generate_uniform_int(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value);$/;"	p	namespace:boost::random::detail	signature:(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value)
generic_interconvert	multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& \/*to_type*\/, const mpl::int_<number_kind_floating_point>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_floating_point>& )
generic_interconvert	multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& \/*to_type*\/, const mpl::int_<number_kind_integer>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_integer>& )
generic_interconvert	multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& \/*to_type*\/, const mpl::int_<number_kind_rational>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_rational>& )
generic_interconvert	multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_integer>& \/*to_type*\/, const mpl::int_<number_kind_integer>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_integer>& , const mpl::int_<number_kind_integer>& )
generic_interconvert	multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_rational>& \/*to_type*\/, const mpl::int_<number_kind_integer>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_rational>& , const mpl::int_<number_kind_integer>& )
generic_interconvert	multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_rational>& \/*to_type*\/, const mpl::int_<number_kind_rational>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_rational>& , const mpl::int_<number_kind_rational>& )
get	multiprecision/mpfi.hpp	/^   static inline result_type const& get(const mpl::int_<N>&)$/;"	f	struct:math::constants::detail::constant_catalan	access:public	signature:(const mpl::int_<N>&)
get	multiprecision/mpfi.hpp	/^   static inline result_type const& get(const mpl::int_<N>&)$/;"	f	struct:math::constants::detail::constant_euler	access:public	signature:(const mpl::int_<N>&)
get	multiprecision/mpfi.hpp	/^   static inline result_type const& get(const mpl::int_<N>&)$/;"	f	struct:math::constants::detail::constant_ln_two	access:public	signature:(const mpl::int_<N>&)
get	multiprecision/mpfi.hpp	/^   static inline result_type const& get(const mpl::int_<N>&)$/;"	f	struct:math::constants::detail::constant_pi	access:public	signature:(const mpl::int_<N>&)
get_constant_e	multiprecision/detail/functions/constants.hpp	/^const T& get_constant_e()$/;"	f	signature:()
get_constant_ln2	multiprecision/detail/functions/constants.hpp	/^const T& get_constant_ln2()$/;"	f	signature:()
get_constant_log10	multiprecision/detail/functions/pow.hpp	/^const T& get_constant_log10()$/;"	f	signature:()
get_constant_pi	multiprecision/detail/functions/constants.hpp	/^const T& get_constant_pi()$/;"	f	signature:()
get_default_precision	multiprecision/mpfr.hpp	/^inline long get_default_precision() { return 50; }$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
get_max	multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::false_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::false_&)
get_max	multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::false_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::true_&)
get_max	multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::true_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::false_&)
get_max	multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::true_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::true_&)
get_min	multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::false_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::false_&)
get_min	multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::false_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::true_&)
get_min	multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::true_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::false_&)
get_min	multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::true_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::true_&)
gmp_float	multiprecision/gmp.hpp	/^   explicit gmp_float(const gmp_float<D>& o, typename disable_if_c<D <= digits10>::type* = 0);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_float<D>& o, typename disable_if_c<D <= digits10>::type* = 0)
gmp_float	multiprecision/gmp.hpp	/^   gmp_float()$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:()
gmp_float	multiprecision/gmp.hpp	/^   gmp_float()$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:()
gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_float& o) : detail::gmp_float_imp<0>(o) {}$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float& o)
gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_float& o) : detail::gmp_float_imp<digits10>(o) {}$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_float& o)
gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_float& o, unsigned digits10)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float& o, unsigned digits10)
gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_float<D>& o)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float<D>& o)
gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_float<D>& o, typename enable_if_c<D <= digits10>::type* = 0);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_float<D>& o, typename enable_if_c<D <= digits10>::type* = 0)
gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_int& o);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_int& o)
gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_rational& o)
gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_rational& o)
gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const mpf_t val)$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const mpf_t val)
gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpf_t val)
gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const mpq_t val)$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const mpq_t val)
gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpq_t val)
gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const mpz_t val)$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const mpz_t val)
gmp_float	multiprecision/gmp.hpp	/^   gmp_float(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpz_t val)
gmp_float	multiprecision/gmp.hpp	/^inline gmp_float<0>::gmp_float(const gmp_int& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_int& o)
gmp_float	multiprecision/gmp.hpp	/^inline gmp_float<0>::gmp_float(const gmp_rational& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_rational& o)
gmp_float	multiprecision/gmp.hpp	/^struct gmp_float : public detail::gmp_float_imp<digits10>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::gmp_float_imp
gmp_float	multiprecision/gmp.hpp	/^struct gmp_float<0> : public detail::gmp_float_imp<0>$/;"	s	namespace:boost::multiprecision	inherits:detail::gmp_float_imp
gmp_float_imp	multiprecision/gmp.hpp	/^   gmp_float_imp(const gmp_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(const gmp_float_imp& o)
gmp_float_imp	multiprecision/gmp.hpp	/^struct gmp_float_imp$/;"	s	namespace:boost::multiprecision::backends::detail
gmp_int	multiprecision/gmp.hpp	/^   explicit gmp_int(const gmp_float<Digits10>& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_float<Digits10>& o)
gmp_int	multiprecision/gmp.hpp	/^   explicit gmp_int(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_rational& o)
gmp_int	multiprecision/gmp.hpp	/^   explicit gmp_int(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpf_t val)
gmp_int	multiprecision/gmp.hpp	/^   explicit gmp_int(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpq_t val)
gmp_int	multiprecision/gmp.hpp	/^   gmp_int()$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:()
gmp_int	multiprecision/gmp.hpp	/^   gmp_int(const gmp_int& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_int& o)
gmp_int	multiprecision/gmp.hpp	/^   gmp_int(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpz_t val)
gmp_int	multiprecision/gmp.hpp	/^inline gmp_int::gmp_int(const gmp_rational& o)$/;"	f	class:boost::gmp_int	signature:(const gmp_rational& o)
gmp_int	multiprecision/gmp.hpp	/^struct gmp_int$/;"	s	namespace:boost::multiprecision
half	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& half()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
has_denorm	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR std::float_denorm_style has_denorm        = std::denorm_absent;$/;"	m	class:std::numeric_limits	access:public
has_denorm	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST float_denorm_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_denorm;$/;"	m	class:std::numeric_limits
has_denorm	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR float_denorm_style has_denorm = denorm_absent;$/;"	m	class:std::numeric_limits	access:public
has_denorm	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST float_denorm_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_denorm;$/;"	m	class:std::numeric_limits
has_denorm	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR float_denorm_style has_denorm = denorm_absent;$/;"	m	class:std::numeric_limits	access:public
has_denorm	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR float_denorm_style has_denorm = denorm_absent;$/;"	m	class:std::numeric_limits	access:public
has_denorm	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST float_denorm_style numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_denorm;$/;"	m	class:std::numeric_limits
has_denorm_loss	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_denorm_loss   = false;$/;"	m	class:std::numeric_limits	access:public
has_denorm_loss	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_denorm_loss;$/;"	m	class:std::numeric_limits
has_denorm_loss	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_denorm_loss = false;$/;"	m	class:std::numeric_limits	access:public
has_denorm_loss	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_denorm_loss;$/;"	m	class:std::numeric_limits
has_denorm_loss	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_denorm_loss = false;$/;"	m	class:std::numeric_limits	access:public
has_denorm_loss	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_denorm_loss = false;$/;"	m	class:std::numeric_limits	access:public
has_denorm_loss	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_denorm_loss;$/;"	m	class:std::numeric_limits
has_enough_bits	multiprecision/detail/default_ops.hpp	/^struct has_enough_bits$/;"	s	namespace:boost::multiprecision::default_ops
has_enough_bits	multiprecision/detail/number_base.hpp	/^struct has_enough_bits$/;"	s	namespace:boost::multiprecision::detail
has_generic_interconversion	multiprecision/traits/explicit_conversion.hpp	/^struct has_generic_interconversion$/;"	s	namespace:boost::multiprecision::detail
has_infinity	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_infinity      = true;$/;"	m	class:std::numeric_limits	access:public
has_infinity	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_infinity;$/;"	m	class:std::numeric_limits
has_infinity	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_infinity = false;$/;"	m	class:std::numeric_limits	access:public
has_infinity	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_infinity;$/;"	m	class:std::numeric_limits
has_infinity	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_infinity = true;$/;"	m	class:std::numeric_limits	access:public
has_infinity	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_infinity = false;$/;"	m	class:std::numeric_limits	access:public
has_infinity	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_infinity;$/;"	m	class:std::numeric_limits
has_quiet_NaN	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_quiet_NaN     = true;$/;"	m	class:std::numeric_limits	access:public
has_quiet_NaN	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_quiet_NaN;$/;"	m	class:std::numeric_limits
has_quiet_NaN	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_quiet_NaN = false;$/;"	m	class:std::numeric_limits	access:public
has_quiet_NaN	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_quiet_NaN;$/;"	m	class:std::numeric_limits
has_quiet_NaN	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_quiet_NaN = true;$/;"	m	class:std::numeric_limits	access:public
has_quiet_NaN	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_quiet_NaN = false;$/;"	m	class:std::numeric_limits	access:public
has_quiet_NaN	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_quiet_NaN;$/;"	m	class:std::numeric_limits
has_signaling_NaN	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_signaling_NaN = false;$/;"	m	class:std::numeric_limits	access:public
has_signaling_NaN	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_signaling_NaN;$/;"	m	class:std::numeric_limits
has_signaling_NaN	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_signaling_NaN = false;$/;"	m	class:std::numeric_limits	access:public
has_signaling_NaN	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_signaling_NaN;$/;"	m	class:std::numeric_limits
has_signaling_NaN	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_signaling_NaN = false;$/;"	m	class:std::numeric_limits	access:public
has_signaling_NaN	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_signaling_NaN = false;$/;"	m	class:std::numeric_limits	access:public
has_signaling_NaN	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_signaling_NaN;$/;"	m	class:std::numeric_limits
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'0'> { static constexpr limb_type value = 0; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'1'> { static constexpr limb_type value = 1; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'2'> { static constexpr limb_type value = 2; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'3'> { static constexpr limb_type value = 3; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'4'> { static constexpr limb_type value = 4; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'5'> { static constexpr limb_type value = 5; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'6'> { static constexpr limb_type value = 6; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'7'> { static constexpr limb_type value = 7; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'8'> { static constexpr limb_type value = 8; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'9'> { static constexpr limb_type value = 9; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'A'> { static constexpr limb_type value = 10; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'B'> { static constexpr limb_type value = 11; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'C'> { static constexpr limb_type value = 12; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'D'> { static constexpr limb_type value = 13; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'E'> { static constexpr limb_type value = 14; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'F'> { static constexpr limb_type value = 15; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'a'> { static constexpr limb_type value = 10; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'b'> { static constexpr limb_type value = 11; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'c'> { static constexpr limb_type value = 12; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'d'> { static constexpr limb_type value = 13; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'e'> { static constexpr limb_type value = 14; };$/;"	s	namespace:boost::multiprecision::literals::detail
hex_value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'f'> { static constexpr limb_type value = 15; };$/;"	s	namespace:boost::multiprecision::literals::detail
hull	multiprecision/mpfi.hpp	/^inline number<mpfi_float_backend<Digits10>, ExpressionTemplates> hull(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  b)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& b)
hyp0F0	multiprecision/detail/functions/pow.hpp	/^void hyp0F0(T& H0F0, const T& x)$/;"	f	signature:(T& H0F0, const T& x)
hyp0F1	multiprecision/detail/functions/trig.hpp	/^void hyp0F1(T& result, const T& b, const T& x)$/;"	f	signature:(T& result, const T& b, const T& x)
hyp1F0	multiprecision/detail/functions/pow.hpp	/^void hyp1F0(T& H1F0, const T& a, const T& x)$/;"	f	signature:(T& H1F0, const T& a, const T& x)
hyp2F1	multiprecision/detail/functions/trig.hpp	/^void hyp2F1(T& result, const T& a, const T& b, const T& c, const T& x)$/;"	f	signature:(T& result, const T& a, const T& b, const T& c, const T& x)
if_c	multiprecision/integer.hpp	/^   typedef typename mpl::if_c<$/;"	t	class:boost::multiprecision::detail::double_integer::mpl	access:public
in	multiprecision/mpfi.hpp	/^inline bool in(const number<mpfr_float_backend<Digits10>, ExpressionTemplates1>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates2>&  b)$/;"	f	namespace:boost	signature:(const number<mpfr_float_backend<Digits10>, ExpressionTemplates1>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates2>& b)
independent_bits_engine	multiprecision/random.hpp	/^    independent_bits_engine() { }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
independent_bits_engine	multiprecision/random.hpp	/^    independent_bits_engine(It& first, It last) : _base(first, last) { }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(It& first, It last)
independent_bits_engine	multiprecision/random.hpp	/^    independent_bits_engine(const base_type& base_arg) : _base(base_arg) {}$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(const base_type& base_arg)
independent_bits_engine	multiprecision/random.hpp	/^class independent_bits_engine<Engine, w, boost::multiprecision::number<Backend, ExpressionTemplates> >$/;"	c	namespace:boost::random
inf	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& inf()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
infinity	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> infinity     (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::inf(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
infinity	multiprecision/cpp_int/limits.hpp	/^   static number_type infinity() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
infinity	multiprecision/float128.hpp	/^   static number_type infinity() { return 1.0q \/ 0.0q; }$/;"	f	class:std::numeric_limits	access:public	signature:()
infinity	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type infinity() { return base_type::infinity(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
infinity	multiprecision/tommath.hpp	/^   static number_type infinity() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
init	multiprecision/cpp_dec_float.hpp	/^      static initializer init;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
init	multiprecision/cpp_dec_float.hpp	/^typename cpp_dec_float<Digits10, ExponentType, Allocator>::initializer cpp_dec_float<Digits10, ExponentType, Allocator>::init;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
init	multiprecision/cpp_int/limits.hpp	/^   static const inititializer init;$/;"	m	class:std::numeric_limits	access:private
init	multiprecision/cpp_int/limits.hpp	/^const typename numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::inititializer numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::init;$/;"	m	class:std::numeric_limits
init	multiprecision/detail/functions/constants.hpp	/^   static const initializer init;$/;"	m	struct:constant_initializer	access:private
init	multiprecision/detail/functions/constants.hpp	/^typename constant_initializer<T, F>::initializer const constant_initializer<T, F>::init;$/;"	m	class:constant_initializer::constant_initializer
init	multiprecision/mpfi.hpp	/^      init()$/;"	f	struct:math::constants::detail::mpfi_initializer::init	access:public	signature:()
init	multiprecision/mpfi.hpp	/^   struct init$/;"	s	struct:math::constants::detail::mpfi_initializer	access:public
init	multiprecision/mpfr.hpp	/^   static const initializer init;$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_cleanup	access:public
init	multiprecision/mpfr.hpp	/^typename mpfr_cleanup<b>::initializer const mpfr_cleanup<b>::init;$/;"	m	class:boost::multiprecision::backends::detail::mpfr_cleanup::mpfr_cleanup
initializer	multiprecision/cpp_dec_float.hpp	/^         initializer()$/;"	f	struct:boost::multiprecision::backends::cpp_dec_float::initializer	access:public	signature:()
initializer	multiprecision/cpp_dec_float.hpp	/^      struct initializer$/;"	s	class:boost::multiprecision::backends::cpp_dec_float	access:private
initializer	multiprecision/detail/functions/constants.hpp	/^      initializer()$/;"	f	struct:constant_initializer::initializer	access:public	signature:()
initializer	multiprecision/detail/functions/constants.hpp	/^   struct initializer$/;"	s	struct:constant_initializer	access:private
initializer	multiprecision/mpfi.hpp	/^   static const init initializer;$/;"	m	struct:math::constants::detail::mpfi_initializer	access:public
initializer	multiprecision/mpfi.hpp	/^const typename mpfi_initializer<T>::init mpfi_initializer<T>::initializer;$/;"	m	class:math::constants::detail::mpfi_initializer
initializer	multiprecision/mpfr.hpp	/^      initializer() {}$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_cleanup::initializer	access:public	signature:()
initializer	multiprecision/mpfr.hpp	/^   struct initializer$/;"	s	struct:boost::multiprecision::backends::detail::mpfr_cleanup	access:public
inititializer	multiprecision/cpp_int/limits.hpp	/^      inititializer()$/;"	f	struct:std::numeric_limits::inititializer	access:public	signature:()
inititializer	multiprecision/cpp_int/limits.hpp	/^   struct inititializer$/;"	s	class:std::numeric_limits	access:private
input_type	multiprecision/random.hpp	/^    typedef boost::multiprecision::number<Backend, ExpressionTemplates> input_type;$/;"	t	class:boost::random::uniform_smallint	access:public
int1024_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<1024, 1024, signed_magnitude, unchecked, void> >  int1024_t;$/;"	t
int128_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<128, 128, signed_magnitude, unchecked, void> >    int128_t;$/;"	t
int256_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<256, 256, signed_magnitude, unchecked, void> >    int256_t;$/;"	t
int512_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<512, 512, signed_magnitude, unchecked, void> >    int512_t;$/;"	t
int_t_digits	multiprecision/integer.hpp	/^   static const unsigned int_t_digits =$/;"	m	struct:boost::multiprecision::detail::double_integer	access:public
integer_gcd_reduce	multiprecision/cpp_int/misc.hpp	/^inline double_limb_type integer_gcd_reduce(double_limb_type u, double_limb_type v)$/;"	f	namespace:boost::multiprecision::backends	signature:(double_limb_type u, double_limb_type v)
integer_gcd_reduce	multiprecision/cpp_int/misc.hpp	/^inline limb_type integer_gcd_reduce(limb_type u, limb_type v)$/;"	f	namespace:boost::multiprecision::backends	signature:(limb_type u, limb_type v)
integer_modulus	multiprecision/detail/integer_ops.hpp	/^   integer_modulus(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, Integer val)$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, Integer val)
integer_modulus	multiprecision/detail/integer_ops.hpp	/^   integer_modulus(const number<Backend, ExpressionTemplates>& x, Integer val)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, Integer val)
integer_modulus	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<I1>::value && is_integral<I2>::value, I2>::type integer_modulus(const I1& x, I2 val)$/;"	f	namespace:boost::multiprecision	signature:(const I1& x, I2 val)
integer_traits	multiprecision/cpp_int/cpp_int_config.hpp	/^class integer_traits<multiprecision::double_limb_type>$/;"	c	namespace:boost	inherits:std::numeric_limits,detail::integer_traits_base
integer_traits	multiprecision/cpp_int/cpp_int_config.hpp	/^class integer_traits<multiprecision::signed_double_limb_type>$/;"	c	namespace:boost	inherits:std::numeric_limits,detail::integer_traits_base
integer_type	multiprecision/rational_adaptor.hpp	/^   typedef number<IntBackend>                integer_type;$/;"	t	struct:boost::multiprecision::backends::rational_adaptor	access:public
internal_limb_count	multiprecision/cpp_int.hpp	/^const unsigned cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::internal_limb_count;$/;"	m	class:boost::multiprecision::cpp_int_base
intersect	multiprecision/mpfi.hpp	/^inline number<mpfi_float_backend<Digits10>, ExpressionTemplates> intersect(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  b)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& b)
interval_error	multiprecision/mpfi.hpp	/^   interval_error(const std::string& s) : std::runtime_error(s) {}$/;"	f	struct:boost::multiprecision::interval_error	access:public	signature:(const std::string& s)
interval_error	multiprecision/mpfi.hpp	/^struct interval_error : public std::runtime_error$/;"	s	namespace:boost::multiprecision	inherits:std::runtime_error
iround	multiprecision/detail/default_ops.hpp	/^inline int iround(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
iround	multiprecision/detail/default_ops.hpp	/^inline int iround(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
iround	multiprecision/detail/default_ops.hpp	/^inline int iround(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
iround	multiprecision/detail/default_ops.hpp	/^inline int iround(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
is_binary_archive	multiprecision/cpp_int/serialize.hpp	/^struct is_binary_archive : public mpl::false_ {};$/;"	s	namespace:boost::serialization::cpp_int_detail	inherits:mpl::false_
is_binary_archive	multiprecision/cpp_int/serialize.hpp	/^struct is_binary_archive<boost::archive::binary_iarchive> : public mpl::true_ {};$/;"	s	namespace:boost::serialization::cpp_int_detail	inherits:mpl::true_
is_binary_archive	multiprecision/cpp_int/serialize.hpp	/^struct is_binary_archive<boost::archive::binary_oarchive> : public mpl::true_ {};$/;"	s	namespace:boost::serialization::cpp_int_detail	inherits:mpl::true_
is_bounded	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_bounded        = true;$/;"	m	class:std::numeric_limits	access:public
is_bounded	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_bounded;$/;"	m	class:std::numeric_limits
is_bounded	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_bounded = boost::multiprecision::backends::is_fixed_precision<backend_type>::value;$/;"	m	class:std::numeric_limits	access:public
is_bounded	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_bounded;$/;"	m	class:std::numeric_limits
is_bounded	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_bounded = false;$/;"	m	class:std::numeric_limits	access:public
is_bounded	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_bounded = false;$/;"	m	class:std::numeric_limits	access:public
is_bounded	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_bounded;$/;"	m	class:std::numeric_limits
is_compatible_arithmetic_type	multiprecision/detail/number_base.hpp	/^struct is_compatible_arithmetic_type$/;"	s	namespace:boost::multiprecision	inherits:mpl::bool_
is_exact	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_exact          = false;$/;"	m	class:std::numeric_limits	access:public
is_exact	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_exact;$/;"	m	class:std::numeric_limits
is_exact	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_exact = true;$/;"	m	class:std::numeric_limits	access:public
is_exact	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_exact;$/;"	m	class:std::numeric_limits
is_exact	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_exact = false;$/;"	m	class:std::numeric_limits	access:public
is_exact	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_exact = true;$/;"	m	class:std::numeric_limits	access:public
is_exact	multiprecision/rational_adaptor.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::rational_adaptor<IntBackend>, ExpressionTemplates> >::is_exact;$/;"	m	class:std::numeric_limits
is_exact	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_exact = true;$/;"	m	class:std::numeric_limits	access:public
is_exact	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_exact;$/;"	m	class:std::numeric_limits
is_explicitly_convertible	multiprecision/cpp_dec_float.hpp	/^struct is_explicitly_convertible<cpp_dec_float<D1, E1, A1>, cpp_dec_float<D2, E2, A2> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::true_
is_explicitly_convertible	multiprecision/cpp_int.hpp	/^struct is_explicitly_convertible<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> > : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
is_explicitly_convertible	multiprecision/gmp.hpp	/^struct is_explicitly_convertible<canonical<mpf_t, gmp_int>::type, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
is_explicitly_convertible	multiprecision/gmp.hpp	/^struct is_explicitly_convertible<canonical<mpq_t, gmp_int>::type, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
is_explicitly_convertible	multiprecision/gmp.hpp	/^struct is_explicitly_convertible<gmp_float<D1>, gmp_float<D2> > : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
is_explicitly_convertible	multiprecision/gmp.hpp	/^struct is_explicitly_convertible<gmp_float<Digits10>, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
is_explicitly_convertible	multiprecision/gmp.hpp	/^struct is_explicitly_convertible<gmp_rational, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
is_explicitly_convertible	multiprecision/mpfi.hpp	/^struct is_explicitly_convertible<backends::mpfi_float_backend<D1>, backends::mpfi_float_backend<D2> > : public mpl::true_ {};$/;"	s	namespace:boost::detail	inherits:mpl::true_
is_explicitly_convertible	multiprecision/rational_adaptor.hpp	/^struct is_explicitly_convertible<U, rational_adaptor<IntBackend> > : public is_explicitly_convertible<U, IntBackend> {};$/;"	s	namespace:boost::multiprecision::detail	inherits:is_explicitly_convertible
is_explicitly_convertible	multiprecision/traits/explicit_conversion.hpp	/^struct is_explicitly_convertible : public is_explicitly_convertible_imp<From, To>::type$/;"	s	namespace:boost::multiprecision::detail	inherits:is_explicitly_convertible_imp::type
is_explicitly_convertible_imp	multiprecision/traits/explicit_conversion.hpp	/^struct is_explicitly_convertible_imp$/;"	s	namespace:boost::multiprecision::detail
is_fixed_precision	multiprecision/cpp_int.hpp	/^struct is_fixed_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends	inherits:mpl::bool_
is_iec559	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_iec559         = false;$/;"	m	class:std::numeric_limits	access:public
is_iec559	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_iec559;$/;"	m	class:std::numeric_limits
is_iec559	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_iec559 = false;$/;"	m	class:std::numeric_limits	access:public
is_iec559	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_iec559;$/;"	m	class:std::numeric_limits
is_iec559	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_iec559 = true;$/;"	m	class:std::numeric_limits	access:public
is_iec559	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_iec559 = false;$/;"	m	class:std::numeric_limits	access:public
is_iec559	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_iec559;$/;"	m	class:std::numeric_limits
is_implicit_cpp_int_conversion	multiprecision/cpp_int.hpp	/^struct is_implicit_cpp_int_conversion<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >$/;"	s	namespace:boost::multiprecision::backends
is_integer	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_integer        = false;$/;"	m	class:std::numeric_limits	access:public
is_integer	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_integer;$/;"	m	class:std::numeric_limits
is_integer	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_integer = true;$/;"	m	class:std::numeric_limits	access:public
is_integer	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_integer;$/;"	m	class:std::numeric_limits
is_integer	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_integer = false;$/;"	m	class:std::numeric_limits	access:public
is_integer	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_integer = false;$/;"	m	class:std::numeric_limits	access:public
is_integer	multiprecision/rational_adaptor.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::rational_adaptor<IntBackend>, ExpressionTemplates> >::is_integer;$/;"	m	class:std::numeric_limits
is_integer	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_integer = true;$/;"	m	class:std::numeric_limits	access:public
is_integer	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_integer;$/;"	m	class:std::numeric_limits
is_interval_number	multiprecision/detail/number_base.hpp	/^struct is_interval_number : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::false_
is_interval_number	multiprecision/detail/number_base.hpp	/^struct is_interval_number<number<Backend, ExpressionTemplates> > : public is_interval_number<Backend>{};$/;"	s	namespace:boost::multiprecision	inherits:is_interval_number
is_interval_number	multiprecision/mpfi.hpp	/^struct is_interval_number<backends::mpfi_float_backend<Digits10> > : public mpl::true_ {};$/;"	s	namespace:boost	inherits:mpl::true_
is_lossy_conversion	multiprecision/traits/is_restricted_conversion.hpp	/^struct is_lossy_conversion$/;"	s	namespace:boost::multiprecision::detail
is_modulo	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_modulo         = false;$/;"	m	class:std::numeric_limits	access:public
is_modulo	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_modulo;$/;"	m	class:std::numeric_limits
is_modulo	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_modulo = (boost::multiprecision::backends::is_fixed_precision<backend_type>::value && (Checked == boost::multiprecision::unchecked));$/;"	m	class:std::numeric_limits	access:public
is_modulo	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_modulo;$/;"	m	class:std::numeric_limits
is_modulo	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_modulo = false;$/;"	m	class:std::numeric_limits	access:public
is_modulo	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_modulo = false;$/;"	m	class:std::numeric_limits	access:public
is_modulo	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_modulo;$/;"	m	class:std::numeric_limits
is_non_throwing_cpp_int	multiprecision/cpp_int.hpp	/^struct is_non_throwing_cpp_int : public mpl::false_{};$/;"	s	namespace:boost::multiprecision::backends	inherits:mpl::false_
is_non_throwing_cpp_int	multiprecision/cpp_int.hpp	/^struct is_non_throwing_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, unchecked, void> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision::backends	inherits:mpl::true_
is_number	multiprecision/detail/number_base.hpp	/^struct is_number : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::false_
is_number	multiprecision/detail/number_base.hpp	/^struct is_number<number<Backend, ExpressionTemplates> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::true_
is_number_expression	multiprecision/detail/number_base.hpp	/^struct is_number_expression : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::false_
is_number_expression	multiprecision/detail/number_base.hpp	/^struct is_number_expression<detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::true_
is_restricted_conversion	multiprecision/traits/is_restricted_conversion.hpp	/^struct is_restricted_conversion$/;"	s	namespace:boost::multiprecision::detail
is_signed	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_signed         = true;$/;"	m	class:std::numeric_limits	access:public
is_signed	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_signed;$/;"	m	class:std::numeric_limits
is_signed	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_signed = boost::multiprecision::is_signed_number<backend_type>::value;$/;"	m	class:std::numeric_limits	access:public
is_signed	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_signed;$/;"	m	class:std::numeric_limits
is_signed	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_signed = true;$/;"	m	class:std::numeric_limits	access:public
is_signed	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_signed = true;$/;"	m	class:std::numeric_limits	access:public
is_signed	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_signed;$/;"	m	class:std::numeric_limits
is_signed_number	multiprecision/detail/number_base.hpp	/^struct is_signed_number : public mpl::bool_<!is_unsigned_number<T>::value> {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::bool_
is_small_prime	multiprecision/miller_rabin.hpp	/^inline bool is_small_prime(unsigned n)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned n)
is_specialized	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_specialized    = true;$/;"	m	class:std::numeric_limits	access:public
is_specialized	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_specialized = true;$/;"	m	class:std::numeric_limits	access:public
is_specialized	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_specialized = true;$/;"	m	class:std::numeric_limits	access:public
is_specialized	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_specialized = true;$/;"	m	class:std::numeric_limits	access:public
is_trivial_cpp_int	multiprecision/cpp_int.hpp	/^struct is_trivial_cpp_int$/;"	s	namespace:boost::multiprecision::backends
is_trivial_cpp_int	multiprecision/cpp_int.hpp	/^struct is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends
is_trivial_cpp_int	multiprecision/cpp_int.hpp	/^struct is_trivial_cpp_int<cpp_int_base<MinBits, MaxBits, SignType, Checked, Allocator, true> >$/;"	s	namespace:boost::multiprecision::backends
is_unsigned_number	multiprecision/cpp_int.hpp	/^struct is_unsigned_number<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision	inherits:mpl::bool_
is_unsigned_number	multiprecision/detail/number_base.hpp	/^struct is_unsigned_number : public mpl::false_{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::false_
is_unsigned_number	multiprecision/detail/number_base.hpp	/^struct is_unsigned_number<number<Backend, ExpressionTemplates> > : public is_unsigned_number<Backend> {};$/;"	s	namespace:boost::multiprecision	inherits:is_unsigned_number
is_valid_bitwise_op	multiprecision/cpp_int/bitwise.hpp	/^void is_valid_bitwise_op($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::int_<checked>&)
is_valid_bitwise_op	multiprecision/cpp_int/bitwise.hpp	/^void is_valid_bitwise_op($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>&, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& , const mpl::int_<unchecked>&)
is_valid_mixed_compare	multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::false_
is_valid_mixed_compare	multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, ET> > $/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::bool_
is_valid_mixed_compare	multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<number<B, ET>, Val> : public is_convertible<Val, number<B, ET> > {};$/;"	s	namespace:boost::multiprecision::detail	inherits:is_convertible
is_valid_mixed_compare	multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<number<B, ET>, expression<tag, Arg1, Arg2, Arg3, Arg4> > $/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::bool_
is_valid_mixed_compare	multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<number<B, ET>, number<B, ET> > : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::false_
is_value_pack	multiprecision/cpp_int/value_pack.hpp	/^struct is_value_pack<value_pack<VALUES...> >{ static constexpr bool value = true; };$/;"	s	namespace:boost::multiprecision::literals::detail
is_value_pack	multiprecision/cpp_int/value_pack.hpp	/^struct is_value_pack{ static constexpr bool value = false; };$/;"	s	namespace:boost::multiprecision::literals::detail
isinfq	multiprecision/float128.hpp	/^inline _Quad isinfq(_Quad v)$/;"	f	signature:(_Quad v)
isint	multiprecision/cpp_dec_float.hpp	/^   bool isint  (void) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
isint	multiprecision/cpp_dec_float.hpp	/^bool cpp_dec_float<Digits10, ExponentType, Allocator>::isint() const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:() const
isnanq	multiprecision/float128.hpp	/^inline _Quad isnanq(_Quad v)$/;"	f	signature:(_Quad v)
isneg	multiprecision/cpp_dec_float.hpp	/^   bool isneg  (void) const  { return neg; }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
isone	multiprecision/cpp_dec_float.hpp	/^   bool isone  (void) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
isone	multiprecision/cpp_dec_float.hpp	/^bool cpp_dec_float<Digits10, ExponentType, Allocator>::isone() const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:() const
iszero	multiprecision/cpp_dec_float.hpp	/^   bool iszero (void) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
iter_type	multiprecision/detail/default_ops.hpp	/^   >::type iter_type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
iter_type	multiprecision/detail/number_base.hpp	/^   >::type iter_type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
itrunc	multiprecision/detail/default_ops.hpp	/^inline int itrunc(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
itrunc	multiprecision/detail/default_ops.hpp	/^inline int itrunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
itrunc	multiprecision/detail/default_ops.hpp	/^inline int itrunc(const number<Backend, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& v)
itrunc	multiprecision/detail/default_ops.hpp	/^inline int itrunc(const number<Backend, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& v, const Policy& pol)
la	multiprecision/cpp_int.hpp	/^      limb_type la[internal_limb_count];$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
lanczos	multiprecision/detail/big_lanczos.hpp	/^namespace lanczos{$/;"	n	namespace:boost::math
lanczos	multiprecision/detail/big_lanczos.hpp	/^struct lanczos<multiprecision::number<Backend, ExpressionTemplates>, Policy>$/;"	s	namespace:boost::math::lanczos
largest_signed_type	multiprecision/cpp_int/cpp_int_config.hpp	/^struct largest_signed_type$/;"	s	namespace:boost::multiprecision::detail
largest_unsigned_type	multiprecision/cpp_int/cpp_int_config.hpp	/^struct largest_unsigned_type$/;"	s	namespace:boost::multiprecision::detail
ld	multiprecision/cpp_int.hpp	/^      limb_data ld;$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
ldexpq	multiprecision/float128.hpp	74;"	d
lead_values	multiprecision/cpp_int/literals.hpp	/^   typedef typename reverse_value_pack<value_pack<VALUES...> >::type lead_values;$/;"	t	struct:boost::multiprecision::literals::detail::reverse_value_pack	access:public
left	multiprecision/detail/number_base.hpp	/^   left_type left()const { return left_type(arg); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
left	multiprecision/detail/number_base.hpp	/^   left_type left()const { return left_type(arg1); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
left_depth	multiprecision/detail/number_base.hpp	/^   static const unsigned left_depth = left_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
left_max_depth	multiprecision/detail/number_base.hpp	/^   static const unsigned left_max_depth = left_depth > left_middle_depth ? left_depth : left_middle_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
left_middle	multiprecision/detail/number_base.hpp	/^   left_middle_type left_middle()const { return left_middle_type(arg2); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
left_middle_depth	multiprecision/detail/number_base.hpp	/^   static const unsigned left_middle_depth = left_middle_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
left_middle_result_type	multiprecision/detail/number_base.hpp	/^   typedef typename left_middle_type::result_type left_middle_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
left_middle_type	multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg2>::type left_middle_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
left_result_type	multiprecision/detail/number_base.hpp	/^   typedef typename left_type::result_type left_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
left_type	multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg1>::type left_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
limb_bits	multiprecision/cpp_int.hpp	/^const unsigned cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::limb_bits;$/;"	m	class:boost::multiprecision::cpp_int_base
limb_count	multiprecision/mpfr.hpp	/^   static const unsigned limb_count = mpfr_custom_get_size(digits2) \/ sizeof(mp_limb_t);$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
limb_data	multiprecision/cpp_int.hpp	/^   struct limb_data$/;"	s	struct:boost::multiprecision::backends::cpp_int_base	access:private
limb_pointer	multiprecision/cpp_int.hpp	/^   typedef limb_type*                      limb_pointer;$/;"	t	struct:boost::multiprecision::cpp_int_base	access:public
limb_pointer	multiprecision/cpp_int.hpp	/^   typedef typename allocator_type::pointer                      limb_pointer;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
limb_type	multiprecision/cpp_int/cpp_int_config.hpp	/^typedef detail::largest_unsigned_type<64>::type limb_type;$/;"	t	namespace:boost::multiprecision
list_type	multiprecision/detail/default_ops.hpp	/^   >::type list_type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
literals	multiprecision/cpp_int/literals.hpp	/^namespace literals{ namespace detail{$/;"	n	namespace:boost::multiprecision
literals	multiprecision/cpp_int/value_pack.hpp	/^namespace literals{ namespace detail{$/;"	n	namespace:boost::multiprecision
llround	multiprecision/detail/default_ops.hpp	/^inline long long llround(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
llround	multiprecision/detail/default_ops.hpp	/^inline long long llround(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
llround	multiprecision/detail/default_ops.hpp	/^inline long long llround(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
llround	multiprecision/detail/default_ops.hpp	/^inline long long llround(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
lltrunc	multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
lltrunc	multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
lltrunc	multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
lltrunc	multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
log10q	multiprecision/float128.hpp	84;"	d
log_postfix_event	multiprecision/logged_adaptor.hpp	/^inline void log_postfix_event(const Backend&, const T&, const char* \/*event_description*\/)$/;"	f	namespace:boost::multiprecision	signature:(const Backend&, const T&, const char* )
log_postfix_event	multiprecision/logged_adaptor.hpp	/^inline void log_postfix_event(const Backend&, const char* \/*event_description*\/)$/;"	f	namespace:boost::multiprecision	signature:(const Backend&, const char* )
log_prefix_event	multiprecision/logged_adaptor.hpp	/^inline void log_prefix_event(const Backend&, const T&, const U&, const V&, const char* \/*event_description*\/)$/;"	f	namespace:boost::multiprecision	signature:(const Backend&, const T&, const U&, const V&, const char* )
log_prefix_event	multiprecision/logged_adaptor.hpp	/^inline void log_prefix_event(const Backend&, const T&, const U&, const char* \/*event_description*\/)$/;"	f	namespace:boost::multiprecision	signature:(const Backend&, const T&, const U&, const char* )
log_prefix_event	multiprecision/logged_adaptor.hpp	/^inline void log_prefix_event(const Backend&, const T&, const char* \/*event_description*\/)$/;"	f	namespace:boost::multiprecision	signature:(const Backend&, const T&, const char* )
log_prefix_event	multiprecision/logged_adaptor.hpp	/^inline void log_prefix_event(const Backend&, const char* \/*event_description*\/)$/;"	f	namespace:boost::multiprecision	signature:(const Backend&, const char* )
logged_adaptor	multiprecision/logged_adaptor.hpp	/^   logged_adaptor()$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:()
logged_adaptor	multiprecision/logged_adaptor.hpp	/^   logged_adaptor(const T& i, const typename enable_if_c<is_convertible<T, Backend>::value>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(const T& i, const typename enable_if_c<is_convertible<T, Backend>::value>::type* = 0)
logged_adaptor	multiprecision/logged_adaptor.hpp	/^   logged_adaptor(const logged_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(const logged_adaptor& o)
logged_adaptor	multiprecision/logged_adaptor.hpp	/^struct logged_adaptor$/;"	s	namespace:boost::multiprecision::backends
logq	multiprecision/float128.hpp	83;"	d
long_double_max	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_double_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
long_double_min	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_double_min()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
long_long_max	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_long_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
long_long_min	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_long_min()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
lower	multiprecision/mpfi.hpp	/^inline number<mpfr_float_backend<Digits10>, ExpressionTemplates> lower(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)
lowest	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> lowest       (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::zero(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
lowest	multiprecision/cpp_int/limits.hpp	/^   static number_type lowest() { return (min)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
lowest	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type lowest() { return -(max)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
lowest	multiprecision/tommath.hpp	/^   static number_type lowest() { return (min)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
lround	multiprecision/detail/default_ops.hpp	/^inline long lround(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
lround	multiprecision/detail/default_ops.hpp	/^inline long lround(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
lround	multiprecision/detail/default_ops.hpp	/^inline long lround(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
lround	multiprecision/detail/default_ops.hpp	/^inline long lround(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
lsb	multiprecision/detail/integer_ops.hpp	/^   lsb(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x)$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x)
lsb	multiprecision/detail/integer_ops.hpp	/^   lsb(const number<Backend, ExpressionTemplates>& x)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x)
lsb	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, unsigned>::type lsb(const Integer& val)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& val)
ltrunc	multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
ltrunc	multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
ltrunc	multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
ltrunc	multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
m_buffer	multiprecision/mpfr.hpp	/^   mp_limb_t m_buffer[limb_count];$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:protected
m_data	multiprecision/cpp_int.hpp	/^      limb_type          m_data[internal_limb_count];$/;"	m	union:boost::multiprecision::cpp_int_base::data_type	access:public
m_data	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base() BOOST_NOEXCEPT : m_data(), m_limbs(1), m_sign(false), m_internal(true) {}$/;"	p	namespace:boost::multiprecision::backends	signature:()
m_data	multiprecision/cpp_int.hpp	/^   data_type   m_data;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
m_data	multiprecision/gmp.hpp	/^      mpf_init2(this->m_data, multiprecision::detail::digits10_2_2(Digits10 ? Digits10 : this->get_default_precision()));$/;"	m	namespace:boost::multiprecision
m_data	multiprecision/gmp.hpp	/^   mpf_t m_data;$/;"	m	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:protected
m_data	multiprecision/gmp.hpp	/^   mpz_t m_data;$/;"	m	struct:boost::multiprecision::gmp_int	access:protected
m_data	multiprecision/mpfi.hpp	/^   mpfi_t m_data;$/;"	m	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:protected
m_data	multiprecision/mpfr.hpp	/^   mpfr_t m_data;$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:protected
m_data	multiprecision/tommath.hpp	/^   ::mp_int m_data;$/;"	m	struct:boost::multiprecision::backends::tommath_int	access:protected
m_double_first_limb	multiprecision/cpp_int.hpp	/^      double_limb_type   m_double_first_limb;$/;"	m	union:boost::multiprecision::cpp_int_base::data_type	access:public
m_first_limb	multiprecision/cpp_int.hpp	/^      limb_type          m_first_limb;$/;"	m	union:boost::multiprecision::cpp_int_base::data_type	access:public
m_internal	multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(1), m_sign(false), m_internal(true) { }$/;"	f	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(true)
m_internal	multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(i > max_limb_value ? 2 : 1), m_sign(false), m_internal(true) { }$/;"	f	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(true)
m_internal	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base() BOOST_NOEXCEPT : m_data(), m_limbs(1), m_sign(false), m_internal(true) {}$/;"	f	namespace:boost::multiprecision::backends	signature:(true)
m_internal	multiprecision/cpp_int.hpp	/^   bool        m_sign, m_internal;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
m_limbs	multiprecision/cpp_int.hpp	/^   boost::uint16_t    m_limbs;$/;"	m	struct:boost::multiprecision::cpp_int_base	access:private
m_limbs	multiprecision/cpp_int.hpp	/^   unsigned    m_limbs;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
m_sign	multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(1), m_sign(false), m_internal(true) { }$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(false)
m_sign	multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(i > max_limb_value ? 2 : 1), m_sign(false), m_internal(true) { }$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(false)
m_sign	multiprecision/cpp_int.hpp	/^      : m_wrapper(i), m_limbs(1), m_sign(false) {}$/;"	f	struct:boost::multiprecision::cpp_int_base	access:public	signature:(false)
m_sign	multiprecision/cpp_int.hpp	/^      : m_wrapper(i), m_limbs(i > max_limb_value ? 2 : 1), m_sign(false) {}$/;"	f	struct:boost::multiprecision::cpp_int_base	access:public	signature:(false)
m_sign	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base() BOOST_NOEXCEPT : m_data(), m_limbs(1), m_sign(false), m_internal(true) {}$/;"	p	namespace:boost::multiprecision::backends	signature:(false)
m_sign	multiprecision/cpp_int.hpp	/^   bool               m_sign;$/;"	m	struct:boost::multiprecision::cpp_int_base	access:private
m_sign	multiprecision/cpp_int.hpp	/^   bool        m_sign, m_internal;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
m_value	multiprecision/concepts/mp_number_archetypes.hpp	/^   long double m_value;$/;"	m	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
m_value	multiprecision/debug_adaptor.hpp	/^   Backend m_value;$/;"	m	struct:boost::multiprecision::backends::debug_adaptor	access:private
m_value	multiprecision/float128.hpp	/^   float128_type m_value;$/;"	m	struct:boost::multiprecision::backends::float128_backend	access:private
m_value	multiprecision/logged_adaptor.hpp	/^   Backend m_value;$/;"	m	struct:boost::multiprecision::backends::logged_adaptor	access:private
m_value	multiprecision/rational_adaptor.hpp	/^   rational_type m_value;$/;"	m	struct:boost::multiprecision::backends::rational_adaptor	access:private
m_wrapper	multiprecision/cpp_int.hpp	/^   } m_wrapper;$/;"	m	struct:boost::multiprecision::cpp_int_base	typeref:union:boost::multiprecision::cpp_int_base::data_type	access:private
make_backend_from_pack	multiprecision/cpp_int/literals.hpp	/^struct make_backend_from_pack$/;"	s	namespace:boost::multiprecision::literals::detail
make_negate_tag	multiprecision/cpp_int/value_pack.hpp	/^constexpr negate_tag make_negate_tag()$/;"	f	namespace:boost::multiprecision::literals::detail	signature:()
make_packed_value_from_str	multiprecision/cpp_int/literals.hpp	/^struct make_packed_value_from_str$/;"	s	namespace:boost::multiprecision::literals::detail
math	multiprecision/cpp_dec_float.hpp	/^namespace boost{ namespace math{$/;"	n	namespace:boost
math	multiprecision/debug_adaptor.hpp	/^namespace boost{ namespace math{$/;"	n	namespace:boost
math	multiprecision/detail/big_lanczos.hpp	/^namespace boost{ namespace math{$/;"	n	namespace:boost
math	multiprecision/detail/default_ops.hpp	/^namespace math{$/;"	n	namespace:boost
math	multiprecision/detail/number_base.hpp	/^namespace boost{ namespace math{ namespace tools{$/;"	n	namespace:boost
math	multiprecision/logged_adaptor.hpp	/^namespace boost{ namespace math{$/;"	n	namespace:boost
math	multiprecision/mpfi.hpp	/^namespace math{$/;"	n
math::constants	multiprecision/mpfi.hpp	/^namespace constants{ namespace detail{$/;"	n	namespace:math
math::constants::detail	multiprecision/mpfi.hpp	/^namespace constants{ namespace detail{$/;"	n	namespace:math::constants
math::constants::detail::constant_catalan	multiprecision/mpfi.hpp	/^struct constant_catalan<boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> >$/;"	s	namespace:math::constants::detail
math::constants::detail::constant_catalan::get	multiprecision/mpfi.hpp	/^   static inline result_type const& get(const mpl::int_<N>&)$/;"	f	struct:math::constants::detail::constant_catalan	access:public	signature:(const mpl::int_<N>&)
math::constants::detail::constant_catalan::result_type	multiprecision/mpfi.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> result_type;$/;"	t	struct:math::constants::detail::constant_catalan	access:public
math::constants::detail::constant_euler	multiprecision/mpfi.hpp	/^struct constant_euler<boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> >$/;"	s	namespace:math::constants::detail
math::constants::detail::constant_euler::get	multiprecision/mpfi.hpp	/^   static inline result_type const& get(const mpl::int_<N>&)$/;"	f	struct:math::constants::detail::constant_euler	access:public	signature:(const mpl::int_<N>&)
math::constants::detail::constant_euler::result_type	multiprecision/mpfi.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> result_type;$/;"	t	struct:math::constants::detail::constant_euler	access:public
math::constants::detail::constant_ln_two	multiprecision/mpfi.hpp	/^struct constant_ln_two<boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> >$/;"	s	namespace:math::constants::detail
math::constants::detail::constant_ln_two::get	multiprecision/mpfi.hpp	/^   static inline result_type const& get(const mpl::int_<N>&)$/;"	f	struct:math::constants::detail::constant_ln_two	access:public	signature:(const mpl::int_<N>&)
math::constants::detail::constant_ln_two::result_type	multiprecision/mpfi.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> result_type;$/;"	t	struct:math::constants::detail::constant_ln_two	access:public
math::constants::detail::constant_pi	multiprecision/mpfi.hpp	/^struct constant_pi<boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> >$/;"	s	namespace:math::constants::detail
math::constants::detail::constant_pi::get	multiprecision/mpfi.hpp	/^   static inline result_type const& get(const mpl::int_<N>&)$/;"	f	struct:math::constants::detail::constant_pi	access:public	signature:(const mpl::int_<N>&)
math::constants::detail::constant_pi::result_type	multiprecision/mpfi.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> result_type;$/;"	t	struct:math::constants::detail::constant_pi	access:public
math::constants::detail::mpfi_initializer	multiprecision/mpfi.hpp	/^struct mpfi_initializer$/;"	s	namespace:math::constants::detail
math::constants::detail::mpfi_initializer::force_instantiate	multiprecision/mpfi.hpp	/^   static void force_instantiate()$/;"	f	struct:math::constants::detail::mpfi_initializer	access:public	signature:()
math::constants::detail::mpfi_initializer::init	multiprecision/mpfi.hpp	/^   struct init$/;"	s	struct:math::constants::detail::mpfi_initializer	access:public
math::constants::detail::mpfi_initializer::init::force_instantiate	multiprecision/mpfi.hpp	/^      void force_instantiate()const{}$/;"	f	struct:math::constants::detail::mpfi_initializer::init	access:public	signature:() const
math::constants::detail::mpfi_initializer::init::init	multiprecision/mpfi.hpp	/^      init()$/;"	f	struct:math::constants::detail::mpfi_initializer::init	access:public	signature:()
math::constants::detail::mpfi_initializer::initializer	multiprecision/mpfi.hpp	/^   static const init initializer;$/;"	m	struct:math::constants::detail::mpfi_initializer	access:public
math::constants::detail::mpfi_initializer::initializer	multiprecision/mpfi.hpp	/^const typename mpfi_initializer<T>::init mpfi_initializer<T>::initializer;$/;"	m	class:math::constants::detail::mpfi_initializer
math::tools	multiprecision/mpfi.hpp	/^namespace tools{$/;"	n	namespace:math
math::tools::digits	multiprecision/mpfi.hpp	/^inline int digits<boost::multiprecision::mpfi_float>()$/;"	f	namespace:math::tools	signature:()
math::tools::digits	multiprecision/mpfi.hpp	/^inline int digits<boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<0>, boost::multiprecision::et_off> >()$/;"	f	namespace:math::tools	signature:()
max	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> (max)        (void)  { return (boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::max)(); }$/;"	f	class:std::numeric_limits::boost::multiprecision	access:public	signature:(void)
max	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& (max)()$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
max	multiprecision/cpp_int/limits.hpp	/^   static number_type (max)() $/;"	f	class:std::numeric_limits	access:public	signature:()
max	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type (max)() { return (base_type::max)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
max	multiprecision/tommath.hpp	/^   static number_type (max)() $/;"	f	class:std::numeric_limits	access:public	signature:()
max_block_10	multiprecision/cpp_int/cpp_int_config.hpp	/^static const limb_type max_block_10 = 1000000000000000000uLL;$/;"	m	namespace:boost::multiprecision
max_digits10	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     max_digits10      = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_total_digits10;$/;"	m	class:std::numeric_limits	access:public
max_digits10	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::max_digits10;$/;"	m	class:std::numeric_limits
max_digits10	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int max_digits10 = digits10 + 2;$/;"	m	class:std::numeric_limits	access:public
max_digits10	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::max_digits10;$/;"	m	class:std::numeric_limits
max_digits10	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int max_digits10 = 36;$/;"	m	class:std::numeric_limits	access:public
max_digits10	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int max_digits10 = digits10 + 2;$/;"	m	class:std::numeric_limits	access:public
max_digits10	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::max_digits10;$/;"	m	class:std::numeric_limits
max_exponent	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          max_exponent      = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp;      \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
max_exponent	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::max_exponent;$/;"	m	class:std::numeric_limits
max_exponent	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
max_exponent	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::max_exponent;$/;"	m	class:std::numeric_limits
max_exponent	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent = 16384;$/;"	m	class:std::numeric_limits	access:public
max_exponent	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
max_exponent	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::max_exponent;$/;"	m	class:std::numeric_limits
max_exponent10	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          max_exponent10    = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10;    \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
max_exponent10	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::max_exponent10;$/;"	m	class:std::numeric_limits
max_exponent10	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
max_exponent10	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::max_exponent10;$/;"	m	class:std::numeric_limits
max_exponent10	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent10 = max_exponent * 301L \/ 1000L;$/;"	m	class:std::numeric_limits	access:public
max_exponent10	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
max_exponent10	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::max_exponent10;$/;"	m	class:std::numeric_limits
max_limb_value	multiprecision/cpp_int.hpp	/^const limb_type cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::max_limb_value;$/;"	m	class:boost::multiprecision::cpp_int_base
max_precision	multiprecision/cpp_int.hpp	/^struct max_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends
median	multiprecision/mpfi.hpp	/^inline number<mpfr_float_backend<Digits10>, ExpressionTemplates> median(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)
middle	multiprecision/detail/number_base.hpp	/^   middle_type middle()const { return middle_type(arg2); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
middle_depth	multiprecision/detail/number_base.hpp	/^   static const unsigned middle_depth = middle_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
middle_result_type	multiprecision/detail/number_base.hpp	/^   typedef typename middle_type::result_type middle_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
middle_type	multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg2>::type middle_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
miller_rabin_test	multiprecision/miller_rabin.hpp	/^   miller_rabin_test(const I& n, unsigned trials, Engine& gen)$/;"	f	namespace:boost::multiprecision	signature:(const I& n, unsigned trials, Engine& gen)
miller_rabin_test	multiprecision/miller_rabin.hpp	/^   miller_rabin_test(const I& x, unsigned trials)$/;"	f	namespace:boost::multiprecision	signature:(const I& x, unsigned trials)
miller_rabin_test	multiprecision/miller_rabin.hpp	/^bool miller_rabin_test(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials)
miller_rabin_test	multiprecision/miller_rabin.hpp	/^bool miller_rabin_test(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials, Engine& gen)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials, Engine& gen)
min	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> (min)        (void)  { return (boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::min)(); }$/;"	f	class:std::numeric_limits::boost::multiprecision	access:public	signature:(void)
min	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& (min)()$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
min	multiprecision/cpp_int/limits.hpp	/^   static number_type (min)()$/;"	f	class:std::numeric_limits	access:public	signature:()
min	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type (min)() { return (base_type::min)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
min	multiprecision/tommath.hpp	/^   static number_type (min)()$/;"	f	class:std::numeric_limits	access:public	signature:()
min_exponent	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          min_exponent      = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp;      \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
min_exponent	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::min_exponent;$/;"	m	class:std::numeric_limits
min_exponent	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
min_exponent	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::min_exponent;$/;"	m	class:std::numeric_limits
min_exponent	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent = -16381;$/;"	m	class:std::numeric_limits	access:public
min_exponent	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
min_exponent	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::min_exponent;$/;"	m	class:std::numeric_limits
min_exponent10	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          min_exponent10    = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10;    \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
min_exponent10	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::min_exponent10;$/;"	m	class:std::numeric_limits
min_exponent10	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
min_exponent10	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::min_exponent10;$/;"	m	class:std::numeric_limits
min_exponent10	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent10 = min_exponent * 301L \/ 1000L;$/;"	m	class:std::numeric_limits	access:public
min_exponent10	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
min_exponent10	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::min_exponent10;$/;"	m	class:std::numeric_limits
min_precision	multiprecision/cpp_int.hpp	/^struct min_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends
minmax	multiprecision/cpp_int/cpp_int_config.hpp	/^inline void minmax(const T& a, const T& b, T& aa, T& bb)$/;"	f	namespace:boost::multiprecision	signature:(const T& a, const T& b, T& aa, T& bb)
minus	multiprecision/detail/number_base.hpp	/^struct minus{};$/;"	s	namespace:boost::multiprecision::detail
modulus	multiprecision/detail/number_base.hpp	/^struct modulus{};$/;"	s	namespace:boost::multiprecision::detail
modulus_immediates	multiprecision/detail/number_base.hpp	/^struct modulus_immediates{};$/;"	s	namespace:boost::multiprecision::detail
mp_number_float_architype	multiprecision/concepts/mp_number_archetypes.hpp	/^typedef boost::multiprecision::number<number_backend_float_architype> mp_number_float_architype;$/;"	t	namespace:boost::multiprecision::concepts
mpf_float	multiprecision/gmp.hpp	/^typedef number<gmp_float<0> >     mpf_float;$/;"	t
mpf_float_100	multiprecision/gmp.hpp	/^typedef number<gmp_float<100> >   mpf_float_100;$/;"	t
mpf_float_1000	multiprecision/gmp.hpp	/^typedef number<gmp_float<1000> >  mpf_float_1000;$/;"	t
mpf_float_50	multiprecision/gmp.hpp	/^typedef number<gmp_float<50> >    mpf_float_50;$/;"	t
mpf_float_500	multiprecision/gmp.hpp	/^typedef number<gmp_float<500> >   mpf_float_500;$/;"	t
mpf_set	multiprecision/gmp.hpp	/^   mpf_set(this->m_data, o.data());$/;"	p	namespace:boost::multiprecision	signature:(this->m_data, o.data())
mpfi_float	multiprecision/mpfi.hpp	/^typedef number<mpfi_float_backend<0> >     mpfi_float;$/;"	t	namespace:boost
mpfi_float_100	multiprecision/mpfi.hpp	/^typedef number<mpfi_float_backend<100> >   mpfi_float_100;$/;"	t	namespace:boost
mpfi_float_1000	multiprecision/mpfi.hpp	/^typedef number<mpfi_float_backend<1000> >  mpfi_float_1000;$/;"	t	namespace:boost
mpfi_float_50	multiprecision/mpfi.hpp	/^typedef number<mpfi_float_backend<50> >    mpfi_float_50;$/;"	t	namespace:boost
mpfi_float_500	multiprecision/mpfi.hpp	/^typedef number<mpfi_float_backend<500> >   mpfi_float_500;$/;"	t	namespace:boost
mpfi_float_backend	multiprecision/mpfi.hpp	/^   explicit mpfi_float_backend(const mpfi_float_backend<D>& val, typename disable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_float_backend<D>& val, typename disable_if_c<D <= digits10>::type* = 0)
mpfi_float_backend	multiprecision/mpfi.hpp	/^   explicit mpfi_float_backend(const mpfr_float_backend<D>& val, typename disable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfr_float_backend<D>& val, typename disable_if_c<D <= digits10>::type* = 0)
mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend() : detail::mpfi_float_imp<0>() {}$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:()
mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend() : detail::mpfi_float_imp<digits10>() {}$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:()
mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend(const mpfi_float_backend& o) : detail::mpfi_float_imp<0>(o) {}$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_float_backend& o)
mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend(const mpfi_float_backend& o) : detail::mpfi_float_imp<digits10>(o) {}$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_float_backend& o)
mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend(const mpfi_float_backend<D>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpfi_float_backend<D>& val)
mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend(const mpfi_float_backend<D>& val, typename enable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_float_backend<D>& val, typename enable_if_c<D <= digits10>::type* = 0)
mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend(const mpfi_t val)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_t val)
mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend(const mpfr_float_backend<D>& val, typename enable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfr_float_backend<D>& val, typename enable_if_c<D <= digits10>::type* = 0)
mpfi_float_backend	multiprecision/mpfi.hpp	/^   mpfi_float_backend(mpfi_float_backend&& o) : detail::mpfi_float_imp<digits10>(static_cast<detail::mpfi_float_imp<digits10>&&>(o)) {}$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(mpfi_float_backend&& o)
mpfi_float_backend	multiprecision/mpfi.hpp	/^struct mpfi_float_backend : public detail::mpfi_float_imp<digits10>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::mpfi_float_imp
mpfi_float_backend	multiprecision/mpfi.hpp	/^struct mpfi_float_backend<0> : public detail::mpfi_float_imp<0>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::mpfi_float_imp
mpfi_float_imp	multiprecision/mpfi.hpp	/^   mpfi_float_imp()$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:()
mpfi_float_imp	multiprecision/mpfi.hpp	/^   mpfi_float_imp(const mpfi_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(const mpfi_float_imp& o)
mpfi_float_imp	multiprecision/mpfi.hpp	/^   mpfi_float_imp(unsigned prec)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(unsigned prec)
mpfi_float_imp	multiprecision/mpfi.hpp	/^struct mpfi_float_imp$/;"	s	namespace:boost::multiprecision::backends::detail
mpfi_initializer	multiprecision/mpfi.hpp	/^struct mpfi_initializer$/;"	s	namespace:math::constants::detail
mpfi_sgn	multiprecision/mpfi.hpp	/^inline int mpfi_sgn(mpfi_srcptr p)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(mpfi_srcptr p)
mpfr_allocation_type	multiprecision/mpfr.hpp	/^enum mpfr_allocation_type$/;"	g	namespace:boost::multiprecision
mpfr_cleanup	multiprecision/mpfr.hpp	/^struct mpfr_cleanup$/;"	s	namespace:boost::multiprecision::backends::detail
mpfr_float_backend	multiprecision/mpfr.hpp	/^   explicit mpfr_float_backend(const mpfr_float_backend<D, AT>& val, typename disable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D, AT>& val, typename disable_if_c<D <= digits10>::type* = 0)
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend() : detail::mpfr_float_imp<0, allocate_dynamic>() {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:()
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend() : detail::mpfr_float_imp<digits10, AllocationType>() {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:()
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_float<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val)
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_float<D>& val, typename disable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val, typename disable_if_c<D <= digits10>::type* = 0)
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_float<D>& val, typename enable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val, typename enable_if_c<D <= digits10>::type* = 0)
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_int& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_int& val)
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_rational& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_rational& val)
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpf_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpf_t val)
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend& o) : detail::mpfr_float_imp<0, allocate_dynamic>(o) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o)
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend& o) : detail::mpfr_float_imp<digits10, AllocationType>(o) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o)
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend& o, unsigned digits10)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o, unsigned digits10)
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend<D, AT>& val, typename enable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D, AT>& val, typename enable_if_c<D <= digits10>::type* = 0)
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D>& val)
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_t val)
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpq_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpq_t val)
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpz_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpz_t val)
mpfr_float_backend	multiprecision/mpfr.hpp	/^   mpfr_float_backend(mpfr_float_backend&& o) : detail::mpfr_float_imp<digits10, AllocationType>(static_cast<detail::mpfr_float_imp<digits10, AllocationType>&&>(o)) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(mpfr_float_backend&& o)
mpfr_float_backend	multiprecision/mpfr.hpp	/^struct mpfr_float_backend : public detail::mpfr_float_imp<digits10, AllocationType>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::mpfr_float_imp
mpfr_float_backend	multiprecision/mpfr.hpp	/^struct mpfr_float_backend<0, allocate_dynamic> : public detail::mpfr_float_imp<0, allocate_dynamic>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::mpfr_float_imp
mpfr_float_imp	multiprecision/mpfr.hpp	/^   mpfr_float_imp()$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:()
mpfr_float_imp	multiprecision/mpfr.hpp	/^   mpfr_float_imp(const mpfr_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(const mpfr_float_imp& o)
mpfr_float_imp	multiprecision/mpfr.hpp	/^   mpfr_float_imp(unsigned prec)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(unsigned prec)
mpfr_float_imp	multiprecision/mpfr.hpp	/^struct mpfr_float_imp<digits10, allocate_dynamic>$/;"	s	namespace:boost::multiprecision::backends::detail
mpfr_float_imp	multiprecision/mpfr.hpp	/^struct mpfr_float_imp<digits10, allocate_stack>$/;"	s	namespace:boost::multiprecision::backends::detail
mpq_rational	multiprecision/gmp.hpp	/^typedef number<gmp_rational >    mpq_rational;$/;"	t
mpz_int	multiprecision/gmp.hpp	/^typedef number<gmp_int >         mpz_int;$/;"	t
msb	multiprecision/detail/integer_ops.hpp	/^   msb(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x)$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x)
msb	multiprecision/detail/integer_ops.hpp	/^   msb(const number<Backend, ExpressionTemplates>& x)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x)
msb	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, unsigned>::type msb(Integer val)$/;"	f	namespace:boost::multiprecision	signature:(Integer val)
mul_loop_n	multiprecision/cpp_dec_float.hpp	/^   static boost::uint32_t mul_loop_n (boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
mul_loop_n	multiprecision/cpp_dec_float.hpp	/^boost::uint32_t cpp_dec_float<Digits10, ExponentType, Allocator>::mul_loop_n(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
mul_loop_uv	multiprecision/cpp_dec_float.hpp	/^   static boost::uint32_t mul_loop_uv(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)
mul_loop_uv	multiprecision/cpp_dec_float.hpp	/^boost::uint32_t cpp_dec_float<Digits10, ExponentType, Allocator>::mul_loop_uv(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)
mul_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& mul_unsigned_long_long(const unsigned long long n);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
mul_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::mul_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const unsigned long long n)
multiplies	multiprecision/detail/number_base.hpp	/^struct multiplies{};$/;"	s	namespace:boost::multiprecision::detail
multiply	multiprecision/detail/default_ops.hpp	/^   multiply(number<B, ET>& result, const I& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, ET>& result, const I& a, const I& b)
multiply	multiprecision/detail/default_ops.hpp	/^inline number<B1, ET1>& multiply(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)
multiply	multiprecision/integer.hpp	/^   multiply(Integer& result, const I2& a, const I2& b)$/;"	f	namespace:boost::multiprecision	signature:(Integer& result, const I2& a, const I2& b)
multiply_add	multiprecision/detail/number_base.hpp	/^struct multiply_add{};$/;"	s	namespace:boost::multiprecision::detail
multiply_immediates	multiprecision/detail/number_base.hpp	/^struct multiply_immediates{};$/;"	s	namespace:boost::multiprecision::detail
multiply_subtract	multiprecision/detail/number_base.hpp	/^struct multiply_subtract{};$/;"	s	namespace:boost::multiprecision::detail
multiprecision	multiprecision/concepts/mp_number_archetypes.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/cpp_dec_float.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/cpp_int.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/cpp_int/add.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
multiprecision	multiprecision/cpp_int/bitwise.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
multiprecision	multiprecision/cpp_int/checked.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{ namespace detail{$/;"	n	namespace:boost
multiprecision	multiprecision/cpp_int/comparison.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
multiprecision	multiprecision/cpp_int/cpp_int_config.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/cpp_int/cpp_int_config.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/cpp_int/divide.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
multiprecision	multiprecision/cpp_int/literals.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/cpp_int/misc.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
multiprecision	multiprecision/cpp_int/multiply.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
multiprecision	multiprecision/cpp_int/value_pack.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/debug_adaptor.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/detail/bitscan.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
multiprecision	multiprecision/detail/default_ops.hpp	/^namespace boost{ namespace multiprecision{ namespace default_ops{$/;"	n	namespace:boost
multiprecision	multiprecision/detail/default_ops.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/detail/digits.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
multiprecision	multiprecision/detail/dynamic_array.hpp	/^  namespace boost { namespace multiprecision { namespace backends { namespace detail$/;"	n	namespace:boost
multiprecision	multiprecision/detail/et_ops.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/detail/float_string_cvt.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
multiprecision	multiprecision/detail/generic_interconvert.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
multiprecision	multiprecision/detail/integer_ops.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/detail/no_et_ops.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/detail/number_base.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/detail/number_compare.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/detail/rebind.hpp	/^  namespace boost { namespace multiprecision { namespace backends { namespace detail$/;"	n	namespace:boost
multiprecision	multiprecision/detail/utype_helper.hpp	/^  namespace boost { namespace multiprecision {$/;"	n	namespace:boost
multiprecision	multiprecision/float128.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/gmp.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/integer.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/logged_adaptor.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/miller_rabin.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/mpfi.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/mpfr.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/number.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/rational_adaptor.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/tommath.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
multiprecision	multiprecision/traits/explicit_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
multiprecision	multiprecision/traits/extract_exponent_type.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	multiprecision/traits/is_restricted_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
nan	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& nan()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
neg	multiprecision/cpp_dec_float.hpp	/^   bool            neg;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
negate	multiprecision/concepts/mp_number_archetypes.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:()
negate	multiprecision/cpp_dec_float.hpp	/^   void negate()   $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
negate	multiprecision/debug_adaptor.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:()
negate	multiprecision/detail/number_base.hpp	/^struct negate{};$/;"	s	namespace:boost::multiprecision::detail
negate	multiprecision/float128.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:()
negate	multiprecision/logged_adaptor.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:()
negate	multiprecision/rational_adaptor.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:()
negate	multiprecision/tommath.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
negate_tag	multiprecision/cpp_int/value_pack.hpp	/^struct negate_tag{};$/;"	s	namespace:boost::multiprecision::literals::detail
new_size	multiprecision/cpp_int.hpp	/^         new_size = max_limbs;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
next_type	multiprecision/cpp_int/value_pack.hpp	/^   typedef value_pack<0, VALUES...> next_type;$/;"	t	struct:boost::multiprecision::literals::detail::value_pack	access:public
noexcept	multiprecision/number.hpp	/^         >::type* = 0) BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Other&>(std::declval<Other>()))))$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
noexcept	multiprecision/number.hpp	/^      BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Backend&>(std::declval<Backend>())))) : m_backend(val.backend()) {}$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
noexcept	multiprecision/number.hpp	/^      BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Other&>(std::declval<Other>()))))$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
noexcept	multiprecision/number.hpp	/^      BOOST_NOEXCEPT_IF(noexcept(std::declval<Backend>() = static_cast<const Backend&>(std::declval<Backend>())))$/;"	p	class:boost::multiprecision::number	access:public	signature:(std::declval<Backend>(
noexcept	multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number() BOOST_NOEXCEPT_IF(noexcept(Backend())) {}$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
noexcept	multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const number& e) BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Backend&>(std::declval<Backend>())))) : m_backend(e.m_backend){}$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
number	multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const V& v, typename boost::enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename boost::enable_if_c< is_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && !detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value >::type* = 0)
number	multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const number& e, unsigned digits10)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const number& e, unsigned digits10)
number	multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE number(V v1, V v2, typename boost::enable_if<mpl::or_<boost::is_arithmetic<V>, is_same<std::string, V>, is_convertible<V, const char*> > >::type* = 0)$/;"	f	class:boost::multiprecision::number	access:public	signature:(V v1, V v2, typename boost::enable_if<mpl::or_<boost::is_arithmetic<V>, is_same<std::string, V>, is_convertible<V, const char*> > >::type* = 0)
number	multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE number(const V& v, typename boost::enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename boost::enable_if_c< (boost::is_arithmetic<V>::value || is_same<std::string, V>::value || is_convertible<V, const char*>::value) && !is_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && !detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value >::type* = 0)
number	multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE number(const number<Other, ET>& v1, const number<Other, ET>& v2, typename boost::enable_if<boost::is_convertible<Other, Backend> >::type* = 0)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const number<Other, ET>& v1, const number<Other, ET>& v2, typename boost::enable_if<boost::is_convertible<Other, Backend> >::type* = 0)
number	multiprecision/number.hpp	/^   explicit BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const V& v, typename boost::enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename boost::enable_if_c< detail::is_explicitly_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && (detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value || !is_convertible<typename detail::canonical<V, Backend>::type, Backend>::value) >::type* = 0)
number	multiprecision/number.hpp	/^   explicit BOOST_MP_FORCEINLINE number(const V& v, typename boost::enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename boost::enable_if_c< (boost::is_arithmetic<V>::value || is_same<std::string, V>::value || is_convertible<V, const char*>::value) && !detail::is_explicitly_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value >::type* = 0)
number	multiprecision/number.hpp	/^   explicit number(const number<Other, ET>& val, typename boost::enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const number<Other, ET>& val, typename boost::enable_if_c< (!detail::is_explicitly_convertible<Other, Backend>::value) >::type* = 0)
number	multiprecision/number.hpp	/^class number$/;"	c	namespace:boost::multiprecision
number1_t	multiprecision/detail/ublas_interop.hpp	/^   typedef boost::multiprecision::number<Backend1, ExpressionTemplates1> number1_t;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
number1_t	multiprecision/detail/ublas_interop.hpp	/^   typedef typename expression1_t::result_type number1_t;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
number2_t	multiprecision/detail/ublas_interop.hpp	/^   typedef boost::multiprecision::number<Backend2, ExpressionTemplates2> number2_t;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
number2_t	multiprecision/detail/ublas_interop.hpp	/^   typedef typename expression2_t::result_type number2_t;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
number2_t	multiprecision/detail/ublas_interop.hpp	/^   typedef typename expression_type::result_type number2_t;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
number_backend_float_architype	multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype()$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:()
number_backend_float_architype	multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype(const number_backend_float_architype& o)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const number_backend_float_architype& o)
number_backend_float_architype	multiprecision/concepts/mp_number_archetypes.hpp	/^struct number_backend_float_architype$/;"	s	namespace:boost::multiprecision::concepts
number_category	multiprecision/concepts/mp_number_archetypes.hpp	/^struct number_category<concepts::number_backend_float_architype> : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	multiprecision/cpp_dec_float.hpp	/^struct number_category<backends::cpp_dec_float<Digits10, ExponentType, Allocator> > : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	multiprecision/cpp_int.hpp	/^struct number_category<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> > : public mpl::int_<number_kind_integer>{};$/;"	s	inherits:mpl::int_
number_category	multiprecision/debug_adaptor.hpp	/^struct number_category<backends::debug_adaptor<Backend> > : public number_category<Backend> {};$/;"	s	namespace:boost::multiprecision	inherits:number_category
number_category	multiprecision/detail/number_base.hpp	/^struct number_category : public mpl::int_<std::numeric_limits<Num>::is_integer ? number_kind_integer : (std::numeric_limits<Num>::max_exponent ? number_kind_floating_point : number_kind_unknown)> {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	multiprecision/detail/number_base.hpp	/^struct number_category<detail::expression<tag, A1, A2, A3, A4> > : public number_category<typename detail::expression<tag, A1, A2, A3, A4>::result_type>{};$/;"	s	namespace:boost::multiprecision	inherits:number_category
number_category	multiprecision/detail/number_base.hpp	/^struct number_category<number<Backend, ExpressionTemplates> > : public number_category<Backend>{};$/;"	s	namespace:boost::multiprecision	inherits:number_category
number_category	multiprecision/float128.hpp	/^struct number_category<backends::float128_backend> : public mpl::int_<number_kind_floating_point> {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	multiprecision/float128.hpp	/^struct number_category<float128_type> : public mpl::int_<number_kind_floating_point> {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	multiprecision/gmp.hpp	/^struct number_category<backends::gmp_float<digits10> > : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	multiprecision/gmp.hpp	/^struct number_category<backends::gmp_int> : public mpl::int_<number_kind_integer>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	multiprecision/gmp.hpp	/^struct number_category<backends::gmp_rational> : public mpl::int_<number_kind_rational>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	multiprecision/gmp.hpp	/^struct number_category<detail::canonical<mpf_t, gmp_float<0> >::type> : public mpl::int_<number_kind_floating_point>{};$/;"	s	inherits:mpl::int_
number_category	multiprecision/gmp.hpp	/^struct number_category<detail::canonical<mpq_t, gmp_rational>::type> : public mpl::int_<number_kind_rational>{};$/;"	s	inherits:mpl::int_
number_category	multiprecision/gmp.hpp	/^struct number_category<detail::canonical<mpz_t, gmp_int>::type> : public mpl::int_<number_kind_integer>{};$/;"	s	inherits:mpl::int_
number_category	multiprecision/logged_adaptor.hpp	/^struct number_category<backends::logged_adaptor<Backend> > : public number_category<Backend> {};$/;"	s	namespace:boost::multiprecision	inherits:number_category
number_category	multiprecision/mpfi.hpp	/^struct number_category<backends::mpfi_float_backend<digits10> > : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	multiprecision/mpfi.hpp	/^struct number_category<detail::canonical<mpfi_t, backends::mpfi_float_backend<0> >::type> : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost	inherits:mpl::int_
number_category	multiprecision/mpfr.hpp	/^struct number_category<backends::mpfr_float_backend<digits10, AllocationType> > : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	multiprecision/rational_adaptor.hpp	/^struct number_category<backends::rational_adaptor<IntBackend> > : public mpl::int_<number_kind_rational>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	multiprecision/tommath.hpp	/^struct number_category<tommath_int> : public mpl::int_<number_kind_integer>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category_type	multiprecision/detail/number_base.hpp	/^enum number_category_type$/;"	g	namespace:boost::multiprecision
number_kind_fixed_point	multiprecision/detail/number_base.hpp	/^   number_kind_fixed_point = 3$/;"	e	enum:boost::multiprecision::number_category_type
number_kind_floating_point	multiprecision/detail/number_base.hpp	/^   number_kind_floating_point = 1,$/;"	e	enum:boost::multiprecision::number_category_type
number_kind_integer	multiprecision/detail/number_base.hpp	/^   number_kind_integer = 0,$/;"	e	enum:boost::multiprecision::number_category_type
number_kind_rational	multiprecision/detail/number_base.hpp	/^   number_kind_rational = 2,$/;"	e	enum:boost::multiprecision::number_category_type
number_kind_unknown	multiprecision/detail/number_base.hpp	/^   number_kind_unknown = -1,$/;"	e	enum:boost::multiprecision::number_category_type
number_type	multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::concepts::number_backend_float_architype, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
number_type	multiprecision/cpp_int/limits.hpp	/^   typedef boost::multiprecision::number<backend_type, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
number_type	multiprecision/cpp_int/literals.hpp	/^   typedef number<backend_type, et_off> number_type;$/;"	t	struct:boost::multiprecision::literals::detail::signed_cpp_int_literal_result_type	access:public
number_type	multiprecision/cpp_int/literals.hpp	/^   typedef number<backend_type, et_off> number_type;$/;"	t	struct:boost::multiprecision::literals::detail::unsigned_cpp_int_literal_result_type	access:public
number_type	multiprecision/debug_adaptor.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::backends::debug_adaptor<Backend>, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
number_type	multiprecision/float128.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::backends::float128_backend, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
number_type	multiprecision/logged_adaptor.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::backends::logged_adaptor<Backend>, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
number_type	multiprecision/rational_adaptor.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::rational_adaptor<IntBackend> > number_type;$/;"	t	class:std::numeric_limits	access:private
number_type	multiprecision/tommath.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
numerator	multiprecision/gmp.hpp	/^inline number<gmp_int, ET> numerator(const number<gmp_rational, ET>& val)$/;"	f	signature:(const number<gmp_rational, ET>& val)
numerator	multiprecision/number.hpp	/^inline multiprecision::number<T, ExpressionTemplates> numerator(const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a)
numerator	multiprecision/rational_adaptor.hpp	/^inline number<IntBackend, ET> numerator(const number<rational_adaptor<IntBackend>, ET>& val)$/;"	f	namespace:boost::multiprecision	signature:(const number<rational_adaptor<IntBackend>, ET>& val)
numeric	multiprecision/detail/ublas_interop.hpp	/^namespace boost { namespace numeric { namespace ublas {$/;"	n	namespace:boost
numeric_limits	multiprecision/concepts/mp_number_archetypes.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::concepts::number_backend_float_architype, ExpressionTemplates> > : public std::numeric_limits<long double>$/;"	c	namespace:std	inherits:std::numeric_limits
numeric_limits	multiprecision/cpp_dec_float.hpp	/^   class numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >$/;"	c	namespace:std
numeric_limits	multiprecision/cpp_int/limits.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >$/;"	c	namespace:std
numeric_limits	multiprecision/debug_adaptor.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::backends::debug_adaptor<Backend>, ExpressionTemplates> >$/;"	c	namespace:std	inherits:std::numeric_limits
numeric_limits	multiprecision/float128.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::backends::float128_backend, ExpressionTemplates> >$/;"	c	namespace:std
numeric_limits	multiprecision/logged_adaptor.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::backends::logged_adaptor<Backend>, ExpressionTemplates> >$/;"	c	namespace:std	inherits:std::numeric_limits
numeric_limits	multiprecision/rational_adaptor.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::rational_adaptor<IntBackend>, ExpressionTemplates> > : public std::numeric_limits<boost::multiprecision::number<IntBackend, ExpressionTemplates> >$/;"	c	namespace:std	inherits:std::numeric_limits
numeric_limits	multiprecision/tommath.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >$/;"	c	namespace:std
one	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& one()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
operator !=	multiprecision/detail/number_compare.hpp	/^   operator != (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
operator !=	multiprecision/detail/number_compare.hpp	/^   operator != (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
operator !=	multiprecision/detail/number_compare.hpp	/^   operator != (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
operator !=	multiprecision/detail/number_compare.hpp	/^   operator != (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
operator !=	multiprecision/detail/number_compare.hpp	/^   operator != (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
operator !=	multiprecision/detail/number_compare.hpp	/^inline bool operator != (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
operator !=	multiprecision/number.hpp	/^typename boost::enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator != (const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)
operator !=	multiprecision/number.hpp	/^typename boost::enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator != (const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)
operator %	multiprecision/detail/et_ops.hpp	/^      operator % (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator %	multiprecision/detail/et_ops.hpp	/^      operator % (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator %	multiprecision/detail/et_ops.hpp	/^      operator % (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator %	multiprecision/detail/et_ops.hpp	/^      operator % (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator %	multiprecision/detail/et_ops.hpp	/^      operator % (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
operator %	multiprecision/detail/et_ops.hpp	/^      operator % (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator %	multiprecision/detail/et_ops.hpp	/^      operator % (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator %	multiprecision/detail/et_ops.hpp	/^   operator % (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator %	multiprecision/detail/no_et_ops.hpp	/^   operator % (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator %	multiprecision/detail/no_et_ops.hpp	/^   operator % (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator %	multiprecision/detail/no_et_ops.hpp	/^   operator % (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator %	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator % (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator %	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator % (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator &	multiprecision/detail/et_ops.hpp	/^      operator & (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator &	multiprecision/detail/no_et_ops.hpp	/^   operator & (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator &	multiprecision/detail/no_et_ops.hpp	/^   operator & (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
operator &	multiprecision/detail/no_et_ops.hpp	/^   operator & (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator &	multiprecision/detail/no_et_ops.hpp	/^   operator & (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator &	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator & (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator &	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator & (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
operator &	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator & (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator &	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator & (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
operator ()	multiprecision/detail/default_ops.hpp	/^   void operator()(Backend& result, const Backend& arg)const$/;"	f	struct:boost::multiprecision::detail::abs_funct	access:public	signature:(Backend& result, const Backend& arg) const
operator ()	multiprecision/detail/integer_ops.hpp	/^   void operator()(T& result, const T& b, const U& p, const V& m)const$/;"	f	struct:boost::multiprecision::default_ops::powm_func	access:public	signature:(T& result, const T& b, const U& p, const V& m) const
operator ()	multiprecision/random.hpp	/^    result_type operator()()$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
operator ()	multiprecision/random.hpp	/^    result_type operator()(Engine& eng) const$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(Engine& eng) const
operator ()	multiprecision/random.hpp	/^    result_type operator()(Engine& eng, const param_type& parm) const$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(Engine& eng, const param_type& parm) const
operator ()	multiprecision/random.hpp	/^  result_type operator()(result_type const& x, result_type const& y) { return x - y; }$/;"	f	struct:boost::random::detail::subtract	access:public	signature:(result_type const& x, result_type const& y)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator *	multiprecision/detail/et_ops.hpp	/^   operator * (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator *	multiprecision/detail/no_et_ops.hpp	/^   operator * (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator *	multiprecision/detail/no_et_ops.hpp	/^   operator * (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
operator *	multiprecision/detail/no_et_ops.hpp	/^   operator * (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator *	multiprecision/detail/no_et_ops.hpp	/^   operator * (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator *	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator *	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
operator *	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator *	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
operator *=	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator*=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
operator *=	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator*=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator +	multiprecision/detail/et_ops.hpp	/^   operator + (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator +	multiprecision/detail/et_ops.hpp	/^inline BOOST_CONSTEXPR const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v) { return v; }$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v)
operator +	multiprecision/detail/et_ops.hpp	/^inline BOOST_CONSTEXPR const number<B, ExpressionTemplates> operator + (const number<B, ExpressionTemplates>& v) { return v; }$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ExpressionTemplates>& v)
operator +	multiprecision/detail/no_et_ops.hpp	/^   operator + (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator +	multiprecision/detail/no_et_ops.hpp	/^   operator + (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
operator +	multiprecision/detail/no_et_ops.hpp	/^   operator + (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator +	multiprecision/detail/no_et_ops.hpp	/^   operator + (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator +	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator +	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
operator +	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator +	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
operator ++	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator++(void)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
operator +=	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator+=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
operator +=	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator+=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
operator -	multiprecision/cpp_int/literals.hpp	/^   operator - (const number<cpp_int_backend<MinBits, MinBits, signed_magnitude, Checked, void>, et_off>& a)$/;"	f	namespace:boost::multiprecision	signature:(const number<cpp_int_backend<MinBits, MinBits, signed_magnitude, Checked, void>, et_off>& a)
operator -	multiprecision/cpp_int/literals.hpp	/^   operator - (number<cpp_int_backend<MinBits, MinBits, signed_magnitude, Checked, void>, et_off>&& a)$/;"	f	namespace:boost::multiprecision	signature:(number<cpp_int_backend<MinBits, MinBits, signed_magnitude, Checked, void>, et_off>&& a)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator -	multiprecision/detail/et_ops.hpp	/^   operator - (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator -	multiprecision/detail/et_ops.hpp	/^inline detail::expression<detail::negate, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v)
operator -	multiprecision/detail/et_ops.hpp	/^inline detail::expression<detail::negate, number<B, et_on> > operator - (const number<B, et_on>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& v)
operator -	multiprecision/detail/no_et_ops.hpp	/^   operator - (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator -	multiprecision/detail/no_et_ops.hpp	/^   operator - (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
operator -	multiprecision/detail/no_et_ops.hpp	/^   operator - (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator -	multiprecision/detail/no_et_ops.hpp	/^   operator - (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator -	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator -	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (const number<B, et_off>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& v)
operator -	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator -	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
operator -	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (number<B, et_off>&& v)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& v)
operator -	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if<is_signed_number<B>, number<B, et_off> >::type operator - (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
operator --	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator--(void)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
operator -=	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator-=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
operator -=	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator-=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator /	multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator /	multiprecision/detail/no_et_ops.hpp	/^   operator \/ (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator /	multiprecision/detail/no_et_ops.hpp	/^   operator \/ (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator /	multiprecision/detail/no_et_ops.hpp	/^   operator \/ (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator /	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator \/ (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator /	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator \/ (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator /=	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator\/=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
operator /=	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator\/=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
operator <	multiprecision/detail/number_compare.hpp	/^   operator < (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
operator <	multiprecision/detail/number_compare.hpp	/^   operator < (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
operator <	multiprecision/detail/number_compare.hpp	/^   operator < (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
operator <	multiprecision/detail/number_compare.hpp	/^   operator < (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
operator <	multiprecision/detail/number_compare.hpp	/^   operator < (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
operator <	multiprecision/detail/number_compare.hpp	/^inline bool operator < (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
operator <<	multiprecision/detail/et_ops.hpp	/^      operator << (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)
operator <<	multiprecision/detail/et_ops.hpp	/^   operator << (const number<B, et_on>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const I& b)
operator <<	multiprecision/detail/no_et_ops.hpp	/^   operator << (const number<B, et_off>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const I& b)
operator <<	multiprecision/detail/no_et_ops.hpp	/^   operator << (number<B, et_off>&& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const I& b)
operator <<	multiprecision/number.hpp	/^inline std::ostream& operator << (std::ostream& os, const expression<tag, A1, A2, A3, A4>& r)$/;"	f	namespace:boost::multiprecision::detail	signature:(std::ostream& os, const expression<tag, A1, A2, A3, A4>& r)
operator <<	multiprecision/number.hpp	/^inline std::ostream& operator << (std::ostream& os, const number<Backend, ExpressionTemplates>& r)$/;"	f	namespace:boost::multiprecision	signature:(std::ostream& os, const number<Backend, ExpressionTemplates>& r)
operator <=	multiprecision/detail/number_compare.hpp	/^   operator <= (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
operator <=	multiprecision/detail/number_compare.hpp	/^   operator <= (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
operator <=	multiprecision/detail/number_compare.hpp	/^   operator <= (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
operator <=	multiprecision/detail/number_compare.hpp	/^   operator <= (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
operator <=	multiprecision/detail/number_compare.hpp	/^   operator <= (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
operator <=	multiprecision/detail/number_compare.hpp	/^inline bool operator <= (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
operator =	multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (const char* s)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const char* s)
operator =	multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (const number_backend_float_architype& o)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const number_backend_float_architype& o)
operator =	multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (long double d)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long double d)
operator =	multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (long long i)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long long i)
operator =	multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(unsigned long long i)
operator =	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (const char* v)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const char* v)
operator =	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (const cpp_dec_float& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
operator =	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (long double v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(long double v)
operator =	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (long long v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(long long v)
operator =	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (unsigned long long v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(unsigned long long v)
operator =	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator=(const cpp_dec_float<D>& f)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float<D>& f)
operator =	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator= (long double a)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(long double a)
operator =	multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE cpp_int_backend& operator = (Arithmetic val)$/;"	f	namespace:boost::multiprecision	access:public	signature:(Arithmetic val)
operator =	multiprecision/cpp_int.hpp	/^   cpp_int_backend& operator = (const char* s)$/;"	f	namespace:boost::multiprecision	access:public	signature:(const char* s)
operator =	multiprecision/debug_adaptor.hpp	/^   debug_adaptor& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const char* s)
operator =	multiprecision/debug_adaptor.hpp	/^   debug_adaptor& operator = (const debug_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const debug_adaptor& o)
operator =	multiprecision/debug_adaptor.hpp	/^   typename enable_if_c<is_arithmetic<T>::value || is_convertible<T, Backend>::value, debug_adaptor&>::type operator = (const T& i)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(const T& i)
operator =	multiprecision/detail/default_ops.hpp	/^   terminal& operator = (R val) {  value = val;  }$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:(R val)
operator =	multiprecision/detail/number_base.hpp	/^   expression& operator=(const expression&);$/;"	p	struct:boost::multiprecision::detail::expression	access:private	signature:(const expression&)
operator =	multiprecision/float128.hpp	/^   float128_backend& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(const char* s)
operator =	multiprecision/float128.hpp	/^   float128_backend& operator = (const float128_backend& o) $/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(const float128_backend& o)
operator =	multiprecision/float128.hpp	/^   typename enable_if_c<is_arithmetic<T>::value || is_convertible<T, float128_type>::value, float128_backend&>::type operator = (const T& i)$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(const T& i)
operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const V& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(const V& v)
operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const V& v)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const V& v)
operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_float& o)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float& o)
operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_float<D>& o)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float<D>& o)
operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_float<D>& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(const gmp_float<D>& o)
operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_int& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(const gmp_int& o)
operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_int& o);$/;"	p	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_int& o)
operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_rational& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(const gmp_rational& o)
operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_rational& o)
operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpf_t val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpf_t val)
operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpf_t val)
operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpq_t val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpq_t val)
operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpq_t val)
operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpz_t val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpz_t val)
operator =	multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpz_t val)
operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(const char* s)
operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (const gmp_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(const gmp_float_imp& o)
operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (double d)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(double d)
operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (long double a)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(long double a)
operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(long i)
operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (long long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(long long i)
operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (unsigned long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(unsigned long i)
operator =	multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(unsigned long long i)
operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (const char* s)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const char* s)
operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (const gmp_int& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_int& o)
operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (double d)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(double d)
operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (long double a)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(long double a)
operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(long i)
operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (long long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(long long i)
operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (unsigned long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(unsigned long i)
operator =	multiprecision/gmp.hpp	/^   gmp_int& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(unsigned long long i)
operator =	multiprecision/gmp.hpp	/^   gmp_int& operator=(const gmp_float<Digits10>& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_float<Digits10>& o)
operator =	multiprecision/gmp.hpp	/^   gmp_int& operator=(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_rational& o)
operator =	multiprecision/gmp.hpp	/^   gmp_int& operator=(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpf_t val)
operator =	multiprecision/gmp.hpp	/^   gmp_int& operator=(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpq_t val)
operator =	multiprecision/gmp.hpp	/^   gmp_int& operator=(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpz_t val)
operator =	multiprecision/gmp.hpp	/^inline gmp_float<0>& gmp_float<0>::operator=(const gmp_int& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_int& o)
operator =	multiprecision/gmp.hpp	/^inline gmp_float<0>& gmp_float<0>::operator=(const gmp_rational& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_rational& o)
operator =	multiprecision/gmp.hpp	/^inline gmp_float<Digits10>& gmp_float<Digits10>::operator=(const gmp_int& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_int& o)
operator =	multiprecision/gmp.hpp	/^inline gmp_float<Digits10>& gmp_float<Digits10>::operator=(const gmp_rational& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_rational& o)
operator =	multiprecision/gmp.hpp	/^inline gmp_int& gmp_int::operator=(const gmp_rational& o)$/;"	f	class:boost::gmp_int	signature:(const gmp_rational& o)
operator =	multiprecision/logged_adaptor.hpp	/^   logged_adaptor& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(const char* s)
operator =	multiprecision/logged_adaptor.hpp	/^   logged_adaptor& operator = (const logged_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(const logged_adaptor& o)
operator =	multiprecision/logged_adaptor.hpp	/^   typename enable_if_c<is_arithmetic<T>::value || is_convertible<T, Backend>::value, logged_adaptor&>::type operator = (const T& i)$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(const T& i)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const V& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(const V& v)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const V& v)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const V& v)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const mpfi_float_backend& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpfi_float_backend& o)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const mpfi_float_backend& o)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_float_backend& o)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const mpfi_float_backend<D>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpfi_float_backend<D>& val)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const mpfi_float_backend<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_float_backend<D>& val)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const mpfi_t val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpfi_t val)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const mpfi_t val)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfi_t val)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_backend& operator=(const mpfr_float_backend<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfi_float_backend	access:public	signature:(const mpfr_float_backend<D>& val)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(const char* s)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (const mpfi_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(const mpfi_float_imp& o)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (double d)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(double d)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (long double a)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(long double a)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(long i)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (long long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(long long i)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (unsigned long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(unsigned long i)
operator =	multiprecision/mpfi.hpp	/^   mpfi_float_imp& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(unsigned long long i)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const V& v)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const V& v)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const gmp_float<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const gmp_int& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_int& val)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const gmp_rational& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_rational& val)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpf_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpf_t val)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_float_backend& o)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_float_backend<D, AT>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D, AT>& val)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_float_backend<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D>& val)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_t val)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpq_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpq_t val)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpz_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpz_t val)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(const char* s)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (const mpfr_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(const mpfr_float_imp& o)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (double d)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(double d)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (long double a)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(long double a)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(long i)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (long long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(long long i)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (unsigned long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(unsigned long i)
operator =	multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(unsigned long long i)
operator =	multiprecision/number.hpp	/^   typename boost::enable_if<is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>, number&>::type operator=(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
operator =	multiprecision/rational_adaptor.hpp	/^   rational_adaptor& operator = (const IntBackend& o)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const IntBackend& o)
operator =	multiprecision/rational_adaptor.hpp	/^   rational_adaptor& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const char* s)
operator =	multiprecision/rational_adaptor.hpp	/^   rational_adaptor& operator = (const rational_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const rational_adaptor& o)
operator =	multiprecision/rational_adaptor.hpp	/^   rational_adaptor& operator = (rational_adaptor&& o)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(rational_adaptor&& o)
operator =	multiprecision/rational_adaptor.hpp	/^   typename enable_if<is_floating_point<Float>, rational_adaptor&>::type operator = (Float i)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(Float i)
operator =	multiprecision/rational_adaptor.hpp	/^   typename enable_if<is_integral<Int>, rational_adaptor&>::type operator = (Int i)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(Int i)
operator =	multiprecision/rational_adaptor.hpp	/^   typename enable_if_c<(boost::multiprecision::detail::is_explicitly_convertible<U, IntBackend>::value && !is_arithmetic<U>::value), rational_adaptor&>::type operator = (const U& u) $/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const U& u)
operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (boost::int32_t i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(boost::int32_t i)
operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (boost::uint32_t i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(boost::uint32_t i)
operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const char* s)
operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (const tommath_int& o)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const tommath_int& o)
operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (long double a)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(long double a)
operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (long long i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(long long i)
operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (tommath_int&& o)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(tommath_int&& o)
operator =	multiprecision/tommath.hpp	/^   tommath_int& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(unsigned long long i)
operator ==	multiprecision/detail/number_compare.hpp	/^   operator == (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
operator ==	multiprecision/detail/number_compare.hpp	/^   operator == (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
operator ==	multiprecision/detail/number_compare.hpp	/^   operator == (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
operator ==	multiprecision/detail/number_compare.hpp	/^   operator == (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
operator ==	multiprecision/detail/number_compare.hpp	/^   operator == (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
operator ==	multiprecision/detail/number_compare.hpp	/^inline bool operator == (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
operator ==	multiprecision/detail/ublas_interop.hpp	/^inline bool operator == (const sparse_vector_element<V>& a, const ::boost::multiprecision::number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::numeric::ublas	signature:(const sparse_vector_element<V>& a, const ::boost::multiprecision::number<Backend, ExpressionTemplates>& b)
operator ==	multiprecision/number.hpp	/^typename boost::enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator == (const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)
operator ==	multiprecision/number.hpp	/^typename boost::enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator == (const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)
operator >	multiprecision/detail/number_compare.hpp	/^   operator > (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
operator >	multiprecision/detail/number_compare.hpp	/^   operator > (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
operator >	multiprecision/detail/number_compare.hpp	/^   operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
operator >	multiprecision/detail/number_compare.hpp	/^   operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
operator >	multiprecision/detail/number_compare.hpp	/^   operator > (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
operator >	multiprecision/detail/number_compare.hpp	/^inline bool operator > (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
operator >=	multiprecision/detail/number_compare.hpp	/^   operator >= (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
operator >=	multiprecision/detail/number_compare.hpp	/^   operator >= (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
operator >=	multiprecision/detail/number_compare.hpp	/^   operator >= (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
operator >=	multiprecision/detail/number_compare.hpp	/^   operator >= (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
operator >=	multiprecision/detail/number_compare.hpp	/^   operator >= (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
operator >=	multiprecision/detail/number_compare.hpp	/^inline bool operator >= (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
operator >>	multiprecision/detail/et_ops.hpp	/^      operator >> (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)
operator >>	multiprecision/detail/et_ops.hpp	/^      operator >> (const number<B, et_on>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const I& b)
operator >>	multiprecision/detail/no_et_ops.hpp	/^   operator >> (const number<B, et_off>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const I& b)
operator >>	multiprecision/detail/no_et_ops.hpp	/^   operator >> (number<B, et_off>&& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const I& b)
operator >>	multiprecision/number.hpp	/^inline std::istream& operator >> (std::istream& is, number<Backend, ExpressionTemplates>& r)$/;"	f	namespace:boost::multiprecision	signature:(std::istream& is, number<Backend, ExpressionTemplates>& r)
operator >>	multiprecision/number.hpp	/^inline std::istream& operator >> (std::istream& is, rational<multiprecision::number<Backend, ExpressionTemplates> >& r)$/;"	f	namespace:boost	signature:(std::istream& is, rational<multiprecision::number<Backend, ExpressionTemplates> >& r)
operator R	multiprecision/detail/default_ops.hpp	/^   operator R()const {  return value;  }$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:() const
operator ^	multiprecision/detail/et_ops.hpp	/^      operator^ (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator ^	multiprecision/detail/et_ops.hpp	/^      operator^ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator ^	multiprecision/detail/et_ops.hpp	/^      operator^ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator ^	multiprecision/detail/et_ops.hpp	/^      operator^ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
operator ^	multiprecision/detail/et_ops.hpp	/^      operator^ (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator ^	multiprecision/detail/et_ops.hpp	/^      operator^ (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator ^	multiprecision/detail/et_ops.hpp	/^      operator^ (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator ^	multiprecision/detail/et_ops.hpp	/^   operator^ (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator ^	multiprecision/detail/no_et_ops.hpp	/^   operator ^ (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator ^	multiprecision/detail/no_et_ops.hpp	/^   operator ^ (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
operator ^	multiprecision/detail/no_et_ops.hpp	/^   operator ^ (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator ^	multiprecision/detail/no_et_ops.hpp	/^   operator ^ (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator ^	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator ^ (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator ^	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator ^ (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
operator ^	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator ^ (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator ^	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator ^ (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
operator bool	multiprecision/detail/number_base.hpp	/^   explicit operator bool()const$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
operator unmentionable_type	multiprecision/detail/number_base.hpp	/^   operator unmentionable_type()const$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
operator |	multiprecision/detail/et_ops.hpp	/^      operator| (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator |	multiprecision/detail/et_ops.hpp	/^      operator| (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator |	multiprecision/detail/et_ops.hpp	/^      operator| (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator |	multiprecision/detail/et_ops.hpp	/^      operator| (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator |	multiprecision/detail/et_ops.hpp	/^      operator| (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
operator |	multiprecision/detail/et_ops.hpp	/^      operator| (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator |	multiprecision/detail/et_ops.hpp	/^      operator| (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator |	multiprecision/detail/et_ops.hpp	/^   operator| (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator |	multiprecision/detail/no_et_ops.hpp	/^   operator | (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator |	multiprecision/detail/no_et_ops.hpp	/^   operator | (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
operator |	multiprecision/detail/no_et_ops.hpp	/^   operator | (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator |	multiprecision/detail/no_et_ops.hpp	/^   operator | (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator |	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator | (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator |	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator | (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
operator |	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator | (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator |	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator | (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
operator ~	multiprecision/detail/et_ops.hpp	/^      operator ~ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v) { return detail::expression<detail::bitwise_complement, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(v); }$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v)
operator ~	multiprecision/detail/et_ops.hpp	/^      operator ~ (const number<B, et_on>& v) { return detail::expression<detail::complement_immediates, number<B, et_on> >(v); }$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& v)
operator ~	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator ~ (const number<B, et_off>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& v)
operator ~	multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if_c<number_category<B>::value == number_kind_integer, number<B, et_off> >::type operator ~ (number<B, et_off>&& v)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& v)
order	multiprecision/cpp_dec_float.hpp	/^   ExponentType order()const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:() const
overlap	multiprecision/mpfi.hpp	/^inline bool overlap(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  b)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& b)
p	multiprecision/cpp_int/literals.hpp	/^   static constexpr Pack p = {};$/;"	m	struct:boost::multiprecision::literals::detail::make_backend_from_pack	access:public
pack_type	multiprecision/cpp_int/literals.hpp	/^      recursive_packed_type>::type pack_type;$/;"	t	struct:boost::multiprecision::literals::detail::pack_values	access:public
pack_values	multiprecision/cpp_int/literals.hpp	/^struct pack_values$/;"	s	namespace:boost::multiprecision::literals::detail
pack_values	multiprecision/cpp_int/literals.hpp	/^struct pack_values<NextChar>$/;"	s	namespace:boost::multiprecision::literals::detail
packed_type	multiprecision/cpp_int/literals.hpp	/^   typedef typename pack_values<STR...>::type packed_type;$/;"	t	struct:boost::multiprecision::literals::detail::make_packed_value_from_str	access:public
param	multiprecision/random.hpp	/^    param_type param() const { return param_type(_min, _max); }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
param	multiprecision/random.hpp	/^    void param(const param_type& parm)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(const param_type& parm)
param_type	multiprecision/random.hpp	/^        param_type(result_type const& min_arg = 0, result_type const& max_arg = 9)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(result_type const& min_arg = 0, result_type const& max_arg = 9)
param_type	multiprecision/random.hpp	/^    class param_type$/;"	c	class:boost::random::uniform_smallint	access:public
plus	multiprecision/detail/number_base.hpp	/^struct plus{};$/;"	s	namespace:boost::multiprecision::detail
policies	multiprecision/cpp_dec_float.hpp	/^namespace policies{$/;"	n	namespace:boost::math
policies	multiprecision/debug_adaptor.hpp	/^namespace policies{$/;"	n	namespace:boost::math
policies	multiprecision/logged_adaptor.hpp	/^namespace policies{$/;"	n	namespace:boost::math
pow2	multiprecision/cpp_dec_float.hpp	/^   static cpp_dec_float pow2(long long i);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(long long i)
pow2	multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator> cpp_dec_float<Digits10, ExponentType, Allocator>::pow2(const long long p)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const long long p)
pow_imp	multiprecision/detail/functions/pow.hpp	/^inline void pow_imp(T& result, const T& t, const U& p, const mpl::false_&)$/;"	f	namespace:detail	signature:(T& result, const T& t, const U& p, const mpl::false_&)
pow_imp	multiprecision/detail/functions/pow.hpp	/^inline void pow_imp(T& result, const T& t, const U& p, const mpl::true_&)$/;"	f	namespace:detail	signature:(T& result, const T& t, const U& p, const mpl::true_&)
powm	multiprecision/detail/integer_ops.hpp	/^   powm(const T& b, const U& p, const V& mod)$/;"	f	namespace:boost::multiprecision	signature:(const T& b, const U& p, const V& mod)
powm_func	multiprecision/detail/integer_ops.hpp	/^struct powm_func$/;"	s	namespace:boost::multiprecision::default_ops
powq	multiprecision/float128.hpp	82;"	d
prec_elem	multiprecision/cpp_dec_float.hpp	/^   boost::int32_t  prec_elem;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
precision	multiprecision/cpp_dec_float.hpp	/^   void precision(const boost::int32_t prec_digits) $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const boost::int32_t prec_digits)
precision	multiprecision/cpp_dec_float.hpp	/^struct precision< boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates>, Policy>$/;"	s	namespace:boost::math::policies
precision	multiprecision/debug_adaptor.hpp	/^struct precision< boost::multiprecision::number<boost::multiprecision::debug_adaptor<Backend>, ExpressionTemplates>, Policy>$/;"	s	namespace:boost::math::policies	inherits:precision
precision	multiprecision/logged_adaptor.hpp	/^struct precision< boost::multiprecision::number<boost::multiprecision::logged_adaptor<Backend>, ExpressionTemplates>, Policy>$/;"	s	namespace:boost::math::policies	inherits:precision
precision_type	multiprecision/cpp_dec_float.hpp	/^   typedef typename Policy::precision_type precision_type;$/;"	t	struct:boost::math::policies::precision	access:public
precision_type	multiprecision/detail/big_lanczos.hpp	/^   typedef typename boost::math::policies::precision<multiprecision::number<Backend, ExpressionTemplates>, Policy>::type precision_type;$/;"	t	struct:boost::math::lanczos::lanczos	access:public
pred_type	multiprecision/detail/default_ops.hpp	/^   typedef typename has_enough_bits<R, std::numeric_limits<R>::digits>::template type<mpl::_> pred_type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
pred_type	multiprecision/detail/number_base.hpp	/^   typedef typename has_enough_bits<bits_of<Val>::value>::template type<mpl::_> pred_type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
proc	multiprecision/detail/number_base.hpp	/^   unmentionable* proc(){ return 0; }$/;"	f	struct:boost::multiprecision::detail::unmentionable	access:public	signature:()
promote_arg	multiprecision/detail/number_base.hpp	/^struct promote_arg<boost::multiprecision::detail::expression<tag, A1, A2, A3, A4> >$/;"	s	namespace:boost::math::tools
promote_traits	multiprecision/detail/ublas_interop.hpp	/^struct promote_traits<boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::detail::expression<tagb, Arg1b, Arg2b, Arg3b, Arg4b> >$/;"	s	namespace:boost::numeric::ublas
promote_traits	multiprecision/detail/ublas_interop.hpp	/^struct promote_traits<boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>, boost::multiprecision::number<Backend1, ExpressionTemplates1> >$/;"	s	namespace:boost::numeric::ublas
promote_traits	multiprecision/detail/ublas_interop.hpp	/^struct promote_traits<boost::multiprecision::number<Backend1, ExpressionTemplates1>, boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >$/;"	s	namespace:boost::numeric::ublas
promote_traits	multiprecision/detail/ublas_interop.hpp	/^struct promote_traits<boost::multiprecision::number<Backend1, ExpressionTemplates1>, boost::multiprecision::number<Backend2, ExpressionTemplates2> >$/;"	s	namespace:boost::numeric::ublas
promote_type	multiprecision/detail/ublas_interop.hpp	/^   >::type promote_type;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
promote_type	multiprecision/detail/ublas_interop.hpp	/^   typedef typename promote_traits<number1_t, number2_t>::promote_type promote_type;$/;"	t	struct:boost::numeric::ublas::promote_traits	access:public
proper_subset	multiprecision/mpfi.hpp	/^inline bool proper_subset(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  b)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& b)
quiet_NaN	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> quiet_NaN    (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::nan(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
quiet_NaN	multiprecision/cpp_int/limits.hpp	/^   static number_type quiet_NaN() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
quiet_NaN	multiprecision/float128.hpp	/^   static number_type quiet_NaN() { return number_type("nan"); }$/;"	f	class:std::numeric_limits	access:public	signature:()
quiet_NaN	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type quiet_NaN() { return base_type::quiet_NaN(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
quiet_NaN	multiprecision/tommath.hpp	/^   static number_type quiet_NaN() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
radix	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     radix             = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_radix;$/;"	m	class:std::numeric_limits	access:public
radix	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::radix;$/;"	m	class:std::numeric_limits
radix	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int radix = 2;$/;"	m	class:std::numeric_limits	access:public
radix	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::radix;$/;"	m	class:std::numeric_limits
radix	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int radix = 2;$/;"	m	class:std::numeric_limits	access:public
radix	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int radix = 2;$/;"	m	class:std::numeric_limits	access:public
radix	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::radix;$/;"	m	class:std::numeric_limits
raise_add_overflow	multiprecision/cpp_int/checked.hpp	/^inline void raise_add_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
raise_div_overflow	multiprecision/cpp_int/checked.hpp	/^inline void raise_div_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
raise_mul_overflow	multiprecision/cpp_int/checked.hpp	/^inline void raise_mul_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
raise_overflow	multiprecision/cpp_int/checked.hpp	/^inline void raise_overflow(std::string op)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(std::string op)
raise_subtract_overflow	multiprecision/cpp_int/checked.hpp	/^inline void raise_subtract_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
random	multiprecision/random.hpp	/^namespace boost{ namespace random{ namespace detail{$/;"	n	namespace:boost
random	multiprecision/random.hpp	/^namespace random{$/;"	n	namespace:boost
range	multiprecision/detail/default_ops.hpp	/^   typedef mpl::iterator_range<start_seq, typename mpl::end<list_type>::type> range;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
rational_adaptor	multiprecision/rational_adaptor.hpp	/^   explicit rational_adaptor(const U& u, $/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const U& u, typename enable_if_c< boost::multiprecision::detail::is_explicitly_convertible<U, IntBackend>::value && !is_convertible<U, IntBackend>::value >::type* = 0)
rational_adaptor	multiprecision/rational_adaptor.hpp	/^   rational_adaptor(){}$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:()
rational_adaptor	multiprecision/rational_adaptor.hpp	/^   rational_adaptor(IntBackend&& o) : m_value(o) {}$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(IntBackend&& o)
rational_adaptor	multiprecision/rational_adaptor.hpp	/^   rational_adaptor(const IntBackend& o) : m_value(o) {}$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const IntBackend& o)
rational_adaptor	multiprecision/rational_adaptor.hpp	/^   rational_adaptor(const U& u, typename enable_if_c<is_convertible<U, IntBackend>::value>::type* = 0) $/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const U& u, typename enable_if_c<is_convertible<U, IntBackend>::value>::type* = 0)
rational_adaptor	multiprecision/rational_adaptor.hpp	/^   rational_adaptor(const rational_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(const rational_adaptor& o)
rational_adaptor	multiprecision/rational_adaptor.hpp	/^   rational_adaptor(rational_adaptor&& o) : m_value(o.m_value) {}$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(rational_adaptor&& o)
rational_adaptor	multiprecision/rational_adaptor.hpp	/^struct rational_adaptor$/;"	s	namespace:boost::multiprecision::backends
rational_type	multiprecision/rational_adaptor.hpp	/^   typedef boost::rational<integer_type>        rational_type;$/;"	t	struct:boost::multiprecision::backends::rational_adaptor	access:public
rd_string	multiprecision/cpp_dec_float.hpp	/^   bool rd_string(const char* const s);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const char* const s)
rd_string	multiprecision/cpp_dec_float.hpp	/^bool cpp_dec_float<Digits10, ExponentType, Allocator>::rd_string(const char* const s)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const char* const s)
real_cast	multiprecision/detail/number_base.hpp	/^inline R real_cast(const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>& val)$/;"	f	namespace:boost::math::tools	signature:(const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>& val)
real_cast	multiprecision/detail/number_base.hpp	/^inline R real_cast(const boost::multiprecision::number<B, ET>& val)$/;"	f	namespace:boost::math::tools	signature:(const boost::multiprecision::number<B, ET>& val)
rebind	multiprecision/detail/rebind.hpp	/^    struct rebind$/;"	s	namespace:boost::multiprecision::backends::detail
recursive_packed_type	multiprecision/cpp_int/literals.hpp	/^   typedef typename pack_values<CHARS...>::type recursive_packed_type;$/;"	t	struct:boost::multiprecision::literals::detail::pack_values	access:public
reset	multiprecision/random.hpp	/^    void reset() { }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:()
resize_for_carry	multiprecision/cpp_int/multiply.hpp	/^inline void resize_for_carry(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& \/*result*\/, unsigned \/*required*\/){}$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& , unsigned )
resize_for_carry	multiprecision/cpp_int/multiply.hpp	/^inline void resize_for_carry(cpp_int_backend<MinBits1, MaxBits1, SignType1, checked, void>& result, unsigned required)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, checked, void>& result, unsigned required)
result_type	multiprecision/detail/number_base.hpp	/^   >::type result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
result_type	multiprecision/detail/number_base.hpp	/^   typedef Arg1 result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
result_type	multiprecision/detail/number_base.hpp	/^   typedef typename combine_expression<left_result_type, right_result_type>::type result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
result_type	multiprecision/detail/number_base.hpp	/^   typedef typename left_type::result_type result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
result_type	multiprecision/mpfi.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> result_type;$/;"	t	struct:math::constants::detail::constant_catalan	access:public
result_type	multiprecision/mpfi.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> result_type;$/;"	t	struct:math::constants::detail::constant_euler	access:public
result_type	multiprecision/mpfi.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> result_type;$/;"	t	struct:math::constants::detail::constant_ln_two	access:public
result_type	multiprecision/mpfi.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::mpfi_float_backend<Digits10>, ExpressionTemplates> result_type;$/;"	t	struct:math::constants::detail::constant_pi	access:public
result_type	multiprecision/random.hpp	/^    typedef boost::multiprecision::number<Backend, ExpressionTemplates> result_type;$/;"	t	class:boost::random::independent_bits_engine	access:public
result_type	multiprecision/random.hpp	/^    typedef boost::multiprecision::number<Backend, ExpressionTemplates> result_type;$/;"	t	class:boost::random::uniform_smallint	access:public
result_type	multiprecision/random.hpp	/^  typedef boost::multiprecision::number<Backend, ExpressionTemplates> result_type;$/;"	t	struct:boost::random::detail::subtract	access:public
reverse_value_pack	multiprecision/cpp_int/literals.hpp	/^struct reverse_value_pack<value_pack<> >$/;"	s	namespace:boost::multiprecision::literals::detail
reverse_value_pack	multiprecision/cpp_int/literals.hpp	/^struct reverse_value_pack<value_pack<v, VALUES...> >$/;"	s	namespace:boost::multiprecision::literals::detail
reverse_value_pack	multiprecision/cpp_int/literals.hpp	/^struct reverse_value_pack<value_pack<v> >$/;"	s	namespace:boost::multiprecision::literals::detail
right	multiprecision/detail/number_base.hpp	/^   right_type right()const { return right_type(arg2); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
right	multiprecision/detail/number_base.hpp	/^   right_type right()const { return right_type(arg3); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
right	multiprecision/detail/number_base.hpp	/^   right_type right()const { return right_type(arg4); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
right_depth	multiprecision/detail/number_base.hpp	/^   static const unsigned right_depth = right_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
right_max_depth	multiprecision/detail/number_base.hpp	/^   static const unsigned right_max_depth = right_depth > right_middle_depth ? right_depth : right_middle_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
right_middle	multiprecision/detail/number_base.hpp	/^   right_middle_type right_middle()const { return right_middle_type(arg3); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
right_middle_depth	multiprecision/detail/number_base.hpp	/^   static const unsigned right_middle_depth = right_middle_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
right_middle_result_type	multiprecision/detail/number_base.hpp	/^   typedef typename right_middle_type::result_type right_middle_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
right_middle_type	multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg3>::type right_middle_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
right_result_type	multiprecision/detail/number_base.hpp	/^   typedef typename right_type::result_type right_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
right_type	multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg2>::type right_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
right_type	multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg3>::type right_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
right_type	multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg4>::type right_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
round	multiprecision/detail/default_ops.hpp	/^inline number<T, ExpressionTemplates> round(const number<T, ExpressionTemplates>& v, const Policy&)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy&)
round	multiprecision/detail/default_ops.hpp	/^inline typename detail::expression<tag, A1, A2, A3, A4>::result_type round(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
round_error	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> round_error  (void)  { return 0.5L; }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
round_error	multiprecision/cpp_int/limits.hpp	/^   static number_type round_error() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
round_error	multiprecision/float128.hpp	/^   static number_type round_error() { return 0.5; }$/;"	f	class:std::numeric_limits	access:public	signature:()
round_error	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type round_error() { return epsilon() \/ 2; }$/;"	f	class:std::numeric_limits	access:public	signature:()
round_error	multiprecision/tommath.hpp	/^   static number_type round_error() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
round_string_up_at	multiprecision/detail/float_string_cvt.hpp	/^inline void round_string_up_at(std::string& s, int pos, int& expon)$/;"	f	namespace:boost::multiprecision::detail	signature:(std::string& s, int pos, int& expon)
round_style	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR std::float_round_style  round_style       = std::round_indeterminate;$/;"	m	class:std::numeric_limits	access:public
round_style	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST float_round_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::round_style;$/;"	m	class:std::numeric_limits
round_style	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR float_round_style round_style = round_toward_zero;$/;"	m	class:std::numeric_limits	access:public
round_style	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST float_round_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::round_style;$/;"	m	class:std::numeric_limits
round_style	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR float_round_style round_style = round_to_nearest;$/;"	m	class:std::numeric_limits	access:public
round_style	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR float_round_style round_style = round_toward_zero;$/;"	m	class:std::numeric_limits	access:public
round_style	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST float_round_style numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::round_style;$/;"	m	class:std::numeric_limits
seed	multiprecision/random.hpp	/^    template<class It> void seed(It& first, It last)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(It& first, It last)
seed	multiprecision/random.hpp	/^    void seed() { _base.seed(); }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
select_uniform_01	multiprecision/random.hpp	/^struct select_uniform_01<boost::multiprecision::number<Backend, ExpressionTemplates> >$/;"	s	namespace:boost::random::detail
selector	multiprecision/traits/explicit_conversion.hpp	/^   static type_traits::no_type selector(...);$/;"	p	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public	signature:(....)
selector	multiprecision/traits/explicit_conversion.hpp	/^   static type_traits::yes_type selector(dummy_size<sizeof(static_cast<T1>(declval<S1>()))>*);$/;"	p	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public	signature:(dummy_size<sizeof(static_cast<T1>(declval<S1>()))>*)
self	multiprecision/cpp_int.hpp	/^   typedef cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> self;$/;"	t	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
self_type	multiprecision/number.hpp	/^   typedef number<Backend, ExpressionTemplates> self_type;$/;"	t	class:boost::multiprecision::number	access:private
serialization	multiprecision/cpp_int/serialize.hpp	/^namespace serialization {$/;"	n	namespace:boost
serialization	multiprecision/float128.hpp	/^namespace serialization{ namespace float128_detail{$/;"	n	namespace:boost
serialize	multiprecision/cpp_dec_float.hpp	/^   void serialize(Archive & ar, const unsigned int \/*version*\/)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(Archive & ar, const unsigned int )
serialize	multiprecision/cpp_int/serialize.hpp	/^void serialize(Archive & ar, mp::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>& val, const unsigned int \/*version*\/)$/;"	f	namespace:boost::serialization	signature:(Archive & ar, mp::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>& val, const unsigned int )
serialize	multiprecision/debug_adaptor.hpp	/^   void serialize(Archive& ar, const unsigned int \/*version*\/)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(Archive& ar, const unsigned int )
serialize	multiprecision/float128.hpp	/^void serialize(Archive& ar, boost::multiprecision::backends::float128_backend& val, unsigned int \/*version*\/)$/;"	f	namespace:boost::serialization	signature:(Archive& ar, boost::multiprecision::backends::float128_backend& val, unsigned int )
serialize	multiprecision/logged_adaptor.hpp	/^   void serialize(Archive& ar, const unsigned int \/*version*\/)$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(Archive& ar, const unsigned int )
serialize	multiprecision/rational_adaptor.hpp	/^   void serialize(Archive& ar, const mpl::false_&)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(Archive& ar, const mpl::false_&)
serialize	multiprecision/rational_adaptor.hpp	/^   void serialize(Archive& ar, const mpl::true_&)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(Archive& ar, const mpl::true_&)
serialize	multiprecision/rational_adaptor.hpp	/^   void serialize(Archive& ar, const unsigned int \/*version*\/)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(Archive& ar, const unsigned int )
shift	multiprecision/cpp_int/literals.hpp	/^   static constexpr unsigned shift = ((sizeof...(CHARS)) % chars_per_limb) * 4;$/;"	m	struct:boost::multiprecision::literals::detail::pack_values	access:public
shift_left	multiprecision/detail/number_base.hpp	/^struct shift_left{};$/;"	s	namespace:boost::multiprecision::detail
shift_right	multiprecision/detail/number_base.hpp	/^struct shift_right{};$/;"	s	namespace:boost::multiprecision::detail
sign	multiprecision/cpp_int.hpp	/^      this->sign(false);$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(false)
sign_bit_mask	multiprecision/cpp_int.hpp	/^const limb_type cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::sign_bit_mask;$/;"	m	class:boost::multiprecision::cpp_int_base
signaling_NaN	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> signaling_NaN(void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::zero(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
signaling_NaN	multiprecision/cpp_int/limits.hpp	/^   static number_type signaling_NaN() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
signaling_NaN	multiprecision/float128.hpp	/^   static number_type signaling_NaN() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
signaling_NaN	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type signaling_NaN() { return base_type::signaling_NaN(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
signaling_NaN	multiprecision/tommath.hpp	/^   static number_type signaling_NaN() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
signed_cpp_int_literal_result_type	multiprecision/cpp_int/literals.hpp	/^struct signed_cpp_int_literal_result_type$/;"	s	namespace:boost::multiprecision::literals::detail
signed_double_limb_type	multiprecision/cpp_int/cpp_int_config.hpp	/^typedef boost::int128_type signed_double_limb_type;$/;"	t	namespace:boost::multiprecision
signed_limb_type	multiprecision/cpp_int/cpp_int_config.hpp	/^typedef detail::largest_signed_type<64>::type signed_limb_type;$/;"	t	namespace:boost::multiprecision
signed_magnitude	multiprecision/cpp_int/cpp_int_config.hpp	/^   signed_magnitude = 1,$/;"	e	enum:boost::multiprecision::cpp_integer_type
signed_packed	multiprecision/cpp_int/cpp_int_config.hpp	/^   signed_packed = 3,$/;"	e	enum:boost::multiprecision::cpp_integer_type
signed_types	multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef mpl::list<long long>                 signed_types;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
signed_types	multiprecision/cpp_dec_float.hpp	/^   typedef mpl::list<long long>           signed_types;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
signed_types	multiprecision/debug_adaptor.hpp	/^   typedef typename Backend::signed_types              signed_types;$/;"	t	struct:boost::multiprecision::backends::debug_adaptor	access:public
signed_types	multiprecision/float128.hpp	/^   typedef mpl::list<signed char, short, int, long, long long>   signed_types;$/;"	t	struct:boost::multiprecision::backends::float128_backend	access:public
signed_types	multiprecision/gmp.hpp	/^   typedef mpl::list<long, long long>                     signed_types;$/;"	t	struct:boost::multiprecision::gmp_int	access:public
signed_types	multiprecision/gmp.hpp	/^   typedef mpl::list<long, long long>                 signed_types;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
signed_types	multiprecision/logged_adaptor.hpp	/^   typedef typename Backend::signed_types              signed_types;$/;"	t	struct:boost::multiprecision::backends::logged_adaptor	access:public
signed_types	multiprecision/mpfi.hpp	/^   typedef mpl::list<long, long long>                     signed_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public
signed_types	multiprecision/mpfr.hpp	/^   typedef mpl::list<long, long long>                     signed_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
signed_types	multiprecision/rational_adaptor.hpp	/^   typedef typename IntBackend::signed_types    signed_types;$/;"	t	struct:boost::multiprecision::backends::rational_adaptor	access:public
signed_types	multiprecision/tommath.hpp	/^   typedef mpl::list<boost::int32_t, long long>             signed_types;$/;"	t	struct:boost::multiprecision::backends::tommath_int	access:public
sinc_pi	multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x)
sinc_pi	multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)
sinc_pi_imp	multiprecision/detail/default_ops.hpp	/^   template <class T> T sinc_pi_imp(T);$/;"	p	namespace:boost::math::detail	signature:(T)
singleton	multiprecision/mpfi.hpp	/^inline bool singleton(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  a)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a)
sinhc_pi	multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinhc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x)
sinhc_pi	multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinhc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)
sinhc_pi_imp	multiprecision/detail/default_ops.hpp	/^   template <class T> T sinhc_pi_imp(T);$/;"	p	namespace:boost::math::detail	signature:(T)
sinhcosh	multiprecision/detail/functions/pow.hpp	/^   void sinhcosh(const T& x, T* p_sinh, T* p_cosh)$/;"	f	namespace:detail	signature:(const T& x, T* p_sinh, T* p_cosh)
sinhq	multiprecision/float128.hpp	91;"	d
sinq	multiprecision/float128.hpp	85;"	d
sizeof	multiprecision/cpp_dec_float.hpp	/^   BOOST_STATIC_ASSERT_MSG(sizeof(ExponentType) > 1, "ExponentType is too small.");$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(ExponentType)
small_sinh_series	multiprecision/detail/functions/pow.hpp	/^   void small_sinh_series(T x, T& result)$/;"	f	namespace:detail	signature:(T x, T& result)
sqrt	multiprecision/detail/default_ops.hpp	/^   sqrt(const number<B, ExpressionTemplates>& x)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ExpressionTemplates>& x)
sqrt	multiprecision/detail/default_ops.hpp	/^   sqrt(const number<B, ExpressionTemplates>& x, number<B, ExpressionTemplates>& r)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ExpressionTemplates>& x, number<B, ExpressionTemplates>& r)
sqrt	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer>::type sqrt(const Integer& x)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& x)
sqrt	multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer>::type sqrt(const Integer& x, Integer& r)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& x, Integer& r)
sqrtq	multiprecision/float128.hpp	79;"	d
start_last	multiprecision/detail/default_ops.hpp	/^   >::type start_last;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
start_seq	multiprecision/detail/default_ops.hpp	/^   typedef typename mpl::if_<is_same<start_last, typename mpl::end<list_type>::type>, typename mpl::begin<list_type>::type, start_last>::type start_seq;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
static_cast	multiprecision/mpfr.hpp	/^   mpfr_float_backend(mpfr_float_backend&& o) BOOST_NOEXCEPT : detail::mpfr_float_imp<0, allocate_dynamic>(static_cast<detail::mpfr_float_imp<0, allocate_dynamic>&&>(o)) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(o)
std	multiprecision/concepts/mp_number_archetypes.hpp	/^namespace std{$/;"	n
std	multiprecision/cpp_dec_float.hpp	/^namespace std$/;"	n
std	multiprecision/cpp_int/limits.hpp	/^namespace std{$/;"	n
std	multiprecision/debug_adaptor.hpp	/^namespace std{$/;"	n
std	multiprecision/float128.hpp	/^namespace std{$/;"	n
std	multiprecision/logged_adaptor.hpp	/^namespace std{$/;"	n
std	multiprecision/rational_adaptor.hpp	/^namespace std{$/;"	n
std	multiprecision/tommath.hpp	/^namespace std{$/;"	n
std::detail	multiprecision/cpp_int/limits.hpp	/^namespace detail{$/;"	n	namespace:std
std::detail::get_max	multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::false_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::false_&)
std::detail::get_max	multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::false_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::true_&)
std::detail::get_max	multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::true_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::false_&)
std::detail::get_max	multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::true_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::true_&)
std::detail::get_min	multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::false_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::false_&)
std::detail::get_min	multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::false_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::true_&)
std::detail::get_min	multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::true_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::false_&)
std::detail::get_min	multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::true_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::true_&)
std::numeric_limits	multiprecision/concepts/mp_number_archetypes.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::concepts::number_backend_float_architype, ExpressionTemplates> > : public std::numeric_limits<long double>$/;"	c	namespace:std	inherits:std::numeric_limits
std::numeric_limits	multiprecision/cpp_dec_float.hpp	/^   class numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >$/;"	c	namespace:std
std::numeric_limits	multiprecision/cpp_int/limits.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >$/;"	c	namespace:std
std::numeric_limits	multiprecision/debug_adaptor.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::backends::debug_adaptor<Backend>, ExpressionTemplates> >$/;"	c	namespace:std	inherits:std::numeric_limits
std::numeric_limits	multiprecision/float128.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::backends::float128_backend, ExpressionTemplates> >$/;"	c	namespace:std
std::numeric_limits	multiprecision/logged_adaptor.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::backends::logged_adaptor<Backend>, ExpressionTemplates> >$/;"	c	namespace:std	inherits:std::numeric_limits
std::numeric_limits	multiprecision/rational_adaptor.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::rational_adaptor<IntBackend>, ExpressionTemplates> > : public std::numeric_limits<boost::multiprecision::number<IntBackend, ExpressionTemplates> >$/;"	c	namespace:std	inherits:std::numeric_limits
std::numeric_limits	multiprecision/tommath.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >$/;"	c	namespace:std
std::numeric_limits::backend_type	multiprecision/cpp_int/limits.hpp	/^   typedef boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> backend_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::base_type	multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef std::numeric_limits<long double> base_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::base_type	multiprecision/debug_adaptor.hpp	/^   typedef std::numeric_limits<boost::multiprecision::number<Backend, ExpressionTemplates> > base_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::base_type	multiprecision/logged_adaptor.hpp	/^   typedef std::numeric_limits<boost::multiprecision::number<Backend, ExpressionTemplates> > base_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::base_type	multiprecision/rational_adaptor.hpp	/^   typedef std::numeric_limits<boost::multiprecision::number<IntBackend> > base_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::boost::multiprecision::max	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> (max)        (void)  { return (boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::max)(); }$/;"	f	class:std::numeric_limits::boost::multiprecision	access:public	signature:(void)
std::numeric_limits::boost::multiprecision::min	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> (min)        (void)  { return (boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::min)(); }$/;"	f	class:std::numeric_limits::boost::multiprecision	access:public	signature:(void)
std::numeric_limits::denorm_min	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> denorm_min   (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::zero(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
std::numeric_limits::denorm_min	multiprecision/cpp_int/limits.hpp	/^   static number_type denorm_min() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::denorm_min	multiprecision/float128.hpp	/^   static number_type denorm_min() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::denorm_min	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type denorm_min() { return base_type::denorm_min(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::denorm_min	multiprecision/tommath.hpp	/^   static number_type denorm_min() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::digits	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     digits            = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::digits	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::digits;$/;"	m	class:std::numeric_limits
std::numeric_limits::digits	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int digits = boost::multiprecision::backends::max_precision<backend_type>::value == UINT_MAX ? INT_MAX : boost::multiprecision::backends::max_precision<backend_type>::value;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::digits	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::digits;$/;"	m	class:std::numeric_limits
std::numeric_limits::digits	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int digits = 113;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::digits	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int digits = INT_MAX;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::digits	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::digits;$/;"	m	class:std::numeric_limits
std::numeric_limits::digits10	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     digits10          = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::digits10	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::digits10;$/;"	m	class:std::numeric_limits
std::numeric_limits::digits10	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int digits10 = (digits > INT_MAX \/ 301) ? (digits \/ 1000) * 301L : (digits * 301) \/ 1000;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::digits10	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::digits10;$/;"	m	class:std::numeric_limits
std::numeric_limits::digits10	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int digits10 = 34;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::digits10	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int digits10 = (INT_MAX \/ 1000) * 301L;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::digits10	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::digits10;$/;"	m	class:std::numeric_limits
std::numeric_limits::epsilon	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> epsilon      (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::eps(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
std::numeric_limits::epsilon	multiprecision/cpp_int/limits.hpp	/^   static number_type epsilon() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::epsilon	multiprecision/float128.hpp	/^   static number_type epsilon() { return 1.92592994438723585305597794258492732e-34Q; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::epsilon	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type epsilon() { return base_type::epsilon(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::epsilon	multiprecision/tommath.hpp	/^   static number_type epsilon() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::has_denorm	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR std::float_denorm_style has_denorm        = std::denorm_absent;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_denorm	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST float_denorm_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_denorm;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_denorm	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR float_denorm_style has_denorm = denorm_absent;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_denorm	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST float_denorm_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_denorm;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_denorm	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR float_denorm_style has_denorm = denorm_absent;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_denorm	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR float_denorm_style has_denorm = denorm_absent;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_denorm	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST float_denorm_style numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_denorm;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_denorm_loss	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_denorm_loss   = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_denorm_loss	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_denorm_loss;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_denorm_loss	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_denorm_loss = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_denorm_loss	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_denorm_loss;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_denorm_loss	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_denorm_loss = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_denorm_loss	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_denorm_loss = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_denorm_loss	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_denorm_loss;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_infinity	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_infinity      = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_infinity	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_infinity;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_infinity	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_infinity = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_infinity	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_infinity;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_infinity	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_infinity = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_infinity	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_infinity = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_infinity	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_infinity;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_quiet_NaN	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_quiet_NaN     = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_quiet_NaN	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_quiet_NaN;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_quiet_NaN	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_quiet_NaN = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_quiet_NaN	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_quiet_NaN;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_quiet_NaN	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_quiet_NaN = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_quiet_NaN	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_quiet_NaN = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_quiet_NaN	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_quiet_NaN;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_signaling_NaN	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_signaling_NaN = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_signaling_NaN	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_signaling_NaN;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_signaling_NaN	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_signaling_NaN = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_signaling_NaN	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_signaling_NaN;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_signaling_NaN	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_signaling_NaN = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_signaling_NaN	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_signaling_NaN = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_signaling_NaN	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_signaling_NaN;$/;"	m	class:std::numeric_limits
std::numeric_limits::infinity	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> infinity     (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::inf(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
std::numeric_limits::infinity	multiprecision/cpp_int/limits.hpp	/^   static number_type infinity() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::infinity	multiprecision/float128.hpp	/^   static number_type infinity() { return 1.0q \/ 0.0q; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::infinity	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type infinity() { return base_type::infinity(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::infinity	multiprecision/tommath.hpp	/^   static number_type infinity() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::init	multiprecision/cpp_int/limits.hpp	/^   static const inititializer init;$/;"	m	class:std::numeric_limits	access:private
std::numeric_limits::init	multiprecision/cpp_int/limits.hpp	/^const typename numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::inititializer numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::init;$/;"	m	class:std::numeric_limits
std::numeric_limits::inititializer	multiprecision/cpp_int/limits.hpp	/^   struct inititializer$/;"	s	class:std::numeric_limits	access:private
std::numeric_limits::inititializer::do_nothing	multiprecision/cpp_int/limits.hpp	/^      void do_nothing()const{}$/;"	f	struct:std::numeric_limits::inititializer	access:public	signature:() const
std::numeric_limits::inititializer::inititializer	multiprecision/cpp_int/limits.hpp	/^      inititializer()$/;"	f	struct:std::numeric_limits::inititializer	access:public	signature:()
std::numeric_limits::is_bounded	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_bounded        = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_bounded	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_bounded;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_bounded	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_bounded = boost::multiprecision::backends::is_fixed_precision<backend_type>::value;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_bounded	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_bounded;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_bounded	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_bounded = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_bounded	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_bounded = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_bounded	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_bounded;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_exact	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_exact          = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_exact	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_exact;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_exact	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_exact = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_exact	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_exact;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_exact	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_exact = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_exact	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_exact = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_exact	multiprecision/rational_adaptor.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::rational_adaptor<IntBackend>, ExpressionTemplates> >::is_exact;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_exact	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_exact = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_exact	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_exact;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_iec559	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_iec559         = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_iec559	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_iec559;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_iec559	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_iec559 = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_iec559	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_iec559;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_iec559	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_iec559 = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_iec559	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_iec559 = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_iec559	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_iec559;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_integer	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_integer        = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_integer	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_integer;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_integer	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_integer = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_integer	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_integer;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_integer	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_integer = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_integer	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_integer = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_integer	multiprecision/rational_adaptor.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::rational_adaptor<IntBackend>, ExpressionTemplates> >::is_integer;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_integer	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_integer = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_integer	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_integer;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_modulo	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_modulo         = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_modulo	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_modulo;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_modulo	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_modulo = (boost::multiprecision::backends::is_fixed_precision<backend_type>::value && (Checked == boost::multiprecision::unchecked));$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_modulo	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_modulo;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_modulo	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_modulo = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_modulo	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_modulo = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_modulo	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_modulo;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_signed	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_signed         = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_signed	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_signed;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_signed	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_signed = boost::multiprecision::is_signed_number<backend_type>::value;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_signed	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_signed;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_signed	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_signed = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_signed	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_signed = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_signed	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_signed;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_specialized	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_specialized    = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_specialized	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_specialized = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_specialized	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_specialized = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_specialized	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_specialized = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::lowest	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> lowest       (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::zero(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
std::numeric_limits::lowest	multiprecision/cpp_int/limits.hpp	/^   static number_type lowest() { return (min)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::lowest	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type lowest() { return -(max)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::lowest	multiprecision/tommath.hpp	/^   static number_type lowest() { return (min)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::max	multiprecision/cpp_int/limits.hpp	/^   static number_type (max)() $/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::max	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type (max)() { return (base_type::max)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::max	multiprecision/tommath.hpp	/^   static number_type (max)() $/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::max_digits10	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     max_digits10      = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_total_digits10;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_digits10	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::max_digits10;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_digits10	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int max_digits10 = digits10 + 2;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_digits10	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::max_digits10;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_digits10	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int max_digits10 = 36;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_digits10	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int max_digits10 = digits10 + 2;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_digits10	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::max_digits10;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_exponent	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          max_exponent      = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp;      \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::max_exponent;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_exponent	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::max_exponent;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_exponent	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent = 16384;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::max_exponent;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_exponent10	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          max_exponent10    = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10;    \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent10	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::max_exponent10;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_exponent10	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent10	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::max_exponent10;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_exponent10	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent10 = max_exponent * 301L \/ 1000L;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent10	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent10	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::max_exponent10;$/;"	m	class:std::numeric_limits
std::numeric_limits::min	multiprecision/cpp_int/limits.hpp	/^   static number_type (min)()$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::min	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type (min)() { return (base_type::min)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::min	multiprecision/tommath.hpp	/^   static number_type (min)()$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::min_exponent	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          min_exponent      = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp;      \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::min_exponent;$/;"	m	class:std::numeric_limits
std::numeric_limits::min_exponent	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::min_exponent;$/;"	m	class:std::numeric_limits
std::numeric_limits::min_exponent	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent = -16381;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::min_exponent;$/;"	m	class:std::numeric_limits
std::numeric_limits::min_exponent10	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          min_exponent10    = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10;    \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent10	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::min_exponent10;$/;"	m	class:std::numeric_limits
std::numeric_limits::min_exponent10	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent10	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::min_exponent10;$/;"	m	class:std::numeric_limits
std::numeric_limits::min_exponent10	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent10 = min_exponent * 301L \/ 1000L;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent10	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent10	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::min_exponent10;$/;"	m	class:std::numeric_limits
std::numeric_limits::number_type	multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::concepts::number_backend_float_architype, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::number_type	multiprecision/cpp_int/limits.hpp	/^   typedef boost::multiprecision::number<backend_type, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::number_type	multiprecision/debug_adaptor.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::backends::debug_adaptor<Backend>, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::number_type	multiprecision/float128.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::backends::float128_backend, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::number_type	multiprecision/logged_adaptor.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::backends::logged_adaptor<Backend>, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::number_type	multiprecision/rational_adaptor.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::rational_adaptor<IntBackend> > number_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::number_type	multiprecision/tommath.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::quiet_NaN	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> quiet_NaN    (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::nan(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
std::numeric_limits::quiet_NaN	multiprecision/cpp_int/limits.hpp	/^   static number_type quiet_NaN() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::quiet_NaN	multiprecision/float128.hpp	/^   static number_type quiet_NaN() { return number_type("nan"); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::quiet_NaN	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type quiet_NaN() { return base_type::quiet_NaN(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::quiet_NaN	multiprecision/tommath.hpp	/^   static number_type quiet_NaN() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::radix	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     radix             = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_radix;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::radix	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::radix;$/;"	m	class:std::numeric_limits
std::numeric_limits::radix	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int radix = 2;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::radix	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::radix;$/;"	m	class:std::numeric_limits
std::numeric_limits::radix	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR int radix = 2;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::radix	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int radix = 2;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::radix	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::radix;$/;"	m	class:std::numeric_limits
std::numeric_limits::round_error	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> round_error  (void)  { return 0.5L; }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
std::numeric_limits::round_error	multiprecision/cpp_int/limits.hpp	/^   static number_type round_error() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::round_error	multiprecision/float128.hpp	/^   static number_type round_error() { return 0.5; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::round_error	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type round_error() { return epsilon() \/ 2; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::round_error	multiprecision/tommath.hpp	/^   static number_type round_error() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::round_style	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR std::float_round_style  round_style       = std::round_indeterminate;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::round_style	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST float_round_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::round_style;$/;"	m	class:std::numeric_limits
std::numeric_limits::round_style	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR float_round_style round_style = round_toward_zero;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::round_style	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST float_round_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::round_style;$/;"	m	class:std::numeric_limits
std::numeric_limits::round_style	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR float_round_style round_style = round_to_nearest;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::round_style	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR float_round_style round_style = round_toward_zero;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::round_style	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST float_round_style numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::round_style;$/;"	m	class:std::numeric_limits
std::numeric_limits::signaling_NaN	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> signaling_NaN(void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::zero(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
std::numeric_limits::signaling_NaN	multiprecision/cpp_int/limits.hpp	/^   static number_type signaling_NaN() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::signaling_NaN	multiprecision/float128.hpp	/^   static number_type signaling_NaN() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::signaling_NaN	multiprecision/rational_adaptor.hpp	/^   BOOST_STATIC_CONSTEXPR number_type signaling_NaN() { return base_type::signaling_NaN(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::signaling_NaN	multiprecision/tommath.hpp	/^   static number_type signaling_NaN() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::tinyness_before	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    tinyness_before   = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::tinyness_before	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::tinyness_before;$/;"	m	class:std::numeric_limits
std::numeric_limits::tinyness_before	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool tinyness_before = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::tinyness_before	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::tinyness_before;$/;"	m	class:std::numeric_limits
std::numeric_limits::tinyness_before	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool tinyness_before = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::tinyness_before	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool tinyness_before = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::tinyness_before	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::tinyness_before;$/;"	m	class:std::numeric_limits
std::numeric_limits::traps	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    traps             = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::traps	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::traps;$/;"	m	class:std::numeric_limits
std::numeric_limits::traps	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool traps = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::traps	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::traps;$/;"	m	class:std::numeric_limits
std::numeric_limits::traps	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool traps = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::traps	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool traps = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::traps	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::traps;$/;"	m	class:std::numeric_limits
str	multiprecision/concepts/mp_number_archetypes.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
str	multiprecision/cpp_dec_float.hpp	/^   std::string str(boost::intmax_t digits, std::ios_base::fmtflags f)const;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(boost::intmax_t digits, std::ios_base::fmtflags f) const
str	multiprecision/cpp_dec_float.hpp	/^std::string cpp_dec_float<Digits10, ExponentType, Allocator>::str(boost::intmax_t number_of_digits, std::ios_base::fmtflags f) const$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::intmax_t number_of_digits, std::ios_base::fmtflags f) const
str	multiprecision/cpp_int.hpp	/^   std::string str(std::streamsize \/*digits*\/, std::ios_base::fmtflags f)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(std::streamsize , std::ios_base::fmtflags f) const
str	multiprecision/debug_adaptor.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
str	multiprecision/float128.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
str	multiprecision/gmp.hpp	/^   std::string str(std::streamsize \/*digits*\/, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(std::streamsize , std::ios_base::fmtflags f) const
str	multiprecision/gmp.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
str	multiprecision/logged_adaptor.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
str	multiprecision/mpfi.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
str	multiprecision/mpfr.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
str	multiprecision/rational_adaptor.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
str	multiprecision/tommath.hpp	/^   std::string str(std::streamsize \/*digits*\/, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(std::streamsize , std::ios_base::fmtflags f) const
strip_leading_zeros_from_pack	multiprecision/cpp_int/literals.hpp	/^struct strip_leading_zeros_from_pack<value_pack<0u, PACK...> >$/;"	s	namespace:boost::multiprecision::literals::detail
strip_leading_zeros_from_pack	multiprecision/cpp_int/literals.hpp	/^struct strip_leading_zeros_from_pack<value_pack<PACK...> >$/;"	s	namespace:boost::multiprecision::literals::detail
stripped_type	multiprecision/cpp_int/literals.hpp	/^   typedef typename strip_leading_zeros_from_pack<packed_type>::type stripped_type;$/;"	t	struct:boost::multiprecision::literals::detail::make_packed_value_from_str	access:public
sub_unsigned_long_long	multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& sub_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
subset	multiprecision/mpfi.hpp	/^inline bool subset(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  b)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a, const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& b)
subtract	multiprecision/detail/default_ops.hpp	/^   subtract(number<B, ET>& result, const I& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, ET>& result, const I& a, const I& b)
subtract	multiprecision/detail/default_ops.hpp	/^inline number<B1, ET1>& subtract(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)
subtract	multiprecision/integer.hpp	/^   subtract(Integer& result, const I2& a, const I2& b)$/;"	f	namespace:boost::multiprecision	signature:(Integer& result, const I2& a, const I2& b)
subtract	multiprecision/random.hpp	/^struct subtract<boost::multiprecision::number<Backend, ExpressionTemplates>, true> $/;"	s	namespace:boost::random::detail
subtract_immediates	multiprecision/detail/number_base.hpp	/^struct subtract_immediates{};$/;"	s	namespace:boost::multiprecision::detail
swap	multiprecision/concepts/mp_number_archetypes.hpp	/^   void swap(number_backend_float_architype& o)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(number_backend_float_architype& o)
swap	multiprecision/cpp_dec_float.hpp	/^   void swap(cpp_dec_float& v) $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(cpp_dec_float& v)
swap	multiprecision/debug_adaptor.hpp	/^   void swap(debug_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:(debug_adaptor& o)
swap	multiprecision/float128.hpp	/^   void swap(float128_backend& o)$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:(float128_backend& o)
swap	multiprecision/gmp.hpp	/^   void swap(gmp_int& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(gmp_int& o)
swap	multiprecision/logged_adaptor.hpp	/^   void swap(logged_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:(logged_adaptor& o)
swap	multiprecision/number.hpp	/^BOOST_MP_FORCEINLINE void swap(number<Backend, ExpressionTemplates>& a, number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& a, number<Backend, ExpressionTemplates>& b)
swap	multiprecision/rational_adaptor.hpp	/^   void swap(rational_adaptor& o)$/;"	f	struct:boost::multiprecision::backends::rational_adaptor	access:public	signature:(rational_adaptor& o)
t1	multiprecision/cpp_int.hpp	/^   typedef cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> t1;$/;"	t	struct:boost::multiprecision::backends::is_implicit_cpp_int_conversion	access:public
t2	multiprecision/cpp_int.hpp	/^   typedef cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> t2;$/;"	t	struct:boost::multiprecision::backends::is_implicit_cpp_int_conversion	access:public
tag_type	multiprecision/detail/number_base.hpp	/^   >::type tag_type;$/;"	t	struct:boost::multiprecision::detail::canonical	access:public
tag_type	multiprecision/detail/number_base.hpp	/^   typedef tag tag_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
tag_type	multiprecision/detail/number_base.hpp	/^   typedef terminal tag_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
tanhq	multiprecision/float128.hpp	93;"	d
tanq	multiprecision/float128.hpp	87;"	d
terminal	multiprecision/detail/default_ops.hpp	/^   terminal(){}$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:()
terminal	multiprecision/detail/default_ops.hpp	/^   terminal(const R& v) : value(v){}$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:(const R& v)
terminal	multiprecision/detail/default_ops.hpp	/^struct terminal$/;"	s	namespace:boost::multiprecision::default_ops
terminal	multiprecision/detail/number_base.hpp	/^struct terminal{};$/;"	s	namespace:boost::multiprecision::detail
tinyness_before	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    tinyness_before   = false;$/;"	m	class:std::numeric_limits	access:public
tinyness_before	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::tinyness_before;$/;"	m	class:std::numeric_limits
tinyness_before	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool tinyness_before = false;$/;"	m	class:std::numeric_limits	access:public
tinyness_before	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::tinyness_before;$/;"	m	class:std::numeric_limits
tinyness_before	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool tinyness_before = false;$/;"	m	class:std::numeric_limits	access:public
tinyness_before	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool tinyness_before = false;$/;"	m	class:std::numeric_limits	access:public
tinyness_before	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::tinyness_before;$/;"	m	class:std::numeric_limits
tom_int	multiprecision/tommath.hpp	/^typedef number<tommath_int >                     tom_int;$/;"	t	namespace:boost::multiprecision
tom_rational	multiprecision/tommath.hpp	/^typedef number<tommath_rational>                 tom_rational;$/;"	t	namespace:boost::multiprecision
tommath_int	multiprecision/tommath.hpp	/^   tommath_int()$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
tommath_int	multiprecision/tommath.hpp	/^   tommath_int(const tommath_int& o)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const tommath_int& o)
tommath_int	multiprecision/tommath.hpp	/^struct tommath_int$/;"	s	namespace:boost::multiprecision::backends
tommath_rational	multiprecision/tommath.hpp	/^typedef rational_adaptor<tommath_int>               tommath_rational;$/;"	t	namespace:boost::multiprecision
tools	multiprecision/detail/number_base.hpp	/^namespace boost{ namespace math{ namespace tools{$/;"	n	namespace:boost::math
tools	multiprecision/mpfi.hpp	/^namespace tools{$/;"	n	namespace:math
traps	multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    traps             = false;$/;"	m	class:std::numeric_limits	access:public
traps	multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::traps;$/;"	m	class:std::numeric_limits
traps	multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool traps = false;$/;"	m	class:std::numeric_limits	access:public
traps	multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::traps;$/;"	m	class:std::numeric_limits
traps	multiprecision/float128.hpp	/^   BOOST_STATIC_CONSTEXPR bool traps = false;$/;"	m	class:std::numeric_limits	access:public
traps	multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool traps = false;$/;"	m	class:std::numeric_limits	access:public
traps	multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::traps;$/;"	m	class:std::numeric_limits
trunc	multiprecision/detail/default_ops.hpp	/^inline number<Backend, ExpressionTemplates> trunc(const number<Backend, ExpressionTemplates>& v, const Policy&)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& v, const Policy&)
trunc	multiprecision/detail/default_ops.hpp	/^inline typename detail::expression<tag, A1, A2, A3, A4>::result_type trunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
truncq	multiprecision/float128.hpp	80;"	d
two	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& two()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
type	multiprecision/cpp_int.hpp	/^   >::type type;$/;"	t	struct:default_ops::double_precision_type	access:public
type	multiprecision/cpp_int/cpp_int_config.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::largest_signed_type	access:public
type	multiprecision/cpp_int/cpp_int_config.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::largest_unsigned_type	access:public
type	multiprecision/cpp_int/literals.hpp	/^   typedef typename append_value_to_pack<v, lead_values>::type type;$/;"	t	struct:boost::multiprecision::literals::detail::reverse_value_pack	access:public
type	multiprecision/cpp_int/literals.hpp	/^   typedef typename combine_value_to_pack<pack_type, value_to_add>::type type;$/;"	t	struct:boost::multiprecision::literals::detail::pack_values	access:public
type	multiprecision/cpp_int/literals.hpp	/^   typedef typename reverse_value_pack<stripped_type>::type type;$/;"	t	struct:boost::multiprecision::literals::detail::make_packed_value_from_str	access:public
type	multiprecision/cpp_int/literals.hpp	/^   typedef typename strip_leading_zeros_from_pack<value_pack<PACK...> >::type type;$/;"	t	struct:boost::multiprecision::literals::detail::strip_leading_zeros_from_pack	access:public
type	multiprecision/cpp_int/literals.hpp	/^   typedef value_pack<> type;$/;"	t	struct:boost::multiprecision::literals::detail::reverse_value_pack	access:public
type	multiprecision/cpp_int/literals.hpp	/^   typedef value_pack<PACK..., v> type;$/;"	t	struct:boost::multiprecision::literals::detail::append_value_to_pack	access:public
type	multiprecision/cpp_int/literals.hpp	/^   typedef value_pack<PACK...> type;$/;"	t	struct:boost::multiprecision::literals::detail::strip_leading_zeros_from_pack	access:public
type	multiprecision/cpp_int/literals.hpp	/^   typedef value_pack<first | value, ARGS...> type;$/;"	t	struct:boost::multiprecision::literals::detail::combine_value_to_pack	access:public
type	multiprecision/cpp_int/literals.hpp	/^   typedef value_pack<v> type;$/;"	t	struct:boost::multiprecision::literals::detail::reverse_value_pack	access:public
type	multiprecision/cpp_int/literals.hpp	/^   typedef value_pack<value_to_add> type;$/;"	t	struct:boost::multiprecision::literals::detail::pack_values	access:public
type	multiprecision/detail/default_ops.hpp	/^      >::type type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
type	multiprecision/detail/default_ops.hpp	/^   struct type : public mpl::and_<mpl::not_<is_same<R, T> >, mpl::bool_<std::numeric_limits<T>::digits >= b> >{};$/;"	s	struct:boost::multiprecision::default_ops::has_enough_bits	inherits:mpl::and_	access:public
type	multiprecision/detail/integer_ops.hpp	/^   typedef Backend type;$/;"	t	struct:boost::multiprecision::default_ops::double_precision_type	access:public
type	multiprecision/detail/number_base.hpp	/^      >::type type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
type	multiprecision/detail/number_base.hpp	/^   struct type : public mpl::bool_<bits_of<T>::value>= b>{};$/;"	s	struct:boost::multiprecision::detail::has_enough_bits	inherits:mpl::bool_,b	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef B type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef T type;$/;"	t	struct:boost::multiprecision::detail::backend_type	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef T* type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef const T& type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef const T* type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef const char* type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef expression<Tag, Arg1, Arg2, Arg3, Arg4> type;$/;"	t	struct:boost::multiprecision::detail::arg_type	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef expression<tag, A1, A2, A3, A4> type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef expression<terminal, T> type;$/;"	t	struct:boost::multiprecision::detail::arg_type	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef number<T, ExpressionTemplates> type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef number<T1, ExpressionTemplates> type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef number<T2, ExpressionTemplates> type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef typename backend_type<typename expression<tag, A1, A2, A3, A4>::result_type>::type type;$/;"	t	struct:boost::multiprecision::detail::backend_type	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef typename boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type type;$/;"	t	struct:boost::math::tools::promote_arg	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef typename canonical_imp<Val, Backend, tag_type>::type type;$/;"	t	struct:boost::multiprecision::detail::canonical	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef typename mpl::deref<iter_type>::type type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef typename mpl::if_c<(sizeof(T1() + T2()) == sizeof(T1)), T1, T2>::type type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
type	multiprecision/detail/number_base.hpp	/^   typedef typename remove_cv<typename decay<const Val>::type>::type type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
type	multiprecision/detail/rebind.hpp	/^       typedef typename my_allocator::template rebind<value_type>::other type;$/;"	t	struct:boost::multiprecision::backends::detail::rebind	access:public
type	multiprecision/gmp.hpp	/^   typedef number<gmp_int> type;$/;"	t	struct:component_type	access:public
type	multiprecision/mpfi.hpp	/^   typedef number<mpfr_float_backend<Digits10>, ExpressionTemplates> type;$/;"	t	struct:boost::component_type	access:public
type	multiprecision/random.hpp	/^    typedef new_uniform_01<boost::multiprecision::number<Backend, ExpressionTemplates> > type;$/;"	t	struct:boost::random::detail::select_uniform_01::apply	access:public
type	multiprecision/rational_adaptor.hpp	/^   typedef number<T> type;$/;"	t	struct:boost::multiprecision::component_type	access:public
type	multiprecision/traits/explicit_conversion.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::has_generic_interconversion	access:public
type	multiprecision/traits/explicit_conversion.hpp	/^   typedef boost::integral_constant<bool,value> type;$/;"	t	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public
type	multiprecision/traits/extract_exponent_type.hpp	/^   typedef int type;$/;"	t	struct:boost::multiprecision::backends::extract_exponent_type	access:public
type	multiprecision/traits/extract_exponent_type.hpp	/^   typedef typename Backend::exponent_type type;$/;"	t	struct:boost::multiprecision::backends::extract_exponent_type	access:public
type	multiprecision/traits/is_restricted_conversion.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::is_lossy_conversion	access:public
type	multiprecision/traits/is_restricted_conversion.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::is_restricted_conversion	access:public
ublas	multiprecision/detail/ublas_interop.hpp	/^namespace boost { namespace numeric { namespace ublas {$/;"	n	namespace:boost::numeric
uint1024_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<1024, 1024, unsigned_magnitude, unchecked, void> > uint1024_t;$/;"	t
uint128_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<128, 128, unsigned_magnitude, unchecked, void> >   uint128_t;$/;"	t
uint256_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<256, 256, unsigned_magnitude, unchecked, void> >   uint256_t;$/;"	t
uint512_t	multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<512, 512, unsigned_magnitude, unchecked, void> >   uint512_t;$/;"	t
ulong_long_max	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& ulong_long_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
unchecked	multiprecision/cpp_int/cpp_int_config.hpp	/^   unchecked = 0$/;"	e	enum:boost::multiprecision::cpp_int_check_type
uniform_smallint	multiprecision/random.hpp	/^    explicit uniform_smallint(const param_type& parm)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(const param_type& parm)
uniform_smallint	multiprecision/random.hpp	/^    explicit uniform_smallint(result_type const& min_arg = 0, result_type const& max_arg = 9)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(result_type const& min_arg = 0, result_type const& max_arg = 9)
uniform_smallint	multiprecision/random.hpp	/^class uniform_smallint<boost::multiprecision::number<Backend, ExpressionTemplates> >$/;"	c	namespace:boost::random
unmentionable	multiprecision/detail/number_base.hpp	/^struct unmentionable$/;"	s	namespace:boost::multiprecision::detail
unmentionable_type	multiprecision/detail/number_base.hpp	/^typedef unmentionable* (unmentionable::*unmentionable_type)();$/;"	t	namespace:boost::multiprecision::detail
unsigned_cpp_int_literal_result_type	multiprecision/cpp_int/literals.hpp	/^struct unsigned_cpp_int_literal_result_type$/;"	s	namespace:boost::multiprecision::literals::detail
unsigned_magnitude	multiprecision/cpp_int/cpp_int_config.hpp	/^   unsigned_magnitude = 0,$/;"	e	enum:boost::multiprecision::cpp_integer_type
unsigned_packed	multiprecision/cpp_int/cpp_int_config.hpp	/^   unsigned_packed = 2$/;"	e	enum:boost::multiprecision::cpp_integer_type
unsigned_types	multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef mpl::list<unsigned long long>        unsigned_types;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
unsigned_types	multiprecision/cpp_dec_float.hpp	/^   typedef mpl::list<unsigned long long>  unsigned_types;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
unsigned_types	multiprecision/debug_adaptor.hpp	/^   typedef typename Backend::unsigned_types            unsigned_types;$/;"	t	struct:boost::multiprecision::backends::debug_adaptor	access:public
unsigned_types	multiprecision/float128.hpp	/^      unsigned int, unsigned long, unsigned long long>           unsigned_types;$/;"	t	struct:boost::multiprecision::backends::float128_backend	access:public
unsigned_types	multiprecision/gmp.hpp	/^   typedef mpl::list<unsigned long, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
unsigned_types	multiprecision/gmp.hpp	/^   typedef mpl::list<unsigned long, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::gmp_int	access:public
unsigned_types	multiprecision/logged_adaptor.hpp	/^   typedef typename Backend::unsigned_types            unsigned_types;$/;"	t	struct:boost::multiprecision::backends::logged_adaptor	access:public
unsigned_types	multiprecision/mpfi.hpp	/^   typedef mpl::list<unsigned long, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfi_float_imp	access:public
unsigned_types	multiprecision/mpfr.hpp	/^   typedef mpl::list<unsigned long, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
unsigned_types	multiprecision/rational_adaptor.hpp	/^   typedef typename IntBackend::unsigned_types  unsigned_types;$/;"	t	struct:boost::multiprecision::backends::rational_adaptor	access:public
unsigned_types	multiprecision/tommath.hpp	/^   typedef mpl::list<boost::uint32_t, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::backends::tommath_int	access:public
unwrap_debug_type	multiprecision/debug_adaptor.hpp	/^inline Backend const& unwrap_debug_type(debug_adaptor<Backend> const& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(debug_adaptor<Backend> const& val)
unwrap_debug_type	multiprecision/debug_adaptor.hpp	/^inline const T& unwrap_debug_type(const T& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const T& val)
unwrap_logged_type	multiprecision/logged_adaptor.hpp	/^inline const Backend& unwrap_logged_type(const logged_adaptor<Backend>& a) { return a.value(); }$/;"	f	namespace:boost::multiprecision::backends	signature:(const logged_adaptor<Backend>& a)
unwrap_logged_type	multiprecision/logged_adaptor.hpp	/^inline const T& unwrap_logged_type(const T& a) { return a; }$/;"	f	namespace:boost::multiprecision::backends	signature:(const T& a)
update_view	multiprecision/debug_adaptor.hpp	/^   void update_view()$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:()
upper	multiprecision/mpfi.hpp	/^inline number<mpfr_float_backend<Digits10>, ExpressionTemplates> upper(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<0U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<10U> { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<11U> { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<12U> { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<13U> { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<14U> { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<15U> { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<16U> { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<17U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<18U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<19U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<1U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<20U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<21U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<22U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<23U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<24U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<25U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<26U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<27U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<28U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<29U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<2U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<30U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<31U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<32U> { typedef boost::uint32_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<33U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<34U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<35U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<36U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<37U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<38U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<39U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<3U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<40U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<41U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<42U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<43U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<44U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<45U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<46U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<47U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<48U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<49U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<4U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<50U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<51U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<52U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<53U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<54U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<55U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<56U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<57U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<58U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<59U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<5U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<60U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<61U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<62U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<63U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<64U> { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<6U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<7U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<8U> { typedef boost::uint8_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<> struct utype_helper<9U>  { typedef boost::uint16_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_helper	multiprecision/detail/utype_helper.hpp	/^  template<const unsigned> struct utype_helper { typedef boost::uint64_t exact; };$/;"	s	namespace:boost::multiprecision::detail
utype_prior	multiprecision/detail/utype_helper.hpp	/^  int utype_prior(unsigned_type ui)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned_type ui)
value	multiprecision/cpp_int.hpp	/^   static const bool value = false;$/;"	m	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
value	multiprecision/cpp_int.hpp	/^   static const bool value = is_void<Allocator>::value && (max_precision<self>::value <= (sizeof(double_limb_type) * CHAR_BIT) - (SignType == signed_packed ? 1 : 0));$/;"	m	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
value	multiprecision/cpp_int.hpp	/^   static const bool value = true;$/;"	m	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
value	multiprecision/cpp_int.hpp	/^   static const bool value =$/;"	m	struct:boost::multiprecision::backends::is_implicit_cpp_int_conversion	access:public
value	multiprecision/cpp_int.hpp	/^   static const expression_template_option value = et_off;$/;"	m	struct:expression_template_default	access:public
value	multiprecision/cpp_int.hpp	/^   static const unsigned value = (is_void<Allocator>::value ? static_unsigned_max<MinBits, MaxBits>::value : MinBits);$/;"	m	struct:boost::multiprecision::backends::min_precision	access:public
value	multiprecision/cpp_int.hpp	/^   static const unsigned value = is_void<Allocator>::value ?$/;"	m	struct:boost::multiprecision::backends::max_precision	access:public
value	multiprecision/cpp_int/literals.hpp	/^   static constexpr B value = p;$/;"	m	struct:boost::multiprecision::literals::detail::make_backend_from_pack	access:public
value	multiprecision/cpp_int/literals.hpp	/^constexpr B make_backend_from_pack<Pack, B>::value;$/;"	m	class:boost::multiprecision::literals::detail::make_backend_from_pack
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'0'> { static constexpr limb_type value = 0; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'1'> { static constexpr limb_type value = 1; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'2'> { static constexpr limb_type value = 2; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'3'> { static constexpr limb_type value = 3; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'4'> { static constexpr limb_type value = 4; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'5'> { static constexpr limb_type value = 5; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'6'> { static constexpr limb_type value = 6; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'7'> { static constexpr limb_type value = 7; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'8'> { static constexpr limb_type value = 8; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'9'> { static constexpr limb_type value = 9; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'A'> { static constexpr limb_type value = 10; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'B'> { static constexpr limb_type value = 11; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'C'> { static constexpr limb_type value = 12; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'D'> { static constexpr limb_type value = 13; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'E'> { static constexpr limb_type value = 14; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'F'> { static constexpr limb_type value = 15; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'a'> { static constexpr limb_type value = 10; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'b'> { static constexpr limb_type value = 11; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'c'> { static constexpr limb_type value = 12; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'d'> { static constexpr limb_type value = 13; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'e'> { static constexpr limb_type value = 14; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/literals.hpp	/^template <> struct hex_value<'f'> { static constexpr limb_type value = 15; };$/;"	m	struct:boost::multiprecision::literals::detail::hex_value	access:public
value	multiprecision/cpp_int/value_pack.hpp	/^struct is_value_pack<value_pack<VALUES...> >{ static constexpr bool value = true; };$/;"	m	struct:boost::multiprecision::literals::detail::is_value_pack	access:public
value	multiprecision/cpp_int/value_pack.hpp	/^struct is_value_pack{ static constexpr bool value = false; };$/;"	m	struct:boost::multiprecision::literals::detail::is_value_pack	access:public
value	multiprecision/debug_adaptor.hpp	/^   Backend& value()$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:()
value	multiprecision/debug_adaptor.hpp	/^   const Backend& value()const$/;"	f	struct:boost::multiprecision::backends::debug_adaptor	access:public	signature:() const
value	multiprecision/detail/default_ops.hpp	/^   R value;$/;"	m	struct:boost::multiprecision::default_ops::terminal	access:public
value	multiprecision/detail/number_base.hpp	/^   static const expression_template_option value = et_on;$/;"	m	struct:boost::multiprecision::expression_template_default	access:public
value	multiprecision/detail/number_base.hpp	/^   static const long value = std::numeric_limits<T>::radix == 10 ?  (((std::numeric_limits<T>::digits + 1) * 1000L) \/ 301L) : std::numeric_limits<T>::digits;$/;"	m	struct:boost::multiprecision::detail::digits2	access:public
value	multiprecision/detail/number_base.hpp	/^   static const unsigned value =$/;"	m	struct:boost::multiprecision::detail::bits_of	access:public
value	multiprecision/float128.hpp	/^   const float128_type& value()const$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:() const
value	multiprecision/float128.hpp	/^   float128_type& value()$/;"	f	struct:boost::multiprecision::backends::float128_backend	access:public	signature:()
value	multiprecision/logged_adaptor.hpp	/^   Backend& value()$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:()
value	multiprecision/logged_adaptor.hpp	/^   const Backend& value()const$/;"	f	struct:boost::multiprecision::backends::logged_adaptor	access:public	signature:() const
value	multiprecision/traits/explicit_conversion.hpp	/^   static const bool value = sizeof(selector<S,T>(0)) == sizeof(type_traits::yes_type);$/;"	m	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public
value	multiprecision/traits/is_restricted_conversion.hpp	/^   static const bool value = type::value;$/;"	m	struct:boost::multiprecision::detail::is_lossy_conversion	access:public
value	multiprecision/traits/is_restricted_conversion.hpp	/^   static const bool value = type::value;$/;"	m	struct:boost::multiprecision::detail::is_restricted_conversion	access:public
value_pack	multiprecision/cpp_int/value_pack.hpp	/^   constexpr value_pack(){}$/;"	f	struct:boost::multiprecision::literals::detail::value_pack	access:public	signature:()
value_pack	multiprecision/cpp_int/value_pack.hpp	/^struct value_pack$/;"	s	namespace:boost::multiprecision::literals::detail
value_to_add	multiprecision/cpp_int/literals.hpp	/^   static constexpr limb_type value_to_add = hex_value<NextChar>::value;$/;"	m	struct:boost::multiprecision::literals::detail::pack_values	access:public
value_to_add	multiprecision/cpp_int/literals.hpp	/^   static constexpr limb_type value_to_add = shift ? hex_value<NextChar>::value << shift : hex_value<NextChar>::value;$/;"	m	struct:boost::multiprecision::literals::detail::pack_values	access:public
variable	multiprecision/cpp_int.hpp	/^const bool cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::variable;$/;"	m	class:boost::multiprecision::cpp_int_base
verify_limb_mask	multiprecision/cpp_int.hpp	/^inline void verify_limb_mask(bool \/*b*\/, U \/*limb*\/, U \/*mask*\/, const mpl::int_<unchecked>&){}$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(bool , U , U , const mpl::int_<unchecked>&)
verify_limb_mask	multiprecision/cpp_int.hpp	/^inline void verify_limb_mask(bool b, U limb, U mask, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(bool b, U limb, U mask, const mpl::int_<checked>&)
verify_new_size	multiprecision/cpp_int.hpp	/^      detail::verify_new_size(new_size, min_size, checked_type());$/;"	p	class:boost::multiprecision::backends::cpp_int_base::detail	access:public	signature:(new_size, min_size, checked_type())
verify_new_size	multiprecision/cpp_int.hpp	/^inline void verify_new_size(unsigned \/*new_size*\/, unsigned \/*min_size*\/, const mpl::int_<unchecked>&){}$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(unsigned , unsigned , const mpl::int_<unchecked>&)
verify_new_size	multiprecision/cpp_int.hpp	/^inline void verify_new_size(unsigned new_size, unsigned min_size, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(unsigned new_size, unsigned min_size, const mpl::int_<checked>&)
width	multiprecision/mpfi.hpp	/^inline number<mpfr_float_backend<Digits10>, ExpressionTemplates> width(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& val)
zero	multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& zero()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
zero_in	multiprecision/mpfi.hpp	/^inline bool zero_in(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>&  a)$/;"	f	namespace:boost	signature:(const number<mpfi_float_backend<Digits10>, ExpressionTemplates>& a)
~initializer	multiprecision/mpfr.hpp	/^      ~initializer(){ mpfr_free_cache(); }$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_cleanup::initializer	access:public	signature:()
~tommath_int	multiprecision/tommath.hpp	/^   ~tommath_int()$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
