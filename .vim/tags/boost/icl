!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BOOST_ICL_ASSOCIATIVE_ELEMENT_CONTAINER_HPP_JOFA_101023	icl/associative_element_container.hpp	9;"	d
BOOST_ICL_ASSOCIATIVE_INTERVAL_CONTAINER_HPP_JOFA_101023	icl/associative_interval_container.hpp	9;"	d
BOOST_ICL_CLOSED_INTERVAL_HPP_JOFA_100324	icl/closed_interval.hpp	9;"	d
BOOST_ICL_CONCEPT_CHECK_HPP_JOFA_090913	icl/detail/concept_check.hpp	9;"	d
BOOST_ICL_CONCEPT_COMPARABLE_HPP_JOFA_100921	icl/concept/comparable.hpp	9;"	d
BOOST_ICL_CONCEPT_CONTAINER_HPP_JOFA_100923	icl/concept/container.hpp	9;"	d
BOOST_ICL_CONCEPT_ELEMENT_ASSOCIATOR_HPP_JOFA_100921	icl/concept/element_associator.hpp	9;"	d
BOOST_ICL_CONCEPT_ELEMENT_MAP_HPP_JOFA_100921	icl/concept/element_map.hpp	9;"	d
BOOST_ICL_CONCEPT_ELEMENT_SET_HPP_JOFA_100921	icl/concept/element_set.hpp	9;"	d
BOOST_ICL_CONCEPT_ELEMENT_SET_VALUE_HPP_JOFA_100924	icl/concept/element_set_value.hpp	9;"	d
BOOST_ICL_CONCEPT_INTERVAL_ASSOCIATOR_BASE_HPP_JOFA_110301	icl/concept/interval_associator_base.hpp	9;"	d
BOOST_ICL_CONCEPT_INTERVAL_ASSOCIATOR_HPP_JOFA_100920	icl/concept/interval_associator.hpp	9;"	d
BOOST_ICL_CONCEPT_INTERVAL_BOUNDS_HPP_JOFA_100927	icl/concept/interval_bounds.hpp	9;"	d
BOOST_ICL_CONCEPT_INTERVAL_HPP_JOFA_100323	icl/concept/interval.hpp	9;"	d
BOOST_ICL_CONCEPT_INTERVAL_MAP_HPP_JOFA_100920	icl/concept/interval_map.hpp	9;"	d
BOOST_ICL_CONCEPT_INTERVAL_SET_HPP_JOFA_100920	icl/concept/interval_set.hpp	9;"	d
BOOST_ICL_CONCEPT_INTERVAL_SET_VALUE_HPP_JOFA_100924	icl/concept/interval_set_value.hpp	9;"	d
BOOST_ICL_CONCEPT_JOINABLE_HPP_JOFA_100920	icl/concept/joinable.hpp	9;"	d
BOOST_ICL_CONCEPT_MAP_VALUE_HPP_JOFA_100924	icl/concept/map_value.hpp	9;"	d
BOOST_ICL_CONCEPT_SET_VALUE_HPP_JOFA_100924	icl/concept/set_value.hpp	9;"	d
BOOST_ICL_CONTINUOUS_INTERVAL_HPP_JOFA_100327	icl/continuous_interval.hpp	9;"	d
BOOST_ICL_DESIGN_CONFIG_HPP_JOFA_090214	icl/detail/design_config.hpp	16;"	d
BOOST_ICL_DETAIL_ASSOCIATED_VALUE_HPP_JOFA_100829	icl/detail/associated_value.hpp	9;"	d
BOOST_ICL_DETAIL_BOOST_CONFIG_HPP_JOFA_101031	icl/detail/boost_config.hpp	9;"	d
BOOST_ICL_DETAIL_ELEMENT_ITERATOR_HPP_JOFA_091104	icl/detail/element_iterator.hpp	9;"	d
BOOST_ICL_DETAIL_EXCLUSIVE_LESS_THAN_HPP_JOFA_100929	icl/detail/exclusive_less_than.hpp	9;"	d
BOOST_ICL_DETAIL_INTERVAL_MORPHISM_HPP_JOFA_080315	icl/detail/interval_morphism.hpp	9;"	d
BOOST_ICL_DETAIL_MAPPED_REFERENCE_HPP_JOFA_091108	icl/detail/mapped_reference.hpp	9;"	d
BOOST_ICL_DETAIL_NOTATE_HPP_JOFA_990119	icl/detail/notate.hpp	14;"	d
BOOST_ICL_DETAIL_STD_SET_HPP_JOFA_101007	icl/detail/std_set.hpp	9;"	d
BOOST_ICL_DISCRETE_INTERVAL_HPP_JOFA_100403	icl/discrete_interval.hpp	9;"	d
BOOST_ICL_DYNAMIC_INTERVAL_TRAITS_HPP_JOFA_100926	icl/dynamic_interval_traits.hpp	9;"	d
BOOST_ICL_ELEMENT_COMPARER_HPP_JOFA_090202	icl/detail/element_comparer.hpp	9;"	d
BOOST_ICL_FUNCTORS_HPP_JOFA_080315	icl/functors.hpp	9;"	d
BOOST_ICL_GREGORIAN_DATE_HPP_JOFA_080416	icl/gregorian.hpp	9;"	d
BOOST_ICL_IMPL_CONFIG_HPP_JOFA_091225	icl/impl_config.hpp	10;"	d
BOOST_ICL_INTERVAL_BASE_MAP_HPP_JOFA_990223	icl/interval_base_map.hpp	10;"	d
BOOST_ICL_INTERVAL_BASE_SET_H_JOFA_990223	icl/interval_base_set.hpp	10;"	d
BOOST_ICL_INTERVAL_BOUNDS_HPP_JOFA_100330	icl/interval_bounds.hpp	9;"	d
BOOST_ICL_INTERVAL_COMBINING_STYLE_HPP_JOFA_100906	icl/interval_combining_style.hpp	9;"	d
BOOST_ICL_INTERVAL_HPP_JOFA_101014	icl/interval.hpp	9;"	d
BOOST_ICL_INTERVAL_MAP_ALGO_HPP_JOFA_100730	icl/detail/interval_map_algo.hpp	9;"	d
BOOST_ICL_INTERVAL_MAP_HPP_JOFA_080705	icl/interval_map.hpp	9;"	d
BOOST_ICL_INTERVAL_SET_ALGO_HPP_JOFA_081005	icl/detail/interval_set_algo.hpp	9;"	d
BOOST_ICL_INTERVAL_SET_HPP_JOFA_990223	icl/interval_set.hpp	10;"	d
BOOST_ICL_INTERVAL_SUBSET_COMPARER_HPP_JOFA_090827	icl/detail/interval_subset_comparer.hpp	9;"	d
BOOST_ICL_INTERVAL_TRAITS_HPP_JOFA_100926	icl/interval_traits.hpp	9;"	d
BOOST_ICL_IS_COMBINABLE_HPP_JOFA_090115	icl/type_traits/is_combinable.hpp	9;"	d
BOOST_ICL_ITERATOR_HPP_JOFA_091003	icl/iterator.hpp	9;"	d
BOOST_ICL_LEFT_OPEN_INTERVAL_HPP_JOFA_100930	icl/left_open_interval.hpp	9;"	d
BOOST_ICL_MAPALGO_HPP_JOFA_080225	icl/detail/map_algo.hpp	9;"	d
BOOST_ICL_MAP_HPP_JOFA_070519	icl/map.hpp	9;"	d
BOOST_ICL_NO_CXX11_RVALUE_REFERENCES	icl/impl_config.hpp	50;"	d
BOOST_ICL_NO_CXX11_RVALUE_REFERENCES	icl/impl_config.hpp	52;"	d
BOOST_ICL_NO_CXX11_RVALUE_REFERENCES	icl/impl_config.hpp	54;"	d
BOOST_ICL_OPEN_INTERVAL_HPP_JOFA_100930	icl/open_interval.hpp	9;"	d
BOOST_ICL_PREDICATES_DISTINCT_EQUAL_HPP_JOFA_101102	icl/predicates/distinct_equal.hpp	9;"	d
BOOST_ICL_PREDICATES_ELEMENT_EQUAL_HPP_JOFA_101102	icl/predicates/element_equal.hpp	9;"	d
BOOST_ICL_PREDICATES_STD_EQUAL_HPP_JOFA_101102	icl/predicates/std_equal.hpp	9;"	d
BOOST_ICL_PREDICATES_SUB_SUPER_SET_HPP_JOFA_101102	icl/predicates/sub_super_set.hpp	9;"	d
BOOST_ICL_PTIME_HPP_JOFA_080416	icl/ptime.hpp	16;"	d
BOOST_ICL_RATIONAL_HPP_JOFA_080913	icl/rational.hpp	14;"	d
BOOST_ICL_RELATION_STATE_HPP_JOFA_090214	icl/detail/relation_state.hpp	13;"	d
BOOST_ICL_RIGHT_OPEN_INTERVAL_HPP_JOFA_100323	icl/right_open_interval.hpp	9;"	d
BOOST_ICL_SEPARATE_INTERVAL_SET_HPP_JOFA_080608	icl/separate_interval_set.hpp	9;"	d
BOOST_ICL_SET_ALGO_HPP_JOFA_990225	icl/detail/set_algo.hpp	11;"	d
BOOST_ICL_SET_HPP_JOFA_070519	icl/set.hpp	9;"	d
BOOST_ICL_SPLIT_INTERVAL_MAP_HPP_JOFA_000706	icl/split_interval_map.hpp	10;"	d
BOOST_ICL_SPLIT_INTERVAL_SET_HPP_JOFA_990223	icl/split_interval_set.hpp	10;"	d
BOOST_ICL_SUBSET_COMPARER_HPP_JOFA_090202	icl/detail/subset_comparer.hpp	9;"	d
BOOST_ICL_TO_STRING_HPP_JOFA_000712	icl/type_traits/to_string.hpp	17;"	d
BOOST_ICL_TYPE_TO_STRING_HPP_JOFA_080416	icl/type_traits/type_to_string.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_ABSORBS_IDENTITIES_HPP_JOFA_081004	icl/type_traits/absorbs_identities.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_ADDS_INVERSELY_HPP_JOFA_100829	icl/type_traits/adds_inversely.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_CODOMAIN_TYPE_OF_HPP_JOFA_100829	icl/type_traits/codomain_type_of.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_DIFFERENCE_HPP_JOFA_080911	icl/type_traits/difference.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_DIFFERENCE_TYPE_OF_HPP_JOFA_080911	icl/type_traits/difference_type_of.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_DOMAIN_TYPE_OF_HPP_JOFA_100902	icl/type_traits/domain_type_of.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_ELEMENT_TYPE_OF_HPP_JOFA_100902	icl/type_traits/element_type_of.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_HAS_INVERSE_HPP_JOFA_090205	icl/type_traits/has_inverse.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_HAS_SET_SEMANTICS_HPP_JOFA_100829	icl/type_traits/has_set_semantics.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IDENTITY_ELEMENT_HPP_JOFA_080912	icl/type_traits/identity_element.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_INFINITY_HPP_JOFA_100322	icl/type_traits/infinity.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_INTERVAL_TYPE_DEFAULT_HPP_JOFA_100403	icl/type_traits/interval_type_default.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_INTERVAL_TYPE_OF_HPP_JOFA_100910	icl/type_traits/interval_type_of.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_ASSOCIATIVE_ELEMENT_CONTAINER_HPP_JOFA_100831	icl/type_traits/is_associative_element_container.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_ASYMMETRIC_INTERVAL_HPP_JOFA_100327	icl/type_traits/is_asymmetric_interval.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_CONCEPT_EQUIVALENT_HPP_JOFA_090830	icl/type_traits/is_concept_equivalent.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_CONTAINER_HPP_JOFA_100828	icl/type_traits/is_container.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_CONTINUOUS_HPP_JOFA_080910	icl/type_traits/is_continuous.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_CONTINUOUS_INTERVAL_HPP_JOFA_100331	icl/type_traits/is_continuous_interval.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_DISCRETE_HPP_JOFA_100410	icl/type_traits/is_discrete.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_DISCRETE_INTERVAL_HPP_JOFA_100327	icl/type_traits/is_discrete_interval.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_ELEMENT_CONTAINER_HPP_JOFA_090830	icl/type_traits/is_element_container.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_ICL_CONTAINER_HPP_JOFA_100831	icl/type_traits/is_icl_container.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_INCREASING_HPP_JOFA_110416	icl/type_traits/is_increasing.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_INTERVAL_CONTAINER_HPP_JOFA_081004	icl/type_traits/is_interval_container.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_INTERVAL_HPP_JOFA_100327	icl/type_traits/is_interval.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_INTERVAL_JOINER_HPP_JOFA_100901	icl/type_traits/is_interval_joiner.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_INTERVAL_SEPARATOR_HPP_JOFA_081004	icl/type_traits/is_interval_separator.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_INTERVAL_SPLITTER_HPP_JOFA_081004	icl/type_traits/is_interval_splitter.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_KEY_CONTAINER_OF_HPP_JOFA_100829	icl/type_traits/is_key_container_of.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_MAP_HPP_JOFA_081107	icl/type_traits/is_map.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_NUMERIC_HPP_JOFA_100322	icl/type_traits/is_numeric.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_SET_HPP_JOFA_081004	icl/type_traits/is_set.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_IS_TOTAL_HPP_JOFA_081004	icl/type_traits/is_total.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_NO_TYPE_HPP_JOFA_100902	icl/type_traits/no_type.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_ON_ABSORBTION_HPP_JOFA_100915	icl/detail/on_absorbtion.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_PREDICATE_HPP_JOFA_101102	icl/type_traits/predicate.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_REP_TYPE_OF_HPP_JOFA_110329	icl/type_traits/rep_type_of.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_SEGMENT_TYPE_OF_HPP_JOFA_100902	icl/type_traits/segment_type_of.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_SIZE_HPP_JOFA_080911	icl/type_traits/size.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_SIZE_TYPE_OF_HPP_JOFA_080911	icl/type_traits/size_type_of.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_SUCC_PRED_HPP_JOFA_080913	icl/type_traits/succ_pred.hpp	9;"	d
BOOST_ICL_TYPE_TRAITS_UNIT_ELEMENT_HPP_JOFA_080912	icl/type_traits/unit_element.hpp	9;"	d
BOOST_ICL_VALUE_SIZE_HPP_JOFA_081004	icl/type_traits/value_size.hpp	11;"	d
BOOST_STATIC_CONSTANT	icl/closed_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, value = interval_bounds::static_closed);$/;"	p	struct:boost::icl::interval_bound_type	access:public	signature:(bound_type, value = interval_bounds::static_closed)
BOOST_STATIC_CONSTANT	icl/continuous_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_continuous_interval	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/continuous_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, value = interval_bounds::dynamic);$/;"	p	struct:boost::icl::interval_bound_type	access:public	signature:(bound_type, value = interval_bounds::dynamic)
BOOST_STATIC_CONSTANT	icl/detail/element_comparer.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	class:boost::icl::Interval_Set::element_comparer	access:public	signature:(bool, _compare_codomain = (mpl::and_<is_map<LeftT>, is_map<RightT> >::value))
BOOST_STATIC_CONSTANT	icl/detail/element_iterator.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_reverse	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/detail/element_iterator.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_std_pair	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/detail/element_iterator.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = is_reverse<BaseIteratorT>::value);$/;"	p	struct:boost::icl::is_reverse	access:public	signature:(bool, value = is_reverse<BaseIteratorT>::value)
BOOST_STATIC_CONSTANT	icl/detail/element_iterator.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_reverse	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/detail/element_iterator.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_std_pair	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/detail/interval_subset_comparer.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(bool, _compare_codomain = (mpl::and_<is_map<LeftT>, is_map<RightT> >::value))
BOOST_STATIC_CONSTANT	icl/detail/mapped_reference.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_mapped_reference_combinable	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/detail/mapped_reference.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = is_mapped_reference_combinable<Type>::value);$/;"	p	struct:boost::icl::is_mapped_reference_or_combinable	access:public	signature:(bool, value = is_mapped_reference_combinable<Type>::value)
BOOST_STATIC_CONSTANT	icl/detail/mapped_reference.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_mapped_reference_combinable	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/detail/mapped_reference.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_mapped_reference_or_combinable	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/detail/std_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_set	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/detail/subset_comparer.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	class:boost::icl::Set::subset_comparer	access:public	signature:(bool, _compare_codomain = (mpl::and_<is_map<LeftT>, is_map<RightT> >::value))
BOOST_STATIC_CONSTANT	icl/discrete_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = is_discrete<DomainT>::value);$/;"	p	struct:boost::icl::is_discrete_interval	access:public	signature:(bool, value = is_discrete<DomainT>::value)
BOOST_STATIC_CONSTANT	icl/discrete_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, value = interval_bounds::dynamic);$/;"	p	struct:boost::icl::interval_bound_type	access:public	signature:(bound_type, value = interval_bounds::dynamic)
BOOST_STATIC_CONSTANT	icl/functors.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_negative	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/functors.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_negative	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/gregorian.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::has_difference	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/gregorian.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_discrete	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/interval_base_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	class:boost::icl::interval_base_map	access:public	signature:(bool, is_total_invertible = ( Traits::is_total && has_inverse<codomain_type>::value))
BOOST_STATIC_CONSTANT	icl/interval_base_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (Traits::absorbs_identities)); $/;"	p	struct:boost::icl::absorbs_identities	access:public	signature:(bool, value = (Traits::absorbs_identities))
BOOST_STATIC_CONSTANT	icl/interval_base_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (Traits::is_total)); $/;"	p	struct:boost::icl::is_total	access:public	signature:(bool, value = (Traits::is_total))
BOOST_STATIC_CONSTANT	icl/interval_base_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (has_inverse<CodomainT>::value)); $/;"	p	struct:boost::icl::has_inverse	access:public	signature:(bool, value = (has_inverse<CodomainT>::value))
BOOST_STATIC_CONSTANT	icl/interval_base_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/interval_base_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_map	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/interval_base_map.hpp	/^    BOOST_STATIC_CONSTANT(int, fineness = 0); $/;"	p	class:boost::icl::interval_base_map	access:public	signature:(int, fineness = 0)
BOOST_STATIC_CONSTANT	icl/interval_base_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/interval_base_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_set	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/interval_base_set.hpp	/^    BOOST_STATIC_CONSTANT(int, fineness = 0); $/;"	p	class:boost::icl::interval_base_set	access:public	signature:(int, fineness = 0)
BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, _all       = 3);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, _all = 3)
BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, _closed     = 3);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, _closed = 3)
BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, _left      = 2);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, _left = 2)
BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, _left_open  = 1);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, _left_open = 1)
BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, _open       = 0);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, _open = 0)
BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, _right     = 1);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, _right = 1)
BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, _right_open = 2);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, _right_open = 2)
BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, dynamic           = 4);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, dynamic = 4)
BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, static_closed     = 3);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, static_closed = 3)
BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, static_left_open  = 1);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, static_left_open = 1)
BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, static_open       = 0);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, static_open = 0)
BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, static_right_open = 2);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, static_right_open = 2)
BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, undefined         = 5);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, undefined = 5)
BOOST_STATIC_CONSTANT	icl/interval_combining_style.hpp	/^    BOOST_STATIC_CONSTANT(int, elemental  = 4);$/;"	p	namespace:boost::icl::interval_combine	signature:(int, elemental = 4)
BOOST_STATIC_CONSTANT	icl/interval_combining_style.hpp	/^    BOOST_STATIC_CONSTANT(int, joining    = 1);$/;"	p	namespace:boost::icl::interval_combine	signature:(int, joining = 1)
BOOST_STATIC_CONSTANT	icl/interval_combining_style.hpp	/^    BOOST_STATIC_CONSTANT(int, separating = 2);$/;"	p	namespace:boost::icl::interval_combine	signature:(int, separating = 2)
BOOST_STATIC_CONSTANT	icl/interval_combining_style.hpp	/^    BOOST_STATIC_CONSTANT(int, splitting  = 3);$/;"	p	namespace:boost::icl::interval_combine	signature:(int, splitting = 3)
BOOST_STATIC_CONSTANT	icl/interval_combining_style.hpp	/^    BOOST_STATIC_CONSTANT(int, unknown    = 0);$/;"	p	namespace:boost::icl::interval_combine	signature:(int, unknown = 0)
BOOST_STATIC_CONSTANT	icl/interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (Traits::absorbs_identities)); $/;"	p	struct:boost::icl::absorbs_identities	access:public	signature:(bool, value = (Traits::absorbs_identities))
BOOST_STATIC_CONSTANT	icl/interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (Traits::is_total)); $/;"	p	struct:boost::icl::is_total	access:public	signature:(bool, value = (Traits::is_total))
BOOST_STATIC_CONSTANT	icl/interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (has_inverse<CodomainT>::value)); $/;"	p	struct:boost::icl::has_inverse	access:public	signature:(bool, value = (has_inverse<CodomainT>::value))
BOOST_STATIC_CONSTANT	icl/interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_map	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_joiner	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_set	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/left_open_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, value = interval_bounds::static_left_open);$/;"	p	struct:boost::icl::interval_bound_type	access:public	signature:(bound_type, value = interval_bounds::static_left_open)
BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	class:boost::icl::map	access:public	signature:(bool, is_total_invertible = ( Traits::is_total && has_inverse<codomain_type>::value))
BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	class:boost::icl::map	access:public	signature:(bool, total_invertible = (mpl::and_<is_total<type>, has_inverse<codomain_type> >::value))
BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(bool, _absorbs = (Traits::absorbs_identities));$/;"	p	class:boost::icl::map	access:public	signature:(bool, _absorbs = (Traits::absorbs_identities))
BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(bool, _total   = (Traits::is_total));$/;"	p	class:boost::icl::map	access:public	signature:(bool, _total = (Traits::is_total))
BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (has_inverse<CodomainT>::value)); $/;"	p	struct:boost::icl::has_inverse	access:public	signature:(bool, value = (has_inverse<CodomainT>::value))
BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_map	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(int, fineness = 4); $/;"	p	class:boost::icl::map	access:public	signature:(int, fineness = 4)
BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(int, value = Traits::absorbs_identities); $/;"	p	struct:boost::icl::absorbs_identities	access:public	signature:(int, value = Traits::absorbs_identities)
BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(int, value = Traits::is_total); $/;"	p	struct:boost::icl::is_total	access:public	signature:(int, value = Traits::is_total)
BOOST_STATIC_CONSTANT	icl/open_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, value = interval_bounds::static_open);$/;"	p	struct:boost::icl::interval_bound_type	access:public	signature:(bound_type, value = interval_bounds::static_open)
BOOST_STATIC_CONSTANT	icl/ptime.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::has_difference	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/ptime.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_discrete	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/rational.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = (boost::is_signed<Integral>::value));$/;"	p	struct:boost::icl::has_inverse	access:public	signature:(bool, value = (boost::is_signed<Integral>::value))
BOOST_STATIC_CONSTANT	icl/rational.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_discrete	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/rational.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_continuous	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/rational.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_numeric	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/right_open_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, value = interval_bounds::static_right_open);$/;"	p	struct:boost::icl::interval_bound_type	access:public	signature:(bound_type, value = interval_bounds::static_right_open)
BOOST_STATIC_CONSTANT	icl/separate_interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/separate_interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_separator	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/separate_interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_set	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/split_interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (Traits::absorbs_identities)); $/;"	p	struct:boost::icl::absorbs_identities	access:public	signature:(bool, value = (Traits::absorbs_identities))
BOOST_STATIC_CONSTANT	icl/split_interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (Traits::is_total)); $/;"	p	struct:boost::icl::is_total	access:public	signature:(bool, value = (Traits::is_total))
BOOST_STATIC_CONSTANT	icl/split_interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (has_inverse<CodomainT>::value)); $/;"	p	struct:boost::icl::has_inverse	access:public	signature:(bool, value = (has_inverse<CodomainT>::value))
BOOST_STATIC_CONSTANT	icl/split_interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/split_interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_splitter	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/split_interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_map	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/split_interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/split_interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_set	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/split_interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_interval_splitter	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/type_traits/absorbs_identities.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false); $/;"	p	struct:boost::icl::absorbs_identities	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/type_traits/adds_inversely.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::adds_inversely	access:public	signature:(bool, value = (mpl::and_<has_inverse<Type>, is_negative<Combiner> >::value))
BOOST_STATIC_CONSTANT	icl/type_traits/difference_type_of.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_difference	access:public	signature:(bool, value = (mpl::or_< is_subtraction_closed<Type> , is_pointer<Type> , has_difference_type<Type> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/difference_type_of.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_subtraction_closed	access:public	signature:(bool, value = (mpl::or_< is_numeric<Type> , mpl::and_< has_rep_type<Type> , mpl::not_<has_difference_type<Type> > > >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/has_inverse.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_inverse	access:public	signature:(bool, value = (type_traits::ice_or<boost::is_signed<Type>::value, is_floating_point<Type>::value>::value))
BOOST_STATIC_CONSTANT	icl/type_traits/has_set_semantics.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_set_semantics	access:public	signature:(bool, value = (mpl::or_< is_set<Type> , mpl::and_< is_map<Type> , has_set_semantics <typename codomain_type_of<Type>::type > > >::value))
BOOST_STATIC_CONSTANT	icl/type_traits/infinity.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_max_infinity	access:public	signature:(bool, value = (type_traits::ice_and < is_numeric<Type>::value , type_traits::ice_not<std::numeric_limits<Type>::has_infinity>::value >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/infinity.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_std_infinity	access:public	signature:(bool, value = (type_traits::ice_and < is_numeric<Type>::value , std::numeric_limits<Type>::has_infinity >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_associative_element_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_associative_element_container	access:public	signature:(bool, value = (mpl::or_<is_element_set<Type>, is_element_map<Type> >::value))
BOOST_STATIC_CONSTANT	icl/type_traits/is_asymmetric_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool,$/;"	p	struct:boost::icl::is_asymmetric_interval	access:public	signature:(bool, value = (mpl::and_< is_interval<Type> , has_static_bounds<Type> , has_asymmetric_bounds<Type> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_asymmetric_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool,$/;"	p	struct:boost::icl::is_continuous_asymmetric	access:public	signature:(bool, value = (mpl::and_< is_asymmetric_interval<Type> , is_continuous<typename domain_type_of<interval_traits<Type> >::type> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_asymmetric_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool,$/;"	p	struct:boost::icl::is_discrete_asymmetric	access:public	signature:(bool, value = (mpl::and_< is_asymmetric_interval<Type> , mpl::not_<is_continuous<typename domain_type_of<interval_traits<Type> >::type> > >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::combines_right_to_interval_container	access:public	signature:(bool, value = (mpl::or_<combines_right_to_interval_set<GuideT, IntervalContainerT>, combines_right_to_interval_map<GuideT, IntervalContainerT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::combines_right_to_interval_map	access:public	signature:(bool, value = (is_concept_compatible<is_interval_map, GuideT, IntervalMapT>::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::combines_right_to_interval_set	access:public	signature:(bool, value = (is_concept_combinable<is_interval_container, is_interval_set, GuideT, IntervalSetT>::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_inter_derivative	access:public	signature:(bool, value = (mpl::or_< is_intra_derivative<Type, AssociateT> , is_cross_derivative<Type, AssociateT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_interval_map_companion	access:public	signature:(bool, value = (mpl::or_ < combines_right_to_interval_map<GuideT,CompanionT> , is_interval_map_derivative<GuideT,CompanionT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_interval_map_right_cross_combinable	access:public	signature:(bool, value = (mpl::and_ < is_interval_map<GuideT> , mpl::or_ < is_cross_derivative<GuideT, CompanionT> , is_concept_combinable<is_interval_map, is_interval_set, GuideT, CompanionT> > >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_interval_map_right_inter_combinable	access:public	signature:(bool, value = (mpl::or_< is_interval_map_right_intra_combinable<GuideT, CompanionT> , is_interval_map_right_cross_combinable<GuideT, CompanionT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_interval_map_right_intra_combinable	access:public	signature:(bool, value = (mpl::and_ < is_interval_map<GuideT> , mpl::or_ < is_interval_map_derivative<GuideT, CompanionT> , is_concept_compatible<is_interval_map, GuideT, CompanionT> > >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_interval_set_companion	access:public	signature:(bool, value = (mpl::or_ < combines_right_to_interval_set<GuideT,CompanionT> , is_interval_set_derivative<GuideT,CompanionT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_interval_set_right_combinable	access:public	signature:(bool, value = (mpl::and_ < is_interval_set<GuideT> , mpl::or_ < is_interval_set_derivative<GuideT, CompanionT> , is_concept_compatible<is_interval_set, GuideT, CompanionT> > >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_overloadable	access:public	signature:(bool, value = (boost::is_same<Type, typename Type::overloadable_type>::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_right_inter_combinable	access:public	signature:(bool, value = (mpl::or_ < is_interval_set_right_combinable<GuideT, CompanionT> , is_interval_map_right_inter_combinable<GuideT, CompanionT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_right_intra_combinable	access:public	signature:(bool, value = (mpl::or_ < is_interval_set_right_combinable<GuideT, CompanionT> , is_interval_map_right_intra_combinable<GuideT, CompanionT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (is_interval_container<Type>::value)); $/;"	p	struct:boost::icl::is_interval_set_derivative	access:public	signature:(bool, value = (is_interval_container<Type>::value))
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (is_interval_container<Type>::value));$/;"	p	struct:boost::icl::is_interval_map_derivative	access:public	signature:(bool, value = (is_interval_container<Type>::value))
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_fragment_of	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_interval_map_derivative	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_interval_set_derivative	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_key_of	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_fragment_of	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_key_of	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_binary_cross_combinable	access:public	signature:(bool, value = (mpl::and_ < is_interval_map<GuideT> , mpl::or_< is_coarser_interval_map_companion<GuideT, CompanionT> , is_interval_set_companion<GuideT, CompanionT> > >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_binary_inter_combinable	access:public	signature:(bool, value = (mpl::or_ < mpl::and_<is_interval_map<GuideT>, is_binary_cross_combinable<GuideT, CompanionT> > , mpl::and_<is_interval_set<GuideT>, is_binary_intra_combinable<GuideT, CompanionT> > >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_binary_intra_combinable	access:public	signature:(bool, value = (mpl::or_<is_binary_interval_set_combinable<GuideT, CompanionT>, is_binary_interval_map_combinable<GuideT, CompanionT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_coarser_interval_map_companion	access:public	signature:(bool, value = (mpl::and_ < is_interval_map_companion<GuideT, CompanionT> , mpl::bool_<( segmentational_fineness<GuideT>::value > segmentational_fineness<CompanionT>::value)> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_coarser_interval_set_companion	access:public	signature:(bool, value = (mpl::and_ < is_interval_set_companion<GuideT, CompanionT> , mpl::bool_<( segmentational_fineness<GuideT>::value > segmentational_fineness<CompanionT>::value)> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_codomain_equal	access:public	signature:(bool, value = (boost::is_same<typename LeftT::codomain_type, typename RightT::codomain_type>::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_codomain_type_equal	access:public	signature:(bool, value = (mpl::and_<is_key_compare_equal<LeftT, RightT>, is_codomain_equal<LeftT, RightT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_concept_combinable	access:public	signature:(bool, value = (mpl::and_< LeftConcept<LeftT> , RightConcept<RightT> , is_key_compare_equal<LeftT, RightT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_concept_compatible	access:public	signature:(bool, value = (mpl::and_< IsConcept<LeftT> , IsConcept<RightT> , is_codomain_type_equal<LeftT, RightT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_cross_combinable	access:public	signature:(bool, value = (mpl::or_< is_concept_combinable<is_interval_set, is_interval_map, LeftT, RightT> , is_concept_combinable<is_interval_map, is_interval_set, LeftT, RightT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_cross_derivative	access:public	signature:(bool, value = (mpl::and_< is_interval_map<Type> , is_interval_set_derivative<Type, AssociateT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_inter_combinable	access:public	signature:(bool, value = (mpl::or_<is_intra_combinable<LeftT,RightT>, is_cross_combinable<LeftT,RightT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_intra_combinable	access:public	signature:(bool, value = (mpl::or_< is_concept_compatible<is_interval_set, LeftT, RightT> , is_concept_compatible<is_interval_map, LeftT, RightT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_intra_derivative	access:public	signature:(bool, value = (mpl::or_ < mpl::and_<is_interval_set<Type>, is_interval_set_derivative<Type, AssociateT> > , mpl::and_<is_interval_map<Type>, is_interval_map_derivative<Type, AssociateT> > >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_key_compare_equal	access:public	signature:(bool, value = (boost::is_same<typename LeftT::key_compare, typename RightT::key_compare>::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_concept_equivalent.hpp	/^        BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::has_same_concept	access:public	signature:(bool, value = (mpl::and_<IsConcept<LeftT>, is_concept_equivalent<IsConcept, LeftT, RightT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_concept_equivalent.hpp	/^        BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_concept_equivalent	access:public	signature:(bool, value = (mpl::and_<IsConcept<LeftT>, IsConcept<RightT> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_std_set	access:public	signature:(bool, value = (mpl::and_< is_container<Type> , detail::has_key_type<Type> , boost::is_same< typename key_type_of<Type>::type , typename value_type_of<Type>::type > , mpl::not_<detail::has_segment_type<Type> > >::value ) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_continuous.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_continuous	access:public	signature:(bool, value = mpl::not_<is_discrete<Type> >::value)
BOOST_STATIC_CONSTANT	icl/type_traits/is_continuous_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_continuous_interval	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/type_traits/is_discrete.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_discrete	access:public	signature:(bool, value = (mpl::and_ < boost::detail::is_incrementable<Type> , mpl::or_ < mpl::and_ < mpl::not_<has_rep_type<Type> > , is_non_floating_point<Type> > , mpl::and_ < has_rep_type<Type> , is_discrete<typename rep_type_of<Type>::type> > > >::value ) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_discrete_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_discrete_interval	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/type_traits/is_element_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_element_container	access:public	signature:(bool, value = (mpl::or_<is_element_set<Type>, is_element_map<Type> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_element_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_element_map	access:public	signature:(bool, value = (mpl::and_<is_map<Type>, mpl::not_<is_interval_container<Type> > >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_element_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_element_set	access:public	signature:(bool, value = (mpl::or_< mpl::and_< is_set<Type> , mpl::not_<is_interval_container<Type> > > , is_std_set<Type> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_icl_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_icl_container	access:public	signature:(bool, value = (mpl::or_< is_element_container<Type> , is_interval_container<Type> >::value))
BOOST_STATIC_CONSTANT	icl/type_traits/is_increasing.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_increasing	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/type_traits/is_increasing.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_increasing	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT( bool, $/;"	p	struct:boost::icl::is_discrete_static_closed	access:public	signature:( bool, value = (mpl::and_< is_static_closed<Type> , is_discrete<domain_type> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT( bool, $/;"	p	struct:boost::icl::is_discrete_static_open	access:public	signature:( bool, value = (mpl::and_< is_static_open<Type> , is_discrete<domain_type> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_asymmetric_bounds	access:public	signature:(bool, value = ( bounds == interval_bounds::static_left_open || bounds == interval_bounds::static_right_open))
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_dynamic_bounds	access:public	signature:(bool, value = (interval_bound_type<Type>::value == interval_bounds::dynamic))
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_static_bounds	access:public	signature:(bool, value = ((interval_bound_type<Type>::value) < interval_bounds::dynamic))
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_symmetric_bounds	access:public	signature:(bool, value = ( bounds == interval_bounds::static_closed || bounds == interval_bounds::static_open))
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_continuous_left_open	access:public	signature:(bool, value = (mpl::and_<is_static_left_open<Type>, is_continuous<domain_type> >::value))
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_continuous_right_open	access:public	signature:(bool, value = (mpl::and_<is_static_right_open<Type>, is_continuous<domain_type> >::value))
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_continuous_static	access:public	signature:(bool, value = (mpl::and_< has_static_bounds<Type> , is_continuous<domain_type> , has_asymmetric_bounds<Type> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_discrete_static	access:public	signature:(bool, value = (mpl::and_< has_static_bounds<Type> , is_discrete<domain_type> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_interval	access:public	signature:(bool, value = ((interval_bound_type<Type>::value) < interval_bounds::undefined))
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_singelizable	access:public	signature:(bool, value = (mpl::or_< has_dynamic_bounds<Type> , is_discrete<domain_type> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_static_closed	access:public	signature:(bool, value = (interval_bound_type<Type>::value == interval_bounds::static_closed))
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_static_left_open	access:public	signature:(bool, value = (interval_bound_type<Type>::value == interval_bounds::static_left_open))
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_static_open	access:public	signature:(bool, value = (interval_bound_type<Type>::value == interval_bounds::static_open))
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_static_right_open	access:public	signature:(bool, value = (interval_bound_type<Type>::value == interval_bounds::static_right_open))
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, bounds = (interval_bound_type<Type>::value)); $/;"	p	struct:boost::icl::has_asymmetric_bounds	access:public	signature:(bound_type, bounds = (interval_bound_type<Type>::value))
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, bounds = (interval_bound_type<Type>::value)); $/;"	p	struct:boost::icl::has_symmetric_bounds	access:public	signature:(bound_type, bounds = (interval_bound_type<Type>::value))
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, value = (interval_bounds::undefined)); $/;"	p	struct:boost::icl::interval_bound_type	access:public	signature:(bound_type, value = (interval_bounds::undefined))
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_interval_map	access:public	signature:(bool, value = (mpl::and_<is_interval_container<Type>, is_map<Type> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_interval_set	access:public	signature:(bool, value = (mpl::and_< is_interval_container<Type>, mpl::not_<is_interval_map<Type> > >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval_joiner.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false); $/;"	p	struct:boost::icl::is_interval_joiner	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval_separator.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false); $/;"	p	struct:boost::icl::is_interval_separator	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/type_traits/is_interval_splitter.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false); $/;"	p	struct:boost::icl::is_interval_splitter	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/type_traits/is_key_container_of.hpp	/^        BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_key_container_of	access:public	signature:(bool, value = (mpl::or_< is_strict_key_container_of<KeyT, ObjectT> , mpl::and_< mpl::or_<is_set<ObjectT>, is_map<ObjectT> > , boost::is_same<ObjectT, KeyT> > >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_key_container_of.hpp	/^        BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_strict_key_container_of	access:public	signature:(bool, value = (mpl::and_< is_map<ObjectT> , boost::is_same<KeyT, typename key_container_type_of<ObjectT>::type> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_map.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false); $/;"	p	struct:boost::icl::is_map	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/type_traits/is_numeric.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_std_integral	access:public	signature:(bool, value = (std::numeric_limits<Type>::is_integer))
BOOST_STATIC_CONSTANT	icl/type_traits/is_numeric.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_std_numeric	access:public	signature:(bool, value = (std::numeric_limits<Type>::is_specialized))
BOOST_STATIC_CONSTANT	icl/type_traits/is_numeric.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_non_floating_point	access:public	signature:(bool, value = (mpl::not_< is_floating_point<Type> >::value))
BOOST_STATIC_CONSTANT	icl/type_traits/is_numeric.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_numeric	access:public	signature:(bool, value = (mpl::or_< is_std_numeric<Type> , boost::is_integral<Type> , is_std_integral<Type> >::value) )
BOOST_STATIC_CONSTANT	icl/type_traits/is_numeric.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (0 < std::numeric_limits<Type>::digits));$/;"	p	struct:boost::icl::is_fixed_numeric	access:public	signature:(bool, value = (0 < std::numeric_limits<Type>::digits))
BOOST_STATIC_CONSTANT	icl/type_traits/is_numeric.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_numeric	access:public	signature:(bool, value = true)
BOOST_STATIC_CONSTANT	icl/type_traits/is_set.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = is_std_set<Type>::value); $/;"	p	struct:boost::icl::is_set	access:public	signature:(bool, value = is_std_set<Type>::value)
BOOST_STATIC_CONSTANT	icl/type_traits/is_total.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false); $/;"	p	struct:boost::icl::is_total	access:public	signature:(bool, value = false)
BOOST_STATIC_CONSTANT	icl/type_traits/rep_type_of.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::represents	access:public	signature:(bool, value = (mpl::and_< has_rep_type<Type> , is_same<typename Type::rep, Rep> >::value) )
BOOST_concept	icl/detail/concept_check.hpp	/^    BOOST_concept(EqualComparable,(Type))$/;"	f	namespace:boost::icl	signature:(EqualComparable,(Type))
ICL_ALLOC	icl/detail/design_config.hpp	98;"	d
ICL_COMBINE	icl/detail/design_config.hpp	60;"	d
ICL_COMBINE	icl/detail/design_config.hpp	64;"	d
ICL_COMBINE_CODOMAIN	icl/detail/design_config.hpp	61;"	d
ICL_COMBINE_CODOMAIN	icl/detail/design_config.hpp	65;"	d
ICL_COMBINE_INSTANCE	icl/detail/design_config.hpp	62;"	d
ICL_COMBINE_INSTANCE	icl/detail/design_config.hpp	66;"	d
ICL_COMPARE	icl/detail/design_config.hpp	46;"	d
ICL_COMPARE	icl/detail/design_config.hpp	51;"	d
ICL_COMPARE_DEFAULT	icl/detail/design_config.hpp	104;"	d
ICL_COMPARE_DEFAULT	icl/detail/design_config.hpp	106;"	d
ICL_COMPARE_DOMAIN	icl/detail/design_config.hpp	47;"	d
ICL_COMPARE_DOMAIN	icl/detail/design_config.hpp	52;"	d
ICL_COMPARE_INSTANCE	icl/detail/design_config.hpp	48;"	d
ICL_COMPARE_INSTANCE	icl/detail/design_config.hpp	53;"	d
ICL_EXCLUSIVE_LESS	icl/detail/design_config.hpp	49;"	d
ICL_EXCLUSIVE_LESS	icl/detail/design_config.hpp	54;"	d
ICL_FORALL	icl/detail/notate.hpp	18;"	d
ICL_FORALL_THIS	icl/detail/notate.hpp	21;"	d
ICL_FORALL_VEC	icl/detail/notate.hpp	25;"	d
ICL_IMPL_SPACE	icl/impl_config.hpp	37;"	d
ICL_IMPL_SPACE	icl/impl_config.hpp	39;"	d
ICL_IMPL_SPACE	icl/impl_config.hpp	41;"	d
ICL_INTERVAL	icl/detail/design_config.hpp	85;"	d
ICL_INTERVAL	icl/detail/design_config.hpp	90;"	d
ICL_INTERVAL2	icl/detail/design_config.hpp	86;"	d
ICL_INTERVAL2	icl/detail/design_config.hpp	91;"	d
ICL_INTERVAL_DEFAULT	icl/detail/design_config.hpp	101;"	d
ICL_INTERVAL_INSTANCE	icl/detail/design_config.hpp	88;"	d
ICL_INTERVAL_INSTANCE	icl/detail/design_config.hpp	93;"	d
ICL_INTERVAL_TYPE	icl/detail/design_config.hpp	87;"	d
ICL_INTERVAL_TYPE	icl/detail/design_config.hpp	92;"	d
ICL_SECTION	icl/detail/design_config.hpp	72;"	d
ICL_SECTION	icl/detail/design_config.hpp	76;"	d
ICL_SECTION_CODOMAIN	icl/detail/design_config.hpp	73;"	d
ICL_SECTION_CODOMAIN	icl/detail/design_config.hpp	77;"	d
ICL_SECTION_INSTANCE	icl/detail/design_config.hpp	74;"	d
ICL_SECTION_INSTANCE	icl/detail/design_config.hpp	78;"	d
ICL_USE_COMBINE_TEMPLATE_TEMPLATE	icl/detail/design_config.hpp	37;"	d
ICL_USE_COMPARE_TEMPLATE_TEMPLATE	icl/detail/design_config.hpp	36;"	d
ICL_USE_SECTION_TEMPLATE_TEMPLATE	icl/detail/design_config.hpp	38;"	d
ICL_const_FORALL	icl/detail/notate.hpp	19;"	d
ICL_const_FORALL_THIS	icl/detail/notate.hpp	22;"	d
ImplMapT	icl/interval_base_map.hpp	/^                                key_compare,allocator_type> ImplMapT;$/;"	t	class:boost::icl::interval_base_map	access:public
ImplMapT	icl/interval_map.hpp	/^    typedef typename base_type::ImplMapT ImplMapT;$/;"	t	class:boost::icl::interval_map	access:public
ImplMapT	icl/split_interval_map.hpp	/^    typedef typename base_type::ImplMapT ImplMapT;$/;"	t	class:boost::icl::split_interval_map	access:public
ImplSetT	icl/interval_base_set.hpp	/^    typedef typename ICL_IMPL_SPACE::set<interval_type,key_compare,allocator_type> ImplSetT;$/;"	t	class:boost::icl::interval_base_set	access:public
ImplSetT	icl/interval_set.hpp	/^    typedef typename base_type::ImplSetT ImplSetT;$/;"	t	class:boost::icl::interval_set	access:public
ImplSetT	icl/separate_interval_set.hpp	/^    typedef typename base_type::ImplSetT ImplSetT;$/;"	t	class:boost::icl::separate_interval_set	access:public
ImplSetT	icl/split_interval_set.hpp	/^    typedef typename base_type::ImplSetT ImplSetT;$/;"	t	class:boost::icl::split_interval_set	access:public
Interval_Map	icl/detail/interval_map_algo.hpp	/^namespace Interval_Map$/;"	n	namespace:boost::icl
Interval_Set	icl/detail/element_comparer.hpp	/^namespace Interval_Set$/;"	n	namespace:boost::icl
Interval_Set	icl/detail/interval_set_algo.hpp	/^namespace Interval_Set$/;"	n	namespace:boost::icl
Interval_Set	icl/detail/interval_subset_comparer.hpp	/^namespace Interval_Set$/;"	n	namespace:boost::icl
LeftIterT	icl/detail/element_comparer.hpp	/^    typedef typename LeftT::const_iterator  LeftIterT;$/;"	t	class:boost::icl::Interval_Set::element_comparer	access:public
LeftIterT	icl/detail/interval_subset_comparer.hpp	/^    typedef typename LeftT::const_iterator  LeftIterT;$/;"	t	class:boost::icl::Interval_Set::subset_comparer	access:public
LeftIterT	icl/detail/subset_comparer.hpp	/^    typedef typename LeftT::const_iterator  LeftIterT;$/;"	t	class:boost::icl::Set::subset_comparer	access:public
Map	icl/detail/map_algo.hpp	/^namespace Map $/;"	n	namespace:boost::icl
RightIterT	icl/detail/element_comparer.hpp	/^    typedef typename RightT::const_iterator RightIterT;$/;"	t	class:boost::icl::Interval_Set::element_comparer	access:public
RightIterT	icl/detail/interval_subset_comparer.hpp	/^    typedef typename RightT::const_iterator RightIterT;$/;"	t	class:boost::icl::Interval_Set::subset_comparer	access:public
RightIterT	icl/detail/subset_comparer.hpp	/^    typedef typename RightT::const_iterator RightIterT;$/;"	t	class:boost::icl::Set::subset_comparer	access:public
Set	icl/detail/set_algo.hpp	/^namespace Set$/;"	n	namespace:boost::icl
Set	icl/detail/subset_comparer.hpp	/^namespace Set$/;"	n	namespace:boost::icl
UNDEFINED_INDEX	icl/detail/notate.hpp	/^    const int UNDEFINED_INDEX = -1;$/;"	m	namespace:boost::icl
_add	icl/interval_base_map.hpp	/^    ::_add(const segment_type& addend)$/;"	f	class:boost::icl::interval_base_map	signature:(const segment_type& addend)
_add	icl/interval_base_map.hpp	/^    ::_add(iterator prior_, const segment_type& addend)$/;"	f	class:boost::icl::interval_base_map	signature:(iterator prior_, const segment_type& addend)
_add	icl/interval_base_map.hpp	/^    iterator _add(const segment_type& interval_value_pair);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const segment_type& interval_value_pair)
_add	icl/interval_base_map.hpp	/^    iterator _add(iterator prior_, const segment_type& interval_value_pair);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(iterator prior_, const segment_type& interval_value_pair)
_add	icl/interval_base_set.hpp	/^    ::_add(const segment_type& addend)$/;"	f	class:boost::icl::interval_base_set	signature:(const segment_type& addend)
_add	icl/interval_base_set.hpp	/^    ::_add(iterator prior_, const segment_type& addend)$/;"	f	class:boost::icl::interval_base_set	signature:(iterator prior_, const segment_type& addend)
_add	icl/interval_base_set.hpp	/^    iterator _add(const segment_type& addend);$/;"	p	class:boost::icl::interval_base_set	access:private	signature:(const segment_type& addend)
_add	icl/interval_base_set.hpp	/^    iterator _add(iterator prior, const segment_type& addend);$/;"	p	class:boost::icl::interval_base_set	access:private	signature:(iterator prior, const segment_type& addend)
_add	icl/map.hpp	/^    ::_add(const element_type& addend)$/;"	f	class:boost::icl::map	signature:(const element_type& addend)
_add	icl/map.hpp	/^    ::_add(iterator prior_, const value_type& addend)$/;"	f	class:boost::icl::map	signature:(iterator prior_, const value_type& addend)
_add	icl/map.hpp	/^    iterator _add(iterator prior, const element_type& value_pair);$/;"	p	class:boost::icl::map	access:private	signature:(iterator prior, const element_type& value_pair)
_add	icl/map.hpp	/^    map& _add(const element_type& value_pair);$/;"	p	class:boost::icl::map	access:private	signature:(const element_type& value_pair)
_bits	icl/interval_bounds.hpp	/^    bound_type _bits;$/;"	m	class:boost::icl::interval_bounds	access:public
_bound	icl/interval_bounds.hpp	/^    interval_bounds _bound;$/;"	m	class:boost::icl::bounded_value	access:private
_bounds	icl/continuous_interval.hpp	/^    interval_bounds _bounds;$/;"	m	class:boost::icl::continuous_interval	access:private
_bounds	icl/discrete_interval.hpp	/^    interval_bounds _bounds;$/;"	m	class:boost::icl::discrete_interval	access:private
_cont	icl/iterator.hpp	/^    ContainerT*                   _cont;$/;"	m	class:boost::icl::add_iterator	access:private
_cont	icl/iterator.hpp	/^    ContainerT*                   _cont;$/;"	m	class:boost::icl::insert_iterator	access:private
_insert	icl/interval_base_map.hpp	/^    ::_insert(const segment_type& addend)$/;"	f	class:boost::icl::interval_base_map	signature:(const segment_type& addend)
_insert	icl/interval_base_map.hpp	/^    ::_insert(iterator prior_, const segment_type& addend)$/;"	f	class:boost::icl::interval_base_map	signature:(iterator prior_, const segment_type& addend)
_insert	icl/interval_base_map.hpp	/^    iterator _insert(const segment_type& interval_value_pair);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const segment_type& interval_value_pair)
_insert	icl/interval_base_map.hpp	/^    iterator _insert(iterator prior_, const segment_type& interval_value_pair);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(iterator prior_, const segment_type& interval_value_pair)
_inter_pos	icl/detail/element_iterator.hpp	/^    mutable domain_type            _inter_pos; \/\/ inter position : Position within the current segment$/;"	m	class:boost::icl::element_iterator	access:private
_iter	icl/iterator.hpp	/^    typename ContainerT::iterator _iter;$/;"	m	class:boost::icl::add_iterator	access:private
_iter	icl/iterator.hpp	/^    typename ContainerT::iterator _iter;$/;"	m	class:boost::icl::insert_iterator	access:private
_left	icl/detail/element_comparer.hpp	/^    const LeftT&  _left;$/;"	m	class:boost::icl::Interval_Set::element_comparer	access:private
_left	icl/detail/interval_subset_comparer.hpp	/^    const LeftT&  _left;$/;"	m	class:boost::icl::Interval_Set::subset_comparer	access:private
_left	icl/detail/subset_comparer.hpp	/^    const LeftT&  _left;$/;"	m	class:boost::icl::Set::subset_comparer	access:private
_left_end	icl/detail/element_comparer.hpp	/^    LeftIterT     _left_end;$/;"	m	class:boost::icl::Interval_Set::element_comparer	access:private
_left_end	icl/detail/interval_subset_comparer.hpp	/^    LeftIterT     _left_end;$/;"	m	class:boost::icl::Interval_Set::subset_comparer	access:private
_left_end	icl/detail/subset_comparer.hpp	/^    LeftIterT     _left_end;$/;"	m	class:boost::icl::Set::subset_comparer	access:private
_lwb	icl/closed_interval.hpp	/^    DomainT _lwb;$/;"	m	class:boost::icl::closed_interval	access:private
_lwb	icl/continuous_interval.hpp	/^    domain_type     _lwb;$/;"	m	class:boost::icl::continuous_interval	access:private
_lwb	icl/discrete_interval.hpp	/^    domain_type     _lwb;$/;"	m	class:boost::icl::discrete_interval	access:private
_lwb	icl/left_open_interval.hpp	/^    DomainT _lwb;$/;"	m	class:boost::icl::left_open_interval	access:private
_lwb	icl/open_interval.hpp	/^    DomainT _lwb;$/;"	m	class:boost::icl::open_interval	access:private
_lwb	icl/right_open_interval.hpp	/^    domain_type _lwb;$/;"	m	class:boost::icl::right_open_interval	access:private
_map	icl/interval_base_map.hpp	/^    ImplMapT _map;$/;"	m	class:boost::icl::interval_base_map	access:protected
_prior_left	icl/detail/element_comparer.hpp	/^    LeftIterT     _prior_left;$/;"	m	class:boost::icl::Interval_Set::element_comparer	access:private
_prior_left	icl/detail/interval_subset_comparer.hpp	/^    LeftIterT     _prior_left;$/;"	m	class:boost::icl::Interval_Set::subset_comparer	access:private
_prior_right	icl/detail/element_comparer.hpp	/^    RightIterT    _prior_right;$/;"	m	class:boost::icl::Interval_Set::element_comparer	access:private
_prior_right	icl/detail/interval_subset_comparer.hpp	/^    RightIterT    _prior_right;$/;"	m	class:boost::icl::Interval_Set::subset_comparer	access:private
_reptator	icl/detail/element_iterator.hpp	/^    mutable domain_difference_type _reptator;  \/\/ reptare:  to sneak : the slow moving iterator 0 based$/;"	m	class:boost::icl::element_iterator	access:private
_result	icl/detail/element_comparer.hpp	/^    int           _result;$/;"	m	class:boost::icl::Interval_Set::element_comparer	access:private
_result	icl/detail/interval_subset_comparer.hpp	/^    int           _result;$/;"	m	class:boost::icl::Interval_Set::subset_comparer	access:private
_result	icl/detail/subset_comparer.hpp	/^    int           _result;$/;"	m	class:boost::icl::Set::subset_comparer	access:private
_right	icl/detail/element_comparer.hpp	/^    const RightT& _right;$/;"	m	class:boost::icl::Interval_Set::element_comparer	access:private
_right	icl/detail/interval_subset_comparer.hpp	/^    const RightT& _right;$/;"	m	class:boost::icl::Interval_Set::subset_comparer	access:private
_right	icl/detail/subset_comparer.hpp	/^    const RightT& _right;$/;"	m	class:boost::icl::Set::subset_comparer	access:private
_right_end	icl/detail/element_comparer.hpp	/^    RightIterT    _right_end;$/;"	m	class:boost::icl::Interval_Set::element_comparer	access:private
_right_end	icl/detail/interval_subset_comparer.hpp	/^    RightIterT    _right_end;$/;"	m	class:boost::icl::Interval_Set::subset_comparer	access:private
_right_end	icl/detail/subset_comparer.hpp	/^    RightIterT    _right_end;$/;"	m	class:boost::icl::Set::subset_comparer	access:private
_saltator	icl/detail/element_iterator.hpp	/^    segment_iterator               _saltator;  \/\/ satltare: to jump  : the fast moving iterator$/;"	m	class:boost::icl::element_iterator	access:private
_set	icl/interval_base_set.hpp	/^    ImplSetT _set;$/;"	m	class:boost::icl::interval_base_set	access:protected
_subtract	icl/interval_base_map.hpp	/^    ::_subtract(const segment_type& minuend)$/;"	f	class:boost::icl::interval_base_map	signature:(const segment_type& minuend)
_subtract	icl/interval_base_map.hpp	/^    void _subtract(const segment_type& interval_value_pair);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const segment_type& interval_value_pair)
_subtract	icl/map.hpp	/^    map& _subtract(const element_type& value_pair);$/;"	p	class:boost::icl::map	access:private	signature:(const element_type& value_pair)
_subtract	icl/map.hpp	/^    map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc>::_subtract(const value_type& minuend)$/;"	f	class:boost::icl::map	signature:(const value_type& minuend)
_upb	icl/closed_interval.hpp	/^    DomainT _upb;$/;"	m	class:boost::icl::closed_interval	access:private
_upb	icl/continuous_interval.hpp	/^    domain_type     _upb;$/;"	m	class:boost::icl::continuous_interval	access:private
_upb	icl/discrete_interval.hpp	/^    domain_type     _upb;$/;"	m	class:boost::icl::discrete_interval	access:private
_upb	icl/left_open_interval.hpp	/^    DomainT _upb;$/;"	m	class:boost::icl::left_open_interval	access:private
_upb	icl/open_interval.hpp	/^    DomainT _upb;$/;"	m	class:boost::icl::open_interval	access:private
_upb	icl/right_open_interval.hpp	/^    domain_type _upb;$/;"	m	class:boost::icl::right_open_interval	access:private
_value	icl/interval_bounds.hpp	/^    domain_type     _value;$/;"	m	class:boost::icl::bounded_value	access:private
abs	icl/type_traits/value_size.hpp	/^Type abs(Type val) { return val < 0 ? -val : val; }$/;"	f	namespace:boost::icl	signature:(Type val)
absorb_identities	icl/concept/element_map.hpp	/^absorb_identities(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
absorb_identities	icl/concept/element_map.hpp	/^absorb_identities(Type&){}$/;"	f	namespace:boost::icl	signature:(Type&)
absorb_identities	icl/concept/interval_map.hpp	/^absorb_identities(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
absorbs_identities	icl/interval_base_map.hpp	/^struct absorbs_identities<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
absorbs_identities	icl/interval_map.hpp	/^struct absorbs_identities<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
absorbs_identities	icl/map.hpp	/^    enum { absorbs_identities = false };$/;"	e	enum:boost::icl::partial_enricher::__anon14
absorbs_identities	icl/map.hpp	/^    enum { absorbs_identities = false };$/;"	e	enum:boost::icl::total_enricher::__anon18
absorbs_identities	icl/map.hpp	/^    enum { absorbs_identities = true };$/;"	e	enum:boost::icl::partial_absorber::__anon12
absorbs_identities	icl/map.hpp	/^    enum { absorbs_identities = true };$/;"	e	enum:boost::icl::total_absorber::__anon16
absorbs_identities	icl/map.hpp	/^struct absorbs_identities<icl::map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc> >$/;"	s	namespace:boost::icl
absorbs_identities	icl/split_interval_map.hpp	/^struct absorbs_identities<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
absorbs_identities	icl/type_traits/absorbs_identities.hpp	/^    template <class Type> struct absorbs_identities$/;"	s	namespace:boost::icl
adapt	icl/detail/element_iterator.hpp	/^    typedef typename segment_adapter<segment_iterator,segment_type>::type adapt;$/;"	t	class:boost::icl::element_iterator	access:private
add	icl/concept/element_map.hpp	/^add(Type& object, const typename Type::value_type& value_pair)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& value_pair)
add	icl/concept/element_map.hpp	/^add(Type& object, typename Type::iterator prior, $/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator prior, const typename Type::value_type& value_pair)
add	icl/concept/element_set.hpp	/^add(Type& object, const typename Type::value_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& operand)
add	icl/concept/element_set.hpp	/^add(Type& object, typename Type::iterator prior, $/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator prior, const typename Type::value_type& operand)
add	icl/concept/interval_map.hpp	/^add(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
add	icl/concept/interval_map.hpp	/^add(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
add	icl/concept/interval_map.hpp	/^add(Type& object, typename Type::iterator      prior_,$/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator prior_, const typename Type::segment_type& operand)
add	icl/concept/interval_set.hpp	/^add(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
add	icl/concept/interval_set.hpp	/^add(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
add	icl/concept/interval_set.hpp	/^add(Type& object, typename Type::iterator      prior, $/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator prior, const typename Type::segment_type& operand)
add	icl/detail/interval_set_algo.hpp	/^    add(Type& object, const typename Type::value_type& addend)$/;"	f	namespace:boost::icl::Interval_Set	signature:(Type& object, const typename Type::value_type& addend)
add	icl/detail/interval_set_algo.hpp	/^    add(Type& object, typename Type::iterator    prior_, $/;"	f	namespace:boost::icl::Interval_Set	signature:(Type& object, typename Type::iterator prior_, const typename Type::value_type& addend)
add	icl/interval_base_map.hpp	/^        static void add(Type& intersection, interval_type& common_interval, $/;"	f	struct:boost::icl::interval_base_map::on_codomain_model	access:public	signature:(Type& intersection, interval_type& common_interval, const codomain_type& flip_value, const codomain_type& co_value)
add	icl/interval_base_map.hpp	/^        static void add(Type& intersection, interval_type& common_interval, $/;"	f	struct:boost::icl::interval_base_map::on_codomain_model	access:public	signature:(Type& intersection, interval_type& common_interval, const codomain_type&, const codomain_type&)
add	icl/interval_base_map.hpp	/^    SubType& add(const element_type& key_value_pair) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const element_type& key_value_pair)
add	icl/interval_base_map.hpp	/^    SubType& add(const segment_type& interval_value_pair) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const segment_type& interval_value_pair)
add	icl/interval_base_map.hpp	/^    iterator add(iterator prior_, const segment_type& interval_value_pair) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(iterator prior_, const segment_type& interval_value_pair)
add	icl/interval_base_set.hpp	/^    SubType& add(const element_type& key) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const element_type& key)
add	icl/interval_base_set.hpp	/^    SubType& add(const segment_type& inter_val) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const segment_type& inter_val)
add	icl/interval_base_set.hpp	/^    iterator add(iterator prior_, const segment_type& inter_val) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(iterator prior_, const segment_type& inter_val)
add	icl/map.hpp	/^    iterator add(iterator prior, const value_type& value_pair) $/;"	f	class:boost::icl::map	access:public	signature:(iterator prior, const value_type& value_pair)
add	icl/map.hpp	/^    map& add(const value_type& value_pair) $/;"	f	class:boost::icl::map	access:public	signature:(const value_type& value_pair)
add_at	icl/interval_base_map.hpp	/^    add_at(const iterator& prior_, const interval_type& inter_val, $/;"	f	class:boost::icl::interval_base_map	access:protected	signature:(const iterator& prior_, const interval_type& inter_val, const codomain_type& co_val )
add_front	icl/detail/interval_set_algo.hpp	/^void add_front(Type& object, const typename Type::interval_type& inter_val, $/;"	f	namespace:boost::icl::Interval_Set	signature:(Type& object, const typename Type::interval_type& inter_val, typename Type::iterator& first_)
add_front	icl/interval_base_map.hpp	/^    ::add_front(const interval_type& inter_val, iterator& first_)$/;"	f	class:boost::icl::interval_base_map	signature:(const interval_type& inter_val, iterator& first_)
add_front	icl/interval_base_map.hpp	/^    void add_front(const interval_type& inter_val, iterator& first_);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const interval_type& inter_val, iterator& first_)
add_front	icl/interval_base_set.hpp	/^    ::add_front(const interval_type& inter_val, iterator& first_)$/;"	f	class:boost::icl::interval_base_set	signature:(const interval_type& inter_val, iterator& first_)
add_front	icl/interval_base_set.hpp	/^    void add_front(const interval_type& inter_val, iterator& first_);$/;"	p	class:boost::icl::interval_base_set	access:protected	signature:(const interval_type& inter_val, iterator& first_)
add_if	icl/concept/element_associator.hpp	/^add_if(const Predicate& pred, Type& object, const Type& src)$/;"	f	namespace:boost::icl	signature:(const Predicate& pred, Type& object, const Type& src)
add_if	icl/concept/interval_map.hpp	/^add_if(const Predicate& pred, MapT& object, const MapT& src)$/;"	f	namespace:boost::icl	signature:(const Predicate& pred, MapT& object, const MapT& src)
add_intersection	icl/concept/element_associator.hpp	/^add_intersection(Type& section, const Type&              object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::key_type& operand)
add_intersection	icl/concept/element_associator.hpp	/^add_intersection(Type& section, const Type& object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename key_container_type_of<Type>::type& operand)
add_intersection	icl/concept/element_map.hpp	/^add_intersection(Type& section, const Type&               object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::element_type& operand)
add_intersection	icl/concept/element_map.hpp	/^add_intersection(Type& section, const Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const Type& operand)
add_intersection	icl/concept/interval_associator.hpp	/^add_intersection(Type& section, const Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const OperandT& operand)
add_intersection	icl/concept/interval_map.hpp	/^add_intersection(Type& section, const Type& object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::domain_type& key_value)
add_intersection	icl/concept/interval_map.hpp	/^add_intersection(Type& section, const Type& object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::element_type& operand)
add_intersection	icl/concept/interval_map.hpp	/^add_intersection(Type& section, const Type& object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::interval_type& inter_val)
add_intersection	icl/concept/interval_map.hpp	/^add_intersection(Type& section, const Type& object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::segment_type& operand)
add_intersection	icl/concept/interval_map.hpp	/^add_intersection(Type& section, const Type& object, const KeySetT& key_set)$/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const KeySetT& key_set)
add_intersection	icl/concept/interval_map.hpp	/^add_intersection(Type& section, const Type& object, const MapT& operand)$/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const MapT& operand)
add_intersection	icl/concept/interval_set.hpp	/^add_intersection(Type& section, const Type& object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::element_type& operand)
add_intersection	icl/concept/interval_set.hpp	/^add_intersection(Type& section, const Type& object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::segment_type& segment)
add_intersection	icl/interval_base_map.hpp	/^        static void add_intersection(Type& section, const Type& object, $/;"	f	struct:boost::icl::interval_base_map::on_definedness	access:public	signature:(Type& section, const Type& object, const segment_type& operand)
add_intersection	icl/interval_base_map.hpp	/^    void add_intersection(SubType& section, const segment_type& interval_value_pair)const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(SubType& section, const segment_type& interval_value_pair) const
add_intersection	icl/map.hpp	/^        static void add_intersection(Type& section, const Type& object, $/;"	f	struct:boost::icl::map::on_definedness	access:public	signature:(Type& section, const Type& object, const element_type& operand)
add_intersection	icl/map.hpp	/^    void add_intersection(map& section, const element_type& key_value_pair)const$/;"	f	class:boost::icl::map	access:public	signature:(map& section, const element_type& key_value_pair) const
add_iterator	icl/iterator.hpp	/^    add_iterator(ContainerT& cont, typename ContainerT::iterator iter)$/;"	f	class:boost::icl::add_iterator	access:public	signature:(ContainerT& cont, typename ContainerT::iterator iter)
add_iterator	icl/iterator.hpp	/^template<class ContainerT> class add_iterator$/;"	c	namespace:boost::icl	inherits:std::iterator
add_main	icl/detail/interval_set_algo.hpp	/^void add_main(Type& object, typename Type::interval_type& rest_interval, $/;"	f	namespace:boost::icl::Interval_Set	signature:(Type& object, typename Type::interval_type& rest_interval, typename Type::iterator& it_, const typename Type::iterator& last_)
add_main	icl/interval_base_map.hpp	/^    ::add_main(interval_type& inter_val, const CodomainT& co_val, $/;"	f	class:boost::icl::interval_base_map	signature:(interval_type& inter_val, const CodomainT& co_val, iterator& it_, const iterator& last_)
add_main	icl/interval_base_map.hpp	/^    void add_main(interval_type& inter_val, const CodomainT& co_val, $/;"	p	class:boost::icl::interval_base_map	access:private	signature:(interval_type& inter_val, const CodomainT& co_val, iterator& it_, const iterator& last_)
add_main	icl/interval_base_set.hpp	/^    ::add_main(interval_type& rest_interval, iterator& it_, const iterator& last_)$/;"	f	class:boost::icl::interval_base_set	signature:(interval_type& rest_interval, iterator& it_, const iterator& last_)
add_main	icl/interval_base_set.hpp	/^    void add_main(interval_type& inter_val, iterator& it_, const iterator& last_);$/;"	p	class:boost::icl::interval_base_set	access:protected	signature:(interval_type& inter_val, iterator& it_, const iterator& last_)
add_over	icl/detail/interval_set_algo.hpp	/^    inline static iterator add_over$/;"	f	struct:boost::icl::Interval_Set::on_style	access:public	signature:(Type& object, const interval_type& addend)
add_over	icl/detail/interval_set_algo.hpp	/^    inline static iterator add_over$/;"	f	struct:boost::icl::Interval_Set::on_style	access:public	signature:(Type& object, const interval_type& addend, iterator last_)
add_over	icl/interval_set.hpp	/^    iterator add_over(const interval_type& addend)$/;"	f	class:boost::icl::interval_set	access:private	signature:(const interval_type& addend)
add_over	icl/interval_set.hpp	/^    iterator add_over(const interval_type& addend, iterator last_)$/;"	f	class:boost::icl::interval_set	access:private	signature:(const interval_type& addend, iterator last_)
add_over	icl/separate_interval_set.hpp	/^    iterator add_over(const interval_type& addend)$/;"	f	class:boost::icl::separate_interval_set	access:private	signature:(const interval_type& addend)
add_over	icl/separate_interval_set.hpp	/^    iterator add_over(const interval_type& addend, iterator last_)$/;"	f	class:boost::icl::separate_interval_set	access:private	signature:(const interval_type& addend, iterator last_)
add_over	icl/split_interval_set.hpp	/^    iterator add_over(const interval_type& addend)$/;"	f	class:boost::icl::split_interval_set	access:private	signature:(const interval_type& addend)
add_over	icl/split_interval_set.hpp	/^    iterator add_over(const interval_type& addend, iterator last_)$/;"	f	class:boost::icl::split_interval_set	access:private	signature:(const interval_type& addend, iterator last_)
add_rear	icl/detail/interval_set_algo.hpp	/^void add_rear(Type& object, const typename Type::interval_type& inter_val, $/;"	f	namespace:boost::icl::Interval_Set	signature:(Type& object, const typename Type::interval_type& inter_val, typename Type::iterator& it_ )
add_rear	icl/interval_base_map.hpp	/^    ::add_rear(const interval_type& inter_val, const CodomainT& co_val, iterator& it_)$/;"	f	class:boost::icl::interval_base_map	signature:(const interval_type& inter_val, const CodomainT& co_val, iterator& it_)
add_rear	icl/interval_base_map.hpp	/^    void add_rear(const interval_type& inter_val, const CodomainT& co_val, iterator& it_);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const interval_type& inter_val, const CodomainT& co_val, iterator& it_)
add_rear	icl/interval_base_set.hpp	/^    ::add_rear(const interval_type& inter_val, iterator& it_)$/;"	f	class:boost::icl::interval_base_set	signature:(const interval_type& inter_val, iterator& it_)
add_rear	icl/interval_base_set.hpp	/^    void add_rear(const interval_type& inter_val, iterator& it_);$/;"	p	class:boost::icl::interval_base_set	access:protected	signature:(const interval_type& inter_val, iterator& it_)
add_segment	icl/detail/interval_set_algo.hpp	/^void add_segment(Type& object, const typename Type::interval_type& inter_val, $/;"	f	namespace:boost::icl::Interval_Set	signature:(Type& object, const typename Type::interval_type& inter_val, typename Type::iterator& it_ )
add_segment	icl/interval_base_map.hpp	/^    ::add_segment(const interval_type& inter_val, const CodomainT& co_val, iterator& it_)$/;"	f	class:boost::icl::interval_base_map	signature:(const interval_type& inter_val, const CodomainT& co_val, iterator& it_)
add_segment	icl/interval_base_map.hpp	/^    void add_segment(const interval_type& inter_val, const CodomainT& co_val, iterator& it_);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const interval_type& inter_val, const CodomainT& co_val, iterator& it_)
add_segment	icl/interval_base_set.hpp	/^    ::add_segment(const interval_type& inter_val, iterator& it_)$/;"	f	class:boost::icl::interval_base_set	signature:(const interval_type& inter_val, iterator& it_)
add_segment	icl/interval_base_set.hpp	/^    void add_segment(const interval_type& inter_val, iterator& it_);$/;"	p	class:boost::icl::interval_base_set	access:protected	signature:(const interval_type& inter_val, iterator& it_)
adder	icl/iterator.hpp	/^inline add_iterator<ContainerT> adder(ContainerT& cont, IteratorT iter_)$/;"	f	namespace:boost::icl	signature:(ContainerT& cont, IteratorT iter_)
adds_inversely	icl/type_traits/adds_inversely.hpp	/^struct adds_inversely$/;"	s	namespace:boost::icl
all	icl/concept/interval_bounds.hpp	/^inline interval_bounds all(interval_bounds x1)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1)
all	icl/interval_bounds.hpp	/^    interval_bounds all  ()const { return interval_bounds(_bits & _all  ); }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:() const
allocator_type	icl/interval_base_map.hpp	/^        allocator_type;$/;"	t	class:boost::icl::interval_base_map	access:public
allocator_type	icl/interval_base_set.hpp	/^    typedef Alloc<interval_type> allocator_type;$/;"	t	class:boost::icl::interval_base_set	access:public
allocator_type	icl/interval_set.hpp	/^    typedef Alloc<interval_type> allocator_type;$/;"	t	class:boost::icl::interval_set	access:public
allocator_type	icl/map.hpp	/^    typedef Alloc<typename std::pair<const DomainT, CodomainT> >  allocator_type;$/;"	t	class:boost::icl::map	access:public
allocator_type	icl/separate_interval_set.hpp	/^    typedef Alloc<interval_type> allocator_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
allocator_type	icl/split_interval_set.hpp	/^    typedef Alloc<interval_type> allocator_type;$/;"	t	class:boost::icl::split_interval_set	access:public
apply	icl/closed_interval.hpp	/^    static std::size_t apply(const icl::closed_interval<DomainT>&) $/;"	f	struct:boost::icl::value_size	access:public	signature:(const icl::closed_interval<DomainT>&)
apply	icl/closed_interval.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
apply	icl/continuous_interval.hpp	/^    static std::size_t apply(const icl::continuous_interval<DomainT>&) $/;"	f	struct:boost::icl::value_size	access:public	signature:(const icl::continuous_interval<DomainT>&)
apply	icl/continuous_interval.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
apply	icl/detail/interval_morphism.hpp	/^    inline std::string binary_template_to_string<segmental::atomizer>::apply() { return "@"; }$/;"	f	class:boost::icl::binary_template_to_string	signature:()
apply	icl/detail/interval_morphism.hpp	/^    inline std::string binary_template_to_string<segmental::clusterer>::apply() { return "&"; }$/;"	f	class:boost::icl::binary_template_to_string	signature:()
apply	icl/detail/interval_morphism.hpp	/^    inline std::string binary_template_to_string<segmental::identity_absorber>::apply() { return "a0"; }$/;"	f	class:boost::icl::binary_template_to_string	signature:()
apply	icl/detail/interval_morphism.hpp	/^    inline std::string binary_template_to_string<segmental::joiner>::apply() { return "j"; }$/;"	f	class:boost::icl::binary_template_to_string	signature:()
apply	icl/detail/interval_subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)$/;"	f	struct:boost::icl::Interval_Set::atomic_codomain_compare	access:public	signature:(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)
apply	icl/detail/interval_subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)$/;"	f	struct:boost::icl::Interval_Set::map_codomain_compare	access:public	signature:(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)
apply	icl/detail/interval_subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)$/;"	f	struct:boost::icl::Interval_Set::settic_codomain_compare	access:public	signature:(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)
apply	icl/detail/interval_subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator&, typename RightT::const_iterator)$/;"	f	struct:boost::icl::Interval_Set::empty_codomain_compare	access:public	signature:(typename LeftT::const_iterator&, typename RightT::const_iterator)
apply	icl/detail/std_set.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
apply	icl/detail/subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)$/;"	f	struct:boost::icl::Set::atomic_codomain_compare	access:public	signature:(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)
apply	icl/detail/subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)$/;"	f	struct:boost::icl::Set::map_codomain_compare	access:public	signature:(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)
apply	icl/detail/subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)$/;"	f	struct:boost::icl::Set::settic_codomain_compare	access:public	signature:(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)
apply	icl/detail/subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator&, typename RightT::const_iterator&)$/;"	f	struct:boost::icl::Set::empty_codomain_compare	access:public	signature:(typename LeftT::const_iterator&, typename RightT::const_iterator&)
apply	icl/discrete_interval.hpp	/^    static std::size_t apply(const icl::discrete_interval<DomainT>&) $/;"	f	struct:boost::icl::value_size	access:public	signature:(const icl::discrete_interval<DomainT>&)
apply	icl/discrete_interval.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_bit_add>::apply() { return "b|="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_bit_and>::apply() { return "b&="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_bit_subtract>::apply() { return "b-="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_caret>::apply() { return "^="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_erase>::apply() { return "ers="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_erasure>::apply() $/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_et>::apply() { return "&="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_identity>::apply() $/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_insert>::apply() { return "ins="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_max>::apply() { return "max="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_min>::apply() { return "min="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_minus>::apply() { return "-="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_plus>::apply() { return "+="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_slash>::apply() { return "\/="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_star>::apply() { return "*="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/interval_map.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
apply	icl/interval_set.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
apply	icl/left_open_interval.hpp	/^    static std::size_t apply(const icl::left_open_interval<DomainT>&) $/;"	f	struct:boost::icl::value_size	access:public	signature:(const icl::left_open_interval<DomainT>&)
apply	icl/left_open_interval.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
apply	icl/map.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
apply	icl/map.hpp	/^inline std::string type_to_string<partial_absorber>::apply() { return "@0"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/map.hpp	/^inline std::string type_to_string<partial_enricher>::apply() { return "e0"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/map.hpp	/^inline std::string type_to_string<total_absorber>::apply() { return "^0"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/map.hpp	/^inline std::string type_to_string<total_enricher>::apply() { return "e^0"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/open_interval.hpp	/^    static std::size_t apply(const icl::open_interval<DomainT>&) $/;"	f	struct:boost::icl::value_size	access:public	signature:(const icl::open_interval<DomainT>&)
apply	icl/open_interval.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
apply	icl/predicates/distinct_equal.hpp	/^    inline std::string unary_template_to_string<icl::distinct_equal>::apply()  $/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/predicates/element_equal.hpp	/^    inline std::string unary_template_to_string<icl::element_equal>::apply()  $/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/predicates/std_equal.hpp	/^    inline std::string unary_template_to_string<icl::std_equal>::apply()$/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/predicates/sub_super_set.hpp	/^    inline std::string unary_template_to_string<icl::sub_super_set>::apply()  $/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/predicates/sub_super_set.hpp	/^    inline std::string unary_template_to_string<icl::super_sub_set>::apply()  $/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/right_open_interval.hpp	/^    static std::size_t apply(const icl::right_open_interval<DomainT>&) $/;"	f	struct:boost::icl::value_size	access:public	signature:(const icl::right_open_interval<DomainT>&)
apply	icl/right_open_interval.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
apply	icl/separate_interval_set.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
apply	icl/split_interval_map.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
apply	icl/split_interval_set.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
apply	icl/type_traits/identity_element.hpp	/^    inline std::string unary_template_to_string<identity_element>::apply() { return "0"; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
apply	icl/type_traits/succ_pred.hpp	/^        inline static DomainT apply(DomainT value){ return ++value; }$/;"	f	struct:boost::icl::detail::predecessor	access:public	signature:(DomainT value)
apply	icl/type_traits/succ_pred.hpp	/^        inline static DomainT apply(DomainT value){ return ++value; }$/;"	f	struct:boost::icl::detail::successor	access:public	signature:(DomainT value)
apply	icl/type_traits/succ_pred.hpp	/^        inline static DomainT apply(DomainT value){ return --value; }$/;"	f	struct:boost::icl::detail::predecessor	access:public	signature:(DomainT value)
apply	icl/type_traits/succ_pred.hpp	/^        inline static DomainT apply(DomainT value){ return --value; }$/;"	f	struct:boost::icl::detail::successor	access:public	signature:(DomainT value)
apply	icl/type_traits/succ_pred.hpp	/^    inline static DomainT apply(DomainT value)$/;"	f	struct:boost::icl::predecessor	access:public	signature:(DomainT value)
apply	icl/type_traits/succ_pred.hpp	/^    inline static DomainT apply(DomainT value)$/;"	f	struct:boost::icl::successor	access:public	signature:(DomainT value)
apply	icl/type_traits/to_string.hpp	/^    static std::string apply(const Type& value)$/;"	f	struct:boost::icl::to_string	access:public	signature:(const Type& value)
apply	icl/type_traits/type_to_string.hpp	/^        static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
apply	icl/type_traits/type_to_string.hpp	/^        static std::string apply();$/;"	p	struct:boost::icl::binary_template_to_string	access:public	signature:()
apply	icl/type_traits/type_to_string.hpp	/^        static std::string apply();$/;"	p	struct:boost::icl::type_to_string	access:public	signature:()
apply	icl/type_traits/type_to_string.hpp	/^        static std::string apply();$/;"	p	struct:boost::icl::unary_template_to_string	access:public	signature:()
apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<bool>::apply() { return "bool"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<char>::apply() { return "char"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<double>::apply() { return "dbl"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<float>::apply() { return "flt"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<int>::apply()  { return "int"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<long long>::apply(){ return "Long"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<long>::apply() { return "long"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<short>::apply(){ return "short"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<std::string>::apply() { return "string"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<unsigned char>::apply(){ return "char+"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<unsigned int>::apply()  { return "int+"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<unsigned long long>::apply(){ return "Long+"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<unsigned long>::apply() { return "long+"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<unsigned short>::apply(){ return "short+"; }$/;"	f	class:boost::icl::type_to_string	signature:()
apply	icl/type_traits/value_size.hpp	/^    static std::size_t apply(const Type& val);$/;"	p	struct:boost::icl::value_size	access:public	signature:(const Type& val)
apply	icl/type_traits/value_size.hpp	/^inline std::size_t value_size<Type>::apply(const Type& value)$/;"	f	class:boost::icl::value_size	signature:(const Type& value)
apply	icl/type_traits/value_size.hpp	/^template<> inline std::size_t value_size<double>::apply(const double& value) $/;"	f	class:boost::icl::value_size	signature:(const double& value)
apply	icl/type_traits/value_size.hpp	/^template<> inline std::size_t value_size<int>::apply(const int& value) $/;"	f	class:boost::icl::value_size	signature:(const int& value)
argument_type	icl/functors.hpp	/^            argument_type;$/;"	t	struct:boost::icl::conversion	access:public
argument_type	icl/functors.hpp	/^            remove_reference<typename Functor::first_argument_type>::type argument_type;$/;"	t	struct:boost::icl::inverse	access:public
argument_type	icl/functors.hpp	/^        typedef typename base_type::argument_type argument_type;$/;"	t	struct:boost::icl::version	access:public
assign	icl/interval_map.hpp	/^    void assign(const interval_base_map<SubType,DomainT,CodomainT,$/;"	f	class:boost::icl::interval_map	access:public	signature:(const interval_base_map<SubType,DomainT,CodomainT, Traits,Compare,Combine,Section,Interval,Alloc>& src)
assign	icl/interval_set.hpp	/^    void assign(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)$/;"	f	class:boost::icl::interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
assign	icl/separate_interval_set.hpp	/^    void assign(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
assign	icl/split_interval_map.hpp	/^    void assign(const interval_base_map<SubType,DomainT,CodomainT,$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(const interval_base_map<SubType,DomainT,CodomainT, Traits,Compare,Combine,Section,Interval,Alloc>& src)
assign	icl/split_interval_set.hpp	/^    void assign(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
assign_if	icl/concept/element_associator.hpp	/^assign_if(const Predicate& pred, Type& object, const Type& src)$/;"	f	namespace:boost::icl	signature:(const Predicate& pred, Type& object, const Type& src)
assign_if	icl/concept/interval_map.hpp	/^assign_if(const Predicate& pred, MapT& object, const MapT& src)$/;"	f	namespace:boost::icl	signature:(const Predicate& pred, MapT& object, const MapT& src)
atomic_codomain_compare	icl/detail/interval_subset_comparer.hpp	/^struct atomic_codomain_compare$/;"	s	namespace:boost::icl::Interval_Set
atomic_codomain_compare	icl/detail/subset_comparer.hpp	/^struct atomic_codomain_compare$/;"	s	namespace:boost::icl::Set
atomize	icl/detail/interval_morphism.hpp	/^        void atomize(ElementContainerT& result, const IntervalContainerT& src)$/;"	f	namespace:boost::icl::segmental	signature:(ElementContainerT& result, const IntervalContainerT& src)
atomized_type	icl/interval_base_map.hpp	/^                              Traits,Compare,Combine,Section,Alloc> atomized_type;$/;"	t	class:boost::icl::interval_base_map	access:public
atomized_type	icl/interval_base_set.hpp	/^    typedef typename ICL_IMPL_SPACE::set<DomainT,domain_compare,Alloc<DomainT> > atomized_type;$/;"	t	class:boost::icl::interval_base_set	access:public
atomized_type	icl/interval_set.hpp	/^    typedef typename base_type::atomized_type atomized_type;$/;"	t	class:boost::icl::interval_set	access:public
atomized_type	icl/separate_interval_set.hpp	/^    typedef typename base_type::atomized_type atomized_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
atomized_type	icl/split_interval_set.hpp	/^    typedef typename base_type::atomized_type atomized_type;$/;"	t	class:boost::icl::split_interval_set	access:public
atomizer	icl/detail/interval_morphism.hpp	/^        struct atomizer$/;"	s	namespace:boost::icl::segmental
base_type	icl/functors.hpp	/^        typedef conversion<Combiner> base_type;$/;"	t	struct:boost::icl::version	access:public
base_type	icl/functors.hpp	/^        typedef conversion<icl::inplace_minus<Type> > base_type;$/;"	t	struct:boost::icl::version	access:public
base_type	icl/functors.hpp	/^        typedef identity_based_inplace_combine<Type> base_type;$/;"	t	struct:boost::icl::inplace_erasure	access:public
base_type	icl/interval_map.hpp	/^                              DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> base_type;$/;"	t	class:boost::icl::interval_map	access:public
base_type	icl/interval_set.hpp	/^    typedef interval_base_set<type,DomainT,Compare,Interval,Alloc> base_type;$/;"	t	class:boost::icl::interval_set	access:public
base_type	icl/map.hpp	/^                                         allocator_type>   base_type;$/;"	t	class:boost::icl::map	access:public
base_type	icl/separate_interval_set.hpp	/^    typedef interval_base_set<type,DomainT,Compare,Interval,Alloc> base_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
base_type	icl/split_interval_map.hpp	/^                               DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> base_type;$/;"	t	class:boost::icl::split_interval_map	access:public
base_type	icl/split_interval_set.hpp	/^    typedef interval_base_set<type,DomainT,Compare,Interval,Alloc> base_type;$/;"	t	class:boost::icl::split_interval_set	access:public
begin	icl/interval_base_map.hpp	/^    const_iterator begin()const { return _map.begin(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:() const
begin	icl/interval_base_map.hpp	/^    iterator begin() { return _map.begin(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:()
begin	icl/interval_base_set.hpp	/^    const_iterator begin()const { return _set.begin(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:() const
begin	icl/interval_base_set.hpp	/^    iterator begin() { return _set.begin(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:()
between	icl/concept/interval.hpp	/^between(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
between	icl/concept/interval_map.hpp	/^between(SetT& in_between, const Type& object)$/;"	f	namespace:boost::icl	signature:(SetT& in_between, const Type& object)
between	icl/concept/interval_set.hpp	/^between(Type& in_between, const Type& object)$/;"	f	namespace:boost::icl	signature:(Type& in_between, const Type& object)
binary_template_to_string	icl/type_traits/type_to_string.hpp	/^    struct binary_template_to_string$/;"	s	namespace:boost::icl
bits	icl/interval_bounds.hpp	/^    bound_type bits()const{ return _bits; }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:() const
bool	icl/type_traits/predicate.hpp	/^        member_property( bool(Type::* pred)()const ): property<Type>(), m_pred(pred){}$/;"	f	class:boost::icl::member_property	access:public	signature:(Type::* pred) const
boost	icl/closed_interval.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/concept/comparable.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/concept/container.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/concept/element_associator.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/concept/element_map.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/concept/element_set.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/concept/element_set_value.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/concept/interval.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/concept/interval_associator.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/concept/interval_associator_base.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/concept/interval_bounds.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/concept/interval_map.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/concept/interval_set.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/concept/interval_set_value.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/concept/joinable.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/concept/map_value.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/concept/set_value.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/continuous_interval.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/detail/associated_value.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/detail/concept_check.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/detail/element_comparer.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/detail/element_iterator.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/detail/exclusive_less_than.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/detail/interval_map_algo.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/detail/interval_morphism.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/detail/interval_set_algo.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/detail/interval_subset_comparer.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/detail/map_algo.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/detail/mapped_reference.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/detail/notate.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/detail/on_absorbtion.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/detail/relation_state.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/detail/set_algo.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/detail/std_set.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/detail/subset_comparer.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/discrete_interval.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/dynamic_interval_traits.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/functors.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/gregorian.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/interval.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/interval_base_map.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/interval_base_set.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/interval_bounds.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/interval_combining_style.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/interval_map.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/interval_set.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/interval_traits.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/iterator.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/left_open_interval.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/map.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/open_interval.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/predicates/distinct_equal.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/predicates/element_equal.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/predicates/std_equal.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/predicates/sub_super_set.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/ptime.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/rational.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/right_open_interval.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/separate_interval_set.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/split_interval_map.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/split_interval_set.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/type_traits/absorbs_identities.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/adds_inversely.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/codomain_type_of.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/difference.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/difference_type_of.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/domain_type_of.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/element_type_of.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/has_inverse.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/has_set_semantics.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/identity_element.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/infinity.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/interval_type_default.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/interval_type_of.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_associative_element_container.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_asymmetric_interval.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_combinable.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/type_traits/is_concept_equivalent.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_container.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_continuous.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_continuous_interval.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_discrete.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_discrete_interval.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_element_container.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_icl_container.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_increasing.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_interval.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_interval_container.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_interval_joiner.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_interval_separator.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_interval_splitter.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_key_container_of.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_map.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_numeric.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_set.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/is_total.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/no_type.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/predicate.hpp	/^namespace boost{namespace icl$/;"	n
boost	icl/type_traits/rep_type_of.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/segment_type_of.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/size.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/size_type_of.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/succ_pred.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/to_string.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/type_to_string.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/unit_element.hpp	/^namespace boost{ namespace icl$/;"	n
boost	icl/type_traits/value_size.hpp	/^namespace boost{ namespace icl$/;"	n
boost::icl	icl/closed_interval.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/comparable.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/container.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/element_associator.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/element_map.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/element_set.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/element_set_value.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/interval.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/interval_associator.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/interval_associator_base.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/interval_bounds.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/interval_map.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/interval_set.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/interval_set_value.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/joinable.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/map_value.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/concept/set_value.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/continuous_interval.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/associated_value.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/concept_check.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/element_comparer.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/element_iterator.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/exclusive_less_than.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/interval_map_algo.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/interval_morphism.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/interval_set_algo.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/interval_subset_comparer.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/map_algo.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/mapped_reference.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/notate.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/on_absorbtion.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/relation_state.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/set_algo.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/std_set.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/detail/subset_comparer.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/discrete_interval.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/dynamic_interval_traits.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/functors.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/gregorian.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/interval.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/interval_base_map.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/interval_base_set.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/interval_bounds.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/interval_combining_style.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/interval_map.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/interval_set.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/interval_traits.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/iterator.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/left_open_interval.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/map.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/open_interval.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/predicates/distinct_equal.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/predicates/element_equal.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/predicates/std_equal.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/predicates/sub_super_set.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/ptime.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/rational.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/right_open_interval.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/separate_interval_set.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/split_interval_map.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/split_interval_set.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/absorbs_identities.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/adds_inversely.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/codomain_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/difference.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/difference_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/domain_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/element_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/has_inverse.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/has_set_semantics.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/identity_element.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/infinity.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/interval_type_default.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/interval_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_associative_element_container.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_asymmetric_interval.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_combinable.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_concept_equivalent.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_container.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_continuous.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_continuous_interval.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_discrete.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_discrete_interval.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_element_container.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_icl_container.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_increasing.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_interval.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_interval_container.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_interval_joiner.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_interval_separator.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_interval_splitter.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_key_container_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_map.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_numeric.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_set.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/is_total.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/no_type.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/predicate.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/rep_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/segment_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/size.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/size_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/succ_pred.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/to_string.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/type_to_string.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/unit_element.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl	icl/type_traits/value_size.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
boost::icl::BOOST_concept	icl/detail/concept_check.hpp	/^    BOOST_concept(EqualComparable,(Type))$/;"	f	namespace:boost::icl	signature:(EqualComparable,(Type))
boost::icl::Interval_Map	icl/detail/interval_map_algo.hpp	/^namespace Interval_Map$/;"	n	namespace:boost::icl
boost::icl::Interval_Map::contains	icl/detail/interval_map_algo.hpp	/^bool contains(const IntervalMapT& container, $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT& container, const typename IntervalMapT::element_type& key_value_pair)
boost::icl::Interval_Map::contains	icl/detail/interval_map_algo.hpp	/^bool contains(const IntervalMapT& container, $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT& container, const typename IntervalMapT::segment_type sub_segment)
boost::icl::Interval_Map::contains	icl/detail/interval_map_algo.hpp	/^bool contains(const IntervalMapT& super, const IntervalMapT& sub) $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT& super, const IntervalMapT& sub)
boost::icl::Interval_Map::contains	icl/detail/interval_map_algo.hpp	/^contains(const IntervalMapT& container, $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT& container, const typename IntervalMapT::domain_type& key)
boost::icl::Interval_Map::contains	icl/detail/interval_map_algo.hpp	/^contains(const IntervalMapT& container, $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT& container, const typename IntervalMapT::interval_type& sub_interval)
boost::icl::Interval_Map::contains	icl/detail/interval_map_algo.hpp	/^contains(const IntervalMapT& super_map, const IntervalSetT& sub_set) $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT& super_map, const IntervalSetT& sub_set)
boost::icl::Interval_Map::contains	icl/detail/interval_map_algo.hpp	/^contains(const IntervalMapT&, $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT&, const typename IntervalMapT::domain_type&)
boost::icl::Interval_Map::contains	icl/detail/interval_map_algo.hpp	/^contains(const IntervalMapT&, $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT&, const typename IntervalMapT::interval_type&)
boost::icl::Interval_Map::contains	icl/detail/interval_map_algo.hpp	/^contains(const IntervalMapT&, const IntervalSetT&) $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT&, const IntervalSetT&)
boost::icl::Interval_Map::is_joinable	icl/detail/interval_map_algo.hpp	/^bool is_joinable(const IntervalMapT& container, $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT& container, typename IntervalMapT::const_iterator first, typename IntervalMapT::const_iterator past)
boost::icl::Interval_Set	icl/detail/element_comparer.hpp	/^namespace Interval_Set$/;"	n	namespace:boost::icl
boost::icl::Interval_Set	icl/detail/interval_set_algo.hpp	/^namespace Interval_Set$/;"	n	namespace:boost::icl
boost::icl::Interval_Set	icl/detail/interval_subset_comparer.hpp	/^namespace Interval_Set$/;"	n	namespace:boost::icl
boost::icl::Interval_Set::add	icl/detail/interval_set_algo.hpp	/^    add(Type& object, const typename Type::value_type& addend)$/;"	f	namespace:boost::icl::Interval_Set	signature:(Type& object, const typename Type::value_type& addend)
boost::icl::Interval_Set::add	icl/detail/interval_set_algo.hpp	/^    add(Type& object, typename Type::iterator    prior_, $/;"	f	namespace:boost::icl::Interval_Set	signature:(Type& object, typename Type::iterator prior_, const typename Type::value_type& addend)
boost::icl::Interval_Set::add_front	icl/detail/interval_set_algo.hpp	/^void add_front(Type& object, const typename Type::interval_type& inter_val, $/;"	f	namespace:boost::icl::Interval_Set	signature:(Type& object, const typename Type::interval_type& inter_val, typename Type::iterator& first_)
boost::icl::Interval_Set::add_main	icl/detail/interval_set_algo.hpp	/^void add_main(Type& object, typename Type::interval_type& rest_interval, $/;"	f	namespace:boost::icl::Interval_Set	signature:(Type& object, typename Type::interval_type& rest_interval, typename Type::iterator& it_, const typename Type::iterator& last_)
boost::icl::Interval_Set::add_rear	icl/detail/interval_set_algo.hpp	/^void add_rear(Type& object, const typename Type::interval_type& inter_val, $/;"	f	namespace:boost::icl::Interval_Set	signature:(Type& object, const typename Type::interval_type& inter_val, typename Type::iterator& it_ )
boost::icl::Interval_Set::add_segment	icl/detail/interval_set_algo.hpp	/^void add_segment(Type& object, const typename Type::interval_type& inter_val, $/;"	f	namespace:boost::icl::Interval_Set	signature:(Type& object, const typename Type::interval_type& inter_val, typename Type::iterator& it_ )
boost::icl::Interval_Set::atomic_codomain_compare	icl/detail/interval_subset_comparer.hpp	/^struct atomic_codomain_compare$/;"	s	namespace:boost::icl::Interval_Set
boost::icl::Interval_Set::atomic_codomain_compare::apply	icl/detail/interval_subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)$/;"	f	struct:boost::icl::Interval_Set::atomic_codomain_compare	access:public	signature:(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)
boost::icl::Interval_Set::contains	icl/detail/interval_set_algo.hpp	/^contains(const LeftT& super, const RightT& sub)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT& super, const RightT& sub)
boost::icl::Interval_Set::contains	icl/detail/interval_set_algo.hpp	/^contains(const LeftT&, const RightT&)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT&, const RightT&)
boost::icl::Interval_Set::element_compare	icl/detail/element_comparer.hpp	/^int element_compare$/;"	f	namespace:boost::icl::Interval_Set	signature:( const LeftT& left, const RightT& right, typename LeftT::const_iterator left_begin, typename LeftT::const_iterator left_end, typename RightT::const_iterator right_begin, typename RightT::const_iterator right_end )
boost::icl::Interval_Set::element_comparer	icl/detail/element_comparer.hpp	/^class element_comparer$/;"	c	namespace:boost::icl::Interval_Set
boost::icl::Interval_Set::element_comparer::BOOST_STATIC_CONSTANT	icl/detail/element_comparer.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	class:boost::icl::Interval_Set::element_comparer	access:public	signature:(bool, _compare_codomain = (mpl::and_<is_map<LeftT>, is_map<RightT> >::value))
boost::icl::Interval_Set::element_comparer::LeftIterT	icl/detail/element_comparer.hpp	/^    typedef typename LeftT::const_iterator  LeftIterT;$/;"	t	class:boost::icl::Interval_Set::element_comparer	access:public
boost::icl::Interval_Set::element_comparer::RightIterT	icl/detail/element_comparer.hpp	/^    typedef typename RightT::const_iterator RightIterT;$/;"	t	class:boost::icl::Interval_Set::element_comparer	access:public
boost::icl::Interval_Set::element_comparer::_left	icl/detail/element_comparer.hpp	/^    const LeftT&  _left;$/;"	m	class:boost::icl::Interval_Set::element_comparer	access:private
boost::icl::Interval_Set::element_comparer::_left_end	icl/detail/element_comparer.hpp	/^    LeftIterT     _left_end;$/;"	m	class:boost::icl::Interval_Set::element_comparer	access:private
boost::icl::Interval_Set::element_comparer::_prior_left	icl/detail/element_comparer.hpp	/^    LeftIterT     _prior_left;$/;"	m	class:boost::icl::Interval_Set::element_comparer	access:private
boost::icl::Interval_Set::element_comparer::_prior_right	icl/detail/element_comparer.hpp	/^    RightIterT    _prior_right;$/;"	m	class:boost::icl::Interval_Set::element_comparer	access:private
boost::icl::Interval_Set::element_comparer::_result	icl/detail/element_comparer.hpp	/^    int           _result;$/;"	m	class:boost::icl::Interval_Set::element_comparer	access:private
boost::icl::Interval_Set::element_comparer::_right	icl/detail/element_comparer.hpp	/^    const RightT& _right;$/;"	m	class:boost::icl::Interval_Set::element_comparer	access:private
boost::icl::Interval_Set::element_comparer::_right_end	icl/detail/element_comparer.hpp	/^    RightIterT    _right_end;$/;"	m	class:boost::icl::Interval_Set::element_comparer	access:private
boost::icl::Interval_Set::element_comparer::covalues_are_equal	icl/detail/element_comparer.hpp	/^    bool covalues_are_equal(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::element_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
boost::icl::Interval_Set::element_comparer::element_comparer	icl/detail/element_comparer.hpp	/^    element_comparer(const LeftT&      left,$/;"	f	class:boost::icl::Interval_Set::element_comparer	access:public	signature:(const LeftT& left, const RightT& right, const LeftIterT& left_end, const RightIterT& right_end)
boost::icl::Interval_Set::element_comparer::equal	icl/detail/element_comparer.hpp	/^        equal   = comparison::equal, $/;"	e	enum:boost::icl::Interval_Set::element_comparer::__anon7
boost::icl::Interval_Set::element_comparer::greater	icl/detail/element_comparer.hpp	/^        greater = comparison::greater$/;"	e	enum:boost::icl::Interval_Set::element_comparer::__anon7
boost::icl::Interval_Set::element_comparer::less	icl/detail/element_comparer.hpp	/^        less    = comparison::less, $/;"	e	enum:boost::icl::Interval_Set::element_comparer::__anon7
boost::icl::Interval_Set::element_comparer::next_both	icl/detail/element_comparer.hpp	/^    int next_both(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::element_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
boost::icl::Interval_Set::element_comparer::next_left	icl/detail/element_comparer.hpp	/^    int next_left(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::element_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
boost::icl::Interval_Set::element_comparer::next_right	icl/detail/element_comparer.hpp	/^    int next_right(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::element_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
boost::icl::Interval_Set::element_comparer::nextboth	icl/detail/element_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::element_comparer::__anon6
boost::icl::Interval_Set::element_comparer::nextleft	icl/detail/element_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::element_comparer::__anon6
boost::icl::Interval_Set::element_comparer::nextright	icl/detail/element_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::element_comparer::__anon6
boost::icl::Interval_Set::element_comparer::proceed	icl/detail/element_comparer.hpp	/^    int proceed(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::element_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
boost::icl::Interval_Set::element_comparer::result	icl/detail/element_comparer.hpp	/^    int result()const{ return _result; }$/;"	f	class:boost::icl::Interval_Set::element_comparer	access:public	signature:() const
boost::icl::Interval_Set::element_comparer::stop	icl/detail/element_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::element_comparer::__anon6
boost::icl::Interval_Set::empty_codomain_compare	icl/detail/interval_subset_comparer.hpp	/^struct empty_codomain_compare$/;"	s	namespace:boost::icl::Interval_Set
boost::icl::Interval_Set::empty_codomain_compare::apply	icl/detail/interval_subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator&, typename RightT::const_iterator)$/;"	f	struct:boost::icl::Interval_Set::empty_codomain_compare	access:public	signature:(typename LeftT::const_iterator&, typename RightT::const_iterator)
boost::icl::Interval_Set::is_dense	icl/detail/interval_set_algo.hpp	/^bool is_dense(const IntervalContainerT& container, $/;"	f	namespace:boost::icl::Interval_Set	signature:(const IntervalContainerT& container, typename IntervalContainerT::const_iterator first, typename IntervalContainerT::const_iterator past)
boost::icl::Interval_Set::is_element_equal	icl/detail/interval_set_algo.hpp	/^bool is_element_equal(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT& left, const RightT& right)
boost::icl::Interval_Set::is_element_greater	icl/detail/interval_set_algo.hpp	/^bool is_element_greater(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT& left, const RightT& right)
boost::icl::Interval_Set::is_element_less	icl/detail/interval_set_algo.hpp	/^bool is_element_less(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT& left, const RightT& right)
boost::icl::Interval_Set::is_inclusion_equal	icl/detail/interval_set_algo.hpp	/^bool is_inclusion_equal(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT& left, const RightT& right)
boost::icl::Interval_Set::is_joinable	icl/detail/interval_set_algo.hpp	/^bool is_joinable(const IntervalContainerT& container, $/;"	f	namespace:boost::icl::Interval_Set	signature:(const IntervalContainerT& container, typename IntervalContainerT::const_iterator first, typename IntervalContainerT::const_iterator past)
boost::icl::Interval_Set::map_codomain_compare	icl/detail/interval_subset_comparer.hpp	/^struct map_codomain_compare$/;"	s	namespace:boost::icl::Interval_Set
boost::icl::Interval_Set::map_codomain_compare::apply	icl/detail/interval_subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)$/;"	f	struct:boost::icl::Interval_Set::map_codomain_compare	access:public	signature:(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)
boost::icl::Interval_Set::on_style	icl/detail/interval_set_algo.hpp	/^struct on_style<Type, interval_combine::joining>$/;"	s	namespace:boost::icl::Interval_Set
boost::icl::Interval_Set::on_style	icl/detail/interval_set_algo.hpp	/^struct on_style<Type, interval_combine::separating>$/;"	s	namespace:boost::icl::Interval_Set
boost::icl::Interval_Set::on_style	icl/detail/interval_set_algo.hpp	/^struct on_style<Type, interval_combine::splitting>$/;"	s	namespace:boost::icl::Interval_Set
boost::icl::Interval_Set::on_style::add_over	icl/detail/interval_set_algo.hpp	/^    inline static iterator add_over$/;"	f	struct:boost::icl::Interval_Set::on_style	access:public	signature:(Type& object, const interval_type& addend)
boost::icl::Interval_Set::on_style::add_over	icl/detail/interval_set_algo.hpp	/^    inline static iterator add_over$/;"	f	struct:boost::icl::Interval_Set::on_style	access:public	signature:(Type& object, const interval_type& addend, iterator last_)
boost::icl::Interval_Set::on_style::handle_inserted	icl/detail/interval_set_algo.hpp	/^    inline static iterator handle_inserted(Type& object, iterator inserted_)$/;"	f	struct:boost::icl::Interval_Set::on_style	access:public	signature:(Type& object, iterator inserted_)
boost::icl::Interval_Set::on_style::handle_inserted	icl/detail/interval_set_algo.hpp	/^    inline static iterator handle_inserted(Type&, iterator inserted_)$/;"	f	struct:boost::icl::Interval_Set::on_style	access:public	signature:(Type&, iterator inserted_)
boost::icl::Interval_Set::on_style::interval_type	icl/detail/interval_set_algo.hpp	/^    typedef typename Type::interval_type interval_type;$/;"	t	struct:boost::icl::Interval_Set::on_style	access:public
boost::icl::Interval_Set::on_style::iterator	icl/detail/interval_set_algo.hpp	/^    typedef typename Type::iterator      iterator;$/;"	t	struct:boost::icl::Interval_Set::on_style	access:public
boost::icl::Interval_Set::on_style::type	icl/detail/interval_set_algo.hpp	/^    typedef          on_style            type;$/;"	t	struct:boost::icl::Interval_Set::on_style	access:public
boost::icl::Interval_Set::settic_codomain_compare	icl/detail/interval_subset_comparer.hpp	/^struct settic_codomain_compare$/;"	s	namespace:boost::icl::Interval_Set
boost::icl::Interval_Set::settic_codomain_compare::apply	icl/detail/interval_subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)$/;"	f	struct:boost::icl::Interval_Set::settic_codomain_compare	access:public	signature:(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)
boost::icl::Interval_Set::subset_compare	icl/detail/interval_subset_comparer.hpp	/^int subset_compare$/;"	f	namespace:boost::icl::Interval_Set	signature:( const LeftT& left, const RightT& right, typename LeftT::const_iterator left_begin, typename LeftT::const_iterator left_end, typename RightT::const_iterator right_begin, typename RightT::const_iterator right_end )
boost::icl::Interval_Set::subset_comparer	icl/detail/interval_subset_comparer.hpp	/^class subset_comparer$/;"	c	namespace:boost::icl::Interval_Set
boost::icl::Interval_Set::subset_comparer::BOOST_STATIC_CONSTANT	icl/detail/interval_subset_comparer.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(bool, _compare_codomain = (mpl::and_<is_map<LeftT>, is_map<RightT> >::value))
boost::icl::Interval_Set::subset_comparer::LeftIterT	icl/detail/interval_subset_comparer.hpp	/^    typedef typename LeftT::const_iterator  LeftIterT;$/;"	t	class:boost::icl::Interval_Set::subset_comparer	access:public
boost::icl::Interval_Set::subset_comparer::RightIterT	icl/detail/interval_subset_comparer.hpp	/^    typedef typename RightT::const_iterator RightIterT;$/;"	t	class:boost::icl::Interval_Set::subset_comparer	access:public
boost::icl::Interval_Set::subset_comparer::_left	icl/detail/interval_subset_comparer.hpp	/^    const LeftT&  _left;$/;"	m	class:boost::icl::Interval_Set::subset_comparer	access:private
boost::icl::Interval_Set::subset_comparer::_left_end	icl/detail/interval_subset_comparer.hpp	/^    LeftIterT     _left_end;$/;"	m	class:boost::icl::Interval_Set::subset_comparer	access:private
boost::icl::Interval_Set::subset_comparer::_prior_left	icl/detail/interval_subset_comparer.hpp	/^    LeftIterT     _prior_left;$/;"	m	class:boost::icl::Interval_Set::subset_comparer	access:private
boost::icl::Interval_Set::subset_comparer::_prior_right	icl/detail/interval_subset_comparer.hpp	/^    RightIterT    _prior_right;$/;"	m	class:boost::icl::Interval_Set::subset_comparer	access:private
boost::icl::Interval_Set::subset_comparer::_result	icl/detail/interval_subset_comparer.hpp	/^    int           _result;$/;"	m	class:boost::icl::Interval_Set::subset_comparer	access:private
boost::icl::Interval_Set::subset_comparer::_right	icl/detail/interval_subset_comparer.hpp	/^    const RightT& _right;$/;"	m	class:boost::icl::Interval_Set::subset_comparer	access:private
boost::icl::Interval_Set::subset_comparer::_right_end	icl/detail/interval_subset_comparer.hpp	/^    RightIterT    _right_end;$/;"	m	class:boost::icl::Interval_Set::subset_comparer	access:private
boost::icl::Interval_Set::subset_comparer::co_compare	icl/detail/interval_subset_comparer.hpp	/^    int co_compare(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
boost::icl::Interval_Set::subset_comparer::equal	icl/detail/interval_subset_comparer.hpp	/^        equal      = inclusion::equal       \/\/ equal = subset | superset$/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon3
boost::icl::Interval_Set::subset_comparer::next_both	icl/detail/interval_subset_comparer.hpp	/^    int next_both(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
boost::icl::Interval_Set::subset_comparer::next_left	icl/detail/interval_subset_comparer.hpp	/^    int next_left(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
boost::icl::Interval_Set::subset_comparer::next_right	icl/detail/interval_subset_comparer.hpp	/^    int next_right(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
boost::icl::Interval_Set::subset_comparer::nextboth	icl/detail/interval_subset_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon2
boost::icl::Interval_Set::subset_comparer::nextleft	icl/detail/interval_subset_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon2
boost::icl::Interval_Set::subset_comparer::nextright	icl/detail/interval_subset_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon2
boost::icl::Interval_Set::subset_comparer::operator =	icl/detail/interval_subset_comparer.hpp	/^    subset_comparer& operator = (const subset_comparer&);$/;"	p	class:boost::icl::Interval_Set::subset_comparer	access:private	signature:(const subset_comparer&)
boost::icl::Interval_Set::subset_comparer::proceed	icl/detail/interval_subset_comparer.hpp	/^    int proceed(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
boost::icl::Interval_Set::subset_comparer::restrict_result	icl/detail/interval_subset_comparer.hpp	/^    int restrict_result(int state) { return _result &= state; }$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(int state)
boost::icl::Interval_Set::subset_comparer::result	icl/detail/interval_subset_comparer.hpp	/^    int result()const{ return _result; }$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:() const
boost::icl::Interval_Set::subset_comparer::stop	icl/detail/interval_subset_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon2
boost::icl::Interval_Set::subset_comparer::subset	icl/detail/interval_subset_comparer.hpp	/^        subset     = inclusion::subset,     \/\/ left is_subset_of   right $/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon3
boost::icl::Interval_Set::subset_comparer::subset_comparer	icl/detail/interval_subset_comparer.hpp	/^    subset_comparer(const LeftT&      left,$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(const LeftT& left, const RightT& right, const LeftIterT& left_end, const RightIterT& right_end)
boost::icl::Interval_Set::subset_comparer::superset	icl/detail/interval_subset_comparer.hpp	/^        superset   = inclusion::superset,   \/\/ left is_superset_of right$/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon3
boost::icl::Interval_Set::subset_comparer::unrelated	icl/detail/interval_subset_comparer.hpp	/^        unrelated  = inclusion::unrelated, $/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon3
boost::icl::Interval_Set::subtract	icl/detail/interval_set_algo.hpp	/^void subtract(Type& object, const typename Type::value_type& minuend)$/;"	f	namespace:boost::icl::Interval_Set	signature:(Type& object, const typename Type::value_type& minuend)
boost::icl::Interval_Set::within	icl/detail/interval_set_algo.hpp	/^within(const LeftT& sub, const RightT& super)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT& sub, const RightT& super)
boost::icl::Interval_Set::within	icl/detail/interval_set_algo.hpp	/^within(const LeftT&, const RightT&)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT&, const RightT&)
boost::icl::Map	icl/detail/map_algo.hpp	/^namespace Map $/;"	n	namespace:boost::icl
boost::icl::Map::intersects	icl/detail/map_algo.hpp	/^bool intersects(const ObjectT& left, const CoObjectT& right)$/;"	f	namespace:boost::icl::Map	signature:(const ObjectT& left, const CoObjectT& right)
boost::icl::Map::lexicographical_distinct_equal	icl/detail/map_algo.hpp	/^bool lexicographical_distinct_equal(const MapT& left, const MapT& right)$/;"	f	namespace:boost::icl::Map	signature:(const MapT& left, const MapT& right)
boost::icl::Map::next_proton	icl/detail/map_algo.hpp	/^typename MapT::const_iterator next_proton(typename MapT::const_iterator& iter_, const MapT& object)$/;"	f	namespace:boost::icl::Map	signature:(typename MapT::const_iterator& iter_, const MapT& object)
boost::icl::Set	icl/detail/set_algo.hpp	/^namespace Set$/;"	n	namespace:boost::icl
boost::icl::Set	icl/detail/subset_comparer.hpp	/^namespace Set$/;"	n	namespace:boost::icl
boost::icl::Set::atomic_codomain_compare	icl/detail/subset_comparer.hpp	/^struct atomic_codomain_compare$/;"	s	namespace:boost::icl::Set
boost::icl::Set::atomic_codomain_compare::apply	icl/detail/subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)$/;"	f	struct:boost::icl::Set::atomic_codomain_compare	access:public	signature:(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)
boost::icl::Set::common_range	icl/detail/set_algo.hpp	/^bool common_range(IteratorT& lwb, IteratorT& upb, ObjectT& x1, const ConstObjectT& x2)$/;"	f	namespace:boost::icl::Set	signature:(IteratorT& lwb, IteratorT& upb, ObjectT& x1, const ConstObjectT& x2)
boost::icl::Set::empty_codomain_compare	icl/detail/subset_comparer.hpp	/^struct empty_codomain_compare$/;"	s	namespace:boost::icl::Set
boost::icl::Set::empty_codomain_compare::apply	icl/detail/subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator&, typename RightT::const_iterator&)$/;"	f	struct:boost::icl::Set::empty_codomain_compare	access:public	signature:(typename LeftT::const_iterator&, typename RightT::const_iterator&)
boost::icl::Set::intersects	icl/detail/set_algo.hpp	/^bool intersects(const SetType& left, const SetType& right)$/;"	f	namespace:boost::icl::Set	signature:(const SetType& left, const SetType& right)
boost::icl::Set::lexicographical_equal	icl/detail/set_algo.hpp	/^inline bool lexicographical_equal(const SetType& left, const SetType& right)$/;"	f	namespace:boost::icl::Set	signature:(const SetType& left, const SetType& right)
boost::icl::Set::map_codomain_compare	icl/detail/subset_comparer.hpp	/^struct map_codomain_compare$/;"	s	namespace:boost::icl::Set
boost::icl::Set::map_codomain_compare::apply	icl/detail/subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)$/;"	f	struct:boost::icl::Set::map_codomain_compare	access:public	signature:(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)
boost::icl::Set::settic_codomain_compare	icl/detail/subset_comparer.hpp	/^struct settic_codomain_compare$/;"	s	namespace:boost::icl::Set
boost::icl::Set::settic_codomain_compare::apply	icl/detail/subset_comparer.hpp	/^    static int apply(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)$/;"	f	struct:boost::icl::Set::settic_codomain_compare	access:public	signature:(typename LeftT::const_iterator& left_, typename RightT::const_iterator& right_)
boost::icl::Set::subset_compare	icl/detail/subset_comparer.hpp	/^int subset_compare$/;"	f	namespace:boost::icl::Set	signature:( const LeftT& left, const RightT& right, typename LeftT::const_iterator left_begin, typename LeftT::const_iterator left_end, typename RightT::const_iterator right_begin, typename RightT::const_iterator right_end )
boost::icl::Set::subset_compare	icl/detail/subset_comparer.hpp	/^int subset_compare(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl::Set	signature:(const LeftT& left, const RightT& right)
boost::icl::Set::subset_comparer	icl/detail/subset_comparer.hpp	/^class subset_comparer$/;"	c	namespace:boost::icl::Set
boost::icl::Set::subset_comparer::BOOST_STATIC_CONSTANT	icl/detail/subset_comparer.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	class:boost::icl::Set::subset_comparer	access:public	signature:(bool, _compare_codomain = (mpl::and_<is_map<LeftT>, is_map<RightT> >::value))
boost::icl::Set::subset_comparer::LeftIterT	icl/detail/subset_comparer.hpp	/^    typedef typename LeftT::const_iterator  LeftIterT;$/;"	t	class:boost::icl::Set::subset_comparer	access:public
boost::icl::Set::subset_comparer::RightIterT	icl/detail/subset_comparer.hpp	/^    typedef typename RightT::const_iterator RightIterT;$/;"	t	class:boost::icl::Set::subset_comparer	access:public
boost::icl::Set::subset_comparer::_left	icl/detail/subset_comparer.hpp	/^    const LeftT&  _left;$/;"	m	class:boost::icl::Set::subset_comparer	access:private
boost::icl::Set::subset_comparer::_left_end	icl/detail/subset_comparer.hpp	/^    LeftIterT     _left_end;$/;"	m	class:boost::icl::Set::subset_comparer	access:private
boost::icl::Set::subset_comparer::_result	icl/detail/subset_comparer.hpp	/^    int           _result;$/;"	m	class:boost::icl::Set::subset_comparer	access:private
boost::icl::Set::subset_comparer::_right	icl/detail/subset_comparer.hpp	/^    const RightT& _right;$/;"	m	class:boost::icl::Set::subset_comparer	access:private
boost::icl::Set::subset_comparer::_right_end	icl/detail/subset_comparer.hpp	/^    RightIterT    _right_end;$/;"	m	class:boost::icl::Set::subset_comparer	access:private
boost::icl::Set::subset_comparer::co_compare	icl/detail/subset_comparer.hpp	/^    int co_compare(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Set::subset_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
boost::icl::Set::subset_comparer::equal	icl/detail/subset_comparer.hpp	/^        equal      = inclusion::equal       \/\/ equal = subset | superset$/;"	e	enum:boost::icl::Set::subset_comparer::__anon5
boost::icl::Set::subset_comparer::next_both	icl/detail/subset_comparer.hpp	/^    int next_both(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Set::subset_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
boost::icl::Set::subset_comparer::nextboth	icl/detail/subset_comparer.hpp	/^    enum{nextboth, stop};$/;"	e	enum:boost::icl::Set::subset_comparer::__anon4
boost::icl::Set::subset_comparer::operator =	icl/detail/subset_comparer.hpp	/^    subset_comparer& operator = (const subset_comparer&);$/;"	p	class:boost::icl::Set::subset_comparer	access:private	signature:(const subset_comparer&)
boost::icl::Set::subset_comparer::restrict_result	icl/detail/subset_comparer.hpp	/^    int restrict_result(int state) { return _result &= state; }$/;"	f	class:boost::icl::Set::subset_comparer	access:public	signature:(int state)
boost::icl::Set::subset_comparer::result	icl/detail/subset_comparer.hpp	/^    int result()const{ return _result; }$/;"	f	class:boost::icl::Set::subset_comparer	access:public	signature:() const
boost::icl::Set::subset_comparer::stop	icl/detail/subset_comparer.hpp	/^    enum{nextboth, stop};$/;"	e	enum:boost::icl::Set::subset_comparer::__anon4
boost::icl::Set::subset_comparer::subset	icl/detail/subset_comparer.hpp	/^        subset     = inclusion::subset,     \/\/ left is_subset_of   right $/;"	e	enum:boost::icl::Set::subset_comparer::__anon5
boost::icl::Set::subset_comparer::subset_comparer	icl/detail/subset_comparer.hpp	/^    subset_comparer(const LeftT&      left,$/;"	f	class:boost::icl::Set::subset_comparer	access:public	signature:(const LeftT& left, const RightT& right, const LeftIterT& left_end, const RightIterT& right_end)
boost::icl::Set::subset_comparer::superset	icl/detail/subset_comparer.hpp	/^        superset   = inclusion::superset,   \/\/ left is_superset_of right$/;"	e	enum:boost::icl::Set::subset_comparer::__anon5
boost::icl::Set::subset_comparer::unrelated	icl/detail/subset_comparer.hpp	/^        unrelated  = inclusion::unrelated, $/;"	e	enum:boost::icl::Set::subset_comparer::__anon5
boost::icl::Set::within	icl/detail/set_algo.hpp	/^inline bool within(const SetType& sub, const SetType& super)$/;"	f	namespace:boost::icl::Set	signature:(const SetType& sub, const SetType& super)
boost::icl::UNDEFINED_INDEX	icl/detail/notate.hpp	/^    const int UNDEFINED_INDEX = -1;$/;"	m	namespace:boost::icl
boost::icl::abs	icl/type_traits/value_size.hpp	/^Type abs(Type val) { return val < 0 ? -val : val; }$/;"	f	namespace:boost::icl	signature:(Type val)
boost::icl::absorb_identities	icl/concept/element_map.hpp	/^absorb_identities(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
boost::icl::absorb_identities	icl/concept/element_map.hpp	/^absorb_identities(Type&){}$/;"	f	namespace:boost::icl	signature:(Type&)
boost::icl::absorb_identities	icl/concept/interval_map.hpp	/^absorb_identities(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
boost::icl::absorbs_identities	icl/interval_base_map.hpp	/^struct absorbs_identities<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::absorbs_identities	icl/interval_map.hpp	/^struct absorbs_identities<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::absorbs_identities	icl/map.hpp	/^struct absorbs_identities<icl::map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::absorbs_identities	icl/split_interval_map.hpp	/^struct absorbs_identities<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::absorbs_identities	icl/type_traits/absorbs_identities.hpp	/^    template <class Type> struct absorbs_identities$/;"	s	namespace:boost::icl
boost::icl::absorbs_identities::BOOST_STATIC_CONSTANT	icl/interval_base_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (Traits::absorbs_identities)); $/;"	p	struct:boost::icl::absorbs_identities	access:public	signature:(bool, value = (Traits::absorbs_identities))
boost::icl::absorbs_identities::BOOST_STATIC_CONSTANT	icl/interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (Traits::absorbs_identities)); $/;"	p	struct:boost::icl::absorbs_identities	access:public	signature:(bool, value = (Traits::absorbs_identities))
boost::icl::absorbs_identities::BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(int, value = Traits::absorbs_identities); $/;"	p	struct:boost::icl::absorbs_identities	access:public	signature:(int, value = Traits::absorbs_identities)
boost::icl::absorbs_identities::BOOST_STATIC_CONSTANT	icl/split_interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (Traits::absorbs_identities)); $/;"	p	struct:boost::icl::absorbs_identities	access:public	signature:(bool, value = (Traits::absorbs_identities))
boost::icl::absorbs_identities::BOOST_STATIC_CONSTANT	icl/type_traits/absorbs_identities.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false); $/;"	p	struct:boost::icl::absorbs_identities	access:public	signature:(bool, value = false)
boost::icl::absorbs_identities::type	icl/interval_base_map.hpp	/^    typedef absorbs_identities<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::absorbs_identities	access:public
boost::icl::absorbs_identities::type	icl/interval_map.hpp	/^    typedef absorbs_identities<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::absorbs_identities	access:public
boost::icl::absorbs_identities::type	icl/map.hpp	/^    typedef absorbs_identities type;$/;"	t	struct:boost::icl::absorbs_identities	access:public
boost::icl::absorbs_identities::type	icl/split_interval_map.hpp	/^    typedef absorbs_identities<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::absorbs_identities	access:public
boost::icl::absorbs_identities::type	icl/type_traits/absorbs_identities.hpp	/^        typedef absorbs_identities<Type> type;$/;"	t	struct:boost::icl::absorbs_identities	access:public
boost::icl::add	icl/concept/element_map.hpp	/^add(Type& object, const typename Type::value_type& value_pair)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& value_pair)
boost::icl::add	icl/concept/element_map.hpp	/^add(Type& object, typename Type::iterator prior, $/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator prior, const typename Type::value_type& value_pair)
boost::icl::add	icl/concept/element_set.hpp	/^add(Type& object, const typename Type::value_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& operand)
boost::icl::add	icl/concept/element_set.hpp	/^add(Type& object, typename Type::iterator prior, $/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator prior, const typename Type::value_type& operand)
boost::icl::add	icl/concept/interval_map.hpp	/^add(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::add	icl/concept/interval_map.hpp	/^add(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
boost::icl::add	icl/concept/interval_map.hpp	/^add(Type& object, typename Type::iterator      prior_,$/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator prior_, const typename Type::segment_type& operand)
boost::icl::add	icl/concept/interval_set.hpp	/^add(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::add	icl/concept/interval_set.hpp	/^add(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
boost::icl::add	icl/concept/interval_set.hpp	/^add(Type& object, typename Type::iterator      prior, $/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator prior, const typename Type::segment_type& operand)
boost::icl::add_if	icl/concept/element_associator.hpp	/^add_if(const Predicate& pred, Type& object, const Type& src)$/;"	f	namespace:boost::icl	signature:(const Predicate& pred, Type& object, const Type& src)
boost::icl::add_if	icl/concept/interval_map.hpp	/^add_if(const Predicate& pred, MapT& object, const MapT& src)$/;"	f	namespace:boost::icl	signature:(const Predicate& pred, MapT& object, const MapT& src)
boost::icl::add_intersection	icl/concept/element_associator.hpp	/^add_intersection(Type& section, const Type&              object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::key_type& operand)
boost::icl::add_intersection	icl/concept/element_associator.hpp	/^add_intersection(Type& section, const Type& object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename key_container_type_of<Type>::type& operand)
boost::icl::add_intersection	icl/concept/element_map.hpp	/^add_intersection(Type& section, const Type&               object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::element_type& operand)
boost::icl::add_intersection	icl/concept/element_map.hpp	/^add_intersection(Type& section, const Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const Type& operand)
boost::icl::add_intersection	icl/concept/interval_associator.hpp	/^add_intersection(Type& section, const Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const OperandT& operand)
boost::icl::add_intersection	icl/concept/interval_map.hpp	/^add_intersection(Type& section, const Type& object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::domain_type& key_value)
boost::icl::add_intersection	icl/concept/interval_map.hpp	/^add_intersection(Type& section, const Type& object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::element_type& operand)
boost::icl::add_intersection	icl/concept/interval_map.hpp	/^add_intersection(Type& section, const Type& object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::interval_type& inter_val)
boost::icl::add_intersection	icl/concept/interval_map.hpp	/^add_intersection(Type& section, const Type& object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::segment_type& operand)
boost::icl::add_intersection	icl/concept/interval_map.hpp	/^add_intersection(Type& section, const Type& object, const KeySetT& key_set)$/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const KeySetT& key_set)
boost::icl::add_intersection	icl/concept/interval_map.hpp	/^add_intersection(Type& section, const Type& object, const MapT& operand)$/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const MapT& operand)
boost::icl::add_intersection	icl/concept/interval_set.hpp	/^add_intersection(Type& section, const Type& object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::element_type& operand)
boost::icl::add_intersection	icl/concept/interval_set.hpp	/^add_intersection(Type& section, const Type& object, $/;"	f	namespace:boost::icl	signature:(Type& section, const Type& object, const typename Type::segment_type& segment)
boost::icl::add_iterator	icl/iterator.hpp	/^template<class ContainerT> class add_iterator$/;"	c	namespace:boost::icl	inherits:std::iterator
boost::icl::add_iterator::_cont	icl/iterator.hpp	/^    ContainerT*                   _cont;$/;"	m	class:boost::icl::add_iterator	access:private
boost::icl::add_iterator::_iter	icl/iterator.hpp	/^    typename ContainerT::iterator _iter;$/;"	m	class:boost::icl::add_iterator	access:private
boost::icl::add_iterator::add_iterator	icl/iterator.hpp	/^    add_iterator(ContainerT& cont, typename ContainerT::iterator iter)$/;"	f	class:boost::icl::add_iterator	access:public	signature:(ContainerT& cont, typename ContainerT::iterator iter)
boost::icl::add_iterator::container_type	icl/iterator.hpp	/^    typedef ContainerT container_type;$/;"	t	class:boost::icl::add_iterator	access:public
boost::icl::add_iterator::iterator_category	icl/iterator.hpp	/^    typedef std::output_iterator_tag iterator_category; $/;"	t	class:boost::icl::add_iterator	access:public
boost::icl::add_iterator::operator *	icl/iterator.hpp	/^    add_iterator& operator*()    { return *this; }$/;"	f	class:boost::icl::add_iterator	access:public	signature:()
boost::icl::add_iterator::operator ++	icl/iterator.hpp	/^    add_iterator& operator++()   { return *this; }$/;"	f	class:boost::icl::add_iterator	access:public	signature:()
boost::icl::add_iterator::operator ++	icl/iterator.hpp	/^    add_iterator& operator++(int){ return *this; }$/;"	f	class:boost::icl::add_iterator	access:public	signature:(int)
boost::icl::add_iterator::operator =	icl/iterator.hpp	/^    add_iterator& operator=(typename ContainerT::const_reference value)$/;"	f	class:boost::icl::add_iterator	access:public	signature:(typename ContainerT::const_reference value)
boost::icl::adder	icl/iterator.hpp	/^inline add_iterator<ContainerT> adder(ContainerT& cont, IteratorT iter_)$/;"	f	namespace:boost::icl	signature:(ContainerT& cont, IteratorT iter_)
boost::icl::adds_inversely	icl/type_traits/adds_inversely.hpp	/^struct adds_inversely$/;"	s	namespace:boost::icl
boost::icl::adds_inversely::BOOST_STATIC_CONSTANT	icl/type_traits/adds_inversely.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::adds_inversely	access:public	signature:(bool, value = (mpl::and_<has_inverse<Type>, is_negative<Combiner> >::value))
boost::icl::adds_inversely::type	icl/type_traits/adds_inversely.hpp	/^    typedef adds_inversely type;$/;"	t	struct:boost::icl::adds_inversely	access:public
boost::icl::all	icl/concept/interval_bounds.hpp	/^inline interval_bounds all(interval_bounds x1)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1)
boost::icl::assign_if	icl/concept/element_associator.hpp	/^assign_if(const Predicate& pred, Type& object, const Type& src)$/;"	f	namespace:boost::icl	signature:(const Predicate& pred, Type& object, const Type& src)
boost::icl::assign_if	icl/concept/interval_map.hpp	/^assign_if(const Predicate& pred, MapT& object, const MapT& src)$/;"	f	namespace:boost::icl	signature:(const Predicate& pred, MapT& object, const MapT& src)
boost::icl::between	icl/concept/interval.hpp	/^between(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::between	icl/concept/interval_map.hpp	/^between(SetT& in_between, const Type& object)$/;"	f	namespace:boost::icl	signature:(SetT& in_between, const Type& object)
boost::icl::between	icl/concept/interval_set.hpp	/^between(Type& in_between, const Type& object)$/;"	f	namespace:boost::icl	signature:(Type& in_between, const Type& object)
boost::icl::binary_template_to_string	icl/type_traits/type_to_string.hpp	/^    struct binary_template_to_string$/;"	s	namespace:boost::icl
boost::icl::binary_template_to_string::apply	icl/detail/interval_morphism.hpp	/^    inline std::string binary_template_to_string<segmental::atomizer>::apply() { return "@"; }$/;"	f	class:boost::icl::binary_template_to_string	signature:()
boost::icl::binary_template_to_string::apply	icl/detail/interval_morphism.hpp	/^    inline std::string binary_template_to_string<segmental::clusterer>::apply() { return "&"; }$/;"	f	class:boost::icl::binary_template_to_string	signature:()
boost::icl::binary_template_to_string::apply	icl/detail/interval_morphism.hpp	/^    inline std::string binary_template_to_string<segmental::identity_absorber>::apply() { return "a0"; }$/;"	f	class:boost::icl::binary_template_to_string	signature:()
boost::icl::binary_template_to_string::apply	icl/detail/interval_morphism.hpp	/^    inline std::string binary_template_to_string<segmental::joiner>::apply() { return "j"; }$/;"	f	class:boost::icl::binary_template_to_string	signature:()
boost::icl::binary_template_to_string::apply	icl/type_traits/type_to_string.hpp	/^        static std::string apply();$/;"	p	struct:boost::icl::binary_template_to_string	access:public	signature:()
boost::icl::bound_type	icl/interval_bounds.hpp	/^typedef unsigned char bound_type;$/;"	t	namespace:boost::icl
boost::icl::bounded_lower	icl/concept/interval.hpp	/^bounded_lower(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::bounded_upper	icl/concept/interval.hpp	/^bounded_upper(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::bounded_value	icl/interval_bounds.hpp	/^class bounded_value$/;"	c	namespace:boost::icl
boost::icl::bounded_value::_bound	icl/interval_bounds.hpp	/^    interval_bounds _bound;$/;"	m	class:boost::icl::bounded_value	access:private
boost::icl::bounded_value::_value	icl/interval_bounds.hpp	/^    domain_type     _value;$/;"	m	class:boost::icl::bounded_value	access:private
boost::icl::bounded_value::bound	icl/interval_bounds.hpp	/^    interval_bounds bound()const { return _bound; }$/;"	f	class:boost::icl::bounded_value	access:public	signature:() const
boost::icl::bounded_value::bounded_value	icl/interval_bounds.hpp	/^    bounded_value(const domain_type& value, interval_bounds bound)$/;"	f	class:boost::icl::bounded_value	access:public	signature:(const domain_type& value, interval_bounds bound)
boost::icl::bounded_value::domain_type	icl/interval_bounds.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::bounded_value	access:public
boost::icl::bounded_value::type	icl/interval_bounds.hpp	/^    typedef bounded_value<DomainT> type;$/;"	t	class:boost::icl::bounded_value	access:public
boost::icl::bounded_value::value	icl/interval_bounds.hpp	/^    domain_type     value()const { return _value; }$/;"	f	class:boost::icl::bounded_value	access:public	signature:() const
boost::icl::bounds	icl/concept/interval.hpp	/^bounds(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::bounds	icl/concept/interval.hpp	/^bounds(const Type&)$/;"	f	namespace:boost::icl	signature:(const Type&)
boost::icl::cardinality	icl/concept/element_associator.hpp	/^cardinality(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::cardinality	icl/concept/interval.hpp	/^cardinality(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::cardinality	icl/concept/interval_associator.hpp	/^cardinality(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::clear	icl/concept/container.hpp	/^clear(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
boost::icl::closed_interval	icl/closed_interval.hpp	/^class closed_interval$/;"	c	namespace:boost::icl
boost::icl::closed_interval::_lwb	icl/closed_interval.hpp	/^    DomainT _lwb;$/;"	m	class:boost::icl::closed_interval	access:private
boost::icl::closed_interval::_upb	icl/closed_interval.hpp	/^    DomainT _upb;$/;"	m	class:boost::icl::closed_interval	access:private
boost::icl::closed_interval::closed_interval	icl/closed_interval.hpp	/^    closed_interval() $/;"	f	class:boost::icl::closed_interval	access:public	signature:()
boost::icl::closed_interval::closed_interval	icl/closed_interval.hpp	/^    closed_interval(const DomainT& low, const DomainT& up) :$/;"	f	class:boost::icl::closed_interval	access:public	signature:(const DomainT& low, const DomainT& up)
boost::icl::closed_interval::closed_interval	icl/closed_interval.hpp	/^    explicit closed_interval(const DomainT& val)$/;"	f	class:boost::icl::closed_interval	access:public	signature:(const DomainT& val)
boost::icl::closed_interval::domain_compare	icl/closed_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::closed_interval	access:public
boost::icl::closed_interval::domain_type	icl/closed_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::closed_interval	access:public
boost::icl::closed_interval::first	icl/closed_interval.hpp	/^    DomainT first()const{ return _lwb; }$/;"	f	class:boost::icl::closed_interval	access:public	signature:() const
boost::icl::closed_interval::last	icl/closed_interval.hpp	/^    DomainT last() const{ return _upb; }$/;"	f	class:boost::icl::closed_interval	access:public	signature:() const
boost::icl::closed_interval::lower	icl/closed_interval.hpp	/^    DomainT lower()const{ return _lwb; }$/;"	f	class:boost::icl::closed_interval	access:public	signature:() const
boost::icl::closed_interval::type	icl/closed_interval.hpp	/^    typedef closed_interval<DomainT,Compare> type;$/;"	t	class:boost::icl::closed_interval	access:public
boost::icl::closed_interval::upper	icl/closed_interval.hpp	/^    DomainT upper()const{ return _upb; }$/;"	f	class:boost::icl::closed_interval	access:public	signature:() const
boost::icl::co_equal	icl/detail/associated_value.hpp	/^co_equal(typename Type::const_iterator left_, typename CoType::const_iterator right_, $/;"	f	namespace:boost::icl	signature:(typename Type::const_iterator left_, typename CoType::const_iterator right_, const Type* = 0, const CoType* = 0)
boost::icl::co_equal	icl/detail/associated_value.hpp	/^co_equal(typename Type::const_iterator, typename CoType::const_iterator,$/;"	f	namespace:boost::icl	signature:(typename Type::const_iterator, typename CoType::const_iterator, const Type* = 0, const CoType* = 0)
boost::icl::co_value	icl/concept/element_set_value.hpp	/^co_value(Iterator it_)$/;"	f	namespace:boost::icl	signature:(Iterator it_)
boost::icl::co_value	icl/concept/interval_set_value.hpp	/^co_value(Iterator value_)$/;"	f	namespace:boost::icl	signature:(Iterator value_)
boost::icl::co_value	icl/concept/map_value.hpp	/^co_value(Iterator it_)$/;"	f	namespace:boost::icl	signature:(Iterator it_)
boost::icl::codomain_type_of	icl/type_traits/codomain_type_of.hpp	/^    struct codomain_type_of$/;"	s	namespace:boost::icl
boost::icl::codomain_type_of::type	icl/type_traits/codomain_type_of.hpp	/^                             >::type type;$/;"	t	struct:boost::icl::codomain_type_of	access:public
boost::icl::combines_right_to_interval_container	icl/type_traits/is_combinable.hpp	/^struct combines_right_to_interval_container$/;"	s	namespace:boost::icl
boost::icl::combines_right_to_interval_container::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::combines_right_to_interval_container	access:public	signature:(bool, value = (mpl::or_<combines_right_to_interval_set<GuideT, IntervalContainerT>, combines_right_to_interval_map<GuideT, IntervalContainerT> >::value) )
boost::icl::combines_right_to_interval_container::type	icl/type_traits/is_combinable.hpp	/^    typedef combines_right_to_interval_container<GuideT, IntervalContainerT> type;$/;"	t	struct:boost::icl::combines_right_to_interval_container	access:public
boost::icl::combines_right_to_interval_map	icl/type_traits/is_combinable.hpp	/^struct combines_right_to_interval_map$/;"	s	namespace:boost::icl
boost::icl::combines_right_to_interval_map::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::combines_right_to_interval_map	access:public	signature:(bool, value = (is_concept_compatible<is_interval_map, GuideT, IntervalMapT>::value) )
boost::icl::combines_right_to_interval_map::type	icl/type_traits/is_combinable.hpp	/^    typedef combines_right_to_interval_map<GuideT, IntervalMapT> type;$/;"	t	struct:boost::icl::combines_right_to_interval_map	access:public
boost::icl::combines_right_to_interval_set	icl/type_traits/is_combinable.hpp	/^struct combines_right_to_interval_set$/;"	s	namespace:boost::icl
boost::icl::combines_right_to_interval_set::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::combines_right_to_interval_set	access:public	signature:(bool, value = (is_concept_combinable<is_interval_container, is_interval_set, GuideT, IntervalSetT>::value) )
boost::icl::combines_right_to_interval_set::type	icl/type_traits/is_combinable.hpp	/^    typedef combines_right_to_interval_set<GuideT, IntervalSetT> type;$/;"	t	struct:boost::icl::combines_right_to_interval_set	access:public
boost::icl::comparison	icl/detail/relation_state.hpp	/^    namespace comparison$/;"	n	namespace:boost::icl
boost::icl::comparison::equal	icl/detail/relation_state.hpp	/^        static const int equal   =  0;$/;"	m	namespace:boost::icl::comparison
boost::icl::comparison::greater	icl/detail/relation_state.hpp	/^        static const int greater =  1;$/;"	m	namespace:boost::icl::comparison
boost::icl::comparison::less	icl/detail/relation_state.hpp	/^        static const int less    = -1;$/;"	m	namespace:boost::icl::comparison
boost::icl::construct	icl/concept/interval.hpp	/^construct(const typename Type::bounded_domain_type& low,$/;"	f	namespace:boost::icl	signature:(const typename Type::bounded_domain_type& low, const typename Type::bounded_domain_type& up)
boost::icl::construct	icl/concept/interval.hpp	/^construct(const typename interval_traits<Type>::domain_type& low,$/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& low, const typename interval_traits<Type>::domain_type& up )
boost::icl::construct	icl/concept/interval.hpp	/^construct(const typename interval_traits<Type>::domain_type& low,$/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& low, const typename interval_traits<Type>::domain_type& up, interval_bounds bounds = interval_bounds::right_open())
boost::icl::contains	icl/concept/element_associator.hpp	/^contains(const SuperT& super, const SubT& sub)$/;"	f	namespace:boost::icl	signature:(const SuperT& super, const SubT& sub)
boost::icl::contains	icl/concept/element_associator.hpp	/^contains(const Type& super, const typename Type::key_type& key)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::key_type& key)
boost::icl::contains	icl/concept/element_map.hpp	/^contains(const Type& super, const typename Type::element_type& value_pair)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::element_type& value_pair)
boost::icl::contains	icl/concept/interval.hpp	/^contains(const Type& super, const Type& sub)$/;"	f	namespace:boost::icl	signature:(const Type& super, const Type& sub)
boost::icl::contains	icl/concept/interval.hpp	/^contains(const Type& super, const typename interval_traits<Type>::domain_type& element)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename interval_traits<Type>::domain_type& element)
boost::icl::contains	icl/concept/interval_map.hpp	/^contains(const Type& super, const CoType& sub)$/;"	f	namespace:boost::icl	signature:(const Type& super, const CoType& sub)
boost::icl::contains	icl/concept/interval_map.hpp	/^contains(const Type& super, const KeyT& sub)$/;"	f	namespace:boost::icl	signature:(const Type& super, const KeyT& sub)
boost::icl::contains	icl/concept/interval_map.hpp	/^contains(const Type& super, const typename Type::domain_type& key)    $/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::domain_type& key)
boost::icl::contains	icl/concept/interval_map.hpp	/^contains(const Type& super, const typename Type::element_type& key_value_pair)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::element_type& key_value_pair)
boost::icl::contains	icl/concept/interval_map.hpp	/^contains(const Type& super, const typename Type::interval_type& sub_interval)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::interval_type& sub_interval)
boost::icl::contains	icl/concept/interval_map.hpp	/^contains(const Type& super, const typename Type::segment_type& sub_segment)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::segment_type& sub_segment)
boost::icl::contains	icl/concept/interval_map.hpp	/^contains(const Type&, const CoType&)$/;"	f	namespace:boost::icl	signature:(const Type&, const CoType&)
boost::icl::contains	icl/concept/interval_set.hpp	/^contains(const Type& super, const OperandT& sub)$/;"	f	namespace:boost::icl	signature:(const Type& super, const OperandT& sub)
boost::icl::contains	icl/concept/interval_set.hpp	/^contains(const Type& super, const typename Type::element_type& element)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::element_type& element)
boost::icl::contains	icl/concept/interval_set.hpp	/^contains(const Type& super, const typename Type::segment_type& inter_val)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::segment_type& inter_val)
boost::icl::content_is_identity_element	icl/concept/map_value.hpp	/^class content_is_identity_element: public property<Type>$/;"	c	namespace:boost::icl	inherits:property
boost::icl::content_is_identity_element::operator ()	icl/concept/map_value.hpp	/^    bool operator() (const Type& value_pair)const $/;"	f	class:boost::icl::content_is_identity_element	access:public	signature:(const Type& value_pair) const
boost::icl::continuous_interval	icl/continuous_interval.hpp	/^class continuous_interval$/;"	c	namespace:boost::icl
boost::icl::continuous_interval::_bounds	icl/continuous_interval.hpp	/^    interval_bounds _bounds;$/;"	m	class:boost::icl::continuous_interval	access:private
boost::icl::continuous_interval::_lwb	icl/continuous_interval.hpp	/^    domain_type     _lwb;$/;"	m	class:boost::icl::continuous_interval	access:private
boost::icl::continuous_interval::_upb	icl/continuous_interval.hpp	/^    domain_type     _upb;$/;"	m	class:boost::icl::continuous_interval	access:private
boost::icl::continuous_interval::bounded_domain_type	icl/continuous_interval.hpp	/^    typedef typename bounded_value<DomainT>::type bounded_domain_type;$/;"	t	class:boost::icl::continuous_interval	access:public
boost::icl::continuous_interval::bounds	icl/continuous_interval.hpp	/^    interval_bounds bounds()const{ return _bounds; }$/;"	f	class:boost::icl::continuous_interval	access:public	signature:() const
boost::icl::continuous_interval::closed	icl/continuous_interval.hpp	/^    static continuous_interval closed   (const DomainT& lo, const DomainT& up){ return continuous_interval(lo, up, interval_bounds::closed());    }$/;"	f	class:boost::icl::continuous_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
boost::icl::continuous_interval::continuous_interval	icl/continuous_interval.hpp	/^    continuous_interval()$/;"	f	class:boost::icl::continuous_interval	access:public	signature:()
boost::icl::continuous_interval::continuous_interval	icl/continuous_interval.hpp	/^    continuous_interval(const DomainT& low, const DomainT& up, $/;"	f	class:boost::icl::continuous_interval	access:public	signature:(const DomainT& low, const DomainT& up, interval_bounds bounds = interval_bounds::right_open(), continuous_interval* = 0)
boost::icl::continuous_interval::continuous_interval	icl/continuous_interval.hpp	/^    explicit continuous_interval(const DomainT& val)$/;"	f	class:boost::icl::continuous_interval	access:public	signature:(const DomainT& val)
boost::icl::continuous_interval::domain_compare	icl/continuous_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::continuous_interval	access:public
boost::icl::continuous_interval::domain_type	icl/continuous_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::continuous_interval	access:public
boost::icl::continuous_interval::left_open	icl/continuous_interval.hpp	/^    static continuous_interval left_open (const DomainT& lo, const DomainT& up){ return continuous_interval(lo, up, interval_bounds::left_open()); }$/;"	f	class:boost::icl::continuous_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
boost::icl::continuous_interval::lower	icl/continuous_interval.hpp	/^    domain_type     lower()const { return _lwb; }$/;"	f	class:boost::icl::continuous_interval	access:public	signature:() const
boost::icl::continuous_interval::open	icl/continuous_interval.hpp	/^    static continuous_interval open     (const DomainT& lo, const DomainT& up){ return continuous_interval(lo, up, interval_bounds::open());      }$/;"	f	class:boost::icl::continuous_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
boost::icl::continuous_interval::right_open	icl/continuous_interval.hpp	/^    static continuous_interval right_open(const DomainT& lo, const DomainT& up){ return continuous_interval(lo, up, interval_bounds::right_open());}$/;"	f	class:boost::icl::continuous_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
boost::icl::continuous_interval::type	icl/continuous_interval.hpp	/^    typedef continuous_interval<DomainT,Compare> type;$/;"	t	class:boost::icl::continuous_interval	access:public
boost::icl::continuous_interval::upper	icl/continuous_interval.hpp	/^    domain_type     upper()const { return _upb; }$/;"	f	class:boost::icl::continuous_interval	access:public	signature:() const
boost::icl::conversion	icl/functors.hpp	/^    struct conversion$/;"	s	namespace:boost::icl
boost::icl::conversion::argument_type	icl/functors.hpp	/^            argument_type;$/;"	t	struct:boost::icl::conversion	access:public
boost::icl::conversion::inversion	icl/functors.hpp	/^        static argument_type inversion(const argument_type& value)$/;"	f	struct:boost::icl::conversion	access:public	signature:(const argument_type& value)
boost::icl::conversion::proversion	icl/functors.hpp	/^        static argument_type proversion(const argument_type& value)$/;"	f	struct:boost::icl::conversion	access:public	signature:(const argument_type& value)
boost::icl::conversion::type	icl/functors.hpp	/^        typedef conversion<Combiner> type;$/;"	t	struct:boost::icl::conversion	access:public
boost::icl::cyclic_prior	icl/concept/container.hpp	/^cyclic_prior(Type& object, typename Type::iterator it_)$/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator it_)
boost::icl::cyclic_prior	icl/concept/container.hpp	/^cyclic_prior(const Type& object, typename Type::const_iterator it_)$/;"	f	namespace:boost::icl	signature:(const Type& object, typename Type::const_iterator it_)
boost::icl::detail	icl/concept/interval.hpp	/^namespace detail$/;"	n	namespace:boost::icl
boost::icl::detail	icl/type_traits/codomain_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
boost::icl::detail	icl/type_traits/difference_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
boost::icl::detail	icl/type_traits/domain_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
boost::icl::detail	icl/type_traits/element_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
boost::icl::detail	icl/type_traits/interval_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
boost::icl::detail	icl/type_traits/is_container.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
boost::icl::detail	icl/type_traits/is_key_container_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
boost::icl::detail	icl/type_traits/rep_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
boost::icl::detail	icl/type_traits/segment_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
boost::icl::detail	icl/type_traits/size_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
boost::icl::detail	icl/type_traits/succ_pred.hpp	/^namespace detail$/;"	n	namespace:boost::icl
boost::icl::detail::predecessor	icl/type_traits/succ_pred.hpp	/^    struct predecessor<DomainT, false>$/;"	s	namespace:boost::icl::detail
boost::icl::detail::predecessor	icl/type_traits/succ_pred.hpp	/^    struct predecessor<DomainT, true>$/;"	s	namespace:boost::icl::detail
boost::icl::detail::predecessor::apply	icl/type_traits/succ_pred.hpp	/^        inline static DomainT apply(DomainT value){ return ++value; }$/;"	f	struct:boost::icl::detail::predecessor	access:public	signature:(DomainT value)
boost::icl::detail::predecessor::apply	icl/type_traits/succ_pred.hpp	/^        inline static DomainT apply(DomainT value){ return --value; }$/;"	f	struct:boost::icl::detail::predecessor	access:public	signature:(DomainT value)
boost::icl::detail::predecessor::type	icl/type_traits/succ_pred.hpp	/^        typedef predecessor type;$/;"	t	struct:boost::icl::detail::predecessor	access:public
boost::icl::detail::successor	icl/type_traits/succ_pred.hpp	/^    struct successor<DomainT, false>$/;"	s	namespace:boost::icl::detail
boost::icl::detail::successor	icl/type_traits/succ_pred.hpp	/^    struct successor<DomainT, true>$/;"	s	namespace:boost::icl::detail
boost::icl::detail::successor::apply	icl/type_traits/succ_pred.hpp	/^        inline static DomainT apply(DomainT value){ return ++value; }$/;"	f	struct:boost::icl::detail::successor	access:public	signature:(DomainT value)
boost::icl::detail::successor::apply	icl/type_traits/succ_pred.hpp	/^        inline static DomainT apply(DomainT value){ return --value; }$/;"	f	struct:boost::icl::detail::successor	access:public	signature:(DomainT value)
boost::icl::detail::successor::type	icl/type_traits/succ_pred.hpp	/^        typedef successor type;$/;"	t	struct:boost::icl::detail::successor	access:public
boost::icl::detail::unit_trail	icl/concept/interval.hpp	/^unit_trail(const typename interval_traits<Type>::domain_type& value)$/;"	f	namespace:boost::icl::detail	signature:(const typename interval_traits<Type>::domain_type& value)
boost::icl::difference	icl/type_traits/difference.hpp	/^    template <class Type> struct difference{ typedef Type type; };$/;"	s	namespace:boost::icl
boost::icl::difference::type	icl/type_traits/difference.hpp	/^    template <class Type> struct difference{ typedef Type type; };$/;"	t	struct:boost::icl::difference	access:public
boost::icl::difference_type_of	icl/gregorian.hpp	/^    struct difference_type_of<boost::gregorian::date> $/;"	s	namespace:boost::icl
boost::icl::difference_type_of	icl/interval_traits.hpp	/^struct difference_type_of<interval_traits<Type> >$/;"	s	namespace:boost::icl
boost::icl::difference_type_of	icl/ptime.hpp	/^    struct difference_type_of<boost::posix_time::ptime> $/;"	s	namespace:boost::icl
boost::icl::difference_type_of	icl/type_traits/difference_type_of.hpp	/^    struct difference_type_of$/;"	s	namespace:boost::icl
boost::icl::difference_type_of::domain_type	icl/interval_traits.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::difference_type_of	access:public
boost::icl::difference_type_of::type	icl/gregorian.hpp	/^    { typedef boost::gregorian::date_duration type; };  $/;"	t	struct:boost::icl::difference_type_of	access:public
boost::icl::difference_type_of::type	icl/interval_traits.hpp	/^    typedef typename difference_type_of<domain_type>::type type;$/;"	t	struct:boost::icl::difference_type_of	access:public
boost::icl::difference_type_of::type	icl/ptime.hpp	/^        typedef boost::posix_time::time_duration type; $/;"	t	struct:boost::icl::difference_type_of	access:public
boost::icl::difference_type_of::type	icl/type_traits/difference_type_of.hpp	/^                               >::type type;$/;"	t	struct:boost::icl::difference_type_of	access:public
boost::icl::discrete_interval	icl/discrete_interval.hpp	/^class discrete_interval$/;"	c	namespace:boost::icl
boost::icl::discrete_interval::_bounds	icl/discrete_interval.hpp	/^    interval_bounds _bounds;$/;"	m	class:boost::icl::discrete_interval	access:private
boost::icl::discrete_interval::_lwb	icl/discrete_interval.hpp	/^    domain_type     _lwb;$/;"	m	class:boost::icl::discrete_interval	access:private
boost::icl::discrete_interval::_upb	icl/discrete_interval.hpp	/^    domain_type     _upb;$/;"	m	class:boost::icl::discrete_interval	access:private
boost::icl::discrete_interval::bounded_domain_type	icl/discrete_interval.hpp	/^    typedef typename bounded_value<DomainT>::type bounded_domain_type;$/;"	t	class:boost::icl::discrete_interval	access:public
boost::icl::discrete_interval::bounds	icl/discrete_interval.hpp	/^    interval_bounds bounds()const{ return _bounds; }$/;"	f	class:boost::icl::discrete_interval	access:public	signature:() const
boost::icl::discrete_interval::closed	icl/discrete_interval.hpp	/^    static discrete_interval closed    (const DomainT& lo, const DomainT& up){ return discrete_interval(lo, up, interval_bounds::closed());    }$/;"	f	class:boost::icl::discrete_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
boost::icl::discrete_interval::discrete_interval	icl/discrete_interval.hpp	/^    discrete_interval()$/;"	f	class:boost::icl::discrete_interval	access:public	signature:()
boost::icl::discrete_interval::discrete_interval	icl/discrete_interval.hpp	/^    discrete_interval(const DomainT& low, const DomainT& up, $/;"	f	class:boost::icl::discrete_interval	access:public	signature:(const DomainT& low, const DomainT& up, interval_bounds bounds = interval_bounds::right_open(), discrete_interval* = 0)
boost::icl::discrete_interval::discrete_interval	icl/discrete_interval.hpp	/^    explicit discrete_interval(const DomainT& val)$/;"	f	class:boost::icl::discrete_interval	access:public	signature:(const DomainT& val)
boost::icl::discrete_interval::domain_compare	icl/discrete_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::discrete_interval	access:public
boost::icl::discrete_interval::domain_type	icl/discrete_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::discrete_interval	access:public
boost::icl::discrete_interval::left_open	icl/discrete_interval.hpp	/^    static discrete_interval left_open (const DomainT& lo, const DomainT& up){ return discrete_interval(lo, up, interval_bounds::left_open()); }$/;"	f	class:boost::icl::discrete_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
boost::icl::discrete_interval::lower	icl/discrete_interval.hpp	/^    domain_type     lower()const { return _lwb; }$/;"	f	class:boost::icl::discrete_interval	access:public	signature:() const
boost::icl::discrete_interval::open	icl/discrete_interval.hpp	/^    static discrete_interval open      (const DomainT& lo, const DomainT& up){ return discrete_interval(lo, up, interval_bounds::open());      }$/;"	f	class:boost::icl::discrete_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
boost::icl::discrete_interval::right_open	icl/discrete_interval.hpp	/^    static discrete_interval right_open(const DomainT& lo, const DomainT& up){ return discrete_interval(lo, up, interval_bounds::right_open());}$/;"	f	class:boost::icl::discrete_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
boost::icl::discrete_interval::type	icl/discrete_interval.hpp	/^    typedef discrete_interval<DomainT,Compare> type;$/;"	t	class:boost::icl::discrete_interval	access:public
boost::icl::discrete_interval::upper	icl/discrete_interval.hpp	/^    domain_type     upper()const { return _upb; }$/;"	f	class:boost::icl::discrete_interval	access:public	signature:() const
boost::icl::disjoint	icl/concept/element_associator.hpp	/^disjoint(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::disjoint	icl/concept/interval.hpp	/^disjoint(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::disjoint	icl/concept/interval_associator.hpp	/^disjoint(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
boost::icl::disjoint	icl/concept/interval_associator.hpp	/^disjoint(const Type& left, const AssociateT& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const AssociateT& right)
boost::icl::distance	icl/concept/interval.hpp	/^distance(const Type& x1, const Type& x2)$/;"	f	namespace:boost::icl	signature:(const Type& x1, const Type& x2)
boost::icl::distance	icl/concept/interval_associator.hpp	/^distance(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::distinct_equal	icl/predicates/distinct_equal.hpp	/^    struct distinct_equal : public relation<Type,Type>$/;"	s	namespace:boost::icl	inherits:relation
boost::icl::distinct_equal::operator ()	icl/predicates/distinct_equal.hpp	/^        bool operator()(const Type& lhs, const Type& rhs)const$/;"	f	struct:boost::icl::distinct_equal	access:public	signature:(const Type& lhs, const Type& rhs) const
boost::icl::domain	icl/concept/element_map.hpp	/^domain(typename Type::set_type& domain_set, const Type& object)$/;"	f	namespace:boost::icl	signature:(typename Type::set_type& domain_set, const Type& object)
boost::icl::domain	icl/concept/interval_map.hpp	/^domain(SetT& result, const Type& object)$/;"	f	namespace:boost::icl	signature:(SetT& result, const Type& object)
boost::icl::domain	icl/concept/interval_set.hpp	/^domain(Type& dom, const Type& object)$/;"	f	namespace:boost::icl	signature:(Type& dom, const Type& object)
boost::icl::domain_equal	icl/concept/interval.hpp	/^domain_equal(const typename interval_traits<Type>::domain_type& left, $/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& left, const typename interval_traits<Type>::domain_type& right)
boost::icl::domain_less	icl/concept/interval.hpp	/^domain_less(const typename interval_traits<Type>::domain_type& left, $/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& left, const typename interval_traits<Type>::domain_type& right)
boost::icl::domain_less_equal	icl/concept/interval.hpp	/^domain_less_equal(const typename interval_traits<Type>::domain_type& left, $/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& left, const typename interval_traits<Type>::domain_type& right)
boost::icl::domain_next	icl/concept/interval.hpp	/^domain_next(const typename interval_traits<Type>::domain_type value) $/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type value)
boost::icl::domain_prior	icl/concept/interval.hpp	/^domain_prior(const typename interval_traits<Type>::domain_type value) $/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type value)
boost::icl::domain_type_of	icl/interval_traits.hpp	/^struct domain_type_of<interval_traits<Type> >$/;"	s	namespace:boost::icl
boost::icl::domain_type_of	icl/type_traits/domain_type_of.hpp	/^    struct domain_type_of$/;"	s	namespace:boost::icl
boost::icl::domain_type_of::type	icl/interval_traits.hpp	/^    typedef typename interval_traits<Type>::domain_type type;$/;"	t	struct:boost::icl::domain_type_of	access:public
boost::icl::domain_type_of::type	icl/type_traits/domain_type_of.hpp	/^            get_domain_type<Type, has_domain_type<Type>::value>::type type;$/;"	t	struct:boost::icl::domain_type_of	access:public
boost::icl::dynamic_interval_traits	icl/continuous_interval.hpp	/^struct dynamic_interval_traits<boost::icl::continuous_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::dynamic_interval_traits	icl/discrete_interval.hpp	/^struct dynamic_interval_traits<boost::icl::discrete_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::dynamic_interval_traits	icl/dynamic_interval_traits.hpp	/^struct dynamic_interval_traits$/;"	s	namespace:boost::icl
boost::icl::dynamic_interval_traits::construct	icl/continuous_interval.hpp	/^    static interval_type construct(const domain_type lo, const domain_type up, interval_bounds bounds)$/;"	f	struct:boost::icl::dynamic_interval_traits	access:public	signature:(const domain_type lo, const domain_type up, interval_bounds bounds)
boost::icl::dynamic_interval_traits::construct	icl/discrete_interval.hpp	/^    static interval_type construct(const domain_type& lo, const domain_type& up, interval_bounds bounds)$/;"	f	struct:boost::icl::dynamic_interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up, interval_bounds bounds)
boost::icl::dynamic_interval_traits::construct	icl/dynamic_interval_traits.hpp	/^    static Type construct(const domain_type& lo, const domain_type& up, interval_bounds bounds);$/;"	p	struct:boost::icl::dynamic_interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up, interval_bounds bounds)
boost::icl::dynamic_interval_traits::construct_bounded	icl/continuous_interval.hpp	/^    static interval_type construct_bounded(const bounded_value<DomainT>& lo, $/;"	f	struct:boost::icl::dynamic_interval_traits	access:public	signature:(const bounded_value<DomainT>& lo, const bounded_value<DomainT>& up)
boost::icl::dynamic_interval_traits::construct_bounded	icl/discrete_interval.hpp	/^    static interval_type construct_bounded(const bounded_value<DomainT>& lo, $/;"	f	struct:boost::icl::dynamic_interval_traits	access:public	signature:(const bounded_value<DomainT>& lo, const bounded_value<DomainT>& up)
boost::icl::dynamic_interval_traits::construct_bounded	icl/dynamic_interval_traits.hpp	/^    static Type construct_bounded(const bounded_value<domain_type>& lo, $/;"	p	struct:boost::icl::dynamic_interval_traits	access:public	signature:(const bounded_value<domain_type>& lo, const bounded_value<domain_type>& up)
boost::icl::dynamic_interval_traits::domain_compare	icl/continuous_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
boost::icl::dynamic_interval_traits::domain_compare	icl/discrete_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
boost::icl::dynamic_interval_traits::domain_compare	icl/dynamic_interval_traits.hpp	/^    typedef typename Type::domain_compare domain_compare;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
boost::icl::dynamic_interval_traits::domain_type	icl/continuous_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
boost::icl::dynamic_interval_traits::domain_type	icl/discrete_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
boost::icl::dynamic_interval_traits::domain_type	icl/dynamic_interval_traits.hpp	/^    typedef typename Type::domain_type    domain_type;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
boost::icl::dynamic_interval_traits::interval_type	icl/continuous_interval.hpp	/^    typedef boost::icl::continuous_interval<DomainT,Compare> interval_type;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
boost::icl::dynamic_interval_traits::interval_type	icl/discrete_interval.hpp	/^    typedef boost::icl::discrete_interval<DomainT,Compare> interval_type;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
boost::icl::dynamic_interval_traits::type	icl/continuous_interval.hpp	/^    typedef dynamic_interval_traits type;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
boost::icl::dynamic_interval_traits::type	icl/discrete_interval.hpp	/^    typedef dynamic_interval_traits type;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
boost::icl::element_equal	icl/predicates/element_equal.hpp	/^    struct element_equal : public relation<Type,Type>$/;"	s	namespace:boost::icl	inherits:relation
boost::icl::element_equal::operator ()	icl/predicates/element_equal.hpp	/^        bool operator()(const Type& lhs, const Type& rhs)const$/;"	f	struct:boost::icl::element_equal	access:public	signature:(const Type& lhs, const Type& rhs) const
boost::icl::element_iterator	icl/detail/element_iterator.hpp	/^class element_iterator$/;"	c	namespace:boost::icl	inherits:boost::iterator_facade
boost::icl::element_iterator::_inter_pos	icl/detail/element_iterator.hpp	/^    mutable domain_type            _inter_pos; \/\/ inter position : Position within the current segment$/;"	m	class:boost::icl::element_iterator	access:private
boost::icl::element_iterator::_reptator	icl/detail/element_iterator.hpp	/^    mutable domain_difference_type _reptator;  \/\/ reptare:  to sneak : the slow moving iterator 0 based$/;"	m	class:boost::icl::element_iterator	access:private
boost::icl::element_iterator::_saltator	icl/detail/element_iterator.hpp	/^    segment_iterator               _saltator;  \/\/ satltare: to jump  : the fast moving iterator$/;"	m	class:boost::icl::element_iterator	access:private
boost::icl::element_iterator::adapt	icl/detail/element_iterator.hpp	/^    typedef typename segment_adapter<segment_iterator,segment_type>::type adapt;$/;"	t	class:boost::icl::element_iterator	access:private
boost::icl::element_iterator::codomain_type	icl/detail/element_iterator.hpp	/^    typedef typename elemental<segment_type>::codomain_type codomain_type;$/;"	t	class:boost::icl::element_iterator	access:public
boost::icl::element_iterator::decrement	icl/detail/element_iterator.hpp	/^    void decrement()$/;"	f	class:boost::icl::element_iterator	access:private	signature:()
boost::icl::element_iterator::dereference	icl/detail/element_iterator.hpp	/^    value_type dereference()const$/;"	f	class:boost::icl::element_iterator	access:private	signature:() const
boost::icl::element_iterator::domain_difference_type	icl/detail/element_iterator.hpp	/^                                                            domain_difference_type;$/;"	t	class:boost::icl::element_iterator	access:public
boost::icl::element_iterator::domain_type	icl/detail/element_iterator.hpp	/^    typedef typename elemental<segment_type>::domain_type   domain_type;$/;"	t	class:boost::icl::element_iterator	access:public
boost::icl::element_iterator::element_iterator	icl/detail/element_iterator.hpp	/^    element_iterator$/;"	f	class:boost::icl::element_iterator	access:public	signature:( element_iterator<SaltatorT> const& other , typename enable_if<boost::is_convertible<SaltatorT*,SegmentIteratorT*>, enabler>::type = enabler())
boost::icl::element_iterator::element_iterator	icl/detail/element_iterator.hpp	/^    element_iterator()$/;"	f	class:boost::icl::element_iterator	access:public	signature:()
boost::icl::element_iterator::element_iterator	icl/detail/element_iterator.hpp	/^    explicit element_iterator(segment_iterator jumper)$/;"	f	class:boost::icl::element_iterator	access:public	signature:(segment_iterator jumper)
boost::icl::element_iterator::element_type	icl/detail/element_iterator.hpp	/^    typedef typename elemental<segment_type>::type          element_type;$/;"	t	class:boost::icl::element_iterator	access:public
boost::icl::element_iterator::enabler	icl/detail/element_iterator.hpp	/^    struct enabler{};$/;"	s	class:boost::icl::element_iterator	access:private
boost::icl::element_iterator::equal	icl/detail/element_iterator.hpp	/^    bool equal(element_iterator<SaltatorT> const& other) const$/;"	f	class:boost::icl::element_iterator	access:private	signature:(element_iterator<SaltatorT> const& other) const
boost::icl::element_iterator::increment	icl/detail/element_iterator.hpp	/^    void increment()$/;"	f	class:boost::icl::element_iterator	access:private	signature:()
boost::icl::element_iterator::interval_type	icl/detail/element_iterator.hpp	/^    typedef typename first_element<segment_type>::type      interval_type;$/;"	t	class:boost::icl::element_iterator	access:public
boost::icl::element_iterator::segment_iterator	icl/detail/element_iterator.hpp	/^    typedef SegmentIteratorT                                segment_iterator;$/;"	t	class:boost::icl::element_iterator	access:public
boost::icl::element_iterator::segment_type	icl/detail/element_iterator.hpp	/^    typedef typename SegmentIteratorT::value_type           segment_type;$/;"	t	class:boost::icl::element_iterator	access:public
boost::icl::element_iterator::transit_type	icl/detail/element_iterator.hpp	/^    typedef typename elemental<segment_type>::transit_type  transit_type;$/;"	t	class:boost::icl::element_iterator	access:public
boost::icl::element_iterator::type	icl/detail/element_iterator.hpp	/^    typedef element_iterator                                type;$/;"	t	class:boost::icl::element_iterator	access:public
boost::icl::element_iterator::value_type	icl/detail/element_iterator.hpp	/^    typedef transit_type                                    value_type;$/;"	t	class:boost::icl::element_iterator	access:public
boost::icl::element_type_of	icl/type_traits/element_type_of.hpp	/^    struct element_type_of$/;"	s	namespace:boost::icl
boost::icl::element_type_of::type	icl/type_traits/element_type_of.hpp	/^            get_element_type<Type, has_element_type<Type>::value>::type type;$/;"	t	struct:boost::icl::element_type_of	access:public
boost::icl::elemental	icl/detail/element_iterator.hpp	/^    struct elemental$/;"	s	namespace:boost::icl
boost::icl::elemental	icl/detail/element_iterator.hpp	/^    struct elemental<ICL_INTERVAL_TYPE(Interval,DomainT,Compare) >$/;"	s	namespace:boost::icl
boost::icl::elemental	icl/detail/element_iterator.hpp	/^    struct elemental<std::pair<ICL_INTERVAL_TYPE(Interval,DomainT,Compare)const, CodomainT> >$/;"	s	namespace:boost::icl
boost::icl::elemental::codomain_type	icl/detail/element_iterator.hpp	/^        typedef CodomainT                                       codomain_type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::codomain_type	icl/detail/element_iterator.hpp	/^        typedef DomainT                   codomain_type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::codomain_type	icl/detail/element_iterator.hpp	/^        typedef domain_type                         codomain_type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::domain_type	icl/detail/element_iterator.hpp	/^        typedef DomainT                                         domain_type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::domain_type	icl/detail/element_iterator.hpp	/^        typedef DomainT                   domain_type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::domain_type	icl/detail/element_iterator.hpp	/^        typedef typename interval_traits<interval_type>::domain_type domain_type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::interval_type	icl/detail/element_iterator.hpp	/^        typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare)                       interval_type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::interval_type	icl/detail/element_iterator.hpp	/^        typedef segment_type                        interval_type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::interval_type	icl/detail/element_iterator.hpp	/^        typedef segment_type              interval_type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::segment_type	icl/detail/element_iterator.hpp	/^        typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) segment_type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::segment_type	icl/detail/element_iterator.hpp	/^        typedef std::pair<ICL_INTERVAL_TYPE(Interval,DomainT,Compare), CodomainT> segment_type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::transit_type	icl/detail/element_iterator.hpp	/^        typedef DomainT                   transit_type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::transit_type	icl/detail/element_iterator.hpp	/^        typedef domain_type                         transit_type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::transit_type	icl/detail/element_iterator.hpp	/^        typedef mapped_reference<DomainT, CodomainT>            transit_type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::transit_type	icl/detail/element_iterator.hpp	/^        typedef mapped_reference<domain_type, codomain_type>    transit_type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::type	icl/detail/element_iterator.hpp	/^        typedef DomainT                   type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::type	icl/detail/element_iterator.hpp	/^        typedef domain_type                         type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::type	icl/detail/element_iterator.hpp	/^        typedef std::pair<DomainT, CodomainT>                   type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elemental::type	icl/detail/element_iterator.hpp	/^        typedef std::pair<domain_type, codomain_type>           type;$/;"	t	struct:boost::icl::elemental	access:public
boost::icl::elements_begin	icl/concept/interval_associator.hpp	/^elements_begin(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
boost::icl::elements_begin	icl/concept/interval_associator.hpp	/^elements_begin(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::elements_end	icl/concept/interval_associator.hpp	/^elements_end(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
boost::icl::elements_end	icl/concept/interval_associator.hpp	/^elements_end(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::elements_rbegin	icl/concept/interval_associator.hpp	/^elements_rbegin(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
boost::icl::elements_rbegin	icl/concept/interval_associator.hpp	/^elements_rbegin(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::elements_rend	icl/concept/interval_associator.hpp	/^elements_rend(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
boost::icl::elements_rend	icl/concept/interval_associator.hpp	/^elements_rend(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::erase	icl/concept/element_associator.hpp	/^erase(Type& object, const Type& erasure)$/;"	f	namespace:boost::icl	signature:(Type& object, const Type& erasure)
boost::icl::erase	icl/concept/element_associator.hpp	/^erase(Type& object, const typename Type::key_type& key_value)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::key_type& key_value)
boost::icl::erase	icl/concept/element_map.hpp	/^erase(Type& object, const typename Type::element_type& value_pair)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& value_pair)
boost::icl::erase	icl/concept/element_map.hpp	/^erase(Type& object, const typename Type::set_type& erasure)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::set_type& erasure)
boost::icl::erase	icl/concept/interval_associator.hpp	/^erase(Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
boost::icl::erase	icl/concept/interval_map.hpp	/^erase(Type& object, const typename Type::domain_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::domain_type& operand)
boost::icl::erase	icl/concept/interval_map.hpp	/^erase(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::erase	icl/concept/interval_map.hpp	/^erase(Type& object, const typename Type::interval_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::interval_type& operand)
boost::icl::erase	icl/concept/interval_map.hpp	/^erase(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
boost::icl::erase	icl/concept/interval_set.hpp	/^erase(Type& object, const typename Type::element_type& minuend)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& minuend)
boost::icl::erase	icl/concept/interval_set.hpp	/^erase(Type& object, const typename Type::segment_type& minuend)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& minuend)
boost::icl::erase_if	icl/concept/element_associator.hpp	/^erase_if(const Predicate& pred, Type& object)$/;"	f	namespace:boost::icl	signature:(const Predicate& pred, Type& object)
boost::icl::erase_if	icl/concept/element_map.hpp	/^erase_if(const Predicate& pred, Type& object);$/;"	p	namespace:boost::icl	signature:(const Predicate& pred, Type& object)
boost::icl::erase_if	icl/concept/interval_map.hpp	/^erase_if(const Predicate& pred, MapT& object)$/;"	f	namespace:boost::icl	signature:(const Predicate& pred, MapT& object)
boost::icl::exclusive_less	icl/concept/interval.hpp	/^exclusive_less(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::exclusive_less_than	icl/detail/exclusive_less_than.hpp	/^struct exclusive_less_than $/;"	s	namespace:boost::icl
boost::icl::exclusive_less_than::operator ()	icl/detail/exclusive_less_than.hpp	/^    bool operator()(const IntervalT& left, const IntervalT& right)const$/;"	f	struct:boost::icl::exclusive_less_than	access:public	signature:(const IntervalT& left, const IntervalT& right) const
boost::icl::find	icl/concept/interval_associator_base.hpp	/^find(const Type& object, const typename domain_type_of<Type>::type& key_val)$/;"	f	namespace:boost::icl	signature:(const Type& object, const typename domain_type_of<Type>::type& key_val)
boost::icl::find	icl/concept/interval_associator_base.hpp	/^find(const Type& object, const typename interval_type_of<Type>::type& inter_val)$/;"	f	namespace:boost::icl	signature:(const Type& object, const typename interval_type_of<Type>::type& inter_val)
boost::icl::first	icl/concept/interval.hpp	/^first(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::first	icl/concept/interval_associator.hpp	/^first(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::first_element	icl/detail/element_iterator.hpp	/^struct first_element$/;"	s	namespace:boost::icl
boost::icl::first_element	icl/detail/element_iterator.hpp	/^struct first_element<std::pair<FirstT, SecondT> >$/;"	s	namespace:boost::icl
boost::icl::first_element::type	icl/detail/element_iterator.hpp	/^    typedef FirstT type; $/;"	t	struct:boost::icl::first_element	access:public
boost::icl::first_element::type	icl/detail/element_iterator.hpp	/^    typedef Type type; $/;"	t	struct:boost::icl::first_element	access:public
boost::icl::flip	icl/concept/element_map.hpp	/^flip(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::flip	icl/concept/element_set.hpp	/^flip(Type& object, const typename Type::value_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& operand)
boost::icl::flip	icl/concept/interval_map.hpp	/^flip(Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
boost::icl::flip	icl/concept/interval_map.hpp	/^flip(Type& object, const OperandT&)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT&)
boost::icl::flip	icl/concept/interval_map.hpp	/^flip(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::flip	icl/concept/interval_map.hpp	/^flip(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
boost::icl::flip	icl/concept/interval_set.hpp	/^flip(Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
boost::icl::flip	icl/concept/interval_set.hpp	/^flip(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::flip	icl/concept/interval_set.hpp	/^flip(Type& object, const typename Type::segment_type& segment)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& segment)
boost::icl::get_codomain_type	icl/type_traits/codomain_type_of.hpp	/^    struct get_codomain_type<Type, false, false>$/;"	s	namespace:boost::icl
boost::icl::get_codomain_type	icl/type_traits/codomain_type_of.hpp	/^    struct get_codomain_type<Type, false, true>$/;"	s	namespace:boost::icl
boost::icl::get_codomain_type	icl/type_traits/codomain_type_of.hpp	/^    struct get_codomain_type<Type, true, is_std_set>$/;"	s	namespace:boost::icl
boost::icl::get_codomain_type::type	icl/type_traits/codomain_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_codomain_type	access:public
boost::icl::get_codomain_type::type	icl/type_traits/codomain_type_of.hpp	/^        typedef typename Type::codomain_type type;$/;"	t	struct:boost::icl::get_codomain_type	access:public
boost::icl::get_codomain_type::type	icl/type_traits/codomain_type_of.hpp	/^        typedef typename Type::value_type type;$/;"	t	struct:boost::icl::get_codomain_type	access:public
boost::icl::get_difference_type	icl/type_traits/difference_type_of.hpp	/^    struct get_difference_type<Type*, true, false>$/;"	s	namespace:boost::icl
boost::icl::get_difference_type	icl/type_traits/difference_type_of.hpp	/^    struct get_difference_type<Type, false, false>$/;"	s	namespace:boost::icl
boost::icl::get_difference_type	icl/type_traits/difference_type_of.hpp	/^    struct get_difference_type<Type, true, false>$/;"	s	namespace:boost::icl
boost::icl::get_difference_type	icl/type_traits/difference_type_of.hpp	/^    struct get_difference_type<Type, true, true>$/;"	s	namespace:boost::icl
boost::icl::get_difference_type::type	icl/type_traits/difference_type_of.hpp	/^        typedef Type type;$/;"	t	struct:boost::icl::get_difference_type	access:public
boost::icl::get_difference_type::type	icl/type_traits/difference_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_difference_type	access:public
boost::icl::get_difference_type::type	icl/type_traits/difference_type_of.hpp	/^        typedef std::ptrdiff_t type;$/;"	t	struct:boost::icl::get_difference_type	access:public
boost::icl::get_difference_type::type	icl/type_traits/difference_type_of.hpp	/^        typedef typename Type::difference_type type;$/;"	t	struct:boost::icl::get_difference_type	access:public
boost::icl::get_domain_type	icl/type_traits/domain_type_of.hpp	/^    struct get_domain_type<Type, false>$/;"	s	namespace:boost::icl
boost::icl::get_domain_type	icl/type_traits/domain_type_of.hpp	/^    struct get_domain_type<Type, true>$/;"	s	namespace:boost::icl
boost::icl::get_domain_type::type	icl/type_traits/domain_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_domain_type	access:public
boost::icl::get_domain_type::type	icl/type_traits/domain_type_of.hpp	/^        typedef typename Type::domain_type type;$/;"	t	struct:boost::icl::get_domain_type	access:public
boost::icl::get_element_type	icl/type_traits/element_type_of.hpp	/^    struct get_element_type<Type, false>$/;"	s	namespace:boost::icl
boost::icl::get_element_type	icl/type_traits/element_type_of.hpp	/^    struct get_element_type<Type, true>$/;"	s	namespace:boost::icl
boost::icl::get_element_type::type	icl/type_traits/element_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_element_type	access:public
boost::icl::get_element_type::type	icl/type_traits/element_type_of.hpp	/^        typedef typename Type::element_type type;$/;"	t	struct:boost::icl::get_element_type	access:public
boost::icl::get_infinity	icl/type_traits/infinity.hpp	/^struct get_infinity<Type, false, false, false, false>$/;"	s	namespace:boost::icl
boost::icl::get_infinity	icl/type_traits/infinity.hpp	/^struct get_infinity<Type, false, false, false, true>$/;"	s	namespace:boost::icl
boost::icl::get_infinity	icl/type_traits/infinity.hpp	/^struct get_infinity<Type, false, false, true, has_diff>$/;"	s	namespace:boost::icl
boost::icl::get_infinity	icl/type_traits/infinity.hpp	/^struct get_infinity<Type, false, true, has_size, has_diff>$/;"	s	namespace:boost::icl
boost::icl::get_infinity	icl/type_traits/infinity.hpp	/^struct get_infinity<Type, true, has_repr_inf, has_size, has_diff>$/;"	s	namespace:boost::icl
boost::icl::get_infinity::difference_type	icl/type_traits/infinity.hpp	/^    typedef typename Type::difference_type difference_type;$/;"	t	struct:boost::icl::get_infinity	access:public
boost::icl::get_infinity::size_type	icl/type_traits/infinity.hpp	/^    typedef typename Type::size_type size_type;$/;"	t	struct:boost::icl::get_infinity	access:public
boost::icl::get_infinity::type	icl/type_traits/infinity.hpp	/^    typedef get_infinity type;$/;"	t	struct:boost::icl::get_infinity	access:public
boost::icl::get_infinity::value	icl/type_traits/infinity.hpp	/^    static Type value()$/;"	f	struct:boost::icl::get_infinity	access:public	signature:()
boost::icl::get_interval_type	icl/type_traits/interval_type_of.hpp	/^    struct get_interval_type<Type, false>$/;"	s	namespace:boost::icl
boost::icl::get_interval_type	icl/type_traits/interval_type_of.hpp	/^    struct get_interval_type<Type, true>$/;"	s	namespace:boost::icl
boost::icl::get_interval_type::type	icl/type_traits/interval_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_interval_type	access:public
boost::icl::get_interval_type::type	icl/type_traits/interval_type_of.hpp	/^        typedef typename Type::interval_type type;$/;"	t	struct:boost::icl::get_interval_type	access:public
boost::icl::get_key_object_type	icl/type_traits/is_key_container_of.hpp	/^    struct get_key_object_type<Type, false, false>$/;"	s	namespace:boost::icl
boost::icl::get_key_object_type	icl/type_traits/is_key_container_of.hpp	/^    struct get_key_object_type<Type, false, true>$/;"	s	namespace:boost::icl
boost::icl::get_key_object_type	icl/type_traits/is_key_container_of.hpp	/^    struct get_key_object_type<Type, true, IsSet>$/;"	s	namespace:boost::icl
boost::icl::get_key_object_type::no_type	icl/type_traits/is_key_container_of.hpp	/^        typedef Type no_type;$/;"	t	struct:boost::icl::get_key_object_type	access:public
boost::icl::get_key_object_type::type	icl/type_traits/is_key_container_of.hpp	/^        typedef Type type;$/;"	t	struct:boost::icl::get_key_object_type	access:public
boost::icl::get_key_object_type::type	icl/type_traits/is_key_container_of.hpp	/^        typedef typename Type::key_object_type type;$/;"	t	struct:boost::icl::get_key_object_type	access:public
boost::icl::get_key_type	icl/type_traits/element_type_of.hpp	/^    struct get_key_type<Type, false>$/;"	s	namespace:boost::icl
boost::icl::get_key_type	icl/type_traits/element_type_of.hpp	/^    struct get_key_type<Type, true>$/;"	s	namespace:boost::icl
boost::icl::get_key_type::type	icl/type_traits/element_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_key_type	access:public
boost::icl::get_key_type::type	icl/type_traits/element_type_of.hpp	/^        typedef typename Type::key_type type;$/;"	t	struct:boost::icl::get_key_type	access:public
boost::icl::get_numeric_infinity	icl/type_traits/infinity.hpp	/^struct get_numeric_infinity<Type, false, false>$/;"	s	namespace:boost::icl
boost::icl::get_numeric_infinity	icl/type_traits/infinity.hpp	/^struct get_numeric_infinity<Type, false, true>$/;"	s	namespace:boost::icl
boost::icl::get_numeric_infinity	icl/type_traits/infinity.hpp	/^struct get_numeric_infinity<Type, true, has_std_max>$/;"	s	namespace:boost::icl
boost::icl::get_numeric_infinity::type	icl/type_traits/infinity.hpp	/^    typedef get_numeric_infinity type;$/;"	t	struct:boost::icl::get_numeric_infinity	access:public
boost::icl::get_numeric_infinity::value	icl/type_traits/infinity.hpp	/^    static Type value()$/;"	f	struct:boost::icl::get_numeric_infinity	access:public	signature:()
boost::icl::get_rep_type	icl/type_traits/rep_type_of.hpp	/^    struct get_rep_type<Type, false>$/;"	s	namespace:boost::icl
boost::icl::get_rep_type	icl/type_traits/rep_type_of.hpp	/^    struct get_rep_type<Type, true>$/;"	s	namespace:boost::icl
boost::icl::get_rep_type::type	icl/type_traits/rep_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_rep_type	access:public
boost::icl::get_rep_type::type	icl/type_traits/rep_type_of.hpp	/^        typedef typename Type::rep type;$/;"	t	struct:boost::icl::get_rep_type	access:public
boost::icl::get_segment_type	icl/type_traits/segment_type_of.hpp	/^    struct get_segment_type<Type, false>$/;"	s	namespace:boost::icl
boost::icl::get_segment_type	icl/type_traits/segment_type_of.hpp	/^    struct get_segment_type<Type, true>$/;"	s	namespace:boost::icl
boost::icl::get_segment_type::type	icl/type_traits/segment_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_segment_type	access:public
boost::icl::get_segment_type::type	icl/type_traits/segment_type_of.hpp	/^        typedef typename Type::segment_type type;$/;"	t	struct:boost::icl::get_segment_type	access:public
boost::icl::get_size_type	icl/type_traits/size_type_of.hpp	/^    struct get_size_type<Type, false, false, false>$/;"	s	namespace:boost::icl
boost::icl::get_size_type	icl/type_traits/size_type_of.hpp	/^    struct get_size_type<Type, false, false, true>$/;"	s	namespace:boost::icl
boost::icl::get_size_type	icl/type_traits/size_type_of.hpp	/^    struct get_size_type<Type, false, true, has_rep>$/;"	s	namespace:boost::icl
boost::icl::get_size_type	icl/type_traits/size_type_of.hpp	/^    struct get_size_type<Type, true, has_diff, has_rep>$/;"	s	namespace:boost::icl
boost::icl::get_size_type::type	icl/type_traits/size_type_of.hpp	/^        typedef Type type; $/;"	t	struct:boost::icl::get_size_type	access:public
boost::icl::get_size_type::type	icl/type_traits/size_type_of.hpp	/^        typedef std::size_t type; $/;"	t	struct:boost::icl::get_size_type	access:public
boost::icl::get_size_type::type	icl/type_traits/size_type_of.hpp	/^        typedef typename Type::difference_type type; $/;"	t	struct:boost::icl::get_size_type	access:public
boost::icl::get_size_type::type	icl/type_traits/size_type_of.hpp	/^        typedef typename Type::size_type type; $/;"	t	struct:boost::icl::get_size_type	access:public
boost::icl::get_value_type	icl/type_traits/element_type_of.hpp	/^    struct get_value_type<Type, false>$/;"	s	namespace:boost::icl
boost::icl::get_value_type	icl/type_traits/element_type_of.hpp	/^    struct get_value_type<Type, true>$/;"	s	namespace:boost::icl
boost::icl::get_value_type::type	icl/type_traits/element_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_value_type	access:public
boost::icl::get_value_type::type	icl/type_traits/element_type_of.hpp	/^        typedef typename Type::value_type type;$/;"	t	struct:boost::icl::get_value_type	access:public
boost::icl::has_asymmetric_bounds	icl/type_traits/is_interval.hpp	/^template <class Type> struct has_asymmetric_bounds$/;"	s	namespace:boost::icl
boost::icl::has_asymmetric_bounds::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_asymmetric_bounds	access:public	signature:(bool, value = ( bounds == interval_bounds::static_left_open || bounds == interval_bounds::static_right_open))
boost::icl::has_asymmetric_bounds::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, bounds = (interval_bound_type<Type>::value)); $/;"	p	struct:boost::icl::has_asymmetric_bounds	access:public	signature:(bound_type, bounds = (interval_bound_type<Type>::value))
boost::icl::has_asymmetric_bounds::type	icl/type_traits/is_interval.hpp	/^    typedef has_asymmetric_bounds<Type> type;$/;"	t	struct:boost::icl::has_asymmetric_bounds	access:public
boost::icl::has_codomain_type	icl/type_traits/codomain_type_of.hpp	/^    struct has_codomain_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
boost::icl::has_difference	icl/gregorian.hpp	/^    struct has_difference<boost::gregorian::date> $/;"	s	namespace:boost::icl
boost::icl::has_difference	icl/gregorian.hpp	/^    struct has_difference<boost::gregorian::date_duration> $/;"	s	namespace:boost::icl
boost::icl::has_difference	icl/ptime.hpp	/^    struct has_difference<boost::posix_time::ptime> $/;"	s	namespace:boost::icl
boost::icl::has_difference	icl/ptime.hpp	/^    struct has_difference<boost::posix_time::time_duration> $/;"	s	namespace:boost::icl
boost::icl::has_difference	icl/type_traits/difference_type_of.hpp	/^    struct has_difference$/;"	s	namespace:boost::icl
boost::icl::has_difference::BOOST_STATIC_CONSTANT	icl/gregorian.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::has_difference	access:public	signature:(bool, value = true)
boost::icl::has_difference::BOOST_STATIC_CONSTANT	icl/ptime.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::has_difference	access:public	signature:(bool, value = true)
boost::icl::has_difference::BOOST_STATIC_CONSTANT	icl/type_traits/difference_type_of.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_difference	access:public	signature:(bool, value = (mpl::or_< is_subtraction_closed<Type> , is_pointer<Type> , has_difference_type<Type> >::value) )
boost::icl::has_difference::type	icl/gregorian.hpp	/^        typedef has_difference type;$/;"	t	struct:boost::icl::has_difference	access:public
boost::icl::has_difference::type	icl/ptime.hpp	/^        typedef has_difference type;$/;"	t	struct:boost::icl::has_difference	access:public
boost::icl::has_difference::type	icl/type_traits/difference_type_of.hpp	/^        typedef has_difference type;$/;"	t	struct:boost::icl::has_difference	access:public
boost::icl::has_difference_type	icl/type_traits/difference_type_of.hpp	/^    struct has_difference_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
boost::icl::has_domain_type	icl/type_traits/domain_type_of.hpp	/^    struct has_domain_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
boost::icl::has_dynamic_bounds	icl/type_traits/is_interval.hpp	/^template <class Type> struct has_dynamic_bounds$/;"	s	namespace:boost::icl
boost::icl::has_dynamic_bounds::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_dynamic_bounds	access:public	signature:(bool, value = (interval_bound_type<Type>::value == interval_bounds::dynamic))
boost::icl::has_dynamic_bounds::type	icl/type_traits/is_interval.hpp	/^    typedef has_dynamic_bounds<Type> type;$/;"	t	struct:boost::icl::has_dynamic_bounds	access:public
boost::icl::has_element_type	icl/type_traits/element_type_of.hpp	/^    struct has_element_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
boost::icl::has_interval_type	icl/type_traits/interval_type_of.hpp	/^    struct has_interval_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
boost::icl::has_inverse	icl/interval_base_map.hpp	/^struct has_inverse<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::has_inverse	icl/interval_map.hpp	/^struct has_inverse<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::has_inverse	icl/map.hpp	/^struct has_inverse<icl::map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::has_inverse	icl/rational.hpp	/^    struct has_inverse<boost::rational<Integral> >$/;"	s	namespace:boost::icl
boost::icl::has_inverse	icl/split_interval_map.hpp	/^struct has_inverse<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::has_inverse	icl/type_traits/has_inverse.hpp	/^    template <class Type> struct has_inverse$/;"	s	namespace:boost::icl
boost::icl::has_inverse::BOOST_STATIC_CONSTANT	icl/interval_base_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (has_inverse<CodomainT>::value)); $/;"	p	struct:boost::icl::has_inverse	access:public	signature:(bool, value = (has_inverse<CodomainT>::value))
boost::icl::has_inverse::BOOST_STATIC_CONSTANT	icl/interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (has_inverse<CodomainT>::value)); $/;"	p	struct:boost::icl::has_inverse	access:public	signature:(bool, value = (has_inverse<CodomainT>::value))
boost::icl::has_inverse::BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (has_inverse<CodomainT>::value)); $/;"	p	struct:boost::icl::has_inverse	access:public	signature:(bool, value = (has_inverse<CodomainT>::value))
boost::icl::has_inverse::BOOST_STATIC_CONSTANT	icl/rational.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = (boost::is_signed<Integral>::value));$/;"	p	struct:boost::icl::has_inverse	access:public	signature:(bool, value = (boost::is_signed<Integral>::value))
boost::icl::has_inverse::BOOST_STATIC_CONSTANT	icl/split_interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (has_inverse<CodomainT>::value)); $/;"	p	struct:boost::icl::has_inverse	access:public	signature:(bool, value = (has_inverse<CodomainT>::value))
boost::icl::has_inverse::BOOST_STATIC_CONSTANT	icl/type_traits/has_inverse.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_inverse	access:public	signature:(bool, value = (type_traits::ice_or<boost::is_signed<Type>::value, is_floating_point<Type>::value>::value))
boost::icl::has_inverse::type	icl/interval_base_map.hpp	/^    typedef has_inverse<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::has_inverse	access:public
boost::icl::has_inverse::type	icl/interval_map.hpp	/^    typedef has_inverse<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::has_inverse	access:public
boost::icl::has_inverse::type	icl/map.hpp	/^    typedef has_inverse<icl::map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc> > type;$/;"	t	struct:boost::icl::has_inverse	access:public
boost::icl::has_inverse::type	icl/rational.hpp	/^        typedef has_inverse type;$/;"	t	struct:boost::icl::has_inverse	access:public
boost::icl::has_inverse::type	icl/split_interval_map.hpp	/^    typedef has_inverse<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::has_inverse	access:public
boost::icl::has_inverse::type	icl/type_traits/has_inverse.hpp	/^        typedef has_inverse<Type> type;$/;"	t	struct:boost::icl::has_inverse	access:public
boost::icl::has_key_object_type	icl/type_traits/is_key_container_of.hpp	/^    struct has_key_object_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
boost::icl::has_key_type	icl/type_traits/element_type_of.hpp	/^    struct has_key_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
boost::icl::has_max_infinity	icl/type_traits/infinity.hpp	/^template<class Type> struct has_max_infinity$/;"	s	namespace:boost::icl
boost::icl::has_max_infinity::BOOST_STATIC_CONSTANT	icl/type_traits/infinity.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_max_infinity	access:public	signature:(bool, value = (type_traits::ice_and < is_numeric<Type>::value , type_traits::ice_not<std::numeric_limits<Type>::has_infinity>::value >::value) )
boost::icl::has_max_infinity::type	icl/type_traits/infinity.hpp	/^    typedef has_max_infinity type;$/;"	t	struct:boost::icl::has_max_infinity	access:public
boost::icl::has_rep_type	icl/type_traits/rep_type_of.hpp	/^    struct has_rep_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
boost::icl::has_same_concept	icl/type_traits/is_concept_equivalent.hpp	/^    struct has_same_concept$/;"	s	namespace:boost::icl
boost::icl::has_same_concept::BOOST_STATIC_CONSTANT	icl/type_traits/is_concept_equivalent.hpp	/^        BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::has_same_concept	access:public	signature:(bool, value = (mpl::and_<IsConcept<LeftT>, is_concept_equivalent<IsConcept, LeftT, RightT> >::value) )
boost::icl::has_same_concept::type	icl/type_traits/is_concept_equivalent.hpp	/^        typedef has_same_concept<IsConcept, LeftT, RightT> type;$/;"	t	struct:boost::icl::has_same_concept	access:public
boost::icl::has_segment_type	icl/type_traits/segment_type_of.hpp	/^    struct has_segment_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
boost::icl::has_set_semantics	icl/type_traits/has_set_semantics.hpp	/^    template <class Type> struct has_set_semantics$/;"	s	namespace:boost::icl
boost::icl::has_set_semantics::BOOST_STATIC_CONSTANT	icl/type_traits/has_set_semantics.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_set_semantics	access:public	signature:(bool, value = (mpl::or_< is_set<Type> , mpl::and_< is_map<Type> , has_set_semantics <typename codomain_type_of<Type>::type > > >::value))
boost::icl::has_set_semantics::type	icl/type_traits/has_set_semantics.hpp	/^        typedef has_set_semantics<Type> type;$/;"	t	struct:boost::icl::has_set_semantics	access:public
boost::icl::has_size_type	icl/type_traits/size_type_of.hpp	/^    struct has_size_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
boost::icl::has_static_bounds	icl/type_traits/is_interval.hpp	/^template <class Type> struct has_static_bounds$/;"	s	namespace:boost::icl
boost::icl::has_static_bounds::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_static_bounds	access:public	signature:(bool, value = ((interval_bound_type<Type>::value) < interval_bounds::dynamic))
boost::icl::has_static_bounds::type	icl/type_traits/is_interval.hpp	/^    typedef has_static_bounds<Type> type;$/;"	t	struct:boost::icl::has_static_bounds	access:public
boost::icl::has_std_infinity	icl/type_traits/infinity.hpp	/^template<class Type> struct has_std_infinity$/;"	s	namespace:boost::icl
boost::icl::has_std_infinity::BOOST_STATIC_CONSTANT	icl/type_traits/infinity.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_std_infinity	access:public	signature:(bool, value = (type_traits::ice_and < is_numeric<Type>::value , std::numeric_limits<Type>::has_infinity >::value) )
boost::icl::has_std_infinity::type	icl/type_traits/infinity.hpp	/^    typedef has_std_infinity type;$/;"	t	struct:boost::icl::has_std_infinity	access:public
boost::icl::has_symmetric_bounds	icl/type_traits/is_interval.hpp	/^template <class Type> struct has_symmetric_bounds$/;"	s	namespace:boost::icl
boost::icl::has_symmetric_bounds::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::has_symmetric_bounds	access:public	signature:(bool, value = ( bounds == interval_bounds::static_closed || bounds == interval_bounds::static_open))
boost::icl::has_symmetric_bounds::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, bounds = (interval_bound_type<Type>::value)); $/;"	p	struct:boost::icl::has_symmetric_bounds	access:public	signature:(bound_type, bounds = (interval_bound_type<Type>::value))
boost::icl::has_symmetric_bounds::type	icl/type_traits/is_interval.hpp	/^    typedef has_symmetric_bounds<Type> type;$/;"	t	struct:boost::icl::has_symmetric_bounds	access:public
boost::icl::has_value_type	icl/type_traits/element_type_of.hpp	/^    struct has_value_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
boost::icl::hull	icl/concept/interval.hpp	/^hull(Type left, const Type& right)$/;"	f	namespace:boost::icl	signature:(Type left, const Type& right)
boost::icl::hull	icl/concept/interval.hpp	/^hull(const typename interval_traits<Type>::domain_type& left,$/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& left, const typename interval_traits<Type>::domain_type& right)
boost::icl::hull	icl/concept/interval_associator.hpp	/^hull(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::identity_based_inplace_combine	icl/functors.hpp	/^    template <typename Type> struct identity_based_inplace_combine $/;"	s	namespace:boost::icl	inherits:std::binary_function
boost::icl::identity_based_inplace_combine::identity_element	icl/functors.hpp	/^        inline static Type identity_element() { return boost::icl::identity_element<Type>::value(); }$/;"	f	struct:boost::icl::identity_based_inplace_combine	access:public	signature:()
boost::icl::identity_element	icl/gregorian.hpp	/^    struct identity_element<boost::gregorian::date_duration>$/;"	s	namespace:boost::icl
boost::icl::identity_element	icl/type_traits/identity_element.hpp	/^    template <class Type> struct identity_element$/;"	s	namespace:boost::icl
boost::icl::identity_element::operator ()	icl/type_traits/identity_element.hpp	/^        Type operator()()const { return value(); }$/;"	f	struct:boost::icl::identity_element	access:public	signature:() const
boost::icl::identity_element::value	icl/gregorian.hpp	/^        static boost::gregorian::date_duration value()$/;"	f	struct:boost::icl::identity_element	access:public	signature:()
boost::icl::identity_element::value	icl/gregorian.hpp	/^    inline boost::gregorian::date identity_element<boost::gregorian::date>::value()$/;"	f	class:boost::icl::identity_element	signature:()
boost::icl::identity_element::value	icl/ptime.hpp	/^    inline boost::posix_time::ptime identity_element<boost::posix_time::ptime>::value()$/;"	f	class:boost::icl::identity_element	signature:()
boost::icl::identity_element::value	icl/type_traits/identity_element.hpp	/^        static Type value(); $/;"	p	struct:boost::icl::identity_element	access:public	signature:()
boost::icl::identity_element::value	icl/type_traits/identity_element.hpp	/^    inline Type identity_element<Type>::value()$/;"	f	class:boost::icl::identity_element	signature:()
boost::icl::inclusion	icl/detail/relation_state.hpp	/^    namespace inclusion$/;"	n	namespace:boost::icl
boost::icl::inclusion::equal	icl/detail/relation_state.hpp	/^        static const int equal     =  3;$/;"	m	namespace:boost::icl::inclusion
boost::icl::inclusion::subset	icl/detail/relation_state.hpp	/^        static const int subset    =  1;$/;"	m	namespace:boost::icl::inclusion
boost::icl::inclusion::superset	icl/detail/relation_state.hpp	/^        static const int superset  =  2;$/;"	m	namespace:boost::icl::inclusion
boost::icl::inclusion::unrelated	icl/detail/relation_state.hpp	/^        static const int unrelated =  0;$/;"	m	namespace:boost::icl::inclusion
boost::icl::inclusion_compare	icl/concept/element_associator.hpp	/^inclusion_compare(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
boost::icl::inclusion_compare	icl/concept/interval_associator.hpp	/^inclusion_compare(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
boost::icl::infinity	icl/type_traits/infinity.hpp	/^struct infinity<std::string>$/;"	s	namespace:boost::icl
boost::icl::infinity	icl/type_traits/infinity.hpp	/^template <class Type> struct infinity$/;"	s	namespace:boost::icl
boost::icl::infinity::type	icl/type_traits/infinity.hpp	/^    typedef infinity type;$/;"	t	struct:boost::icl::infinity	access:public
boost::icl::infinity::value	icl/type_traits/infinity.hpp	/^    static Type value()$/;"	f	struct:boost::icl::infinity	access:public	signature:()
boost::icl::infinity::value	icl/type_traits/infinity.hpp	/^    static std::string value()$/;"	f	struct:boost::icl::infinity	access:public	signature:()
boost::icl::inner_bounds	icl/concept/interval_bounds.hpp	/^inline interval_bounds inner_bounds(interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
boost::icl::inner_bounds	icl/concept/interval_bounds.hpp	/^inner_bounds(const IntervalT& x1, const IntervalT& x2)$/;"	f	namespace:boost::icl	signature:(const IntervalT& x1, const IntervalT& x2)
boost::icl::inner_complement	icl/concept/interval.hpp	/^inner_complement(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::inplace_bit_add	icl/functors.hpp	/^    template <typename Type> struct inplace_bit_add$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_bit_add::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_bit_add	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inplace_bit_add::type	icl/functors.hpp	/^        typedef inplace_bit_add<Type> type;$/;"	t	struct:boost::icl::inplace_bit_add	access:public
boost::icl::inplace_bit_add::version	icl/functors.hpp	/^        static void version(Type&){}$/;"	f	struct:boost::icl::inplace_bit_add	access:public	signature:(Type&)
boost::icl::inplace_bit_and	icl/functors.hpp	/^    template <typename Type> struct inplace_bit_and$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_bit_and::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_bit_and	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inplace_bit_and::type	icl/functors.hpp	/^        typedef inplace_bit_and<Type> type;$/;"	t	struct:boost::icl::inplace_bit_and	access:public
boost::icl::inplace_bit_subtract	icl/functors.hpp	/^    template <typename Type> struct inplace_bit_subtract$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_bit_subtract::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_bit_subtract	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inplace_bit_subtract::type	icl/functors.hpp	/^        typedef inplace_bit_subtract<Type> type;$/;"	t	struct:boost::icl::inplace_bit_subtract	access:public
boost::icl::inplace_bit_xor	icl/functors.hpp	/^    template <typename Type> struct inplace_bit_xor$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_bit_xor::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_bit_xor	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inplace_bit_xor::type	icl/functors.hpp	/^        typedef inplace_bit_xor<Type> type;$/;"	t	struct:boost::icl::inplace_bit_xor	access:public
boost::icl::inplace_caret	icl/functors.hpp	/^    template <typename Type> struct inplace_caret$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_caret::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_caret	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inplace_caret::type	icl/functors.hpp	/^        typedef inplace_caret<Type> type;$/;"	t	struct:boost::icl::inplace_caret	access:public
boost::icl::inplace_erase	icl/functors.hpp	/^    template <typename Type> struct inplace_erase$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_erase::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_erase	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inplace_erase::type	icl/functors.hpp	/^        typedef inplace_erase<Type> type;$/;"	t	struct:boost::icl::inplace_erase	access:public
boost::icl::inplace_erasure	icl/functors.hpp	/^    template <typename Type> struct inplace_erasure $/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_erasure::base_type	icl/functors.hpp	/^        typedef identity_based_inplace_combine<Type> base_type;$/;"	t	struct:boost::icl::inplace_erasure	access:public
boost::icl::inplace_erasure::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_erasure	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inplace_erasure::type	icl/functors.hpp	/^        typedef inplace_erasure<Type> type;$/;"	t	struct:boost::icl::inplace_erasure	access:public
boost::icl::inplace_et	icl/functors.hpp	/^    template <typename Type> struct inplace_et$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_et::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_et	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inplace_et::type	icl/functors.hpp	/^        typedef inplace_et<Type> type;$/;"	t	struct:boost::icl::inplace_et	access:public
boost::icl::inplace_identity	icl/functors.hpp	/^    template <typename Type> struct inplace_identity $/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_identity::operator ()	icl/functors.hpp	/^        void operator()(Type&, const Type&)const{}$/;"	f	struct:boost::icl::inplace_identity	access:public	signature:(Type&, const Type&) const
boost::icl::inplace_identity::type	icl/functors.hpp	/^        typedef inplace_identity<Type> type;$/;"	t	struct:boost::icl::inplace_identity	access:public
boost::icl::inplace_insert	icl/functors.hpp	/^    template <typename Type> struct inplace_insert$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_insert::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_insert	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inplace_insert::type	icl/functors.hpp	/^        typedef inplace_insert<Type> type;$/;"	t	struct:boost::icl::inplace_insert	access:public
boost::icl::inplace_max	icl/functors.hpp	/^    template <typename Type> struct inplace_max$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_max::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_max	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inplace_max::type	icl/functors.hpp	/^        typedef inplace_max<Type> type;$/;"	t	struct:boost::icl::inplace_max	access:public
boost::icl::inplace_min	icl/functors.hpp	/^    template <typename Type> struct inplace_min$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_min::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_min	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inplace_min::type	icl/functors.hpp	/^        typedef inplace_min<Type> type;$/;"	t	struct:boost::icl::inplace_min	access:public
boost::icl::inplace_minus	icl/functors.hpp	/^    template <typename Type> struct inplace_minus $/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_minus::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_minus	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inplace_minus::type	icl/functors.hpp	/^        typedef inplace_minus<Type> type;$/;"	t	struct:boost::icl::inplace_minus	access:public
boost::icl::inplace_plus	icl/functors.hpp	/^    template <typename Type> struct inplace_plus $/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_plus::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_plus	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inplace_plus::type	icl/functors.hpp	/^        typedef inplace_plus<Type> type;$/;"	t	struct:boost::icl::inplace_plus	access:public
boost::icl::inplace_plus::version	icl/functors.hpp	/^        static void version(Type&){}$/;"	f	struct:boost::icl::inplace_plus	access:public	signature:(Type&)
boost::icl::inplace_slash	icl/functors.hpp	/^    template <typename Type> struct inplace_slash$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_slash::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_slash	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inplace_slash::type	icl/functors.hpp	/^        typedef inplace_slash<Type> type;$/;"	t	struct:boost::icl::inplace_slash	access:public
boost::icl::inplace_star	icl/functors.hpp	/^    template <typename Type> struct inplace_star$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inplace_star::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_star	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inplace_star::type	icl/functors.hpp	/^        typedef inplace_star<Type> type;$/;"	t	struct:boost::icl::inplace_star	access:public
boost::icl::insert	icl/concept/element_associator.hpp	/^insert(Type& object, const Type& addend)$/;"	f	namespace:boost::icl	signature:(Type& object, const Type& addend)
boost::icl::insert	icl/concept/element_associator.hpp	/^insert(Type& object, const typename Type::value_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& operand)
boost::icl::insert	icl/concept/element_associator.hpp	/^insert(Type& object, typename Type::iterator      prior, $/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator prior, const typename Type::value_type& operand)
boost::icl::insert	icl/concept/interval_associator.hpp	/^insert(Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
boost::icl::insert	icl/concept/interval_map.hpp	/^insert(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::insert	icl/concept/interval_map.hpp	/^insert(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
boost::icl::insert	icl/concept/interval_map.hpp	/^insert(Type& object, typename Type::iterator      prior,$/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator prior, const typename Type::segment_type& operand)
boost::icl::insert	icl/concept/interval_set.hpp	/^insert(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::insert	icl/concept/interval_set.hpp	/^insert(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
boost::icl::insert	icl/concept/interval_set.hpp	/^insert(Type& object, typename Type::iterator      prior,$/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator prior, const typename Type::segment_type& operand)
boost::icl::insert_iterator	icl/iterator.hpp	/^template<class ContainerT> class insert_iterator$/;"	c	namespace:boost::icl	inherits:std::iterator
boost::icl::insert_iterator::_cont	icl/iterator.hpp	/^    ContainerT*                   _cont;$/;"	m	class:boost::icl::insert_iterator	access:private
boost::icl::insert_iterator::_iter	icl/iterator.hpp	/^    typename ContainerT::iterator _iter;$/;"	m	class:boost::icl::insert_iterator	access:private
boost::icl::insert_iterator::container_type	icl/iterator.hpp	/^    typedef ContainerT container_type;$/;"	t	class:boost::icl::insert_iterator	access:public
boost::icl::insert_iterator::insert_iterator	icl/iterator.hpp	/^    insert_iterator(ContainerT& cont, typename ContainerT::iterator iter)$/;"	f	class:boost::icl::insert_iterator	access:public	signature:(ContainerT& cont, typename ContainerT::iterator iter)
boost::icl::insert_iterator::iterator_category	icl/iterator.hpp	/^    typedef std::output_iterator_tag iterator_category; $/;"	t	class:boost::icl::insert_iterator	access:public
boost::icl::insert_iterator::operator *	icl/iterator.hpp	/^    insert_iterator& operator*()    { return *this; }$/;"	f	class:boost::icl::insert_iterator	access:public	signature:()
boost::icl::insert_iterator::operator ++	icl/iterator.hpp	/^    insert_iterator& operator++()   { return *this; }$/;"	f	class:boost::icl::insert_iterator	access:public	signature:()
boost::icl::insert_iterator::operator ++	icl/iterator.hpp	/^    insert_iterator& operator++(int){ return *this; }$/;"	f	class:boost::icl::insert_iterator	access:public	signature:(int)
boost::icl::insert_iterator::operator =	icl/iterator.hpp	/^    insert_iterator& operator=(typename ContainerT::const_reference value)$/;"	f	class:boost::icl::insert_iterator	access:public	signature:(typename ContainerT::const_reference value)
boost::icl::inserter	icl/iterator.hpp	/^inline insert_iterator<ContainerT> inserter(ContainerT& cont, IteratorT iter_)$/;"	f	namespace:boost::icl	signature:(ContainerT& cont, IteratorT iter_)
boost::icl::inter_section	icl/functors.hpp	/^    template<class Type> struct inter_section$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inter_section::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inter_section	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inter_section::type	icl/functors.hpp	/^            type;$/;"	t	struct:boost::icl::inter_section	access:public
boost::icl::intersects	icl/concept/element_map.hpp	/^intersects(const Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const Type& operand)
boost::icl::intersects	icl/concept/element_map.hpp	/^intersects(const Type& object, const typename Type::domain_type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const typename Type::domain_type& operand)
boost::icl::intersects	icl/concept/element_map.hpp	/^intersects(const Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const typename Type::element_type& operand)
boost::icl::intersects	icl/concept/element_map.hpp	/^intersects(const Type& object, const typename Type::set_type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const typename Type::set_type& operand)
boost::icl::intersects	icl/concept/element_map.hpp	/^intersects(const Type&, const CoType&)$/;"	f	namespace:boost::icl	signature:(const Type&, const CoType&)
boost::icl::intersects	icl/concept/element_set.hpp	/^intersects(const Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const Type& operand)
boost::icl::intersects	icl/concept/element_set.hpp	/^intersects(const Type& object, const typename Type::key_type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const typename Type::key_type& operand)
boost::icl::intersects	icl/concept/interval.hpp	/^intersects(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::intersects	icl/concept/interval_associator.hpp	/^intersects(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
boost::icl::intersects	icl/concept/interval_associator.hpp	/^intersects(const LeftT&, const RightT&)$/;"	f	namespace:boost::icl	signature:(const LeftT&, const RightT&)
boost::icl::intersects	icl/concept/interval_associator.hpp	/^intersects(const Type& left, const CoType& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const CoType& right)
boost::icl::intersects	icl/concept/interval_map.hpp	/^intersects(const Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const OperandT& operand)
boost::icl::intersects	icl/concept/interval_map.hpp	/^intersects(const Type&, const OperandT&)$/;"	f	namespace:boost::icl	signature:(const Type&, const OperandT&)
boost::icl::interval	icl/interval.hpp	/^    struct interval$/;"	s	namespace:boost::icl
boost::icl::interval::closed	icl/interval.hpp	/^        static inline interval_type closed(const DomainT& low, const DomainT& up)$/;"	f	struct:boost::icl::interval	access:public	signature:(const DomainT& low, const DomainT& up)
boost::icl::interval::construct	icl/interval.hpp	/^        static inline interval_type construct(const DomainT& low, const DomainT& up)$/;"	f	struct:boost::icl::interval	access:public	signature:(const DomainT& low, const DomainT& up)
boost::icl::interval::interval_type	icl/interval.hpp	/^        typedef typename interval_type_default<DomainT,Compare>::type interval_type;$/;"	t	struct:boost::icl::interval	access:public
boost::icl::interval::left_open	icl/interval.hpp	/^        static inline interval_type left_open(const DomainT& low, const DomainT& up)$/;"	f	struct:boost::icl::interval	access:public	signature:(const DomainT& low, const DomainT& up)
boost::icl::interval::open	icl/interval.hpp	/^        static inline interval_type open(const DomainT& low, const DomainT& up)$/;"	f	struct:boost::icl::interval	access:public	signature:(const DomainT& low, const DomainT& up)
boost::icl::interval::right_open	icl/interval.hpp	/^        static inline interval_type right_open(const DomainT& low, const DomainT& up)$/;"	f	struct:boost::icl::interval	access:public	signature:(const DomainT& low, const DomainT& up)
boost::icl::interval::type	icl/interval.hpp	/^        typedef interval_type type;$/;"	t	struct:boost::icl::interval	access:public
boost::icl::interval_base_map	icl/interval_base_map.hpp	/^class interval_base_map$/;"	c	namespace:boost::icl
boost::icl::interval_base_map::BOOST_STATIC_CONSTANT	icl/interval_base_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	class:boost::icl::interval_base_map	access:public	signature:(bool, is_total_invertible = ( Traits::is_total && has_inverse<codomain_type>::value))
boost::icl::interval_base_map::BOOST_STATIC_CONSTANT	icl/interval_base_map.hpp	/^    BOOST_STATIC_CONSTANT(int, fineness = 0); $/;"	p	class:boost::icl::interval_base_map	access:public	signature:(int, fineness = 0)
boost::icl::interval_base_map::ImplMapT	icl/interval_base_map.hpp	/^                                key_compare,allocator_type> ImplMapT;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::_add	icl/interval_base_map.hpp	/^    ::_add(const segment_type& addend)$/;"	f	class:boost::icl::interval_base_map	signature:(const segment_type& addend)
boost::icl::interval_base_map::_add	icl/interval_base_map.hpp	/^    ::_add(iterator prior_, const segment_type& addend)$/;"	f	class:boost::icl::interval_base_map	signature:(iterator prior_, const segment_type& addend)
boost::icl::interval_base_map::_add	icl/interval_base_map.hpp	/^    iterator _add(const segment_type& interval_value_pair);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const segment_type& interval_value_pair)
boost::icl::interval_base_map::_add	icl/interval_base_map.hpp	/^    iterator _add(iterator prior_, const segment_type& interval_value_pair);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(iterator prior_, const segment_type& interval_value_pair)
boost::icl::interval_base_map::_insert	icl/interval_base_map.hpp	/^    ::_insert(const segment_type& addend)$/;"	f	class:boost::icl::interval_base_map	signature:(const segment_type& addend)
boost::icl::interval_base_map::_insert	icl/interval_base_map.hpp	/^    ::_insert(iterator prior_, const segment_type& addend)$/;"	f	class:boost::icl::interval_base_map	signature:(iterator prior_, const segment_type& addend)
boost::icl::interval_base_map::_insert	icl/interval_base_map.hpp	/^    iterator _insert(const segment_type& interval_value_pair);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const segment_type& interval_value_pair)
boost::icl::interval_base_map::_insert	icl/interval_base_map.hpp	/^    iterator _insert(iterator prior_, const segment_type& interval_value_pair);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(iterator prior_, const segment_type& interval_value_pair)
boost::icl::interval_base_map::_map	icl/interval_base_map.hpp	/^    ImplMapT _map;$/;"	m	class:boost::icl::interval_base_map	access:protected
boost::icl::interval_base_map::_subtract	icl/interval_base_map.hpp	/^    ::_subtract(const segment_type& minuend)$/;"	f	class:boost::icl::interval_base_map	signature:(const segment_type& minuend)
boost::icl::interval_base_map::_subtract	icl/interval_base_map.hpp	/^    void _subtract(const segment_type& interval_value_pair);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const segment_type& interval_value_pair)
boost::icl::interval_base_map::add	icl/interval_base_map.hpp	/^    SubType& add(const element_type& key_value_pair) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const element_type& key_value_pair)
boost::icl::interval_base_map::add	icl/interval_base_map.hpp	/^    SubType& add(const segment_type& interval_value_pair) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const segment_type& interval_value_pair)
boost::icl::interval_base_map::add	icl/interval_base_map.hpp	/^    iterator add(iterator prior_, const segment_type& interval_value_pair) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(iterator prior_, const segment_type& interval_value_pair)
boost::icl::interval_base_map::add_at	icl/interval_base_map.hpp	/^    add_at(const iterator& prior_, const interval_type& inter_val, $/;"	f	class:boost::icl::interval_base_map	access:protected	signature:(const iterator& prior_, const interval_type& inter_val, const codomain_type& co_val )
boost::icl::interval_base_map::add_front	icl/interval_base_map.hpp	/^    ::add_front(const interval_type& inter_val, iterator& first_)$/;"	f	class:boost::icl::interval_base_map	signature:(const interval_type& inter_val, iterator& first_)
boost::icl::interval_base_map::add_front	icl/interval_base_map.hpp	/^    void add_front(const interval_type& inter_val, iterator& first_);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const interval_type& inter_val, iterator& first_)
boost::icl::interval_base_map::add_intersection	icl/interval_base_map.hpp	/^    void add_intersection(SubType& section, const segment_type& interval_value_pair)const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(SubType& section, const segment_type& interval_value_pair) const
boost::icl::interval_base_map::add_main	icl/interval_base_map.hpp	/^    ::add_main(interval_type& inter_val, const CodomainT& co_val, $/;"	f	class:boost::icl::interval_base_map	signature:(interval_type& inter_val, const CodomainT& co_val, iterator& it_, const iterator& last_)
boost::icl::interval_base_map::add_main	icl/interval_base_map.hpp	/^    void add_main(interval_type& inter_val, const CodomainT& co_val, $/;"	p	class:boost::icl::interval_base_map	access:private	signature:(interval_type& inter_val, const CodomainT& co_val, iterator& it_, const iterator& last_)
boost::icl::interval_base_map::add_rear	icl/interval_base_map.hpp	/^    ::add_rear(const interval_type& inter_val, const CodomainT& co_val, iterator& it_)$/;"	f	class:boost::icl::interval_base_map	signature:(const interval_type& inter_val, const CodomainT& co_val, iterator& it_)
boost::icl::interval_base_map::add_rear	icl/interval_base_map.hpp	/^    void add_rear(const interval_type& inter_val, const CodomainT& co_val, iterator& it_);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const interval_type& inter_val, const CodomainT& co_val, iterator& it_)
boost::icl::interval_base_map::add_segment	icl/interval_base_map.hpp	/^    ::add_segment(const interval_type& inter_val, const CodomainT& co_val, iterator& it_)$/;"	f	class:boost::icl::interval_base_map	signature:(const interval_type& inter_val, const CodomainT& co_val, iterator& it_)
boost::icl::interval_base_map::add_segment	icl/interval_base_map.hpp	/^    void add_segment(const interval_type& inter_val, const CodomainT& co_val, iterator& it_);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const interval_type& inter_val, const CodomainT& co_val, iterator& it_)
boost::icl::interval_base_map::allocator_type	icl/interval_base_map.hpp	/^        allocator_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::atomized_type	icl/interval_base_map.hpp	/^                              Traits,Compare,Combine,Section,Alloc> atomized_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::begin	icl/interval_base_map.hpp	/^    const_iterator begin()const { return _map.begin(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:() const
boost::icl::interval_base_map::begin	icl/interval_base_map.hpp	/^    iterator begin() { return _map.begin(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:()
boost::icl::interval_base_map::clear	icl/interval_base_map.hpp	/^    void clear() { icl::clear(*that()); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:()
boost::icl::interval_base_map::codomain_combine	icl/interval_base_map.hpp	/^    typedef ICL_COMBINE_CODOMAIN(Combine,CodomainT)  codomain_combine;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::codomain_intersect	icl/interval_base_map.hpp	/^    >::type                                            codomain_intersect;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::codomain_type	icl/interval_base_map.hpp	/^    typedef CodomainT codomain_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::const_iterator	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::const_iterator const_iterator;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::const_pointer	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::const_pointer   const_pointer;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::const_reference	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::const_reference const_reference;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::const_reverse_iterator	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::const_reverse_iterator const_reverse_iterator;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::data_type	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::value_type::second_type data_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::difference_type	icl/interval_base_map.hpp	/^    typedef typename difference_type_of<domain_type>::type difference_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::domain_compare	icl/interval_base_map.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT)      domain_compare;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::domain_mapping_type	icl/interval_base_map.hpp	/^    typedef mapping_pair<domain_type,codomain_type> domain_mapping_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::domain_param	icl/interval_base_map.hpp	/^    typedef typename boost::call_traits<DomainT>::param_type domain_param;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::domain_type	icl/interval_base_map.hpp	/^    typedef DomainT   domain_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::element_const_iterator	icl/interval_base_map.hpp	/^    typedef boost::icl::element_iterator<const_iterator> element_const_iterator; $/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::element_const_reverse_iterator	icl/interval_base_map.hpp	/^    typedef boost::icl::element_iterator<const_reverse_iterator> element_const_reverse_iterator; $/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::element_iterator	icl/interval_base_map.hpp	/^    typedef boost::icl::element_iterator<iterator> element_iterator; $/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::element_reverse_iterator	icl/interval_base_map.hpp	/^    typedef boost::icl::element_iterator<reverse_iterator> element_reverse_iterator; $/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::element_type	icl/interval_base_map.hpp	/^    typedef domain_mapping_type element_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::empty	icl/interval_base_map.hpp	/^    bool empty()const { return icl::is_empty(*that()); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:() const
boost::icl::interval_base_map::end	icl/interval_base_map.hpp	/^    const_iterator end()const   { return _map.end(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:() const
boost::icl::interval_base_map::end	icl/interval_base_map.hpp	/^    iterator end()   { return _map.end(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:()
boost::icl::interval_base_map::equal_range	icl/interval_base_map.hpp	/^        equal_range(const key_type& interval)const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const key_type& interval) const
boost::icl::interval_base_map::equal_range	icl/interval_base_map.hpp	/^    std::pair<iterator,iterator> equal_range(const key_type& interval)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const key_type& interval)
boost::icl::interval_base_map::erase	icl/interval_base_map.hpp	/^    ::erase(const interval_type& minuend)$/;"	f	class:boost::icl::interval_base_map	signature:(const interval_type& minuend)
boost::icl::interval_base_map::erase	icl/interval_base_map.hpp	/^    ::erase(const segment_type& minuend)$/;"	f	class:boost::icl::interval_base_map	signature:(const segment_type& minuend)
boost::icl::interval_base_map::erase	icl/interval_base_map.hpp	/^    SubType& erase(const domain_type& key) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const domain_type& key)
boost::icl::interval_base_map::erase	icl/interval_base_map.hpp	/^    SubType& erase(const element_type& key_value_pair) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const element_type& key_value_pair)
boost::icl::interval_base_map::erase	icl/interval_base_map.hpp	/^    SubType& erase(const interval_type& inter_val);$/;"	p	class:boost::icl::interval_base_map	access:public	signature:(const interval_type& inter_val)
boost::icl::interval_base_map::erase	icl/interval_base_map.hpp	/^    SubType& erase(const segment_type& interval_value_pair);$/;"	p	class:boost::icl::interval_base_map	access:public	signature:(const segment_type& interval_value_pair)
boost::icl::interval_base_map::erase	icl/interval_base_map.hpp	/^    void erase(iterator first, iterator past){ this->_map.erase(first, past); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(iterator first, iterator past)
boost::icl::interval_base_map::erase	icl/interval_base_map.hpp	/^    void erase(iterator position){ this->_map.erase(position); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(iterator position)
boost::icl::interval_base_map::erase_rest	icl/interval_base_map.hpp	/^    ::erase_rest(interval_type& inter_val, const CodomainT& co_val, $/;"	f	class:boost::icl::interval_base_map	signature:(interval_type& inter_val, const CodomainT& co_val, iterator& it_, const iterator& last_)
boost::icl::interval_base_map::erase_rest	icl/interval_base_map.hpp	/^    void erase_rest (      interval_type&, const CodomainT&, iterator&, const iterator&);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:( interval_type&, const CodomainT&, iterator&, const iterator&)
boost::icl::interval_base_map::find	icl/interval_base_map.hpp	/^    const_iterator find(const domain_type& key_value)const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const domain_type& key_value) const
boost::icl::interval_base_map::find	icl/interval_base_map.hpp	/^    const_iterator find(const interval_type& key_interval)const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const interval_type& key_interval) const
boost::icl::interval_base_map::flip	icl/interval_base_map.hpp	/^    SubType& flip(const element_type& key_value_pair)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const element_type& key_value_pair)
boost::icl::interval_base_map::flip	icl/interval_base_map.hpp	/^    SubType& flip(const segment_type& interval_value_pair)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const segment_type& interval_value_pair)
boost::icl::interval_base_map::gap_insert	icl/interval_base_map.hpp	/^    iterator gap_insert(iterator prior_, const interval_type& inter_val, $/;"	f	class:boost::icl::interval_base_map	access:protected	signature:(iterator prior_, const interval_type& inter_val, const codomain_type& co_val )
boost::icl::interval_base_map::insert	icl/interval_base_map.hpp	/^    SubType& insert(const element_type& key_value_pair) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const element_type& key_value_pair)
boost::icl::interval_base_map::insert	icl/interval_base_map.hpp	/^    SubType& insert(const segment_type& interval_value_pair)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const segment_type& interval_value_pair)
boost::icl::interval_base_map::insert	icl/interval_base_map.hpp	/^    iterator insert(iterator prior, const segment_type& interval_value_pair)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(iterator prior, const segment_type& interval_value_pair)
boost::icl::interval_base_map::insert_at	icl/interval_base_map.hpp	/^    insert_at(const iterator& prior_, const interval_type& inter_val, $/;"	f	class:boost::icl::interval_base_map	access:protected	signature:(const iterator& prior_, const interval_type& inter_val, const codomain_type& co_val )
boost::icl::interval_base_map::insert_main	icl/interval_base_map.hpp	/^    ::insert_main(const interval_type& inter_val, const CodomainT& co_val, $/;"	f	class:boost::icl::interval_base_map	signature:(const interval_type& inter_val, const CodomainT& co_val, iterator& it_, const iterator& last_)
boost::icl::interval_base_map::insert_main	icl/interval_base_map.hpp	/^    void insert_main(const interval_type&, const CodomainT&, iterator&, const iterator&);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const interval_type&, const CodomainT&, iterator&, const iterator&)
boost::icl::interval_base_map::interval_base_map	icl/interval_base_map.hpp	/^    interval_base_map()$/;"	f	class:boost::icl::interval_base_map	access:public	signature:()
boost::icl::interval_base_map::interval_base_map	icl/interval_base_map.hpp	/^    interval_base_map(const interval_base_map& src): _map(src._map)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const interval_base_map& src)
boost::icl::interval_base_map::interval_base_map	icl/interval_base_map.hpp	/^    interval_base_map(interval_base_map&& src): _map(boost::move(src._map))$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(interval_base_map&& src)
boost::icl::interval_base_map::interval_compare	icl/interval_base_map.hpp	/^    typedef exclusive_less_than<interval_type> interval_compare;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::interval_mapping_type	icl/interval_base_map.hpp	/^    typedef std::pair<interval_type,CodomainT> interval_mapping_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::interval_type	icl/interval_base_map.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) interval_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::inverse_codomain_combine	icl/interval_base_map.hpp	/^    typedef typename inverse<codomain_combine>::type inverse_codomain_combine;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::inverse_codomain_intersect	icl/interval_base_map.hpp	/^    typedef typename inverse<codomain_intersect>::type inverse_codomain_intersect;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::iterative_size	icl/interval_base_map.hpp	/^    std::size_t iterative_size()const $/;"	f	class:boost::icl::interval_base_map	access:public	signature:() const
boost::icl::interval_base_map::iterator	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::iterator iterator;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::key_compare	icl/interval_base_map.hpp	/^    typedef exclusive_less_than<interval_type> key_compare;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::key_type	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::key_type   key_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::lower_bound	icl/interval_base_map.hpp	/^    const_iterator lower_bound(const key_type& interval)const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const key_type& interval) const
boost::icl::interval_base_map::lower_bound	icl/interval_base_map.hpp	/^    iterator lower_bound(const key_type& interval)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const key_type& interval)
boost::icl::interval_base_map::on_codomain_absorbtion	icl/interval_base_map.hpp	/^                                Traits::absorbs_identities>::type on_codomain_absorbtion;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::on_codomain_model	icl/interval_base_map.hpp	/^    struct on_codomain_model<Type, false>$/;"	s	class:boost::icl::interval_base_map	access:private
boost::icl::interval_base_map::on_codomain_model	icl/interval_base_map.hpp	/^    struct on_codomain_model<Type, true>$/;"	s	class:boost::icl::interval_base_map	access:private
boost::icl::interval_base_map::on_codomain_model::add	icl/interval_base_map.hpp	/^        static void add(Type& intersection, interval_type& common_interval, $/;"	f	struct:boost::icl::interval_base_map::on_codomain_model	access:public	signature:(Type& intersection, interval_type& common_interval, const codomain_type& flip_value, const codomain_type& co_value)
boost::icl::interval_base_map::on_codomain_model::add	icl/interval_base_map.hpp	/^        static void add(Type& intersection, interval_type& common_interval, $/;"	f	struct:boost::icl::interval_base_map::on_codomain_model	access:public	signature:(Type& intersection, interval_type& common_interval, const codomain_type&, const codomain_type&)
boost::icl::interval_base_map::on_codomain_model::codomain_combine	icl/interval_base_map.hpp	/^        typedef typename Type::codomain_combine codomain_combine;$/;"	t	struct:boost::icl::interval_base_map::on_codomain_model	access:public
boost::icl::interval_base_map::on_codomain_model::codomain_type	icl/interval_base_map.hpp	/^        typedef typename Type::codomain_type codomain_type;$/;"	t	struct:boost::icl::interval_base_map::on_codomain_model	access:public
boost::icl::interval_base_map::on_codomain_model::interval_type	icl/interval_base_map.hpp	/^        typedef typename Type::interval_type interval_type;$/;"	t	struct:boost::icl::interval_base_map::on_codomain_model	access:public
boost::icl::interval_base_map::on_codomain_model::inverse_codomain_intersect	icl/interval_base_map.hpp	/^        typedef typename Type::inverse_codomain_intersect inverse_codomain_intersect;$/;"	t	struct:boost::icl::interval_base_map::on_codomain_model	access:public
boost::icl::interval_base_map::on_codomain_model::segment_type	icl/interval_base_map.hpp	/^        typedef typename Type::segment_type  segment_type;$/;"	t	struct:boost::icl::interval_base_map::on_codomain_model	access:public
boost::icl::interval_base_map::on_definedness	icl/interval_base_map.hpp	/^    struct on_definedness<Type, false>$/;"	s	class:boost::icl::interval_base_map	access:private
boost::icl::interval_base_map::on_definedness	icl/interval_base_map.hpp	/^    struct on_definedness<Type, true>$/;"	s	class:boost::icl::interval_base_map	access:private
boost::icl::interval_base_map::on_definedness::add_intersection	icl/interval_base_map.hpp	/^        static void add_intersection(Type& section, const Type& object, $/;"	f	struct:boost::icl::interval_base_map::on_definedness	access:public	signature:(Type& section, const Type& object, const segment_type& operand)
boost::icl::interval_base_map::on_invertible	icl/interval_base_map.hpp	/^    struct on_invertible<Type, false>$/;"	s	class:boost::icl::interval_base_map	access:private
boost::icl::interval_base_map::on_invertible	icl/interval_base_map.hpp	/^    struct on_invertible<Type, true>$/;"	s	class:boost::icl::interval_base_map	access:private
boost::icl::interval_base_map::on_invertible::inverse_codomain_combine	icl/interval_base_map.hpp	/^        typedef typename Type::inverse_codomain_combine inverse_codomain_combine;$/;"	t	struct:boost::icl::interval_base_map::on_invertible	access:public
boost::icl::interval_base_map::on_invertible::segment_type	icl/interval_base_map.hpp	/^        typedef typename Type::segment_type segment_type;$/;"	t	struct:boost::icl::interval_base_map::on_invertible	access:public
boost::icl::interval_base_map::on_invertible::subtract	icl/interval_base_map.hpp	/^        static void subtract(Type& object, const segment_type& operand)$/;"	f	struct:boost::icl::interval_base_map::on_invertible	access:public	signature:(Type& object, const segment_type& operand)
boost::icl::interval_base_map::on_total_absorbable	icl/interval_base_map.hpp	/^    struct on_total_absorbable<Type, false, absorbs_identities>$/;"	s	class:boost::icl::interval_base_map	access:private
boost::icl::interval_base_map::on_total_absorbable	icl/interval_base_map.hpp	/^    struct on_total_absorbable<Type, true, false>$/;"	s	class:boost::icl::interval_base_map	access:private
boost::icl::interval_base_map::on_total_absorbable	icl/interval_base_map.hpp	/^    struct on_total_absorbable<Type, true, true>$/;"	s	class:boost::icl::interval_base_map	access:private
boost::icl::interval_base_map::on_total_absorbable::codomain_type	icl/interval_base_map.hpp	/^        typedef typename Type::codomain_type  codomain_type;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
boost::icl::interval_base_map::on_total_absorbable::codomain_type	icl/interval_base_map.hpp	/^        typedef typename Type::codomain_type codomain_type;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
boost::icl::interval_base_map::on_total_absorbable::const_iterator	icl/interval_base_map.hpp	/^        typedef typename Type::const_iterator const_iterator;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
boost::icl::interval_base_map::on_total_absorbable::flip	icl/interval_base_map.hpp	/^        static void flip(Type& object, const segment_type& interval_value_pair)$/;"	f	struct:boost::icl::interval_base_map::on_total_absorbable	access:public	signature:(Type& object, const segment_type& interval_value_pair)
boost::icl::interval_base_map::on_total_absorbable::flip	icl/interval_base_map.hpp	/^        static void flip(Type& object, const segment_type& operand)$/;"	f	struct:boost::icl::interval_base_map::on_total_absorbable	access:public	signature:(Type& object, const segment_type& operand)
boost::icl::interval_base_map::on_total_absorbable::flip	icl/interval_base_map.hpp	/^        static void flip(Type& object, const typename Type::segment_type&)$/;"	f	struct:boost::icl::interval_base_map::on_total_absorbable	access:public	signature:(Type& object, const typename Type::segment_type&)
boost::icl::interval_base_map::on_total_absorbable::interval_type	icl/interval_base_map.hpp	/^        typedef typename Type::interval_type  interval_type;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
boost::icl::interval_base_map::on_total_absorbable::inverse_codomain_intersect	icl/interval_base_map.hpp	/^        typedef typename Type::inverse_codomain_intersect inverse_codomain_intersect;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
boost::icl::interval_base_map::on_total_absorbable::segment_type	icl/interval_base_map.hpp	/^        typedef typename Type::segment_type   segment_type;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
boost::icl::interval_base_map::on_total_absorbable::segment_type	icl/interval_base_map.hpp	/^        typedef typename Type::segment_type  segment_type;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
boost::icl::interval_base_map::on_total_absorbable::set_type	icl/interval_base_map.hpp	/^        typedef typename Type::set_type       set_type;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
boost::icl::interval_base_map::on_total_absorbable::value_type	icl/interval_base_map.hpp	/^        typedef typename Type::value_type     value_type;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
boost::icl::interval_base_map::operator ()	icl/interval_base_map.hpp	/^    codomain_type operator()(const domain_type& key_value)const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const domain_type& key_value) const
boost::icl::interval_base_map::operator =	icl/interval_base_map.hpp	/^    interval_base_map& operator = (const interval_base_map& src) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const interval_base_map& src)
boost::icl::interval_base_map::operator =	icl/interval_base_map.hpp	/^    interval_base_map& operator = (interval_base_map&& src) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(interval_base_map&& src)
boost::icl::interval_base_map::overloadable_type	icl/interval_base_map.hpp	/^    typedef type overloadable_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::partial_add_intersection	icl/interval_base_map.hpp	/^    void partial_add_intersection(SubType& section, const element_type& operand)const$/;"	f	class:boost::icl::interval_base_map	access:private	signature:(SubType& section, const element_type& operand) const
boost::icl::interval_base_map::partial_add_intersection	icl/interval_base_map.hpp	/^    void partial_add_intersection(SubType& section, const segment_type& operand)const$/;"	f	class:boost::icl::interval_base_map	access:private	signature:(SubType& section, const segment_type& operand) const
boost::icl::interval_base_map::pointer	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::pointer         pointer;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::rbegin	icl/interval_base_map.hpp	/^    const_reverse_iterator rbegin()const { return _map.rbegin(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:() const
boost::icl::interval_base_map::rbegin	icl/interval_base_map.hpp	/^    reverse_iterator rbegin() { return _map.rbegin(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:()
boost::icl::interval_base_map::reference	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::reference       reference;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::rend	icl/interval_base_map.hpp	/^    const_reverse_iterator rend()const   { return _map.rend(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:() const
boost::icl::interval_base_map::rend	icl/interval_base_map.hpp	/^    reverse_iterator rend()   { return _map.rend(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:()
boost::icl::interval_base_map::reverse_iterator	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::reverse_iterator reverse_iterator;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::segment_compare	icl/interval_base_map.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,segment_type) segment_compare;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::segment_type	icl/interval_base_map.hpp	/^    typedef std::pair<interval_type,CodomainT> segment_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::set	icl/interval_base_map.hpp	/^    SubType& set(const element_type& key_value_pair) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const element_type& key_value_pair)
boost::icl::interval_base_map::set	icl/interval_base_map.hpp	/^    SubType& set(const segment_type& interval_value_pair)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const segment_type& interval_value_pair)
boost::icl::interval_base_map::size	icl/interval_base_map.hpp	/^    size_type size()const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:() const
boost::icl::interval_base_map::size_type	icl/interval_base_map.hpp	/^    typedef typename size_type_of<domain_type>::type size_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::sub_type	icl/interval_base_map.hpp	/^    typedef SubType sub_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::subtract	icl/interval_base_map.hpp	/^    SubType& subtract(const element_type& key_value_pair)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const element_type& key_value_pair)
boost::icl::interval_base_map::subtract	icl/interval_base_map.hpp	/^    SubType& subtract(const segment_type& interval_value_pair)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const segment_type& interval_value_pair)
boost::icl::interval_base_map::subtract_front	icl/interval_base_map.hpp	/^    ::subtract_front(const interval_type& inter_val, iterator& it_)$/;"	f	class:boost::icl::interval_base_map	signature:(const interval_type& inter_val, iterator& it_)
boost::icl::interval_base_map::subtract_front	icl/interval_base_map.hpp	/^    void subtract_front(const interval_type& inter_val, iterator& first_);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const interval_type& inter_val, iterator& first_)
boost::icl::interval_base_map::subtract_main	icl/interval_base_map.hpp	/^    ::subtract_main(const CodomainT& co_val, iterator& it_, const iterator& last_)$/;"	f	class:boost::icl::interval_base_map	signature:(const CodomainT& co_val, iterator& it_, const iterator& last_)
boost::icl::interval_base_map::subtract_main	icl/interval_base_map.hpp	/^    void subtract_main(const CodomainT& co_val, iterator& it_, const iterator& last_);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const CodomainT& co_val, iterator& it_, const iterator& last_)
boost::icl::interval_base_map::subtract_rear	icl/interval_base_map.hpp	/^    ::subtract_rear(interval_type& inter_val, const CodomainT& co_val, iterator& it_)$/;"	f	class:boost::icl::interval_base_map	signature:(interval_type& inter_val, const CodomainT& co_val, iterator& it_)
boost::icl::interval_base_map::subtract_rear	icl/interval_base_map.hpp	/^    void subtract_rear(interval_type& inter_val, const CodomainT& co_val, iterator& it_);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(interval_type& inter_val, const CodomainT& co_val, iterator& it_)
boost::icl::interval_base_map::swap	icl/interval_base_map.hpp	/^    void swap(interval_base_map& object) { _map.swap(object._map); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(interval_base_map& object)
boost::icl::interval_base_map::that	icl/interval_base_map.hpp	/^    const sub_type* that()const { return static_cast<const sub_type*>(this); }$/;"	f	class:boost::icl::interval_base_map	access:protected	signature:() const
boost::icl::interval_base_map::that	icl/interval_base_map.hpp	/^    sub_type* that() { return static_cast<sub_type*>(this); }$/;"	f	class:boost::icl::interval_base_map	access:protected	signature:()
boost::icl::interval_base_map::total_add_intersection	icl/interval_base_map.hpp	/^    void total_add_intersection(SubType& section, const FragmentT& fragment)const$/;"	f	class:boost::icl::interval_base_map	access:private	signature:(SubType& section, const FragmentT& fragment) const
boost::icl::interval_base_map::traits	icl/interval_base_map.hpp	/^    typedef Traits traits;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::type	icl/interval_base_map.hpp	/^                              type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_map::upper_bound	icl/interval_base_map.hpp	/^    const_iterator upper_bound(const key_type& interval)const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const key_type& interval) const
boost::icl::interval_base_map::upper_bound	icl/interval_base_map.hpp	/^    iterator upper_bound(const key_type& interval)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const key_type& interval)
boost::icl::interval_base_map::value_type	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::value_type value_type;$/;"	t	class:boost::icl::interval_base_map	access:public
boost::icl::interval_base_set	icl/interval_base_set.hpp	/^class interval_base_set$/;"	c	namespace:boost::icl
boost::icl::interval_base_set::BOOST_STATIC_CONSTANT	icl/interval_base_set.hpp	/^    BOOST_STATIC_CONSTANT(int, fineness = 0); $/;"	p	class:boost::icl::interval_base_set	access:public	signature:(int, fineness = 0)
boost::icl::interval_base_set::ImplSetT	icl/interval_base_set.hpp	/^    typedef typename ICL_IMPL_SPACE::set<interval_type,key_compare,allocator_type> ImplSetT;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::_add	icl/interval_base_set.hpp	/^    ::_add(const segment_type& addend)$/;"	f	class:boost::icl::interval_base_set	signature:(const segment_type& addend)
boost::icl::interval_base_set::_add	icl/interval_base_set.hpp	/^    ::_add(iterator prior_, const segment_type& addend)$/;"	f	class:boost::icl::interval_base_set	signature:(iterator prior_, const segment_type& addend)
boost::icl::interval_base_set::_add	icl/interval_base_set.hpp	/^    iterator _add(const segment_type& addend);$/;"	p	class:boost::icl::interval_base_set	access:private	signature:(const segment_type& addend)
boost::icl::interval_base_set::_add	icl/interval_base_set.hpp	/^    iterator _add(iterator prior, const segment_type& addend);$/;"	p	class:boost::icl::interval_base_set	access:private	signature:(iterator prior, const segment_type& addend)
boost::icl::interval_base_set::_set	icl/interval_base_set.hpp	/^    ImplSetT _set;$/;"	m	class:boost::icl::interval_base_set	access:protected
boost::icl::interval_base_set::add	icl/interval_base_set.hpp	/^    SubType& add(const element_type& key) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const element_type& key)
boost::icl::interval_base_set::add	icl/interval_base_set.hpp	/^    SubType& add(const segment_type& inter_val) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const segment_type& inter_val)
boost::icl::interval_base_set::add	icl/interval_base_set.hpp	/^    iterator add(iterator prior_, const segment_type& inter_val) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(iterator prior_, const segment_type& inter_val)
boost::icl::interval_base_set::add_front	icl/interval_base_set.hpp	/^    ::add_front(const interval_type& inter_val, iterator& first_)$/;"	f	class:boost::icl::interval_base_set	signature:(const interval_type& inter_val, iterator& first_)
boost::icl::interval_base_set::add_front	icl/interval_base_set.hpp	/^    void add_front(const interval_type& inter_val, iterator& first_);$/;"	p	class:boost::icl::interval_base_set	access:protected	signature:(const interval_type& inter_val, iterator& first_)
boost::icl::interval_base_set::add_main	icl/interval_base_set.hpp	/^    ::add_main(interval_type& rest_interval, iterator& it_, const iterator& last_)$/;"	f	class:boost::icl::interval_base_set	signature:(interval_type& rest_interval, iterator& it_, const iterator& last_)
boost::icl::interval_base_set::add_main	icl/interval_base_set.hpp	/^    void add_main(interval_type& inter_val, iterator& it_, const iterator& last_);$/;"	p	class:boost::icl::interval_base_set	access:protected	signature:(interval_type& inter_val, iterator& it_, const iterator& last_)
boost::icl::interval_base_set::add_rear	icl/interval_base_set.hpp	/^    ::add_rear(const interval_type& inter_val, iterator& it_)$/;"	f	class:boost::icl::interval_base_set	signature:(const interval_type& inter_val, iterator& it_)
boost::icl::interval_base_set::add_rear	icl/interval_base_set.hpp	/^    void add_rear(const interval_type& inter_val, iterator& it_);$/;"	p	class:boost::icl::interval_base_set	access:protected	signature:(const interval_type& inter_val, iterator& it_)
boost::icl::interval_base_set::add_segment	icl/interval_base_set.hpp	/^    ::add_segment(const interval_type& inter_val, iterator& it_)$/;"	f	class:boost::icl::interval_base_set	signature:(const interval_type& inter_val, iterator& it_)
boost::icl::interval_base_set::add_segment	icl/interval_base_set.hpp	/^    void add_segment(const interval_type& inter_val, iterator& it_);$/;"	p	class:boost::icl::interval_base_set	access:protected	signature:(const interval_type& inter_val, iterator& it_)
boost::icl::interval_base_set::allocator_type	icl/interval_base_set.hpp	/^    typedef Alloc<interval_type> allocator_type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::atomized_type	icl/interval_base_set.hpp	/^    typedef typename ICL_IMPL_SPACE::set<DomainT,domain_compare,Alloc<DomainT> > atomized_type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::begin	icl/interval_base_set.hpp	/^    const_iterator begin()const { return _set.begin(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:() const
boost::icl::interval_base_set::begin	icl/interval_base_set.hpp	/^    iterator begin() { return _set.begin(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:()
boost::icl::interval_base_set::clear	icl/interval_base_set.hpp	/^    void clear() { icl::clear(*that()); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:()
boost::icl::interval_base_set::codomain_type	icl/interval_base_set.hpp	/^    typedef DomainT   codomain_type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::const_iterator	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::const_iterator const_iterator;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::const_pointer	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::const_pointer   const_pointer;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::const_reference	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::const_reference const_reference;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::const_reverse_iterator	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::const_reverse_iterator const_reverse_iterator;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::data_type	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::key_type   data_type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::difference_type	icl/interval_base_set.hpp	/^    typedef typename difference_type_of<domain_type>::type difference_type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::domain_allocator_type	icl/interval_base_set.hpp	/^    typedef Alloc<DomainT> domain_allocator_type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::domain_compare	icl/interval_base_set.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT)      domain_compare;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::domain_type	icl/interval_base_set.hpp	/^    typedef DomainT   domain_type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::element_const_iterator	icl/interval_base_set.hpp	/^    typedef boost::icl::element_iterator<const_iterator> element_const_iterator; $/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::element_const_reverse_iterator	icl/interval_base_set.hpp	/^    typedef boost::icl::element_iterator<const_reverse_iterator> element_const_reverse_iterator; $/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::element_iterator	icl/interval_base_set.hpp	/^    typedef boost::icl::element_iterator<iterator> element_iterator; $/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::element_reverse_iterator	icl/interval_base_set.hpp	/^    typedef boost::icl::element_iterator<reverse_iterator> element_reverse_iterator; $/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::element_type	icl/interval_base_set.hpp	/^    typedef DomainT   element_type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::empty	icl/interval_base_set.hpp	/^    bool empty()const { return icl::is_empty(*that()); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:() const
boost::icl::interval_base_set::end	icl/interval_base_set.hpp	/^    const_iterator end()const   { return _set.end(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:() const
boost::icl::interval_base_set::end	icl/interval_base_set.hpp	/^    iterator end()   { return _set.end(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:()
boost::icl::interval_base_set::equal_range	icl/interval_base_set.hpp	/^        equal_range(const key_type& interval)const$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const key_type& interval) const
boost::icl::interval_base_set::equal_range	icl/interval_base_set.hpp	/^    std::pair<iterator,iterator> equal_range(const key_type& interval)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const key_type& interval)
boost::icl::interval_base_set::erase	icl/interval_base_set.hpp	/^    SubType& erase(const element_type& key) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const element_type& key)
boost::icl::interval_base_set::erase	icl/interval_base_set.hpp	/^    SubType& erase(const segment_type& inter_val) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const segment_type& inter_val)
boost::icl::interval_base_set::erase	icl/interval_base_set.hpp	/^    void erase(iterator first, iterator past)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(iterator first, iterator past)
boost::icl::interval_base_set::erase	icl/interval_base_set.hpp	/^    void erase(iterator position)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(iterator position)
boost::icl::interval_base_set::find	icl/interval_base_set.hpp	/^    const_iterator find(const element_type& key_value)const$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const element_type& key_value) const
boost::icl::interval_base_set::find	icl/interval_base_set.hpp	/^    const_iterator find(const interval_type& key_interval)const$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const interval_type& key_interval) const
boost::icl::interval_base_set::flip	icl/interval_base_set.hpp	/^    SubType& flip(const element_type& key)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const element_type& key)
boost::icl::interval_base_set::flip	icl/interval_base_set.hpp	/^    SubType& flip(const segment_type& inter_val)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const segment_type& inter_val)
boost::icl::interval_base_set::insert	icl/interval_base_set.hpp	/^    SubType& insert(const element_type& key) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const element_type& key)
boost::icl::interval_base_set::insert	icl/interval_base_set.hpp	/^    SubType& insert(const segment_type& inter_val) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const segment_type& inter_val)
boost::icl::interval_base_set::insert	icl/interval_base_set.hpp	/^    iterator insert(iterator prior_, const segment_type& inter_val) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(iterator prior_, const segment_type& inter_val)
boost::icl::interval_base_set::interval_base_set	icl/interval_base_set.hpp	/^    interval_base_set(){}$/;"	f	class:boost::icl::interval_base_set	access:public	signature:()
boost::icl::interval_base_set::interval_base_set	icl/interval_base_set.hpp	/^    interval_base_set(const interval_base_set& src): _set(src._set)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const interval_base_set& src)
boost::icl::interval_base_set::interval_base_set	icl/interval_base_set.hpp	/^    interval_base_set(interval_base_set&& src): _set(boost::move(src._set))$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(interval_base_set&& src)
boost::icl::interval_base_set::interval_compare	icl/interval_base_set.hpp	/^    typedef exclusive_less_than<interval_type>       interval_compare;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::interval_type	icl/interval_base_set.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) interval_type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::iterative_size	icl/interval_base_set.hpp	/^    std::size_t iterative_size()const $/;"	f	class:boost::icl::interval_base_set	access:public	signature:() const
boost::icl::interval_base_set::iterator	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::iterator iterator;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::key_compare	icl/interval_base_set.hpp	/^    typedef exclusive_less_than<interval_type> key_compare;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::key_type	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::key_type   key_type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::lower_bound	icl/interval_base_set.hpp	/^    const_iterator lower_bound(const value_type& interval)const$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const value_type& interval) const
boost::icl::interval_base_set::lower_bound	icl/interval_base_set.hpp	/^    iterator lower_bound(const value_type& interval)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const value_type& interval)
boost::icl::interval_base_set::operator =	icl/interval_base_set.hpp	/^    interval_base_set& operator = (const interval_base_set& src) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const interval_base_set& src)
boost::icl::interval_base_set::operator =	icl/interval_base_set.hpp	/^    interval_base_set& operator = (interval_base_set&& src) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(interval_base_set&& src)
boost::icl::interval_base_set::overloadable_type	icl/interval_base_set.hpp	/^    typedef type overloadable_type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::pointer	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::pointer         pointer;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::rbegin	icl/interval_base_set.hpp	/^    const_reverse_iterator rbegin()const { return _set.rbegin(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:() const
boost::icl::interval_base_set::rbegin	icl/interval_base_set.hpp	/^    reverse_iterator rbegin() { return _set.rbegin(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:()
boost::icl::interval_base_set::reference	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::reference       reference;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::rend	icl/interval_base_set.hpp	/^    const_reverse_iterator rend()const   { return _set.rend(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:() const
boost::icl::interval_base_set::rend	icl/interval_base_set.hpp	/^    reverse_iterator rend()   { return _set.rend(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:()
boost::icl::interval_base_set::reverse_iterator	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::reverse_iterator reverse_iterator;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::segment_compare	icl/interval_base_set.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,segment_type) segment_compare;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::segment_type	icl/interval_base_set.hpp	/^    typedef interval_type   segment_type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::size	icl/interval_base_set.hpp	/^    size_type size()const$/;"	f	class:boost::icl::interval_base_set	access:public	signature:() const
boost::icl::interval_base_set::size_type	icl/interval_base_set.hpp	/^    typedef typename size_type_of<domain_type>::type size_type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::sub_type	icl/interval_base_set.hpp	/^    typedef SubType sub_type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::subtract	icl/interval_base_set.hpp	/^    ::subtract(const segment_type& minuend)$/;"	f	class:boost::icl::interval_base_set	signature:(const segment_type& minuend)
boost::icl::interval_base_set::subtract	icl/interval_base_set.hpp	/^    SubType& subtract(const element_type& key) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const element_type& key)
boost::icl::interval_base_set::subtract	icl/interval_base_set.hpp	/^    SubType& subtract(const segment_type& inter_val); $/;"	p	class:boost::icl::interval_base_set	access:public	signature:(const segment_type& inter_val)
boost::icl::interval_base_set::swap	icl/interval_base_set.hpp	/^    void swap(interval_base_set& operand) { _set.swap(operand._set); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(interval_base_set& operand)
boost::icl::interval_base_set::that	icl/interval_base_set.hpp	/^    const sub_type* that()const { return static_cast<const sub_type*>(this); }$/;"	f	class:boost::icl::interval_base_set	access:protected	signature:() const
boost::icl::interval_base_set::that	icl/interval_base_set.hpp	/^    sub_type* that() { return static_cast<sub_type*>(this); }$/;"	f	class:boost::icl::interval_base_set	access:protected	signature:()
boost::icl::interval_base_set::type	icl/interval_base_set.hpp	/^    typedef interval_base_set<SubType,DomainT,Compare,Interval,Alloc> type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_base_set::upper_bound	icl/interval_base_set.hpp	/^    const_iterator upper_bound(const value_type& interval)const$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const value_type& interval) const
boost::icl::interval_base_set::upper_bound	icl/interval_base_set.hpp	/^    iterator upper_bound(const value_type& interval)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const value_type& interval)
boost::icl::interval_base_set::value_type	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::value_type value_type;$/;"	t	class:boost::icl::interval_base_set	access:public
boost::icl::interval_bound_type	icl/closed_interval.hpp	/^struct interval_bound_type< closed_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::interval_bound_type	icl/continuous_interval.hpp	/^struct interval_bound_type< continuous_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::interval_bound_type	icl/discrete_interval.hpp	/^struct interval_bound_type< discrete_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::interval_bound_type	icl/left_open_interval.hpp	/^struct interval_bound_type< left_open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::interval_bound_type	icl/open_interval.hpp	/^struct interval_bound_type< open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::interval_bound_type	icl/right_open_interval.hpp	/^struct interval_bound_type< right_open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::interval_bound_type	icl/type_traits/is_interval.hpp	/^struct interval_bound_type$/;"	s	namespace:boost::icl
boost::icl::interval_bound_type::BOOST_STATIC_CONSTANT	icl/closed_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, value = interval_bounds::static_closed);$/;"	p	struct:boost::icl::interval_bound_type	access:public	signature:(bound_type, value = interval_bounds::static_closed)
boost::icl::interval_bound_type::BOOST_STATIC_CONSTANT	icl/continuous_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, value = interval_bounds::dynamic);$/;"	p	struct:boost::icl::interval_bound_type	access:public	signature:(bound_type, value = interval_bounds::dynamic)
boost::icl::interval_bound_type::BOOST_STATIC_CONSTANT	icl/discrete_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, value = interval_bounds::dynamic);$/;"	p	struct:boost::icl::interval_bound_type	access:public	signature:(bound_type, value = interval_bounds::dynamic)
boost::icl::interval_bound_type::BOOST_STATIC_CONSTANT	icl/left_open_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, value = interval_bounds::static_left_open);$/;"	p	struct:boost::icl::interval_bound_type	access:public	signature:(bound_type, value = interval_bounds::static_left_open)
boost::icl::interval_bound_type::BOOST_STATIC_CONSTANT	icl/open_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, value = interval_bounds::static_open);$/;"	p	struct:boost::icl::interval_bound_type	access:public	signature:(bound_type, value = interval_bounds::static_open)
boost::icl::interval_bound_type::BOOST_STATIC_CONSTANT	icl/right_open_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, value = interval_bounds::static_right_open);$/;"	p	struct:boost::icl::interval_bound_type	access:public	signature:(bound_type, value = interval_bounds::static_right_open)
boost::icl::interval_bound_type::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, value = (interval_bounds::undefined)); $/;"	p	struct:boost::icl::interval_bound_type	access:public	signature:(bound_type, value = (interval_bounds::undefined))
boost::icl::interval_bound_type::type	icl/closed_interval.hpp	/^    typedef interval_bound_type type;$/;"	t	struct:boost::icl::interval_bound_type	access:public
boost::icl::interval_bound_type::type	icl/continuous_interval.hpp	/^    typedef interval_bound_type type;$/;"	t	struct:boost::icl::interval_bound_type	access:public
boost::icl::interval_bound_type::type	icl/discrete_interval.hpp	/^    typedef interval_bound_type type;$/;"	t	struct:boost::icl::interval_bound_type	access:public
boost::icl::interval_bound_type::type	icl/left_open_interval.hpp	/^    typedef interval_bound_type type;$/;"	t	struct:boost::icl::interval_bound_type	access:public
boost::icl::interval_bound_type::type	icl/open_interval.hpp	/^    typedef interval_bound_type type;$/;"	t	struct:boost::icl::interval_bound_type	access:public
boost::icl::interval_bound_type::type	icl/right_open_interval.hpp	/^    typedef interval_bound_type type;$/;"	t	struct:boost::icl::interval_bound_type	access:public
boost::icl::interval_bound_type::type	icl/type_traits/is_interval.hpp	/^    typedef interval_bound_type type;$/;"	t	struct:boost::icl::interval_bound_type	access:public
boost::icl::interval_bounds	icl/interval_bounds.hpp	/^class interval_bounds$/;"	c	namespace:boost::icl
boost::icl::interval_bounds::BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, _all       = 3);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, _all = 3)
boost::icl::interval_bounds::BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, _closed     = 3);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, _closed = 3)
boost::icl::interval_bounds::BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, _left      = 2);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, _left = 2)
boost::icl::interval_bounds::BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, _left_open  = 1);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, _left_open = 1)
boost::icl::interval_bounds::BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, _open       = 0);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, _open = 0)
boost::icl::interval_bounds::BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, _right     = 1);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, _right = 1)
boost::icl::interval_bounds::BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, _right_open = 2);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, _right_open = 2)
boost::icl::interval_bounds::BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, dynamic           = 4);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, dynamic = 4)
boost::icl::interval_bounds::BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, static_closed     = 3);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, static_closed = 3)
boost::icl::interval_bounds::BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, static_left_open  = 1);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, static_left_open = 1)
boost::icl::interval_bounds::BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, static_open       = 0);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, static_open = 0)
boost::icl::interval_bounds::BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, static_right_open = 2);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, static_right_open = 2)
boost::icl::interval_bounds::BOOST_STATIC_CONSTANT	icl/interval_bounds.hpp	/^    BOOST_STATIC_CONSTANT(bound_type, undefined         = 5);$/;"	p	class:boost::icl::interval_bounds	access:public	signature:(bound_type, undefined = 5)
boost::icl::interval_bounds::_bits	icl/interval_bounds.hpp	/^    bound_type _bits;$/;"	m	class:boost::icl::interval_bounds	access:public
boost::icl::interval_bounds::all	icl/interval_bounds.hpp	/^    interval_bounds all  ()const { return interval_bounds(_bits & _all  ); }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:() const
boost::icl::interval_bounds::bits	icl/interval_bounds.hpp	/^    bound_type bits()const{ return _bits; }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:() const
boost::icl::interval_bounds::closed	icl/interval_bounds.hpp	/^    static interval_bounds closed()    { return interval_bounds(_closed);   }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:()
boost::icl::interval_bounds::interval_bounds	icl/interval_bounds.hpp	/^    explicit interval_bounds(bound_type bounds): _bits(bounds){}$/;"	f	class:boost::icl::interval_bounds	access:public	signature:(bound_type bounds)
boost::icl::interval_bounds::interval_bounds	icl/interval_bounds.hpp	/^    interval_bounds():_bits(){}$/;"	f	class:boost::icl::interval_bounds	access:public	signature:()
boost::icl::interval_bounds::left	icl/interval_bounds.hpp	/^    interval_bounds left ()const { return interval_bounds(_bits & _left ); }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:() const
boost::icl::interval_bounds::left_open	icl/interval_bounds.hpp	/^    static interval_bounds left_open() { return interval_bounds(_left_open); }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:()
boost::icl::interval_bounds::open	icl/interval_bounds.hpp	/^    static interval_bounds open()      { return interval_bounds(_open);     }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:()
boost::icl::interval_bounds::reverse_left	icl/interval_bounds.hpp	/^    interval_bounds reverse_left ()const { return interval_bounds((~_bits>>1) & _right); }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:() const
boost::icl::interval_bounds::reverse_right	icl/interval_bounds.hpp	/^    interval_bounds reverse_right()const { return interval_bounds((~_bits<<1) & _left ); }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:() const
boost::icl::interval_bounds::right	icl/interval_bounds.hpp	/^    interval_bounds right()const { return interval_bounds(_bits & _right); }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:() const
boost::icl::interval_bounds::right_open	icl/interval_bounds.hpp	/^    static interval_bounds right_open(){ return interval_bounds(_right_open);}$/;"	f	class:boost::icl::interval_bounds	access:public	signature:()
boost::icl::interval_combine	icl/interval_combining_style.hpp	/^namespace interval_combine$/;"	n	namespace:boost::icl
boost::icl::interval_combine::BOOST_STATIC_CONSTANT	icl/interval_combining_style.hpp	/^    BOOST_STATIC_CONSTANT(int, elemental  = 4);$/;"	p	namespace:boost::icl::interval_combine	signature:(int, elemental = 4)
boost::icl::interval_combine::BOOST_STATIC_CONSTANT	icl/interval_combining_style.hpp	/^    BOOST_STATIC_CONSTANT(int, joining    = 1);$/;"	p	namespace:boost::icl::interval_combine	signature:(int, joining = 1)
boost::icl::interval_combine::BOOST_STATIC_CONSTANT	icl/interval_combining_style.hpp	/^    BOOST_STATIC_CONSTANT(int, separating = 2);$/;"	p	namespace:boost::icl::interval_combine	signature:(int, separating = 2)
boost::icl::interval_combine::BOOST_STATIC_CONSTANT	icl/interval_combining_style.hpp	/^    BOOST_STATIC_CONSTANT(int, splitting  = 3);$/;"	p	namespace:boost::icl::interval_combine	signature:(int, splitting = 3)
boost::icl::interval_combine::BOOST_STATIC_CONSTANT	icl/interval_combining_style.hpp	/^    BOOST_STATIC_CONSTANT(int, unknown    = 0);$/;"	p	namespace:boost::icl::interval_combine	signature:(int, unknown = 0)
boost::icl::interval_count	icl/concept/interval_associator.hpp	/^interval_count(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::interval_map	icl/interval_map.hpp	/^class interval_map:$/;"	c	namespace:boost::icl	inherits:interval_base_map
boost::icl::interval_map::ImplMapT	icl/interval_map.hpp	/^    typedef typename base_type::ImplMapT ImplMapT;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::assign	icl/interval_map.hpp	/^    void assign(const interval_base_map<SubType,DomainT,CodomainT,$/;"	f	class:boost::icl::interval_map	access:public	signature:(const interval_base_map<SubType,DomainT,CodomainT, Traits,Compare,Combine,Section,Interval,Alloc>& src)
boost::icl::interval_map::base_type	icl/interval_map.hpp	/^                              DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> base_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::codomain_combine	icl/interval_map.hpp	/^    typedef typename base_type::codomain_combine codomain_combine;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::codomain_type	icl/interval_map.hpp	/^    typedef typename base_type::codomain_type codomain_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::domain_mapping_type	icl/interval_map.hpp	/^    typedef typename base_type::domain_mapping_type domain_mapping_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::domain_type	icl/interval_map.hpp	/^    typedef typename base_type::domain_type   domain_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::element_type	icl/interval_map.hpp	/^    typedef typename base_type::element_type  element_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::fineness	icl/interval_map.hpp	/^    enum { fineness = 1 };$/;"	e	enum:boost::icl::interval_map::__anon1
boost::icl::interval_map::gap_insert_at	icl/interval_map.hpp	/^    void gap_insert_at(iterator& it_, iterator prior_, $/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator& it_, iterator prior_, const interval_type& end_gap, const codomain_type& co_val)
boost::icl::interval_map::handle_combined	icl/interval_map.hpp	/^    void handle_combined(iterator it_)$/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator it_)
boost::icl::interval_map::handle_inserted	icl/interval_map.hpp	/^    iterator handle_inserted(iterator it_)$/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator it_)
boost::icl::interval_map::handle_inserted	icl/interval_map.hpp	/^    void handle_inserted(iterator prior_, iterator it_)$/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator prior_, iterator it_)
boost::icl::interval_map::handle_left_combined	icl/interval_map.hpp	/^    void handle_left_combined(iterator it_)$/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator it_)
boost::icl::interval_map::handle_preceeded_combined	icl/interval_map.hpp	/^    void handle_preceeded_combined(iterator prior_, iterator& it_)$/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator prior_, iterator& it_)
boost::icl::interval_map::handle_reinserted	icl/interval_map.hpp	/^    void handle_reinserted(iterator insertion_)$/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator insertion_)
boost::icl::interval_map::handle_succeeded_combined	icl/interval_map.hpp	/^    void handle_succeeded_combined(iterator it_, iterator next_)$/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator it_, iterator next_)
boost::icl::interval_map::interval_map	icl/interval_map.hpp	/^    explicit interval_map$/;"	f	class:boost::icl::interval_map	access:public	signature:(const interval_base_map<SubType,DomainT,CodomainT, Traits,Compare,Combine,Section,Interval,Alloc>& src)
boost::icl::interval_map::interval_map	icl/interval_map.hpp	/^    explicit interval_map(const domain_mapping_type& base_pair): base_type()$/;"	f	class:boost::icl::interval_map	access:public	signature:(const domain_mapping_type& base_pair)
boost::icl::interval_map::interval_map	icl/interval_map.hpp	/^    explicit interval_map(const value_type& value_pair): base_type()$/;"	f	class:boost::icl::interval_map	access:public	signature:(const value_type& value_pair)
boost::icl::interval_map::interval_map	icl/interval_map.hpp	/^    interval_map(): base_type() {}$/;"	f	class:boost::icl::interval_map	access:public	signature:()
boost::icl::interval_map::interval_map	icl/interval_map.hpp	/^    interval_map(const interval_map& src): base_type(src) {}$/;"	f	class:boost::icl::interval_map	access:public	signature:(const interval_map& src)
boost::icl::interval_map::interval_map	icl/interval_map.hpp	/^    interval_map(interval_map&& src)$/;"	f	class:boost::icl::interval_map	access:public	signature:(interval_map&& src)
boost::icl::interval_map::interval_mapping_type	icl/interval_map.hpp	/^    typedef typename base_type::interval_mapping_type interval_mapping_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::interval_set_type	icl/interval_map.hpp	/^    typedef interval_set<DomainT,Compare,Interval,Alloc> interval_set_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::interval_type	icl/interval_map.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) interval_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::iterator	icl/interval_map.hpp	/^    typedef typename base_type::iterator      iterator;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::joint_type	icl/interval_map.hpp	/^    typedef type joint_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::key_object_type	icl/interval_map.hpp	/^    typedef set_type          key_object_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::operator =	icl/interval_map.hpp	/^    interval_map& operator = (const interval_map& src)$/;"	f	class:boost::icl::interval_map	access:public	signature:(const interval_map& src)
boost::icl::interval_map::operator =	icl/interval_map.hpp	/^    interval_map& operator = (interval_map&& src)$/;"	f	class:boost::icl::interval_map	access:public	signature:(interval_map&& src)
boost::icl::interval_map::operator =	icl/interval_map.hpp	/^    interval_map& operator =$/;"	f	class:boost::icl::interval_map	access:public	signature:(const interval_base_map<SubType,DomainT,CodomainT, Traits,Compare,Combine,Section,Interval,Alloc>& src)
boost::icl::interval_map::overloadable_type	icl/interval_map.hpp	/^    typedef type overloadable_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::segment_type	icl/interval_map.hpp	/^    typedef typename base_type::segment_type  segment_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::set_type	icl/interval_map.hpp	/^    typedef interval_set_type set_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::size_type	icl/interval_map.hpp	/^    typedef typename base_type::size_type     size_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::split_type	icl/interval_map.hpp	/^    typedef split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> split_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::traits	icl/interval_map.hpp	/^    typedef Traits traits;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::type	icl/interval_map.hpp	/^    typedef       interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_map::value_type	icl/interval_map.hpp	/^    typedef typename base_type::value_type    value_type;$/;"	t	class:boost::icl::interval_map	access:public
boost::icl::interval_set	icl/interval_set.hpp	/^class interval_set: $/;"	c	namespace:boost::icl	inherits:interval_base_set
boost::icl::interval_set::ImplSetT	icl/interval_set.hpp	/^    typedef typename base_type::ImplSetT ImplSetT;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::add_over	icl/interval_set.hpp	/^    iterator add_over(const interval_type& addend)$/;"	f	class:boost::icl::interval_set	access:private	signature:(const interval_type& addend)
boost::icl::interval_set::add_over	icl/interval_set.hpp	/^    iterator add_over(const interval_type& addend, iterator last_)$/;"	f	class:boost::icl::interval_set	access:private	signature:(const interval_type& addend, iterator last_)
boost::icl::interval_set::allocator_type	icl/interval_set.hpp	/^    typedef Alloc<interval_type> allocator_type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::assign	icl/interval_set.hpp	/^    void assign(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)$/;"	f	class:boost::icl::interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
boost::icl::interval_set::atomized_type	icl/interval_set.hpp	/^    typedef typename base_type::atomized_type atomized_type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::base_type	icl/interval_set.hpp	/^    typedef interval_base_set<type,DomainT,Compare,Interval,Alloc> base_type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::codomain_type	icl/interval_set.hpp	/^    typedef DomainT   codomain_type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::const_iterator	icl/interval_set.hpp	/^    typedef typename ImplSetT::const_iterator const_iterator;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::data_type	icl/interval_set.hpp	/^    typedef typename ImplSetT::value_type data_type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::domain_allocator_type	icl/interval_set.hpp	/^    typedef Alloc<DomainT> domain_allocator_type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::domain_compare	icl/interval_set.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::domain_type	icl/interval_set.hpp	/^    typedef DomainT   domain_type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::element_type	icl/interval_set.hpp	/^    typedef DomainT   element_type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::fineness	icl/interval_set.hpp	/^    enum { fineness = 1 };$/;"	e	enum:boost::icl::interval_set::__anon10
boost::icl::interval_set::handle_inserted	icl/interval_set.hpp	/^    iterator handle_inserted(iterator it_)$/;"	f	class:boost::icl::interval_set	access:private	signature:(iterator it_)
boost::icl::interval_set::interval_compare	icl/interval_set.hpp	/^    typedef exclusive_less_than<interval_type> interval_compare;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::interval_set	icl/interval_set.hpp	/^    explicit interval_set$/;"	f	class:boost::icl::interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
boost::icl::interval_set::interval_set	icl/interval_set.hpp	/^    explicit interval_set(const domain_type& value): base_type() $/;"	f	class:boost::icl::interval_set	access:public	signature:(const domain_type& value)
boost::icl::interval_set::interval_set	icl/interval_set.hpp	/^    explicit interval_set(const interval_type& itv): base_type() $/;"	f	class:boost::icl::interval_set	access:public	signature:(const interval_type& itv)
boost::icl::interval_set::interval_set	icl/interval_set.hpp	/^    interval_set(): base_type() {}$/;"	f	class:boost::icl::interval_set	access:public	signature:()
boost::icl::interval_set::interval_set	icl/interval_set.hpp	/^    interval_set(const interval_set& src): base_type(src) {}$/;"	f	class:boost::icl::interval_set	access:public	signature:(const interval_set& src)
boost::icl::interval_set::interval_set	icl/interval_set.hpp	/^    interval_set(interval_set&& src)$/;"	f	class:boost::icl::interval_set	access:public	signature:(interval_set&& src)
boost::icl::interval_set::interval_type	icl/interval_set.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) interval_type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::iterator	icl/interval_set.hpp	/^    typedef typename ImplSetT::iterator iterator;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::joint_type	icl/interval_set.hpp	/^    typedef type joint_type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::key_compare	icl/interval_set.hpp	/^    typedef exclusive_less_than<interval_type> key_compare;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::key_object_type	icl/interval_set.hpp	/^    typedef type key_object_type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::key_type	icl/interval_set.hpp	/^    typedef typename ImplSetT::key_type   key_type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::operator =	icl/interval_set.hpp	/^    interval_set& operator = (const interval_set& src)$/;"	f	class:boost::icl::interval_set	access:public	signature:(const interval_set& src)
boost::icl::interval_set::operator =	icl/interval_set.hpp	/^    interval_set& operator = (interval_set&& src)$/;"	f	class:boost::icl::interval_set	access:public	signature:(interval_set&& src)
boost::icl::interval_set::operator =	icl/interval_set.hpp	/^    interval_set& operator =$/;"	f	class:boost::icl::interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
boost::icl::interval_set::overloadable_type	icl/interval_set.hpp	/^    typedef type overloadable_type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::segment_type	icl/interval_set.hpp	/^    typedef interval_type   segment_type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::type	icl/interval_set.hpp	/^    typedef interval_set<DomainT,Compare,Interval,Alloc> type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_set::value_type	icl/interval_set.hpp	/^    typedef typename ImplSetT::value_type value_type;$/;"	t	class:boost::icl::interval_set	access:public
boost::icl::interval_traits	icl/closed_interval.hpp	/^struct interval_traits< icl::closed_interval<DomainT, Compare> >$/;"	s	namespace:boost::icl
boost::icl::interval_traits	icl/continuous_interval.hpp	/^struct interval_traits< icl::continuous_interval<DomainT, Compare> >$/;"	s	namespace:boost::icl
boost::icl::interval_traits	icl/discrete_interval.hpp	/^struct interval_traits< icl::discrete_interval<DomainT, Compare> >$/;"	s	namespace:boost::icl
boost::icl::interval_traits	icl/interval_traits.hpp	/^template<class Type> struct interval_traits$/;"	s	namespace:boost::icl
boost::icl::interval_traits	icl/left_open_interval.hpp	/^struct interval_traits< icl::left_open_interval<DomainT, Compare> >$/;"	s	namespace:boost::icl
boost::icl::interval_traits	icl/open_interval.hpp	/^struct interval_traits< icl::open_interval<DomainT, Compare> >$/;"	s	namespace:boost::icl
boost::icl::interval_traits	icl/right_open_interval.hpp	/^struct interval_traits< icl::right_open_interval<DomainT, Compare> >$/;"	s	namespace:boost::icl
boost::icl::interval_traits::construct	icl/closed_interval.hpp	/^    static interval_type construct(const domain_type& lo, const domain_type& up)$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up)
boost::icl::interval_traits::construct	icl/continuous_interval.hpp	/^    static interval_type construct(const domain_type& lo, const domain_type& up)$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up)
boost::icl::interval_traits::construct	icl/discrete_interval.hpp	/^    static interval_type construct(const domain_type& lo, const domain_type& up)$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up)
boost::icl::interval_traits::construct	icl/interval_traits.hpp	/^    static Type construct(const domain_type& lo, const domain_type& up);$/;"	p	struct:boost::icl::interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up)
boost::icl::interval_traits::construct	icl/left_open_interval.hpp	/^    static interval_type construct(const domain_type& lo, const domain_type& up)$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up)
boost::icl::interval_traits::construct	icl/open_interval.hpp	/^    static interval_type construct(const domain_type& lo, const domain_type& up)$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up)
boost::icl::interval_traits::construct	icl/right_open_interval.hpp	/^    static interval_type construct(const domain_type& lo, const domain_type& up)$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up)
boost::icl::interval_traits::domain_compare	icl/closed_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::domain_compare	icl/continuous_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::domain_compare	icl/discrete_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::domain_compare	icl/left_open_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::domain_compare	icl/open_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::domain_compare	icl/right_open_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::domain_type	icl/closed_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::domain_type	icl/continuous_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::domain_type	icl/discrete_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::domain_type	icl/interval_traits.hpp	/^    typedef typename domain_type_of<Type>::type domain_type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::domain_type	icl/left_open_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::domain_type	icl/open_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::domain_type	icl/right_open_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::interval_type	icl/closed_interval.hpp	/^    typedef icl::closed_interval<DomainT, Compare> interval_type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::interval_type	icl/continuous_interval.hpp	/^    typedef icl::continuous_interval<DomainT, Compare> interval_type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::interval_type	icl/discrete_interval.hpp	/^    typedef icl::discrete_interval<DomainT, Compare> interval_type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::interval_type	icl/left_open_interval.hpp	/^    typedef icl::left_open_interval<DomainT, Compare> interval_type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::interval_type	icl/open_interval.hpp	/^    typedef icl::open_interval<DomainT, Compare> interval_type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::interval_type	icl/right_open_interval.hpp	/^    typedef icl::right_open_interval<DomainT, Compare> interval_type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::lower	icl/closed_interval.hpp	/^    static domain_type lower(const interval_type& inter_val){ return inter_val.lower(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
boost::icl::interval_traits::lower	icl/continuous_interval.hpp	/^    static domain_type lower(const interval_type& inter_val){ return inter_val.lower(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
boost::icl::interval_traits::lower	icl/discrete_interval.hpp	/^    static domain_type lower(const interval_type& inter_val){ return inter_val.lower(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
boost::icl::interval_traits::lower	icl/interval_traits.hpp	/^    static domain_type lower(const Type& inter_val);$/;"	p	struct:boost::icl::interval_traits	access:public	signature:(const Type& inter_val)
boost::icl::interval_traits::lower	icl/left_open_interval.hpp	/^    static domain_type lower(const interval_type& inter_val){ return inter_val.lower(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
boost::icl::interval_traits::lower	icl/open_interval.hpp	/^    static domain_type lower(const interval_type& inter_val){ return inter_val.lower(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
boost::icl::interval_traits::lower	icl/right_open_interval.hpp	/^    static domain_type lower(const interval_type& inter_val){ return inter_val.lower(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
boost::icl::interval_traits::type	icl/continuous_interval.hpp	/^    typedef interval_traits type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::type	icl/discrete_interval.hpp	/^    typedef interval_traits type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::type	icl/interval_traits.hpp	/^    typedef interval_traits                     type;$/;"	t	struct:boost::icl::interval_traits	access:public
boost::icl::interval_traits::upper	icl/closed_interval.hpp	/^    static domain_type upper(const interval_type& inter_val){ return inter_val.upper(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
boost::icl::interval_traits::upper	icl/continuous_interval.hpp	/^    static domain_type upper(const interval_type& inter_val){ return inter_val.upper(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
boost::icl::interval_traits::upper	icl/discrete_interval.hpp	/^    static domain_type upper(const interval_type& inter_val){ return inter_val.upper(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
boost::icl::interval_traits::upper	icl/interval_traits.hpp	/^    static domain_type upper(const Type& inter_val);$/;"	p	struct:boost::icl::interval_traits	access:public	signature:(const Type& inter_val)
boost::icl::interval_traits::upper	icl/left_open_interval.hpp	/^    static domain_type upper(const interval_type& inter_val){ return inter_val.upper(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
boost::icl::interval_traits::upper	icl/open_interval.hpp	/^    static domain_type upper(const interval_type& inter_val){ return inter_val.upper(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
boost::icl::interval_traits::upper	icl/right_open_interval.hpp	/^    static domain_type upper(const interval_type& inter_val){ return inter_val.upper(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
boost::icl::interval_type_default	icl/type_traits/interval_type_default.hpp	/^    struct interval_type_default$/;"	s	namespace:boost::icl
boost::icl::interval_type_default::type	icl/type_traits/interval_type_default.hpp	/^                             >::type type;$/;"	t	struct:boost::icl::interval_type_default	access:public
boost::icl::interval_type_of	icl/type_traits/interval_type_of.hpp	/^    struct interval_type_of$/;"	s	namespace:boost::icl
boost::icl::interval_type_of::type	icl/type_traits/interval_type_of.hpp	/^            get_interval_type<Type, has_interval_type<Type>::value>::type type;$/;"	t	struct:boost::icl::interval_type_of	access:public
boost::icl::inverse	icl/functors.hpp	/^    struct inverse$/;"	s	namespace:boost::icl
boost::icl::inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_bit_add<Type> >$/;"	s	namespace:boost::icl
boost::icl::inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_bit_and<Type> >$/;"	s	namespace:boost::icl
boost::icl::inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_bit_subtract<Type> >$/;"	s	namespace:boost::icl
boost::icl::inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_bit_xor<Type> >$/;"	s	namespace:boost::icl
boost::icl::inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_caret<Type> >$/;"	s	namespace:boost::icl
boost::icl::inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_et<Type> >$/;"	s	namespace:boost::icl
boost::icl::inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_identity<Type> >$/;"	s	namespace:boost::icl
boost::icl::inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_max<Type> >$/;"	s	namespace:boost::icl
boost::icl::inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_min<Type> >$/;"	s	namespace:boost::icl
boost::icl::inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_minus<Type> >$/;"	s	namespace:boost::icl
boost::icl::inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_plus<Type> >$/;"	s	namespace:boost::icl
boost::icl::inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_slash<Type> >$/;"	s	namespace:boost::icl
boost::icl::inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_star<Type> >$/;"	s	namespace:boost::icl
boost::icl::inverse	icl/functors.hpp	/^    struct inverse<icl::inter_section<Type> >$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
boost::icl::inverse::argument_type	icl/functors.hpp	/^            remove_reference<typename Functor::first_argument_type>::type argument_type;$/;"	t	struct:boost::icl::inverse	access:public
boost::icl::inverse::operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inverse	access:public	signature:(Type& object, const Type& operand) const
boost::icl::inverse::type	icl/functors.hpp	/^            type;$/;"	t	struct:boost::icl::inverse	access:public
boost::icl::inverse::type	icl/functors.hpp	/^        typedef icl::inplace_erasure<argument_type> type; $/;"	t	struct:boost::icl::inverse	access:public
boost::icl::inverse::type	icl/functors.hpp	/^    { typedef icl::inplace_bit_add<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
boost::icl::inverse::type	icl/functors.hpp	/^    { typedef icl::inplace_bit_and<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
boost::icl::inverse::type	icl/functors.hpp	/^    { typedef icl::inplace_bit_subtract<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
boost::icl::inverse::type	icl/functors.hpp	/^    { typedef icl::inplace_bit_xor<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
boost::icl::inverse::type	icl/functors.hpp	/^    { typedef icl::inplace_caret<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
boost::icl::inverse::type	icl/functors.hpp	/^    { typedef icl::inplace_erasure<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
boost::icl::inverse::type	icl/functors.hpp	/^    { typedef icl::inplace_et<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
boost::icl::inverse::type	icl/functors.hpp	/^    { typedef icl::inplace_max<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
boost::icl::inverse::type	icl/functors.hpp	/^    { typedef icl::inplace_min<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
boost::icl::inverse::type	icl/functors.hpp	/^    { typedef icl::inplace_minus<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
boost::icl::inverse::type	icl/functors.hpp	/^    { typedef icl::inplace_plus<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
boost::icl::inverse::type	icl/functors.hpp	/^    { typedef icl::inplace_slash<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
boost::icl::inverse::type	icl/functors.hpp	/^    { typedef icl::inplace_star<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
boost::icl::is_associative_element_container	icl/type_traits/is_associative_element_container.hpp	/^    struct is_associative_element_container$/;"	s	namespace:boost::icl
boost::icl::is_associative_element_container::BOOST_STATIC_CONSTANT	icl/type_traits/is_associative_element_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_associative_element_container	access:public	signature:(bool, value = (mpl::or_<is_element_set<Type>, is_element_map<Type> >::value))
boost::icl::is_associative_element_container::type	icl/type_traits/is_associative_element_container.hpp	/^        typedef is_associative_element_container type;$/;"	t	struct:boost::icl::is_associative_element_container	access:public
boost::icl::is_asymmetric_interval	icl/type_traits/is_asymmetric_interval.hpp	/^template <class Type> struct is_asymmetric_interval$/;"	s	namespace:boost::icl
boost::icl::is_asymmetric_interval::BOOST_STATIC_CONSTANT	icl/type_traits/is_asymmetric_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool,$/;"	p	struct:boost::icl::is_asymmetric_interval	access:public	signature:(bool, value = (mpl::and_< is_interval<Type> , has_static_bounds<Type> , has_asymmetric_bounds<Type> >::value) )
boost::icl::is_asymmetric_interval::type	icl/type_traits/is_asymmetric_interval.hpp	/^    typedef is_asymmetric_interval<Type> type;$/;"	t	struct:boost::icl::is_asymmetric_interval	access:public
boost::icl::is_binary_cross_combinable	icl/type_traits/is_combinable.hpp	/^struct is_binary_cross_combinable$/;"	s	namespace:boost::icl
boost::icl::is_binary_cross_combinable::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_binary_cross_combinable	access:public	signature:(bool, value = (mpl::and_ < is_interval_map<GuideT> , mpl::or_< is_coarser_interval_map_companion<GuideT, CompanionT> , is_interval_set_companion<GuideT, CompanionT> > >::value) )
boost::icl::is_binary_cross_combinable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_binary_cross_combinable<GuideT,CompanionT> type;$/;"	t	struct:boost::icl::is_binary_cross_combinable	access:public
boost::icl::is_binary_inter_combinable	icl/type_traits/is_combinable.hpp	/^struct is_binary_inter_combinable$/;"	s	namespace:boost::icl
boost::icl::is_binary_inter_combinable::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_binary_inter_combinable	access:public	signature:(bool, value = (mpl::or_ < mpl::and_<is_interval_map<GuideT>, is_binary_cross_combinable<GuideT, CompanionT> > , mpl::and_<is_interval_set<GuideT>, is_binary_intra_combinable<GuideT, CompanionT> > >::value) )
boost::icl::is_binary_inter_combinable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_binary_inter_combinable<GuideT,CompanionT> type;$/;"	t	struct:boost::icl::is_binary_inter_combinable	access:public
boost::icl::is_binary_interval_map_combinable	icl/type_traits/is_combinable.hpp	/^struct is_binary_interval_map_combinable$/;"	s	namespace:boost::icl
boost::icl::is_binary_interval_map_combinable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_binary_interval_map_combinable<GuideT,CompanionT> type;$/;"	t	struct:boost::icl::is_binary_interval_map_combinable	access:public
boost::icl::is_binary_interval_map_combinable::value	icl/type_traits/is_combinable.hpp	/^    static const int value =$/;"	m	struct:boost::icl::is_binary_interval_map_combinable	access:public
boost::icl::is_binary_interval_set_combinable	icl/type_traits/is_combinable.hpp	/^struct is_binary_interval_set_combinable$/;"	s	namespace:boost::icl
boost::icl::is_binary_interval_set_combinable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_binary_interval_set_combinable<GuideT,CompanionT> type;$/;"	t	struct:boost::icl::is_binary_interval_set_combinable	access:public
boost::icl::is_binary_interval_set_combinable::value	icl/type_traits/is_combinable.hpp	/^    static const int value =$/;"	m	struct:boost::icl::is_binary_interval_set_combinable	access:public
boost::icl::is_binary_intra_combinable	icl/type_traits/is_combinable.hpp	/^struct is_binary_intra_combinable$/;"	s	namespace:boost::icl
boost::icl::is_binary_intra_combinable::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_binary_intra_combinable	access:public	signature:(bool, value = (mpl::or_<is_binary_interval_set_combinable<GuideT, CompanionT>, is_binary_interval_map_combinable<GuideT, CompanionT> >::value) )
boost::icl::is_binary_intra_combinable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_binary_intra_combinable<GuideT,CompanionT> type;$/;"	t	struct:boost::icl::is_binary_intra_combinable	access:public
boost::icl::is_coarser_interval_map_companion	icl/type_traits/is_combinable.hpp	/^struct is_coarser_interval_map_companion$/;"	s	namespace:boost::icl
boost::icl::is_coarser_interval_map_companion::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_coarser_interval_map_companion	access:public	signature:(bool, value = (mpl::and_ < is_interval_map_companion<GuideT, CompanionT> , mpl::bool_<( segmentational_fineness<GuideT>::value > segmentational_fineness<CompanionT>::value)> >::value) )
boost::icl::is_coarser_interval_map_companion::type	icl/type_traits/is_combinable.hpp	/^    typedef is_coarser_interval_map_companion<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_coarser_interval_map_companion	access:public
boost::icl::is_coarser_interval_set_companion	icl/type_traits/is_combinable.hpp	/^struct is_coarser_interval_set_companion$/;"	s	namespace:boost::icl
boost::icl::is_coarser_interval_set_companion::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_coarser_interval_set_companion	access:public	signature:(bool, value = (mpl::and_ < is_interval_set_companion<GuideT, CompanionT> , mpl::bool_<( segmentational_fineness<GuideT>::value > segmentational_fineness<CompanionT>::value)> >::value) )
boost::icl::is_coarser_interval_set_companion::type	icl/type_traits/is_combinable.hpp	/^    typedef is_coarser_interval_set_companion<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_coarser_interval_set_companion	access:public
boost::icl::is_codomain_equal	icl/type_traits/is_combinable.hpp	/^struct is_codomain_equal$/;"	s	namespace:boost::icl
boost::icl::is_codomain_equal::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_codomain_equal	access:public	signature:(bool, value = (boost::is_same<typename LeftT::codomain_type, typename RightT::codomain_type>::value) )
boost::icl::is_codomain_equal::type	icl/type_traits/is_combinable.hpp	/^    typedef is_codomain_equal<LeftT, RightT> type;$/;"	t	struct:boost::icl::is_codomain_equal	access:public
boost::icl::is_codomain_type_equal	icl/type_traits/is_combinable.hpp	/^struct is_codomain_type_equal$/;"	s	namespace:boost::icl
boost::icl::is_codomain_type_equal::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_codomain_type_equal	access:public	signature:(bool, value = (mpl::and_<is_key_compare_equal<LeftT, RightT>, is_codomain_equal<LeftT, RightT> >::value) )
boost::icl::is_codomain_type_equal::type	icl/type_traits/is_combinable.hpp	/^    typedef is_codomain_type_equal<LeftT, RightT> type;$/;"	t	struct:boost::icl::is_codomain_type_equal	access:public
boost::icl::is_complementary	icl/concept/interval_bounds.hpp	/^inline bool is_complementary(interval_bounds x1)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1)
boost::icl::is_concept_combinable	icl/type_traits/is_combinable.hpp	/^struct is_concept_combinable$/;"	s	namespace:boost::icl
boost::icl::is_concept_combinable::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_concept_combinable	access:public	signature:(bool, value = (mpl::and_< LeftConcept<LeftT> , RightConcept<RightT> , is_key_compare_equal<LeftT, RightT> >::value) )
boost::icl::is_concept_combinable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_concept_combinable<LeftConcept, RightConcept, LeftT, RightT> type;$/;"	t	struct:boost::icl::is_concept_combinable	access:public
boost::icl::is_concept_compatible	icl/type_traits/is_combinable.hpp	/^struct is_concept_compatible$/;"	s	namespace:boost::icl
boost::icl::is_concept_compatible::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_concept_compatible	access:public	signature:(bool, value = (mpl::and_< IsConcept<LeftT> , IsConcept<RightT> , is_codomain_type_equal<LeftT, RightT> >::value) )
boost::icl::is_concept_compatible::type	icl/type_traits/is_combinable.hpp	/^    typedef is_concept_compatible<IsConcept, LeftT, RightT> type;$/;"	t	struct:boost::icl::is_concept_compatible	access:public
boost::icl::is_concept_equivalent	icl/type_traits/is_concept_equivalent.hpp	/^    struct is_concept_equivalent$/;"	s	namespace:boost::icl
boost::icl::is_concept_equivalent::BOOST_STATIC_CONSTANT	icl/type_traits/is_concept_equivalent.hpp	/^        BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_concept_equivalent	access:public	signature:(bool, value = (mpl::and_<IsConcept<LeftT>, IsConcept<RightT> >::value) )
boost::icl::is_concept_equivalent::type	icl/type_traits/is_concept_equivalent.hpp	/^        typedef is_concept_equivalent<IsConcept, LeftT, RightT> type;$/;"	t	struct:boost::icl::is_concept_equivalent	access:public
boost::icl::is_container	icl/type_traits/is_container.hpp	/^    struct is_container $/;"	s	namespace:boost::icl	inherits:mpl::bool_
boost::icl::is_continuous	icl/rational.hpp	/^    struct is_continuous<boost::rational<Integral> >$/;"	s	namespace:boost::icl
boost::icl::is_continuous	icl/type_traits/is_continuous.hpp	/^    template <class Type> struct is_continuous$/;"	s	namespace:boost::icl
boost::icl::is_continuous::BOOST_STATIC_CONSTANT	icl/rational.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_continuous	access:public	signature:(bool, value = true)
boost::icl::is_continuous::BOOST_STATIC_CONSTANT	icl/type_traits/is_continuous.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_continuous	access:public	signature:(bool, value = mpl::not_<is_discrete<Type> >::value)
boost::icl::is_continuous::type	icl/rational.hpp	/^        typedef is_continuous type;$/;"	t	struct:boost::icl::is_continuous	access:public
boost::icl::is_continuous::type	icl/type_traits/is_continuous.hpp	/^        typedef is_continuous type;$/;"	t	struct:boost::icl::is_continuous	access:public
boost::icl::is_continuous_asymmetric	icl/type_traits/is_asymmetric_interval.hpp	/^template <class Type> struct is_continuous_asymmetric$/;"	s	namespace:boost::icl
boost::icl::is_continuous_asymmetric::BOOST_STATIC_CONSTANT	icl/type_traits/is_asymmetric_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool,$/;"	p	struct:boost::icl::is_continuous_asymmetric	access:public	signature:(bool, value = (mpl::and_< is_asymmetric_interval<Type> , is_continuous<typename domain_type_of<interval_traits<Type> >::type> >::value) )
boost::icl::is_continuous_asymmetric::type	icl/type_traits/is_asymmetric_interval.hpp	/^    typedef is_continuous_asymmetric<Type> type;$/;"	t	struct:boost::icl::is_continuous_asymmetric	access:public
boost::icl::is_continuous_interval	icl/continuous_interval.hpp	/^struct is_continuous_interval<continuous_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::is_continuous_interval	icl/type_traits/is_continuous_interval.hpp	/^template <class Type> struct is_continuous_interval$/;"	s	namespace:boost::icl
boost::icl::is_continuous_interval::BOOST_STATIC_CONSTANT	icl/continuous_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_continuous_interval	access:public	signature:(bool, value = true)
boost::icl::is_continuous_interval::BOOST_STATIC_CONSTANT	icl/type_traits/is_continuous_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_continuous_interval	access:public	signature:(bool, value = false)
boost::icl::is_continuous_interval::type	icl/continuous_interval.hpp	/^    typedef is_continuous_interval<continuous_interval<DomainT,Compare> > type;$/;"	t	struct:boost::icl::is_continuous_interval	access:public
boost::icl::is_continuous_interval::type	icl/type_traits/is_continuous_interval.hpp	/^    typedef is_continuous_interval<Type> type;$/;"	t	struct:boost::icl::is_continuous_interval	access:public
boost::icl::is_continuous_left_open	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_continuous_left_open$/;"	s	namespace:boost::icl
boost::icl::is_continuous_left_open::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_continuous_left_open	access:public	signature:(bool, value = (mpl::and_<is_static_left_open<Type>, is_continuous<domain_type> >::value))
boost::icl::is_continuous_left_open::domain_type	icl/type_traits/is_interval.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::is_continuous_left_open	access:public
boost::icl::is_continuous_left_open::type	icl/type_traits/is_interval.hpp	/^    typedef is_continuous_left_open<Type> type;$/;"	t	struct:boost::icl::is_continuous_left_open	access:public
boost::icl::is_continuous_right_open	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_continuous_right_open$/;"	s	namespace:boost::icl
boost::icl::is_continuous_right_open::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_continuous_right_open	access:public	signature:(bool, value = (mpl::and_<is_static_right_open<Type>, is_continuous<domain_type> >::value))
boost::icl::is_continuous_right_open::domain_type	icl/type_traits/is_interval.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::is_continuous_right_open	access:public
boost::icl::is_continuous_right_open::type	icl/type_traits/is_interval.hpp	/^    typedef is_continuous_right_open<Type> type;$/;"	t	struct:boost::icl::is_continuous_right_open	access:public
boost::icl::is_continuous_static	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_continuous_static$/;"	s	namespace:boost::icl
boost::icl::is_continuous_static::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_continuous_static	access:public	signature:(bool, value = (mpl::and_< has_static_bounds<Type> , is_continuous<domain_type> , has_asymmetric_bounds<Type> >::value) )
boost::icl::is_continuous_static::domain_type	icl/type_traits/is_interval.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::is_continuous_static	access:public
boost::icl::is_continuous_static::type	icl/type_traits/is_interval.hpp	/^    typedef is_continuous_static type;$/;"	t	struct:boost::icl::is_continuous_static	access:public
boost::icl::is_cross_combinable	icl/type_traits/is_combinable.hpp	/^struct is_cross_combinable$/;"	s	namespace:boost::icl
boost::icl::is_cross_combinable::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_cross_combinable	access:public	signature:(bool, value = (mpl::or_< is_concept_combinable<is_interval_set, is_interval_map, LeftT, RightT> , is_concept_combinable<is_interval_map, is_interval_set, LeftT, RightT> >::value) )
boost::icl::is_cross_combinable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_cross_combinable<LeftT, RightT> type;$/;"	t	struct:boost::icl::is_cross_combinable	access:public
boost::icl::is_cross_derivative	icl/type_traits/is_combinable.hpp	/^struct is_cross_derivative$/;"	s	namespace:boost::icl
boost::icl::is_cross_derivative::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_cross_derivative	access:public	signature:(bool, value = (mpl::and_< is_interval_map<Type> , is_interval_set_derivative<Type, AssociateT> >::value) )
boost::icl::is_cross_derivative::type	icl/type_traits/is_combinable.hpp	/^    typedef is_cross_derivative<Type, AssociateT> type;$/;"	t	struct:boost::icl::is_cross_derivative	access:public
boost::icl::is_discrete	icl/gregorian.hpp	/^    template<> struct is_discrete<boost::gregorian::date>$/;"	s	namespace:boost::icl
boost::icl::is_discrete	icl/gregorian.hpp	/^    template<> struct is_discrete<boost::gregorian::date_duration>$/;"	s	namespace:boost::icl
boost::icl::is_discrete	icl/ptime.hpp	/^    template<> struct is_discrete<boost::posix_time::ptime>$/;"	s	namespace:boost::icl
boost::icl::is_discrete	icl/ptime.hpp	/^    template<> struct is_discrete<boost::posix_time::time_duration>$/;"	s	namespace:boost::icl
boost::icl::is_discrete	icl/rational.hpp	/^    struct is_discrete<boost::rational<Integral> >$/;"	s	namespace:boost::icl
boost::icl::is_discrete	icl/type_traits/is_discrete.hpp	/^    template <class Type> struct is_discrete$/;"	s	namespace:boost::icl
boost::icl::is_discrete::BOOST_STATIC_CONSTANT	icl/gregorian.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_discrete	access:public	signature:(bool, value = true)
boost::icl::is_discrete::BOOST_STATIC_CONSTANT	icl/ptime.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_discrete	access:public	signature:(bool, value = true)
boost::icl::is_discrete::BOOST_STATIC_CONSTANT	icl/rational.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_discrete	access:public	signature:(bool, value = false)
boost::icl::is_discrete::BOOST_STATIC_CONSTANT	icl/type_traits/is_discrete.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_discrete	access:public	signature:(bool, value = (mpl::and_ < boost::detail::is_incrementable<Type> , mpl::or_ < mpl::and_ < mpl::not_<has_rep_type<Type> > , is_non_floating_point<Type> > , mpl::and_ < has_rep_type<Type> , is_discrete<typename rep_type_of<Type>::type> > > >::value ) )
boost::icl::is_discrete::type	icl/gregorian.hpp	/^        typedef is_discrete type;$/;"	t	struct:boost::icl::is_discrete	access:public
boost::icl::is_discrete::type	icl/ptime.hpp	/^        typedef is_discrete type;$/;"	t	struct:boost::icl::is_discrete	access:public
boost::icl::is_discrete::type	icl/rational.hpp	/^        typedef is_discrete type;$/;"	t	struct:boost::icl::is_discrete	access:public
boost::icl::is_discrete::type	icl/type_traits/is_discrete.hpp	/^        typedef is_discrete type;$/;"	t	struct:boost::icl::is_discrete	access:public
boost::icl::is_discrete_asymmetric	icl/type_traits/is_asymmetric_interval.hpp	/^template <class Type> struct is_discrete_asymmetric$/;"	s	namespace:boost::icl
boost::icl::is_discrete_asymmetric::BOOST_STATIC_CONSTANT	icl/type_traits/is_asymmetric_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool,$/;"	p	struct:boost::icl::is_discrete_asymmetric	access:public	signature:(bool, value = (mpl::and_< is_asymmetric_interval<Type> , mpl::not_<is_continuous<typename domain_type_of<interval_traits<Type> >::type> > >::value) )
boost::icl::is_discrete_asymmetric::type	icl/type_traits/is_asymmetric_interval.hpp	/^    typedef is_discrete_asymmetric<Type> type;$/;"	t	struct:boost::icl::is_discrete_asymmetric	access:public
boost::icl::is_discrete_interval	icl/discrete_interval.hpp	/^struct is_discrete_interval<discrete_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::is_discrete_interval	icl/type_traits/is_discrete_interval.hpp	/^template <class Type> struct is_discrete_interval$/;"	s	namespace:boost::icl
boost::icl::is_discrete_interval::BOOST_STATIC_CONSTANT	icl/discrete_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = is_discrete<DomainT>::value);$/;"	p	struct:boost::icl::is_discrete_interval	access:public	signature:(bool, value = is_discrete<DomainT>::value)
boost::icl::is_discrete_interval::BOOST_STATIC_CONSTANT	icl/type_traits/is_discrete_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_discrete_interval	access:public	signature:(bool, value = false)
boost::icl::is_discrete_interval::type	icl/discrete_interval.hpp	/^    typedef is_discrete_interval<discrete_interval<DomainT,Compare> > type;$/;"	t	struct:boost::icl::is_discrete_interval	access:public
boost::icl::is_discrete_interval::type	icl/type_traits/is_discrete_interval.hpp	/^    typedef is_discrete_interval<Type> type;$/;"	t	struct:boost::icl::is_discrete_interval	access:public
boost::icl::is_discrete_static	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_discrete_static$/;"	s	namespace:boost::icl
boost::icl::is_discrete_static::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_discrete_static	access:public	signature:(bool, value = (mpl::and_< has_static_bounds<Type> , is_discrete<domain_type> >::value) )
boost::icl::is_discrete_static::domain_type	icl/type_traits/is_interval.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::is_discrete_static	access:public
boost::icl::is_discrete_static::type	icl/type_traits/is_interval.hpp	/^    typedef is_discrete_static type;$/;"	t	struct:boost::icl::is_discrete_static	access:public
boost::icl::is_discrete_static_closed	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_discrete_static_closed$/;"	s	namespace:boost::icl
boost::icl::is_discrete_static_closed::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT( bool, $/;"	p	struct:boost::icl::is_discrete_static_closed	access:public	signature:( bool, value = (mpl::and_< is_static_closed<Type> , is_discrete<domain_type> >::value) )
boost::icl::is_discrete_static_closed::domain_type	icl/type_traits/is_interval.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::is_discrete_static_closed	access:public
boost::icl::is_discrete_static_closed::type	icl/type_traits/is_interval.hpp	/^    typedef is_static_closed<Type> type;$/;"	t	struct:boost::icl::is_discrete_static_closed	access:public
boost::icl::is_discrete_static_open	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_discrete_static_open$/;"	s	namespace:boost::icl
boost::icl::is_discrete_static_open::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT( bool, $/;"	p	struct:boost::icl::is_discrete_static_open	access:public	signature:( bool, value = (mpl::and_< is_static_open<Type> , is_discrete<domain_type> >::value) )
boost::icl::is_discrete_static_open::domain_type	icl/type_traits/is_interval.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::is_discrete_static_open	access:public
boost::icl::is_discrete_static_open::type	icl/type_traits/is_interval.hpp	/^    typedef is_static_closed<Type> type;$/;"	t	struct:boost::icl::is_discrete_static_open	access:public
boost::icl::is_distinct_equal	icl/concept/element_map.hpp	/^is_distinct_equal(const Type& lhs, const Type& rhs)$/;"	f	namespace:boost::icl	signature:(const Type& lhs, const Type& rhs)
boost::icl::is_distinct_equal	icl/concept/interval_associator.hpp	/^is_distinct_equal(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
boost::icl::is_element_container	icl/type_traits/is_element_container.hpp	/^    struct is_element_container$/;"	s	namespace:boost::icl
boost::icl::is_element_container::BOOST_STATIC_CONSTANT	icl/type_traits/is_element_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_element_container	access:public	signature:(bool, value = (mpl::or_<is_element_set<Type>, is_element_map<Type> >::value) )
boost::icl::is_element_container::type	icl/type_traits/is_element_container.hpp	/^        typedef is_element_container<Type> type;$/;"	t	struct:boost::icl::is_element_container	access:public
boost::icl::is_element_equal	icl/concept/element_associator.hpp	/^is_element_equal(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::is_element_equal	icl/concept/interval_associator.hpp	/^is_element_equal(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
boost::icl::is_element_greater	icl/concept/interval_associator.hpp	/^is_element_greater(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
boost::icl::is_element_less	icl/concept/interval_associator.hpp	/^is_element_less(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
boost::icl::is_element_map	icl/type_traits/is_element_container.hpp	/^    struct is_element_map$/;"	s	namespace:boost::icl
boost::icl::is_element_map::BOOST_STATIC_CONSTANT	icl/type_traits/is_element_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_element_map	access:public	signature:(bool, value = (mpl::and_<is_map<Type>, mpl::not_<is_interval_container<Type> > >::value) )
boost::icl::is_element_map::type	icl/type_traits/is_element_container.hpp	/^        typedef is_element_map<Type> type;$/;"	t	struct:boost::icl::is_element_map	access:public
boost::icl::is_element_set	icl/type_traits/is_element_container.hpp	/^    struct is_element_set$/;"	s	namespace:boost::icl
boost::icl::is_element_set::BOOST_STATIC_CONSTANT	icl/type_traits/is_element_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_element_set	access:public	signature:(bool, value = (mpl::or_< mpl::and_< is_set<Type> , mpl::not_<is_interval_container<Type> > > , is_std_set<Type> >::value) )
boost::icl::is_element_set::type	icl/type_traits/is_element_container.hpp	/^        typedef is_element_set<Type> type;$/;"	t	struct:boost::icl::is_element_set	access:public
boost::icl::is_empty	icl/concept/container.hpp	/^is_empty(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::is_empty	icl/concept/interval.hpp	/^is_empty(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::is_fixed_numeric	icl/type_traits/is_numeric.hpp	/^template <class Type> struct is_fixed_numeric$/;"	s	namespace:boost::icl
boost::icl::is_fixed_numeric::BOOST_STATIC_CONSTANT	icl/type_traits/is_numeric.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (0 < std::numeric_limits<Type>::digits));$/;"	p	struct:boost::icl::is_fixed_numeric	access:public	signature:(bool, value = (0 < std::numeric_limits<Type>::digits))
boost::icl::is_fixed_numeric::type	icl/type_traits/is_numeric.hpp	/^    typedef is_fixed_numeric type;$/;"	t	struct:boost::icl::is_fixed_numeric	access:public
boost::icl::is_fragment_of	icl/type_traits/is_combinable.hpp	/^struct is_fragment_of$/;"	s	namespace:boost::icl
boost::icl::is_fragment_of	icl/type_traits/is_combinable.hpp	/^struct is_fragment_of<typename Type::element_type, Type>$/;"	s	namespace:boost::icl
boost::icl::is_fragment_of	icl/type_traits/is_combinable.hpp	/^struct is_fragment_of<typename Type::segment_type, Type>$/;"	s	namespace:boost::icl
boost::icl::is_fragment_of::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_fragment_of	access:public	signature:(bool, value = false)
boost::icl::is_fragment_of::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_fragment_of	access:public	signature:(bool, value = true)
boost::icl::is_fragment_of::type	icl/type_traits/is_combinable.hpp	/^    typedef is_fragment_of type;$/;"	t	struct:boost::icl::is_fragment_of	access:public
boost::icl::is_icl_container	icl/type_traits/is_icl_container.hpp	/^    struct is_icl_container$/;"	s	namespace:boost::icl
boost::icl::is_icl_container::BOOST_STATIC_CONSTANT	icl/type_traits/is_icl_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_icl_container	access:public	signature:(bool, value = (mpl::or_< is_element_container<Type> , is_interval_container<Type> >::value))
boost::icl::is_icl_container::type	icl/type_traits/is_icl_container.hpp	/^        typedef is_icl_container<Type> type;$/;"	t	struct:boost::icl::is_icl_container	access:public
boost::icl::is_increasing	icl/type_traits/is_increasing.hpp	/^struct is_increasing$/;"	s	namespace:boost::icl
boost::icl::is_increasing	icl/type_traits/is_increasing.hpp	/^struct is_increasing<DomainT, std::greater<DomainT> >$/;"	s	namespace:boost::icl
boost::icl::is_increasing::BOOST_STATIC_CONSTANT	icl/type_traits/is_increasing.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_increasing	access:public	signature:(bool, value = false)
boost::icl::is_increasing::BOOST_STATIC_CONSTANT	icl/type_traits/is_increasing.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_increasing	access:public	signature:(bool, value = true)
boost::icl::is_increasing::type	icl/type_traits/is_increasing.hpp	/^    typedef is_increasing type;$/;"	t	struct:boost::icl::is_increasing	access:public
boost::icl::is_inter_combinable	icl/type_traits/is_combinable.hpp	/^struct is_inter_combinable$/;"	s	namespace:boost::icl
boost::icl::is_inter_combinable::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_inter_combinable	access:public	signature:(bool, value = (mpl::or_<is_intra_combinable<LeftT,RightT>, is_cross_combinable<LeftT,RightT> >::value) )
boost::icl::is_inter_combinable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_inter_combinable<LeftT, RightT> type;$/;"	t	struct:boost::icl::is_inter_combinable	access:public
boost::icl::is_inter_derivative	icl/type_traits/is_combinable.hpp	/^struct is_inter_derivative$/;"	s	namespace:boost::icl
boost::icl::is_inter_derivative::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_inter_derivative	access:public	signature:(bool, value = (mpl::or_< is_intra_derivative<Type, AssociateT> , is_cross_derivative<Type, AssociateT> >::value) )
boost::icl::is_inter_derivative::type	icl/type_traits/is_combinable.hpp	/^    typedef is_inter_derivative<Type, AssociateT> type;$/;"	t	struct:boost::icl::is_inter_derivative	access:public
boost::icl::is_interval	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_interval$/;"	s	namespace:boost::icl
boost::icl::is_interval::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_interval	access:public	signature:(bool, value = ((interval_bound_type<Type>::value) < interval_bounds::undefined))
boost::icl::is_interval::type	icl/type_traits/is_interval.hpp	/^    typedef is_interval<Type> type;$/;"	t	struct:boost::icl::is_interval	access:public
boost::icl::is_interval_container	icl/interval_base_map.hpp	/^struct is_interval_container<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_interval_container	icl/interval_base_set.hpp	/^struct is_interval_container<icl::interval_base_set<SubType,DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_interval_container	icl/interval_map.hpp	/^struct is_interval_container<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_interval_container	icl/interval_set.hpp	/^struct is_interval_container<icl::interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_interval_container	icl/separate_interval_set.hpp	/^struct is_interval_container<icl::separate_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_interval_container	icl/split_interval_map.hpp	/^struct is_interval_container<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_interval_container	icl/split_interval_set.hpp	/^struct is_interval_container<icl::split_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_interval_container	icl/type_traits/is_interval_container.hpp	/^    template <class Type> struct is_interval_container$/;"	s	namespace:boost::icl
boost::icl::is_interval_container::BOOST_STATIC_CONSTANT	icl/interval_base_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = true)
boost::icl::is_interval_container::BOOST_STATIC_CONSTANT	icl/interval_base_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = true)
boost::icl::is_interval_container::BOOST_STATIC_CONSTANT	icl/interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = true)
boost::icl::is_interval_container::BOOST_STATIC_CONSTANT	icl/interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = true)
boost::icl::is_interval_container::BOOST_STATIC_CONSTANT	icl/separate_interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = true)
boost::icl::is_interval_container::BOOST_STATIC_CONSTANT	icl/split_interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = true)
boost::icl::is_interval_container::BOOST_STATIC_CONSTANT	icl/split_interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = true)
boost::icl::is_interval_container::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false); $/;"	p	struct:boost::icl::is_interval_container	access:public	signature:(bool, value = false)
boost::icl::is_interval_container::type	icl/interval_base_map.hpp	/^    typedef is_interval_container<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_container	access:public
boost::icl::is_interval_container::type	icl/interval_base_set.hpp	/^    typedef is_interval_container<icl::interval_base_set<SubType,DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_container	access:public
boost::icl::is_interval_container::type	icl/interval_map.hpp	/^    typedef is_interval_container<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_container	access:public
boost::icl::is_interval_container::type	icl/interval_set.hpp	/^    typedef is_interval_container<icl::interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_container	access:public
boost::icl::is_interval_container::type	icl/separate_interval_set.hpp	/^    typedef is_interval_container<icl::separate_interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_container	access:public
boost::icl::is_interval_container::type	icl/split_interval_map.hpp	/^    typedef is_interval_container<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_container	access:public
boost::icl::is_interval_container::type	icl/split_interval_set.hpp	/^    typedef is_interval_container<icl::split_interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_container	access:public
boost::icl::is_interval_container::type	icl/type_traits/is_interval_container.hpp	/^        typedef is_interval_container<Type> type;$/;"	t	struct:boost::icl::is_interval_container	access:public
boost::icl::is_interval_joiner	icl/interval_set.hpp	/^struct is_interval_joiner<icl::interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_interval_joiner	icl/type_traits/is_interval_joiner.hpp	/^    template <class Type> struct is_interval_joiner$/;"	s	namespace:boost::icl
boost::icl::is_interval_joiner::BOOST_STATIC_CONSTANT	icl/interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_joiner	access:public	signature:(bool, value = true)
boost::icl::is_interval_joiner::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval_joiner.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false); $/;"	p	struct:boost::icl::is_interval_joiner	access:public	signature:(bool, value = false)
boost::icl::is_interval_joiner::type	icl/interval_set.hpp	/^    typedef is_interval_joiner<icl::interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_joiner	access:public
boost::icl::is_interval_joiner::type	icl/type_traits/is_interval_joiner.hpp	/^        typedef is_interval_joiner<Type> type;$/;"	t	struct:boost::icl::is_interval_joiner	access:public
boost::icl::is_interval_map	icl/type_traits/is_interval_container.hpp	/^    struct is_interval_map$/;"	s	namespace:boost::icl
boost::icl::is_interval_map::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_interval_map	access:public	signature:(bool, value = (mpl::and_<is_interval_container<Type>, is_map<Type> >::value) )
boost::icl::is_interval_map::type	icl/type_traits/is_interval_container.hpp	/^        typedef is_interval_map<Type> type; $/;"	t	struct:boost::icl::is_interval_map	access:public
boost::icl::is_interval_map_companion	icl/type_traits/is_combinable.hpp	/^template<class GuideT, class CompanionT> struct is_interval_map_companion$/;"	s	namespace:boost::icl
boost::icl::is_interval_map_companion::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_interval_map_companion	access:public	signature:(bool, value = (mpl::or_ < combines_right_to_interval_map<GuideT,CompanionT> , is_interval_map_derivative<GuideT,CompanionT> >::value) )
boost::icl::is_interval_map_companion::type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_map_companion<GuideT,CompanionT> type;$/;"	t	struct:boost::icl::is_interval_map_companion	access:public
boost::icl::is_interval_map_derivative	icl/type_traits/is_combinable.hpp	/^struct is_interval_map_derivative$/;"	s	namespace:boost::icl
boost::icl::is_interval_map_derivative	icl/type_traits/is_combinable.hpp	/^struct is_interval_map_derivative<Type, typename Type::domain_mapping_type>$/;"	s	namespace:boost::icl
boost::icl::is_interval_map_derivative	icl/type_traits/is_combinable.hpp	/^struct is_interval_map_derivative<Type, typename Type::interval_mapping_type>$/;"	s	namespace:boost::icl
boost::icl::is_interval_map_derivative	icl/type_traits/is_combinable.hpp	/^struct is_interval_map_derivative<Type, typename Type::value_type>$/;"	s	namespace:boost::icl
boost::icl::is_interval_map_derivative::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (is_interval_container<Type>::value));$/;"	p	struct:boost::icl::is_interval_map_derivative	access:public	signature:(bool, value = (is_interval_container<Type>::value))
boost::icl::is_interval_map_derivative::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_interval_map_derivative	access:public	signature:(bool, value = false)
boost::icl::is_interval_map_derivative::type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_map_derivative type;$/;"	t	struct:boost::icl::is_interval_map_derivative	access:public
boost::icl::is_interval_map_derivative::type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_map_derivative<Type, AssociateT> type;$/;"	t	struct:boost::icl::is_interval_map_derivative	access:public
boost::icl::is_interval_map_right_cross_combinable	icl/type_traits/is_combinable.hpp	/^struct is_interval_map_right_cross_combinable \/\/NOTE equivalent to key_type_of<Comp, Guide>$/;"	s	namespace:boost::icl
boost::icl::is_interval_map_right_cross_combinable::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_interval_map_right_cross_combinable	access:public	signature:(bool, value = (mpl::and_ < is_interval_map<GuideT> , mpl::or_ < is_cross_derivative<GuideT, CompanionT> , is_concept_combinable<is_interval_map, is_interval_set, GuideT, CompanionT> > >::value) )
boost::icl::is_interval_map_right_cross_combinable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_map_right_cross_combinable<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_interval_map_right_cross_combinable	access:public
boost::icl::is_interval_map_right_inter_combinable	icl/type_traits/is_combinable.hpp	/^struct is_interval_map_right_inter_combinable$/;"	s	namespace:boost::icl
boost::icl::is_interval_map_right_inter_combinable::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_interval_map_right_inter_combinable	access:public	signature:(bool, value = (mpl::or_< is_interval_map_right_intra_combinable<GuideT, CompanionT> , is_interval_map_right_cross_combinable<GuideT, CompanionT> >::value) )
boost::icl::is_interval_map_right_inter_combinable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_map_right_inter_combinable<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_interval_map_right_inter_combinable	access:public
boost::icl::is_interval_map_right_intra_combinable	icl/type_traits/is_combinable.hpp	/^struct is_interval_map_right_intra_combinable \/\/NOTE equivalent to is_fragment_type_of$/;"	s	namespace:boost::icl
boost::icl::is_interval_map_right_intra_combinable::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_interval_map_right_intra_combinable	access:public	signature:(bool, value = (mpl::and_ < is_interval_map<GuideT> , mpl::or_ < is_interval_map_derivative<GuideT, CompanionT> , is_concept_compatible<is_interval_map, GuideT, CompanionT> > >::value) )
boost::icl::is_interval_map_right_intra_combinable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_map_right_intra_combinable<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_interval_map_right_intra_combinable	access:public
boost::icl::is_interval_separator	icl/separate_interval_set.hpp	/^struct is_interval_separator<icl::separate_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_interval_separator	icl/type_traits/is_interval_separator.hpp	/^    template <class Type> struct is_interval_separator$/;"	s	namespace:boost::icl
boost::icl::is_interval_separator::BOOST_STATIC_CONSTANT	icl/separate_interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_separator	access:public	signature:(bool, value = true)
boost::icl::is_interval_separator::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval_separator.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false); $/;"	p	struct:boost::icl::is_interval_separator	access:public	signature:(bool, value = false)
boost::icl::is_interval_separator::type	icl/separate_interval_set.hpp	/^    typedef is_interval_separator<icl::separate_interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_separator	access:public
boost::icl::is_interval_separator::type	icl/type_traits/is_interval_separator.hpp	/^        typedef is_interval_separator<Type> type;$/;"	t	struct:boost::icl::is_interval_separator	access:public
boost::icl::is_interval_set	icl/type_traits/is_interval_container.hpp	/^    struct is_interval_set$/;"	s	namespace:boost::icl
boost::icl::is_interval_set::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_interval_set	access:public	signature:(bool, value = (mpl::and_< is_interval_container<Type>, mpl::not_<is_interval_map<Type> > >::value) )
boost::icl::is_interval_set::type	icl/type_traits/is_interval_container.hpp	/^        typedef is_interval_set<Type> type; $/;"	t	struct:boost::icl::is_interval_set	access:public
boost::icl::is_interval_set_companion	icl/type_traits/is_combinable.hpp	/^template<class GuideT, class CompanionT> struct is_interval_set_companion$/;"	s	namespace:boost::icl
boost::icl::is_interval_set_companion::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_interval_set_companion	access:public	signature:(bool, value = (mpl::or_ < combines_right_to_interval_set<GuideT,CompanionT> , is_interval_set_derivative<GuideT,CompanionT> >::value) )
boost::icl::is_interval_set_companion::type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_set_companion<GuideT,CompanionT> type;$/;"	t	struct:boost::icl::is_interval_set_companion	access:public
boost::icl::is_interval_set_derivative	icl/type_traits/is_combinable.hpp	/^struct is_interval_set_derivative$/;"	s	namespace:boost::icl
boost::icl::is_interval_set_derivative	icl/type_traits/is_combinable.hpp	/^struct is_interval_set_derivative<Type, typename Type::domain_type>$/;"	s	namespace:boost::icl
boost::icl::is_interval_set_derivative	icl/type_traits/is_combinable.hpp	/^struct is_interval_set_derivative<Type, typename Type::interval_type>$/;"	s	namespace:boost::icl
boost::icl::is_interval_set_derivative::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (is_interval_container<Type>::value)); $/;"	p	struct:boost::icl::is_interval_set_derivative	access:public	signature:(bool, value = (is_interval_container<Type>::value))
boost::icl::is_interval_set_derivative::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_interval_set_derivative	access:public	signature:(bool, value = false)
boost::icl::is_interval_set_derivative::type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_set_derivative type;$/;"	t	struct:boost::icl::is_interval_set_derivative	access:public
boost::icl::is_interval_set_derivative::type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_set_derivative<Type, AssociateT> type;$/;"	t	struct:boost::icl::is_interval_set_derivative	access:public
boost::icl::is_interval_set_right_combinable	icl/type_traits/is_combinable.hpp	/^struct is_interval_set_right_combinable$/;"	s	namespace:boost::icl
boost::icl::is_interval_set_right_combinable::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_interval_set_right_combinable	access:public	signature:(bool, value = (mpl::and_ < is_interval_set<GuideT> , mpl::or_ < is_interval_set_derivative<GuideT, CompanionT> , is_concept_compatible<is_interval_set, GuideT, CompanionT> > >::value) )
boost::icl::is_interval_set_right_combinable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_set_right_combinable<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_interval_set_right_combinable	access:public
boost::icl::is_interval_splitter	icl/split_interval_map.hpp	/^struct is_interval_splitter<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_interval_splitter	icl/split_interval_set.hpp	/^struct is_interval_splitter<icl::split_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_interval_splitter	icl/type_traits/is_interval_splitter.hpp	/^    template <class Type> struct is_interval_splitter$/;"	s	namespace:boost::icl
boost::icl::is_interval_splitter::BOOST_STATIC_CONSTANT	icl/split_interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_interval_splitter	access:public	signature:(bool, value = true)
boost::icl::is_interval_splitter::BOOST_STATIC_CONSTANT	icl/split_interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_interval_splitter	access:public	signature:(bool, value = true)
boost::icl::is_interval_splitter::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval_splitter.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false); $/;"	p	struct:boost::icl::is_interval_splitter	access:public	signature:(bool, value = false)
boost::icl::is_interval_splitter::type	icl/split_interval_map.hpp	/^    typedef is_interval_splitter<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_splitter	access:public
boost::icl::is_interval_splitter::type	icl/split_interval_set.hpp	/^    typedef is_interval_splitter<icl::split_interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_splitter	access:public
boost::icl::is_interval_splitter::type	icl/type_traits/is_interval_splitter.hpp	/^        typedef is_interval_splitter<Type> type;$/;"	t	struct:boost::icl::is_interval_splitter	access:public
boost::icl::is_intra_combinable	icl/type_traits/is_combinable.hpp	/^struct is_intra_combinable$/;"	s	namespace:boost::icl
boost::icl::is_intra_combinable::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_intra_combinable	access:public	signature:(bool, value = (mpl::or_< is_concept_compatible<is_interval_set, LeftT, RightT> , is_concept_compatible<is_interval_map, LeftT, RightT> >::value) )
boost::icl::is_intra_combinable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_intra_combinable<LeftT, RightT> type;$/;"	t	struct:boost::icl::is_intra_combinable	access:public
boost::icl::is_intra_derivative	icl/type_traits/is_combinable.hpp	/^struct is_intra_derivative$/;"	s	namespace:boost::icl
boost::icl::is_intra_derivative::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_intra_derivative	access:public	signature:(bool, value = (mpl::or_ < mpl::and_<is_interval_set<Type>, is_interval_set_derivative<Type, AssociateT> > , mpl::and_<is_interval_map<Type>, is_interval_map_derivative<Type, AssociateT> > >::value) )
boost::icl::is_intra_derivative::type	icl/type_traits/is_combinable.hpp	/^    typedef is_intra_derivative<Type, AssociateT> type;$/;"	t	struct:boost::icl::is_intra_derivative	access:public
boost::icl::is_key_compare_equal	icl/type_traits/is_combinable.hpp	/^struct is_key_compare_equal$/;"	s	namespace:boost::icl
boost::icl::is_key_compare_equal::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_key_compare_equal	access:public	signature:(bool, value = (boost::is_same<typename LeftT::key_compare, typename RightT::key_compare>::value) )
boost::icl::is_key_compare_equal::type	icl/type_traits/is_combinable.hpp	/^    typedef is_key_compare_equal<LeftT, RightT> type;$/;"	t	struct:boost::icl::is_key_compare_equal	access:public
boost::icl::is_key_container_of	icl/type_traits/is_key_container_of.hpp	/^    struct is_key_container_of \/\/ set is_key_container_of (set or map)$/;"	s	namespace:boost::icl
boost::icl::is_key_container_of::BOOST_STATIC_CONSTANT	icl/type_traits/is_key_container_of.hpp	/^        BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_key_container_of	access:public	signature:(bool, value = (mpl::or_< is_strict_key_container_of<KeyT, ObjectT> , mpl::and_< mpl::or_<is_set<ObjectT>, is_map<ObjectT> > , boost::is_same<ObjectT, KeyT> > >::value) )
boost::icl::is_key_container_of::type	icl/type_traits/is_key_container_of.hpp	/^        typedef is_key_container_of<KeyT, ObjectT> type;$/;"	t	struct:boost::icl::is_key_container_of	access:public
boost::icl::is_key_of	icl/type_traits/is_combinable.hpp	/^struct is_key_of$/;"	s	namespace:boost::icl
boost::icl::is_key_of	icl/type_traits/is_combinable.hpp	/^struct is_key_of<typename Type::domain_type, Type>$/;"	s	namespace:boost::icl
boost::icl::is_key_of	icl/type_traits/is_combinable.hpp	/^struct is_key_of<typename Type::interval_type, Type>$/;"	s	namespace:boost::icl
boost::icl::is_key_of::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_key_of	access:public	signature:(bool, value = false)
boost::icl::is_key_of::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_key_of	access:public	signature:(bool, value = true)
boost::icl::is_key_of::type	icl/type_traits/is_combinable.hpp	/^    typedef is_key_of type;$/;"	t	struct:boost::icl::is_key_of	access:public
boost::icl::is_left_closed	icl/concept/interval_bounds.hpp	/^inline bool is_left_closed(interval_bounds bounds)$/;"	f	namespace:boost::icl	signature:(interval_bounds bounds)
boost::icl::is_map	icl/interval_base_map.hpp	/^struct is_map<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_map	icl/interval_map.hpp	/^struct is_map<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_map	icl/map.hpp	/^struct is_map<icl::map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_map	icl/split_interval_map.hpp	/^struct is_map<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_map	icl/type_traits/is_map.hpp	/^    template <class Type> struct is_map$/;"	s	namespace:boost::icl
boost::icl::is_map::BOOST_STATIC_CONSTANT	icl/interval_base_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_map	access:public	signature:(bool, value = true)
boost::icl::is_map::BOOST_STATIC_CONSTANT	icl/interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_map	access:public	signature:(bool, value = true)
boost::icl::is_map::BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_map	access:public	signature:(bool, value = true)
boost::icl::is_map::BOOST_STATIC_CONSTANT	icl/split_interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_map	access:public	signature:(bool, value = true)
boost::icl::is_map::BOOST_STATIC_CONSTANT	icl/type_traits/is_map.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false); $/;"	p	struct:boost::icl::is_map	access:public	signature:(bool, value = false)
boost::icl::is_map::type	icl/interval_base_map.hpp	/^    typedef is_map<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_map	access:public
boost::icl::is_map::type	icl/interval_map.hpp	/^    typedef is_map<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_map	access:public
boost::icl::is_map::type	icl/map.hpp	/^    typedef is_map<icl::map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc> > type;$/;"	t	struct:boost::icl::is_map	access:public
boost::icl::is_map::type	icl/split_interval_map.hpp	/^    typedef is_map<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_map	access:public
boost::icl::is_map::type	icl/type_traits/is_map.hpp	/^        typedef is_map<Type> type;$/;"	t	struct:boost::icl::is_map	access:public
boost::icl::is_mapped_reference_combinable	icl/detail/mapped_reference.hpp	/^struct is_mapped_reference_combinable<std::pair<FirstT,SecondT> >$/;"	s	namespace:boost::icl
boost::icl::is_mapped_reference_combinable	icl/detail/mapped_reference.hpp	/^struct is_mapped_reference_combinable<std::pair<const FirstT,SecondT> >$/;"	s	namespace:boost::icl
boost::icl::is_mapped_reference_combinable	icl/detail/mapped_reference.hpp	/^struct is_mapped_reference_combinable{$/;"	s	namespace:boost::icl
boost::icl::is_mapped_reference_combinable::BOOST_STATIC_CONSTANT	icl/detail/mapped_reference.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_mapped_reference_combinable	access:public	signature:(bool, value = false)
boost::icl::is_mapped_reference_combinable::BOOST_STATIC_CONSTANT	icl/detail/mapped_reference.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_mapped_reference_combinable	access:public	signature:(bool, value = true)
boost::icl::is_mapped_reference_combinable::type	icl/detail/mapped_reference.hpp	/^    typedef is_mapped_reference_combinable type;$/;"	t	struct:boost::icl::is_mapped_reference_combinable	access:public
boost::icl::is_mapped_reference_combinable::type	icl/detail/mapped_reference.hpp	/^    typedef is_mapped_reference_combinable<std::pair<FirstT,SecondT> > type;$/;"	t	struct:boost::icl::is_mapped_reference_combinable	access:public
boost::icl::is_mapped_reference_combinable::type	icl/detail/mapped_reference.hpp	/^    typedef is_mapped_reference_combinable<std::pair<const FirstT,SecondT> > type;$/;"	t	struct:boost::icl::is_mapped_reference_combinable	access:public
boost::icl::is_mapped_reference_or_combinable	icl/detail/mapped_reference.hpp	/^struct is_mapped_reference_or_combinable<mapped_reference<FirstT,SecondT> >$/;"	s	namespace:boost::icl
boost::icl::is_mapped_reference_or_combinable	icl/detail/mapped_reference.hpp	/^struct is_mapped_reference_or_combinable{$/;"	s	namespace:boost::icl
boost::icl::is_mapped_reference_or_combinable::BOOST_STATIC_CONSTANT	icl/detail/mapped_reference.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = is_mapped_reference_combinable<Type>::value);$/;"	p	struct:boost::icl::is_mapped_reference_or_combinable	access:public	signature:(bool, value = is_mapped_reference_combinable<Type>::value)
boost::icl::is_mapped_reference_or_combinable::BOOST_STATIC_CONSTANT	icl/detail/mapped_reference.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_mapped_reference_or_combinable	access:public	signature:(bool, value = true)
boost::icl::is_mapped_reference_or_combinable::type	icl/detail/mapped_reference.hpp	/^    typedef is_mapped_reference_or_combinable type;$/;"	t	struct:boost::icl::is_mapped_reference_or_combinable	access:public
boost::icl::is_mapped_reference_or_combinable::type	icl/detail/mapped_reference.hpp	/^    typedef is_mapped_reference_or_combinable<mapped_reference<FirstT,SecondT> > type;$/;"	t	struct:boost::icl::is_mapped_reference_or_combinable	access:public
boost::icl::is_negative	icl/functors.hpp	/^    struct is_negative$/;"	s	namespace:boost::icl
boost::icl::is_negative	icl/functors.hpp	/^    struct is_negative<icl::inplace_bit_subtract<Type> >$/;"	s	namespace:boost::icl
boost::icl::is_negative	icl/functors.hpp	/^    struct is_negative<icl::inplace_minus<Type> >$/;"	s	namespace:boost::icl
boost::icl::is_negative::BOOST_STATIC_CONSTANT	icl/functors.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_negative	access:public	signature:(bool, value = false)
boost::icl::is_negative::BOOST_STATIC_CONSTANT	icl/functors.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_negative	access:public	signature:(bool, value = true)
boost::icl::is_negative::type	icl/functors.hpp	/^        typedef is_negative type;$/;"	t	struct:boost::icl::is_negative	access:public
boost::icl::is_negative::type	icl/functors.hpp	/^        typedef is_negative<Functor> type;$/;"	t	struct:boost::icl::is_negative	access:public
boost::icl::is_non_floating_point	icl/type_traits/is_numeric.hpp	/^struct is_non_floating_point$/;"	s	namespace:boost::icl
boost::icl::is_non_floating_point::BOOST_STATIC_CONSTANT	icl/type_traits/is_numeric.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_non_floating_point	access:public	signature:(bool, value = (mpl::not_< is_floating_point<Type> >::value))
boost::icl::is_non_floating_point::type	icl/type_traits/is_numeric.hpp	/^    typedef is_non_floating_point type;$/;"	t	struct:boost::icl::is_non_floating_point	access:public
boost::icl::is_numeric	icl/rational.hpp	/^    struct is_numeric<boost::rational<Integral> >$/;"	s	namespace:boost::icl
boost::icl::is_numeric	icl/type_traits/is_numeric.hpp	/^struct is_numeric<std::complex<Type> >$/;"	s	namespace:boost::icl
boost::icl::is_numeric	icl/type_traits/is_numeric.hpp	/^template <class Type> struct is_numeric$/;"	s	namespace:boost::icl
boost::icl::is_numeric::BOOST_STATIC_CONSTANT	icl/rational.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_numeric	access:public	signature:(bool, value = true)
boost::icl::is_numeric::BOOST_STATIC_CONSTANT	icl/type_traits/is_numeric.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_numeric	access:public	signature:(bool, value = (mpl::or_< is_std_numeric<Type> , boost::is_integral<Type> , is_std_integral<Type> >::value) )
boost::icl::is_numeric::BOOST_STATIC_CONSTANT	icl/type_traits/is_numeric.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_numeric	access:public	signature:(bool, value = true)
boost::icl::is_numeric::type	icl/rational.hpp	/^        typedef is_numeric type;$/;"	t	struct:boost::icl::is_numeric	access:public
boost::icl::is_numeric::type	icl/type_traits/is_numeric.hpp	/^    typedef is_numeric type;$/;"	t	struct:boost::icl::is_numeric	access:public
boost::icl::is_overloadable	icl/type_traits/is_combinable.hpp	/^struct is_overloadable$/;"	s	namespace:boost::icl
boost::icl::is_overloadable::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_overloadable	access:public	signature:(bool, value = (boost::is_same<Type, typename Type::overloadable_type>::value) )
boost::icl::is_overloadable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_overloadable<Type> type;$/;"	t	struct:boost::icl::is_overloadable	access:public
boost::icl::is_reverse	icl/detail/element_iterator.hpp	/^struct is_reverse$/;"	s	namespace:boost::icl
boost::icl::is_reverse	icl/detail/element_iterator.hpp	/^struct is_reverse<icl::element_iterator<BaseIteratorT> >$/;"	s	namespace:boost::icl
boost::icl::is_reverse	icl/detail/element_iterator.hpp	/^struct is_reverse<std::reverse_iterator<BaseIteratorT> >$/;"	s	namespace:boost::icl
boost::icl::is_reverse::BOOST_STATIC_CONSTANT	icl/detail/element_iterator.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_reverse	access:public	signature:(bool, value = false)
boost::icl::is_reverse::BOOST_STATIC_CONSTANT	icl/detail/element_iterator.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = is_reverse<BaseIteratorT>::value);$/;"	p	struct:boost::icl::is_reverse	access:public	signature:(bool, value = is_reverse<BaseIteratorT>::value)
boost::icl::is_reverse::BOOST_STATIC_CONSTANT	icl/detail/element_iterator.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_reverse	access:public	signature:(bool, value = true)
boost::icl::is_reverse::type	icl/detail/element_iterator.hpp	/^    typedef is_reverse type; $/;"	t	struct:boost::icl::is_reverse	access:public
boost::icl::is_reverse::type	icl/detail/element_iterator.hpp	/^    typedef is_reverse<icl::element_iterator<BaseIteratorT> > type; $/;"	t	struct:boost::icl::is_reverse	access:public
boost::icl::is_reverse::type	icl/detail/element_iterator.hpp	/^    typedef is_reverse<std::reverse_iterator<BaseIteratorT> > type; $/;"	t	struct:boost::icl::is_reverse	access:public
boost::icl::is_right_closed	icl/concept/interval_bounds.hpp	/^inline bool is_right_closed(interval_bounds bounds)$/;"	f	namespace:boost::icl	signature:(interval_bounds bounds)
boost::icl::is_right_inter_combinable	icl/type_traits/is_combinable.hpp	/^struct is_right_inter_combinable$/;"	s	namespace:boost::icl
boost::icl::is_right_inter_combinable::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_right_inter_combinable	access:public	signature:(bool, value = (mpl::or_ < is_interval_set_right_combinable<GuideT, CompanionT> , is_interval_map_right_inter_combinable<GuideT, CompanionT> >::value) )
boost::icl::is_right_inter_combinable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_right_inter_combinable<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_right_inter_combinable	access:public
boost::icl::is_right_intra_combinable	icl/type_traits/is_combinable.hpp	/^struct is_right_intra_combinable$/;"	s	namespace:boost::icl
boost::icl::is_right_intra_combinable::BOOST_STATIC_CONSTANT	icl/type_traits/is_combinable.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = $/;"	p	struct:boost::icl::is_right_intra_combinable	access:public	signature:(bool, value = (mpl::or_ < is_interval_set_right_combinable<GuideT, CompanionT> , is_interval_map_right_intra_combinable<GuideT, CompanionT> >::value) )
boost::icl::is_right_intra_combinable::type	icl/type_traits/is_combinable.hpp	/^    typedef is_right_intra_combinable<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_right_intra_combinable	access:public
boost::icl::is_set	icl/detail/std_set.hpp	/^struct is_set<std::set<Type> >$/;"	s	namespace:boost::icl
boost::icl::is_set	icl/interval_base_set.hpp	/^struct is_set<icl::interval_base_set<SubType,DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_set	icl/interval_set.hpp	/^struct is_set<icl::interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_set	icl/separate_interval_set.hpp	/^struct is_set<icl::separate_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_set	icl/split_interval_set.hpp	/^struct is_set<icl::split_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_set	icl/type_traits/is_set.hpp	/^    template <class Type> struct is_set$/;"	s	namespace:boost::icl
boost::icl::is_set::BOOST_STATIC_CONSTANT	icl/detail/std_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_set	access:public	signature:(bool, value = true)
boost::icl::is_set::BOOST_STATIC_CONSTANT	icl/interval_base_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_set	access:public	signature:(bool, value = true)
boost::icl::is_set::BOOST_STATIC_CONSTANT	icl/interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_set	access:public	signature:(bool, value = true)
boost::icl::is_set::BOOST_STATIC_CONSTANT	icl/separate_interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_set	access:public	signature:(bool, value = true)
boost::icl::is_set::BOOST_STATIC_CONSTANT	icl/split_interval_set.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true); $/;"	p	struct:boost::icl::is_set	access:public	signature:(bool, value = true)
boost::icl::is_set::BOOST_STATIC_CONSTANT	icl/type_traits/is_set.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = is_std_set<Type>::value); $/;"	p	struct:boost::icl::is_set	access:public	signature:(bool, value = is_std_set<Type>::value)
boost::icl::is_set::type	icl/detail/std_set.hpp	/^    typedef is_set<std::set<Type> > type;$/;"	t	struct:boost::icl::is_set	access:public
boost::icl::is_set::type	icl/interval_base_set.hpp	/^    typedef is_set<icl::interval_base_set<SubType,DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_set	access:public
boost::icl::is_set::type	icl/interval_set.hpp	/^    typedef is_set<icl::interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_set	access:public
boost::icl::is_set::type	icl/separate_interval_set.hpp	/^    typedef is_set<icl::separate_interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_set	access:public
boost::icl::is_set::type	icl/split_interval_set.hpp	/^    typedef is_set<icl::split_interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_set	access:public
boost::icl::is_set::type	icl/type_traits/is_set.hpp	/^        typedef is_set<Type> type;$/;"	t	struct:boost::icl::is_set	access:public
boost::icl::is_singelizable	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_singelizable$/;"	s	namespace:boost::icl
boost::icl::is_singelizable::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_singelizable	access:public	signature:(bool, value = (mpl::or_< has_dynamic_bounds<Type> , is_discrete<domain_type> >::value) )
boost::icl::is_singelizable::domain_type	icl/type_traits/is_interval.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::is_singelizable	access:public
boost::icl::is_singelizable::type	icl/type_traits/is_interval.hpp	/^    typedef is_singelizable type;$/;"	t	struct:boost::icl::is_singelizable	access:public
boost::icl::is_static_closed	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_static_closed$/;"	s	namespace:boost::icl
boost::icl::is_static_closed::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_static_closed	access:public	signature:(bool, value = (interval_bound_type<Type>::value == interval_bounds::static_closed))
boost::icl::is_static_closed::type	icl/type_traits/is_interval.hpp	/^    typedef is_static_closed<Type> type;$/;"	t	struct:boost::icl::is_static_closed	access:public
boost::icl::is_static_left_open	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_static_left_open$/;"	s	namespace:boost::icl
boost::icl::is_static_left_open::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_static_left_open	access:public	signature:(bool, value = (interval_bound_type<Type>::value == interval_bounds::static_left_open))
boost::icl::is_static_left_open::type	icl/type_traits/is_interval.hpp	/^    typedef is_static_left_open<Type> type;$/;"	t	struct:boost::icl::is_static_left_open	access:public
boost::icl::is_static_open	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_static_open$/;"	s	namespace:boost::icl
boost::icl::is_static_open::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_static_open	access:public	signature:(bool, value = (interval_bound_type<Type>::value == interval_bounds::static_open))
boost::icl::is_static_open::type	icl/type_traits/is_interval.hpp	/^    typedef is_static_open<Type> type;$/;"	t	struct:boost::icl::is_static_open	access:public
boost::icl::is_static_right_open	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_static_right_open$/;"	s	namespace:boost::icl
boost::icl::is_static_right_open::BOOST_STATIC_CONSTANT	icl/type_traits/is_interval.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_static_right_open	access:public	signature:(bool, value = (interval_bound_type<Type>::value == interval_bounds::static_right_open))
boost::icl::is_static_right_open::type	icl/type_traits/is_interval.hpp	/^    typedef is_static_right_open<Type> type;$/;"	t	struct:boost::icl::is_static_right_open	access:public
boost::icl::is_std_integral	icl/type_traits/is_numeric.hpp	/^template <class Type> struct is_std_integral$/;"	s	namespace:boost::icl
boost::icl::is_std_integral::BOOST_STATIC_CONSTANT	icl/type_traits/is_numeric.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_std_integral	access:public	signature:(bool, value = (std::numeric_limits<Type>::is_integer))
boost::icl::is_std_integral::type	icl/type_traits/is_numeric.hpp	/^    typedef is_std_integral type;$/;"	t	struct:boost::icl::is_std_integral	access:public
boost::icl::is_std_numeric	icl/type_traits/is_numeric.hpp	/^template <class Type> struct is_std_numeric$/;"	s	namespace:boost::icl
boost::icl::is_std_numeric::BOOST_STATIC_CONSTANT	icl/type_traits/is_numeric.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_std_numeric	access:public	signature:(bool, value = (std::numeric_limits<Type>::is_specialized))
boost::icl::is_std_numeric::type	icl/type_traits/is_numeric.hpp	/^    typedef is_std_numeric type;$/;"	t	struct:boost::icl::is_std_numeric	access:public
boost::icl::is_std_pair	icl/detail/element_iterator.hpp	/^struct is_std_pair$/;"	s	namespace:boost::icl
boost::icl::is_std_pair	icl/detail/element_iterator.hpp	/^struct is_std_pair<std::pair<FirstT, SecondT> >$/;"	s	namespace:boost::icl
boost::icl::is_std_pair::BOOST_STATIC_CONSTANT	icl/detail/element_iterator.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = false);$/;"	p	struct:boost::icl::is_std_pair	access:public	signature:(bool, value = false)
boost::icl::is_std_pair::BOOST_STATIC_CONSTANT	icl/detail/element_iterator.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = true);$/;"	p	struct:boost::icl::is_std_pair	access:public	signature:(bool, value = true)
boost::icl::is_std_pair::type	icl/detail/element_iterator.hpp	/^    typedef is_std_pair<Type> type; $/;"	t	struct:boost::icl::is_std_pair	access:public
boost::icl::is_std_pair::type	icl/detail/element_iterator.hpp	/^    typedef is_std_pair<std::pair<FirstT, SecondT> > type; $/;"	t	struct:boost::icl::is_std_pair	access:public
boost::icl::is_std_set	icl/type_traits/is_container.hpp	/^    struct is_std_set$/;"	s	namespace:boost::icl
boost::icl::is_std_set::BOOST_STATIC_CONSTANT	icl/type_traits/is_container.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_std_set	access:public	signature:(bool, value = (mpl::and_< is_container<Type> , detail::has_key_type<Type> , boost::is_same< typename key_type_of<Type>::type , typename value_type_of<Type>::type > , mpl::not_<detail::has_segment_type<Type> > >::value ) )
boost::icl::is_std_set::type	icl/type_traits/is_container.hpp	/^        typedef is_std_set type;$/;"	t	struct:boost::icl::is_std_set	access:public
boost::icl::is_strict_key_container_of	icl/type_traits/is_key_container_of.hpp	/^    struct is_strict_key_container_of \/\/ set is_strict_key_container_of map$/;"	s	namespace:boost::icl
boost::icl::is_strict_key_container_of::BOOST_STATIC_CONSTANT	icl/type_traits/is_key_container_of.hpp	/^        BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::icl::is_strict_key_container_of	access:public	signature:(bool, value = (mpl::and_< is_map<ObjectT> , boost::is_same<KeyT, typename key_container_type_of<ObjectT>::type> >::value) )
boost::icl::is_strict_key_container_of::type	icl/type_traits/is_key_container_of.hpp	/^        typedef is_strict_key_container_of<KeyT, ObjectT> type;$/;"	t	struct:boost::icl::is_strict_key_container_of	access:public
boost::icl::is_subtraction_closed	icl/type_traits/difference_type_of.hpp	/^    struct is_subtraction_closed$/;"	s	namespace:boost::icl
boost::icl::is_subtraction_closed::BOOST_STATIC_CONSTANT	icl/type_traits/difference_type_of.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::is_subtraction_closed	access:public	signature:(bool, value = (mpl::or_< is_numeric<Type> , mpl::and_< has_rep_type<Type> , mpl::not_<has_difference_type<Type> > > >::value) )
boost::icl::is_subtraction_closed::type	icl/type_traits/difference_type_of.hpp	/^        typedef is_subtraction_closed type;$/;"	t	struct:boost::icl::is_subtraction_closed	access:public
boost::icl::is_total	icl/interval_base_map.hpp	/^struct is_total<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_total	icl/interval_map.hpp	/^struct is_total<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_total	icl/map.hpp	/^struct is_total<icl::map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_total	icl/split_interval_map.hpp	/^struct is_total<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::is_total	icl/type_traits/is_total.hpp	/^    template <class Type> struct is_total$/;"	s	namespace:boost::icl
boost::icl::is_total::BOOST_STATIC_CONSTANT	icl/interval_base_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (Traits::is_total)); $/;"	p	struct:boost::icl::is_total	access:public	signature:(bool, value = (Traits::is_total))
boost::icl::is_total::BOOST_STATIC_CONSTANT	icl/interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (Traits::is_total)); $/;"	p	struct:boost::icl::is_total	access:public	signature:(bool, value = (Traits::is_total))
boost::icl::is_total::BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(int, value = Traits::is_total); $/;"	p	struct:boost::icl::is_total	access:public	signature:(int, value = Traits::is_total)
boost::icl::is_total::BOOST_STATIC_CONSTANT	icl/split_interval_map.hpp	/^    BOOST_STATIC_CONSTANT(bool, value = (Traits::is_total)); $/;"	p	struct:boost::icl::is_total	access:public	signature:(bool, value = (Traits::is_total))
boost::icl::is_total::BOOST_STATIC_CONSTANT	icl/type_traits/is_total.hpp	/^        BOOST_STATIC_CONSTANT(bool, value = false); $/;"	p	struct:boost::icl::is_total	access:public	signature:(bool, value = false)
boost::icl::is_total::type	icl/interval_base_map.hpp	/^    typedef is_total<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_total	access:public
boost::icl::is_total::type	icl/interval_map.hpp	/^    typedef is_total<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_total	access:public
boost::icl::is_total::type	icl/map.hpp	/^    typedef is_total type;$/;"	t	struct:boost::icl::is_total	access:public
boost::icl::is_total::type	icl/split_interval_map.hpp	/^    typedef is_total<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_total	access:public
boost::icl::is_total::type	icl/type_traits/is_total.hpp	/^        typedef is_total<Type> type;$/;"	t	struct:boost::icl::is_total	access:public
boost::icl::iterative_size	icl/concept/container.hpp	/^iterative_size(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::iterative_size	icl/concept/element_associator.hpp	/^iterative_size(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::iterative_size	icl/concept/interval.hpp	/^iterative_size(const Type&)$/;"	f	namespace:boost::icl	signature:(const Type&)
boost::icl::iterative_size	icl/concept/interval_associator.hpp	/^iterative_size(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::join	icl/concept/interval_associator_base.hpp	/^join(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
boost::icl::key_container_type_of	icl/type_traits/is_key_container_of.hpp	/^    struct key_container_type_of$/;"	s	namespace:boost::icl
boost::icl::key_container_type_of::type	icl/type_traits/is_key_container_of.hpp	/^            >::type type;$/;"	t	struct:boost::icl::key_container_type_of	access:public
boost::icl::key_type_of	icl/type_traits/element_type_of.hpp	/^    struct key_type_of$/;"	s	namespace:boost::icl
boost::icl::key_type_of::type	icl/type_traits/element_type_of.hpp	/^            get_key_type<Type, has_key_type<Type>::value>::type type;$/;"	t	struct:boost::icl::key_type_of	access:public
boost::icl::key_value	icl/concept/map_value.hpp	/^key_value(Iterator it_)$/;"	f	namespace:boost::icl	signature:(Iterator it_)
boost::icl::key_value	icl/concept/set_value.hpp	/^key_value(Iterator it_)$/;"	f	namespace:boost::icl	signature:(Iterator it_)
boost::icl::known_fineness	icl/type_traits/is_combinable.hpp	/^template<class Type> struct known_fineness$/;"	s	namespace:boost::icl
boost::icl::known_fineness::type	icl/type_traits/is_combinable.hpp	/^    typedef known_fineness<Type> type;$/;"	t	struct:boost::icl::known_fineness	access:public
boost::icl::known_fineness::value	icl/type_traits/is_combinable.hpp	/^    static const int value = Type::fineness;$/;"	m	struct:boost::icl::known_fineness	access:public
boost::icl::last	icl/concept/interval.hpp	/^last(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::last	icl/concept/interval_associator.hpp	/^last(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::last_next	icl/concept/interval.hpp	/^last_next(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::left	icl/concept/interval_bounds.hpp	/^inline interval_bounds left(interval_bounds x1)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1)
boost::icl::left_bounds	icl/concept/interval_bounds.hpp	/^inline interval_bounds left_bounds(interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
boost::icl::left_bounds	icl/concept/interval_bounds.hpp	/^left_bounds(const IntervalT& x1, const IntervalT& x2)$/;"	f	namespace:boost::icl	signature:(const IntervalT& x1, const IntervalT& x2)
boost::icl::left_bracket	icl/concept/interval.hpp	/^left_bracket(const Type& object) $/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::left_bracket	icl/concept/interval.hpp	/^left_bracket(const Type&) { return "("; }$/;"	f	namespace:boost::icl	signature:(const Type&)
boost::icl::left_bracket	icl/concept/interval.hpp	/^left_bracket(const Type&) { return "["; }$/;"	f	namespace:boost::icl	signature:(const Type&)
boost::icl::left_bracket	icl/concept/interval_bounds.hpp	/^inline std::string left_bracket(interval_bounds bounds)$/;"	f	namespace:boost::icl	signature:(interval_bounds bounds)
boost::icl::left_open_interval	icl/left_open_interval.hpp	/^class left_open_interval$/;"	c	namespace:boost::icl
boost::icl::left_open_interval::_lwb	icl/left_open_interval.hpp	/^    DomainT _lwb;$/;"	m	class:boost::icl::left_open_interval	access:private
boost::icl::left_open_interval::_upb	icl/left_open_interval.hpp	/^    DomainT _upb;$/;"	m	class:boost::icl::left_open_interval	access:private
boost::icl::left_open_interval::domain_compare	icl/left_open_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::left_open_interval	access:public
boost::icl::left_open_interval::domain_type	icl/left_open_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::left_open_interval	access:public
boost::icl::left_open_interval::left_open_interval	icl/left_open_interval.hpp	/^    explicit left_open_interval(const DomainT& val)$/;"	f	class:boost::icl::left_open_interval	access:public	signature:(const DomainT& val)
boost::icl::left_open_interval::left_open_interval	icl/left_open_interval.hpp	/^    left_open_interval() $/;"	f	class:boost::icl::left_open_interval	access:public	signature:()
boost::icl::left_open_interval::left_open_interval	icl/left_open_interval.hpp	/^    left_open_interval(const DomainT& low, const DomainT& up) :$/;"	f	class:boost::icl::left_open_interval	access:public	signature:(const DomainT& low, const DomainT& up)
boost::icl::left_open_interval::lower	icl/left_open_interval.hpp	/^    DomainT lower()const{ return _lwb; }$/;"	f	class:boost::icl::left_open_interval	access:public	signature:() const
boost::icl::left_open_interval::type	icl/left_open_interval.hpp	/^    typedef left_open_interval<DomainT,Compare> type;$/;"	t	class:boost::icl::left_open_interval	access:public
boost::icl::left_open_interval::upper	icl/left_open_interval.hpp	/^    DomainT upper()const{ return _upb; }$/;"	f	class:boost::icl::left_open_interval	access:public	signature:() const
boost::icl::left_subtract	icl/concept/interval.hpp	/^left_subtract(Type right, const Type& left_minuend)$/;"	f	namespace:boost::icl	signature:(Type right, const Type& left_minuend)
boost::icl::left_subtract_bounds	icl/concept/interval_bounds.hpp	/^inline interval_bounds left_subtract_bounds(interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
boost::icl::left_subtract_bounds	icl/concept/interval_bounds.hpp	/^left_subtract_bounds(const IntervalT& x1, const IntervalT& x2)$/;"	f	namespace:boost::icl	signature:(const IntervalT& x1, const IntervalT& x2)
boost::icl::length	icl/concept/interval.hpp	/^length(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::length	icl/concept/interval_associator.hpp	/^length(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::lower	icl/concept/interval.hpp	/^lower(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::lower	icl/concept/interval_associator.hpp	/^lower(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::lower_equal	icl/concept/interval.hpp	/^lower_equal(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::lower_less	icl/concept/interval.hpp	/^lower_less(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::lower_less_equal	icl/concept/interval.hpp	/^lower_less_equal(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::lower_max	icl/concept/interval.hpp	/^lower_max(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::lower_min	icl/concept/interval.hpp	/^lower_min(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::make_mapped_reference	icl/detail/mapped_reference.hpp	/^inline mapped_reference<FirstT, SecondT> make_mapped_reference(const FirstT& left, SecondT& right)$/;"	f	namespace:boost::icl	signature:(const FirstT& left, SecondT& right)
boost::icl::make_segment	icl/concept/interval_map.hpp	/^make_segment(const typename Type::element_type& element)$/;"	f	namespace:boost::icl	signature:(const typename Type::element_type& element)
boost::icl::make_value	icl/concept/map_value.hpp	/^make_value(const typename Type::     key_type& key_val, $/;"	f	namespace:boost::icl	signature:(const typename Type:: key_type& key_val, const typename Type::codomain_type& co_val)
boost::icl::make_value	icl/concept/set_value.hpp	/^make_value(const typename Type::key_type& key_val, $/;"	f	namespace:boost::icl	signature:(const typename Type::key_type& key_val, const typename codomain_type_of<Type>::type& )
boost::icl::map	icl/map.hpp	/^class map: private ICL_IMPL_SPACE::map<DomainT, CodomainT, ICL_COMPARE_DOMAIN(Compare,DomainT), $/;"	c	namespace:boost::icl	inherits:ICL_IMPL_SPACE::map
boost::icl::map::BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	class:boost::icl::map	access:public	signature:(bool, is_total_invertible = ( Traits::is_total && has_inverse<codomain_type>::value))
boost::icl::map::BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(bool, $/;"	p	class:boost::icl::map	access:public	signature:(bool, total_invertible = (mpl::and_<is_total<type>, has_inverse<codomain_type> >::value))
boost::icl::map::BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(bool, _absorbs = (Traits::absorbs_identities));$/;"	p	class:boost::icl::map	access:public	signature:(bool, _absorbs = (Traits::absorbs_identities))
boost::icl::map::BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(bool, _total   = (Traits::is_total));$/;"	p	class:boost::icl::map	access:public	signature:(bool, _total = (Traits::is_total))
boost::icl::map::BOOST_STATIC_CONSTANT	icl/map.hpp	/^    BOOST_STATIC_CONSTANT(int, fineness = 4); $/;"	p	class:boost::icl::map	access:public	signature:(int, fineness = 4)
boost::icl::map::_add	icl/map.hpp	/^    ::_add(const element_type& addend)$/;"	f	class:boost::icl::map	signature:(const element_type& addend)
boost::icl::map::_add	icl/map.hpp	/^    ::_add(iterator prior_, const value_type& addend)$/;"	f	class:boost::icl::map	signature:(iterator prior_, const value_type& addend)
boost::icl::map::_add	icl/map.hpp	/^    iterator _add(iterator prior, const element_type& value_pair);$/;"	p	class:boost::icl::map	access:private	signature:(iterator prior, const element_type& value_pair)
boost::icl::map::_add	icl/map.hpp	/^    map& _add(const element_type& value_pair);$/;"	p	class:boost::icl::map	access:private	signature:(const element_type& value_pair)
boost::icl::map::_subtract	icl/map.hpp	/^    map& _subtract(const element_type& value_pair);$/;"	p	class:boost::icl::map	access:private	signature:(const element_type& value_pair)
boost::icl::map::_subtract	icl/map.hpp	/^    map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc>::_subtract(const value_type& minuend)$/;"	f	class:boost::icl::map	signature:(const value_type& minuend)
boost::icl::map::add	icl/map.hpp	/^    iterator add(iterator prior, const value_type& value_pair) $/;"	f	class:boost::icl::map	access:public	signature:(iterator prior, const value_type& value_pair)
boost::icl::map::add	icl/map.hpp	/^    map& add(const value_type& value_pair) $/;"	f	class:boost::icl::map	access:public	signature:(const value_type& value_pair)
boost::icl::map::add_intersection	icl/map.hpp	/^    void add_intersection(map& section, const element_type& key_value_pair)const$/;"	f	class:boost::icl::map	access:public	signature:(map& section, const element_type& key_value_pair) const
boost::icl::map::allocator_type	icl/map.hpp	/^    typedef Alloc<typename std::pair<const DomainT, CodomainT> >  allocator_type;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::base_type	icl/map.hpp	/^                                         allocator_type>   base_type;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::codomain_combine	icl/map.hpp	/^    typedef ICL_COMBINE_CODOMAIN(Combine,CodomainT)     codomain_combine;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::codomain_intersect	icl/map.hpp	/^        >::type                                         codomain_intersect;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::codomain_type	icl/map.hpp	/^    typedef CodomainT                                   codomain_type;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::const_iterator	icl/map.hpp	/^    typedef typename base_type::const_iterator          const_iterator;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::const_pointer	icl/map.hpp	/^    typedef typename base_type::const_pointer           const_pointer;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::const_reference	icl/map.hpp	/^    typedef typename base_type::const_reference         const_reference;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::const_reverse_iterator	icl/map.hpp	/^    typedef typename base_type::const_reverse_iterator  const_reverse_iterator;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::contains	icl/map.hpp	/^    bool contains(const SubObject& sub)const $/;"	f	class:boost::icl::map	access:public	signature:(const SubObject& sub) const
boost::icl::map::data_type	icl/map.hpp	/^    typedef CodomainT                                   data_type;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::difference_type	icl/map.hpp	/^    typedef typename base_type::difference_type         difference_type;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::domain_compare	icl/map.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT)         domain_compare;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::domain_param	icl/map.hpp	/^    typedef typename boost::call_traits<DomainT>::param_type domain_param;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::domain_type	icl/map.hpp	/^    typedef DomainT                                     domain_type;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::element_compare	icl/map.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,element_type)    element_compare;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::element_type	icl/map.hpp	/^    typedef std::pair<const DomainT, CodomainT>         element_type;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::erase	icl/map.hpp	/^    size_type erase(const element_type& key_value_pair)$/;"	f	class:boost::icl::map	access:public	signature:(const element_type& key_value_pair)
boost::icl::map::flip	icl/map.hpp	/^    map& flip(const element_type& operand)$/;"	f	class:boost::icl::map	access:public	signature:(const element_type& operand)
boost::icl::map::insert	icl/map.hpp	/^    iterator insert(Iterator first, Iterator last)$/;"	f	class:boost::icl::map	access:public	signature:(Iterator first, Iterator last)
boost::icl::map::insert	icl/map.hpp	/^    iterator insert(iterator prior, const value_type& value_pair)$/;"	f	class:boost::icl::map	access:public	signature:(iterator prior, const value_type& value_pair)
boost::icl::map::insert	icl/map.hpp	/^    std::pair<iterator,bool> insert(const value_type& value_pair)$/;"	f	class:boost::icl::map	access:public	signature:(const value_type& value_pair)
boost::icl::map::inverse_codomain_combine	icl/map.hpp	/^    typedef typename inverse<codomain_combine >::type   inverse_codomain_combine;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::inverse_codomain_intersect	icl/map.hpp	/^    typedef typename inverse<codomain_intersect>::type  inverse_codomain_intersect;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::iterative_size	icl/map.hpp	/^    std::size_t iterative_size()const { return base_type::size(); }$/;"	f	class:boost::icl::map	access:public	signature:() const
boost::icl::map::iterator	icl/map.hpp	/^    typedef typename base_type::iterator                iterator;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::key_compare	icl/map.hpp	/^    typedef domain_compare                              key_compare;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::key_object_type	icl/map.hpp	/^    typedef set_type                                       key_object_type;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::key_type	icl/map.hpp	/^    typedef DomainT                                     key_type;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::map	icl/map.hpp	/^    explicit map(const element_type& key_value_pair): base_type::map()$/;"	f	class:boost::icl::map	access:public	signature:(const element_type& key_value_pair)
boost::icl::map::map	icl/map.hpp	/^    map()$/;"	f	class:boost::icl::map	access:public	signature:()
boost::icl::map::map	icl/map.hpp	/^    map(InputIterator first, InputIterator past)$/;"	f	class:boost::icl::map	access:public	signature:(InputIterator first, InputIterator past)
boost::icl::map::map	icl/map.hpp	/^    map(InputIterator first, InputIterator past, const key_compare& comp)$/;"	f	class:boost::icl::map	access:public	signature:(InputIterator first, InputIterator past, const key_compare& comp)
boost::icl::map::map	icl/map.hpp	/^    map(const key_compare& comp): base_type(comp){}$/;"	f	class:boost::icl::map	access:public	signature:(const key_compare& comp)
boost::icl::map::map	icl/map.hpp	/^    map(const map& src)$/;"	f	class:boost::icl::map	access:public	signature:(const map& src)
boost::icl::map::map	icl/map.hpp	/^    map(map&& src)$/;"	f	class:boost::icl::map	access:public	signature:(map&& src)
boost::icl::map::mapped_type	icl/map.hpp	/^    typedef CodomainT                                   mapped_type;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::on_codomain_model	icl/map.hpp	/^    struct on_codomain_model<Type, false, false>$/;"	s	class:boost::icl::map	access:private
boost::icl::map::on_codomain_model	icl/map.hpp	/^    struct on_codomain_model<Type, false, true>$/;"	s	class:boost::icl::map	access:private
boost::icl::map::on_codomain_model	icl/map.hpp	/^    struct on_codomain_model<Type, true, false>$/;"	s	class:boost::icl::map	access:private
boost::icl::map::on_codomain_model	icl/map.hpp	/^    struct on_codomain_model<Type, true, true>$/;"	s	class:boost::icl::map	access:private
boost::icl::map::on_codomain_model::inverse_codomain_intersect	icl/map.hpp	/^        typedef typename Type::inverse_codomain_intersect inverse_codomain_intersect;$/;"	t	struct:boost::icl::map::on_codomain_model	access:public
boost::icl::map::on_codomain_model::subtract	icl/map.hpp	/^        static void subtract(Type& object, typename Type::iterator       it_, $/;"	f	struct:boost::icl::map::on_codomain_model	access:public	signature:(Type& object, typename Type::iterator it_, const typename Type::codomain_type& )
boost::icl::map::on_codomain_model::subtract	icl/map.hpp	/^        static void subtract(Type& object, typename Type::iterator       it_, $/;"	f	struct:boost::icl::map::on_codomain_model	access:public	signature:(Type& object, typename Type::iterator it_, const typename Type::codomain_type& co_value)
boost::icl::map::on_codomain_model::subtract	icl/map.hpp	/^        static void subtract(Type&, typename Type::iterator       it_, $/;"	f	struct:boost::icl::map::on_codomain_model	access:public	signature:(Type&, typename Type::iterator it_, const typename Type::codomain_type& co_value)
boost::icl::map::on_codomain_model::subtract	icl/map.hpp	/^        static void subtract(Type&, typename Type::iterator it_, $/;"	f	struct:boost::icl::map::on_codomain_model	access:public	signature:(Type&, typename Type::iterator it_, const typename Type::codomain_type& )
boost::icl::map::on_definedness	icl/map.hpp	/^    struct on_definedness<Type, false>$/;"	s	class:boost::icl::map	access:private
boost::icl::map::on_definedness	icl/map.hpp	/^    struct on_definedness<Type, true>$/;"	s	class:boost::icl::map	access:private
boost::icl::map::on_definedness::add_intersection	icl/map.hpp	/^        static void add_intersection(Type& section, const Type& object, $/;"	f	struct:boost::icl::map::on_definedness	access:public	signature:(Type& section, const Type& object, const element_type& operand)
boost::icl::map::on_identity_absorbtion	icl/map.hpp	/^                                                        on_identity_absorbtion;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::on_invertible	icl/map.hpp	/^    struct on_invertible<Type, false>$/;"	s	class:boost::icl::map	access:private
boost::icl::map::on_invertible	icl/map.hpp	/^    struct on_invertible<Type, true>$/;"	s	class:boost::icl::map	access:private
boost::icl::map::on_invertible::element_type	icl/map.hpp	/^        typedef typename Type::element_type element_type;$/;"	t	struct:boost::icl::map::on_invertible	access:public
boost::icl::map::on_invertible::inverse_codomain_combine	icl/map.hpp	/^        typedef typename Type::inverse_codomain_combine inverse_codomain_combine;$/;"	t	struct:boost::icl::map::on_invertible	access:public
boost::icl::map::on_invertible::subtract	icl/map.hpp	/^        static void subtract(Type& object, const element_type& operand)$/;"	f	struct:boost::icl::map::on_invertible	access:public	signature:(Type& object, const element_type& operand)
boost::icl::map::on_total_absorbable	icl/map.hpp	/^    struct on_total_absorbable<Type, false, false>$/;"	s	class:boost::icl::map	access:private
boost::icl::map::on_total_absorbable	icl/map.hpp	/^    struct on_total_absorbable<Type, false, true>$/;"	s	class:boost::icl::map	access:private
boost::icl::map::on_total_absorbable	icl/map.hpp	/^    struct on_total_absorbable<Type, true, false>$/;"	s	class:boost::icl::map	access:private
boost::icl::map::on_total_absorbable	icl/map.hpp	/^    struct on_total_absorbable<Type, true, true>$/;"	s	class:boost::icl::map	access:private
boost::icl::map::on_total_absorbable::codomain_type	icl/map.hpp	/^        typedef typename Type::codomain_type  codomain_type;$/;"	t	struct:boost::icl::map::on_total_absorbable	access:public
boost::icl::map::on_total_absorbable::codomain_type	icl/map.hpp	/^        typedef typename Type::codomain_type codomain_type;$/;"	t	struct:boost::icl::map::on_total_absorbable	access:public
boost::icl::map::on_total_absorbable::element_type	icl/map.hpp	/^        typedef typename Type::element_type   element_type;$/;"	t	struct:boost::icl::map::on_total_absorbable	access:public
boost::icl::map::on_total_absorbable::element_type	icl/map.hpp	/^        typedef typename Type::element_type  element_type;$/;"	t	struct:boost::icl::map::on_total_absorbable	access:public
boost::icl::map::on_total_absorbable::flip	icl/map.hpp	/^        static void flip(Type& object, const element_type& operand)$/;"	f	struct:boost::icl::map::on_total_absorbable	access:public	signature:(Type& object, const element_type& operand)
boost::icl::map::on_total_absorbable::flip	icl/map.hpp	/^        static void flip(Type& object, const typename Type::element_type&)$/;"	f	struct:boost::icl::map::on_total_absorbable	access:public	signature:(Type& object, const typename Type::element_type&)
boost::icl::map::on_total_absorbable::inverse_codomain_intersect	icl/map.hpp	/^        typedef typename Type::inverse_codomain_intersect inverse_codomain_intersect;$/;"	t	struct:boost::icl::map::on_total_absorbable	access:public
boost::icl::map::on_total_absorbable::iterator	icl/map.hpp	/^        typedef typename Type::iterator       iterator;$/;"	t	struct:boost::icl::map::on_total_absorbable	access:public
boost::icl::map::operator ()	icl/map.hpp	/^    codomain_type operator()(const domain_type& key)const$/;"	f	class:boost::icl::map	access:public	signature:(const domain_type& key) const
boost::icl::map::operator =	icl/map.hpp	/^    map& operator = (const map& src) $/;"	f	class:boost::icl::map	access:public	signature:(const map& src)
boost::icl::map::operator =	icl/map.hpp	/^    map& operator = (map&& src) $/;"	f	class:boost::icl::map	access:public	signature:(map&& src)
boost::icl::map::partial_add_intersection	icl/map.hpp	/^    void partial_add_intersection(type& section, const element_type& operand)const$/;"	f	class:boost::icl::map	access:private	signature:(type& section, const element_type& operand) const
boost::icl::map::pointer	icl/map.hpp	/^    typedef typename base_type::pointer                 pointer;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::reference	icl/map.hpp	/^    typedef typename base_type::reference               reference;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::reverse_iterator	icl/map.hpp	/^    typedef typename base_type::reverse_iterator        reverse_iterator;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::set	icl/map.hpp	/^    map& set(const element_type& key_value_pair)$/;"	f	class:boost::icl::map	access:public	signature:(const element_type& key_value_pair)
boost::icl::map::set_type	icl/map.hpp	/^    typedef typename ICL_IMPL_SPACE::set<DomainT, domain_compare, Alloc<DomainT> > set_type;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::size_type	icl/map.hpp	/^    typedef typename base_type::size_type               size_type;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::subtract	icl/map.hpp	/^    map& subtract(const domain_type& key)$/;"	f	class:boost::icl::map	access:public	signature:(const domain_type& key)
boost::icl::map::subtract	icl/map.hpp	/^    map& subtract(const element_type& value_pair)$/;"	f	class:boost::icl::map	access:public	signature:(const element_type& value_pair)
boost::icl::map::swap	icl/map.hpp	/^    void swap(map& src) { base_type::swap(src); }$/;"	f	class:boost::icl::map	access:public	signature:(map& src)
boost::icl::map::total_add_intersection	icl/map.hpp	/^    void total_add_intersection(type& section, const FragmentT& fragment)const$/;"	f	class:boost::icl::map	access:private	signature:(type& section, const FragmentT& fragment) const
boost::icl::map::traits	icl/map.hpp	/^    typedef Traits traits;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::type	icl/map.hpp	/^    typedef typename icl::map<DomainT,CodomainT,Traits, Compare,Combine,Section,Alloc> type;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::value_compare	icl/map.hpp	/^    typedef typename base_type::value_compare           value_compare;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::value_type	icl/map.hpp	/^    typedef std::pair<const DomainT, CodomainT>         value_type;$/;"	t	class:boost::icl::map	access:public
boost::icl::map::within	icl/map.hpp	/^    bool within(const map& super)const $/;"	f	class:boost::icl::map	access:public	signature:(const map& super) const
boost::icl::mapped_reference	icl/detail/mapped_reference.hpp	/^class mapped_reference$/;"	c	namespace:boost::icl
boost::icl::mapped_reference::first	icl/detail/mapped_reference.hpp	/^    const first_type&     first ;$/;"	m	class:boost::icl::mapped_reference	access:public
boost::icl::mapped_reference::first_type	icl/detail/mapped_reference.hpp	/^    typedef FirstT  first_type;   $/;"	t	class:boost::icl::mapped_reference	access:public
boost::icl::mapped_reference::key_std_pair_type	icl/detail/mapped_reference.hpp	/^    typedef std::pair<const first_type, second_type> key_std_pair_type; $/;"	t	class:boost::icl::mapped_reference	access:public
boost::icl::mapped_reference::mapped_reference	icl/detail/mapped_reference.hpp	/^    mapped_reference(const FirstT& fst, second_reference_type snd) : first(fst), second(snd){}$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const FirstT& fst, second_reference_type snd)
boost::icl::mapped_reference::mapped_reference	icl/detail/mapped_reference.hpp	/^    mapped_reference(const mapped_reference<FstT, SndT>& source):$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const mapped_reference<FstT, SndT>& source)
boost::icl::mapped_reference::operator !=	icl/detail/mapped_reference.hpp	/^    operator != (const Comparand& right)const$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const Comparand& right) const
boost::icl::mapped_reference::operator <	icl/detail/mapped_reference.hpp	/^    operator < (const Comparand& right)const$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const Comparand& right) const
boost::icl::mapped_reference::operator <=	icl/detail/mapped_reference.hpp	/^    operator <= (const Comparand& right)const$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const Comparand& right) const
boost::icl::mapped_reference::operator =	icl/detail/mapped_reference.hpp	/^    mapped_reference& operator = (const mapped_reference&);$/;"	p	class:boost::icl::mapped_reference	access:private	signature:(const mapped_reference&)
boost::icl::mapped_reference::operator ==	icl/detail/mapped_reference.hpp	/^    operator == (const Comparand& right)const$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const Comparand& right) const
boost::icl::mapped_reference::operator >	icl/detail/mapped_reference.hpp	/^    operator > (const Comparand& right)const$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const Comparand& right) const
boost::icl::mapped_reference::operator >=	icl/detail/mapped_reference.hpp	/^    operator >= (const Comparand& right)const$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const Comparand& right) const
boost::icl::mapped_reference::operator std::pair<FstT,SndT>	icl/detail/mapped_reference.hpp	/^    operator std::pair<FstT,SndT>(){ return std::pair<FstT,SndT>(first, second); }$/;"	f	class:boost::icl::mapped_reference	access:public	signature:()
boost::icl::mapped_reference::second	icl/detail/mapped_reference.hpp	/^    second_reference_type second;$/;"	m	class:boost::icl::mapped_reference	access:public
boost::icl::mapped_reference::second_reference_type	icl/detail/mapped_reference.hpp	/^                 const second_type&>::type second_reference_type;$/;"	t	class:boost::icl::mapped_reference	access:public
boost::icl::mapped_reference::second_type	icl/detail/mapped_reference.hpp	/^    typedef SecondT second_type; $/;"	t	class:boost::icl::mapped_reference	access:public
boost::icl::mapped_reference::std_pair_type	icl/detail/mapped_reference.hpp	/^    typedef std::pair<      first_type, second_type>     std_pair_type; $/;"	t	class:boost::icl::mapped_reference	access:public
boost::icl::mapped_reference::type	icl/detail/mapped_reference.hpp	/^    typedef mapped_reference type;$/;"	t	class:boost::icl::mapped_reference	access:public
boost::icl::mapping_pair	icl/interval_base_map.hpp	/^struct mapping_pair$/;"	s	namespace:boost::icl
boost::icl::mapping_pair::data	icl/interval_base_map.hpp	/^    CodomainT data;$/;"	m	struct:boost::icl::mapping_pair	access:public
boost::icl::mapping_pair::key	icl/interval_base_map.hpp	/^    DomainT   key;$/;"	m	struct:boost::icl::mapping_pair	access:public
boost::icl::mapping_pair::mapping_pair	icl/interval_base_map.hpp	/^    mapping_pair():key(), data(){}$/;"	f	struct:boost::icl::mapping_pair	access:public	signature:()
boost::icl::mapping_pair::mapping_pair	icl/interval_base_map.hpp	/^    mapping_pair(const DomainT& key_value, const CodomainT& data_value)$/;"	f	struct:boost::icl::mapping_pair	access:public	signature:(const DomainT& key_value, const CodomainT& data_value)
boost::icl::mapping_pair::mapping_pair	icl/interval_base_map.hpp	/^    mapping_pair(const std::pair<DomainT,CodomainT>& std_pair)$/;"	f	struct:boost::icl::mapping_pair	access:public	signature:(const std::pair<DomainT,CodomainT>& std_pair)
boost::icl::member_property	icl/type_traits/predicate.hpp	/^    class member_property : public property<Type>$/;"	c	namespace:boost::icl	inherits:property
boost::icl::member_property::bool	icl/type_traits/predicate.hpp	/^        member_property( bool(Type::* pred)()const ): property<Type>(), m_pred(pred){}$/;"	f	class:boost::icl::member_property	access:public	signature:(Type::* pred) const
boost::icl::member_property::m_pred	icl/type_traits/predicate.hpp	/^        bool(Type::* m_pred)()const;$/;"	m	class:boost::icl::member_property	access:private
boost::icl::member_property::operator ()	icl/type_traits/predicate.hpp	/^        bool operator()(const Type& x)const { return (x.*m_pred)(); }$/;"	f	class:boost::icl::member_property	access:public	signature:(const Type& x) const
boost::icl::no_type	icl/type_traits/no_type.hpp	/^    struct no_type{};$/;"	s	namespace:boost::icl
boost::icl::non_empty	icl/concept/interval.hpp	/^namespace non_empty$/;"	n	namespace:boost::icl
boost::icl::non_empty::contains	icl/concept/interval.hpp	/^    contains(const Type& super, const Type& sub)$/;"	f	namespace:boost::icl::non_empty	signature:(const Type& super, const Type& sub)
boost::icl::non_empty::exclusive_less	icl/concept/interval.hpp	/^    exclusive_less(const Type& left, const Type& right)$/;"	f	namespace:boost::icl::non_empty	signature:(const Type& left, const Type& right)
boost::icl::numeric_infinity	icl/type_traits/infinity.hpp	/^struct numeric_infinity$/;"	s	namespace:boost::icl
boost::icl::numeric_infinity::type	icl/type_traits/infinity.hpp	/^    typedef numeric_infinity type;$/;"	t	struct:boost::icl::numeric_infinity	access:public
boost::icl::numeric_infinity::value	icl/type_traits/infinity.hpp	/^    static Type value()$/;"	f	struct:boost::icl::numeric_infinity	access:public	signature:()
boost::icl::numeric_minimum	icl/type_traits/is_numeric.hpp	/^struct numeric_minimum$/;"	s	namespace:boost::icl
boost::icl::numeric_minimum	icl/type_traits/is_numeric.hpp	/^struct numeric_minimum<Type, std::greater<Type>, true>$/;"	s	namespace:boost::icl
boost::icl::numeric_minimum	icl/type_traits/is_numeric.hpp	/^struct numeric_minimum<Type, std::less<Type>, true>$/;"	s	namespace:boost::icl
boost::icl::numeric_minimum::is_less_than	icl/type_traits/is_numeric.hpp	/^    static bool is_less_than(Type value)$/;"	f	struct:boost::icl::numeric_minimum	access:public	signature:(Type value)
boost::icl::numeric_minimum::is_less_than	icl/type_traits/is_numeric.hpp	/^    static bool is_less_than(Type){ return true; }$/;"	f	struct:boost::icl::numeric_minimum	access:public	signature:(Type)
boost::icl::numeric_minimum::is_less_than_or	icl/type_traits/is_numeric.hpp	/^    static bool is_less_than_or(Type value, bool cond)$/;"	f	struct:boost::icl::numeric_minimum	access:public	signature:(Type value, bool cond)
boost::icl::numeric_minimum::is_less_than_or	icl/type_traits/is_numeric.hpp	/^    static bool is_less_than_or(Type, bool){ return true; }$/;"	f	struct:boost::icl::numeric_minimum	access:public	signature:(Type, bool)
boost::icl::on_absorbtion	icl/detail/on_absorbtion.hpp	/^struct on_absorbtion<Type, Combiner, false>$/;"	s	namespace:boost::icl
boost::icl::on_absorbtion	icl/detail/on_absorbtion.hpp	/^struct on_absorbtion<Type, Combiner, true>$/;"	s	namespace:boost::icl
boost::icl::on_absorbtion::codomain_combine	icl/detail/on_absorbtion.hpp	/^    typedef typename Type::codomain_combine codomain_combine;$/;"	t	struct:boost::icl::on_absorbtion	access:public
boost::icl::on_absorbtion::codomain_type	icl/detail/on_absorbtion.hpp	/^    typedef typename Type::codomain_type codomain_type;$/;"	t	struct:boost::icl::on_absorbtion	access:public
boost::icl::on_absorbtion::is_absorbable	icl/detail/on_absorbtion.hpp	/^    static bool is_absorbable(const codomain_type& co_value)$/;"	f	struct:boost::icl::on_absorbtion	access:public	signature:(const codomain_type& co_value)
boost::icl::on_absorbtion::is_absorbable	icl/detail/on_absorbtion.hpp	/^    static bool is_absorbable(const codomain_type&){ return false; }$/;"	f	struct:boost::icl::on_absorbtion	access:public	signature:(const codomain_type&)
boost::icl::on_absorbtion::type	icl/detail/on_absorbtion.hpp	/^    typedef on_absorbtion type;$/;"	t	struct:boost::icl::on_absorbtion	access:public
boost::icl::open_interval	icl/open_interval.hpp	/^class open_interval$/;"	c	namespace:boost::icl
boost::icl::open_interval::_lwb	icl/open_interval.hpp	/^    DomainT _lwb;$/;"	m	class:boost::icl::open_interval	access:private
boost::icl::open_interval::_upb	icl/open_interval.hpp	/^    DomainT _upb;$/;"	m	class:boost::icl::open_interval	access:private
boost::icl::open_interval::domain_compare	icl/open_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::open_interval	access:public
boost::icl::open_interval::domain_type	icl/open_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::open_interval	access:public
boost::icl::open_interval::lower	icl/open_interval.hpp	/^    DomainT lower()const{ return _lwb; }$/;"	f	class:boost::icl::open_interval	access:public	signature:() const
boost::icl::open_interval::open_interval	icl/open_interval.hpp	/^    explicit open_interval(const DomainT& val)$/;"	f	class:boost::icl::open_interval	access:public	signature:(const DomainT& val)
boost::icl::open_interval::open_interval	icl/open_interval.hpp	/^    open_interval() $/;"	f	class:boost::icl::open_interval	access:public	signature:()
boost::icl::open_interval::open_interval	icl/open_interval.hpp	/^    open_interval(const DomainT& low, const DomainT& up) :$/;"	f	class:boost::icl::open_interval	access:public	signature:(const DomainT& low, const DomainT& up)
boost::icl::open_interval::type	icl/open_interval.hpp	/^    typedef open_interval<DomainT,Compare> type;$/;"	t	class:boost::icl::open_interval	access:public
boost::icl::open_interval::upper	icl/open_interval.hpp	/^    DomainT upper()const{ return _upb; }$/;"	f	class:boost::icl::open_interval	access:public	signature:() const
boost::icl::operator !=	icl/concept/comparable.hpp	/^operator != (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::operator !=	icl/concept/interval.hpp	/^operator != (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::operator !=	icl/concept/interval_bounds.hpp	/^inline bool operator != (const interval_bounds x1, const interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(const interval_bounds x1, const interval_bounds x2)
boost::icl::operator !=	icl/detail/mapped_reference.hpp	/^operator != (                         const StdPairT& left, $/;"	f	namespace:boost::icl	signature:( const StdPairT& left, const mapped_reference<FirstT, SecondT>& right)
boost::icl::operator &	icl/concept/element_associator.hpp	/^operator & (Type object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const Type& operand)
boost::icl::operator &	icl/concept/element_associator.hpp	/^operator & (Type object, const typename Type::key_type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::key_type& operand)
boost::icl::operator &	icl/concept/element_associator.hpp	/^operator & (const typename Type::key_type& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const typename Type::key_type& operand, Type object)
boost::icl::operator &	icl/concept/element_map.hpp	/^operator & (Type object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::element_type& operand)
boost::icl::operator &	icl/concept/element_map.hpp	/^operator & (Type object, const typename Type::key_object_type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::key_object_type& operand)
boost::icl::operator &	icl/concept/element_map.hpp	/^operator & (const typename Type::element_type& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const typename Type::element_type& operand, Type object)
boost::icl::operator &	icl/concept/element_map.hpp	/^operator & (const typename Type::key_object_type& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const typename Type::key_object_type& operand, Type object)
boost::icl::operator &	icl/concept/interval.hpp	/^operator & (Type left, const Type& right)$/;"	f	namespace:boost::icl	signature:(Type left, const Type& right)
boost::icl::operator &	icl/concept/interval_associator.hpp	/^operator & (Type object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const OperandT& operand)
boost::icl::operator &	icl/concept/interval_associator.hpp	/^operator & (Type object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const Type& operand)
boost::icl::operator &	icl/concept/interval_associator.hpp	/^operator & (Type&& object, Type&& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, Type&& operand)
boost::icl::operator &	icl/concept/interval_associator.hpp	/^operator & (Type&& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const OperandT& operand)
boost::icl::operator &	icl/concept/interval_associator.hpp	/^operator & (Type&& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const Type& operand)
boost::icl::operator &	icl/concept/interval_associator.hpp	/^operator & (const OperandT& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type object)
boost::icl::operator &	icl/concept/interval_associator.hpp	/^operator & (const OperandT& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type&& object)
boost::icl::operator &	icl/concept/interval_associator.hpp	/^operator & (const OperandT& operand, const Type& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, const Type& object)
boost::icl::operator &	icl/concept/interval_associator.hpp	/^operator & (const Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const OperandT& operand)
boost::icl::operator &	icl/concept/interval_associator.hpp	/^operator & (const Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const Type& operand)
boost::icl::operator &	icl/concept/interval_associator.hpp	/^operator & (const Type& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const Type& operand, Type&& object)
boost::icl::operator &	icl/concept/interval_bounds.hpp	/^inline interval_bounds operator & (interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
boost::icl::operator &=	icl/concept/element_associator.hpp	/^operator &= (Type& object, const typename Type::key_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::key_type& operand)
boost::icl::operator &=	icl/concept/element_associator.hpp	/^operator &= (Type& object, const typename key_container_type_of<Type>::type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename key_container_type_of<Type>::type& operand)
boost::icl::operator &=	icl/concept/element_map.hpp	/^operator &=(Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const Type& operand)
boost::icl::operator &=	icl/concept/element_map.hpp	/^operator &=(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::operator &=	icl/concept/interval_associator.hpp	/^operator &= (Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
boost::icl::operator +	icl/concept/element_associator.hpp	/^operator + (Type object, const Type& operand) $/;"	f	namespace:boost::icl	signature:(Type object, const Type& operand)
boost::icl::operator +	icl/concept/element_associator.hpp	/^operator + (Type object, const typename Type::value_type& operand) $/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::value_type& operand)
boost::icl::operator +	icl/concept/element_associator.hpp	/^operator + (const typename Type::value_type& operand, Type object) $/;"	f	namespace:boost::icl	signature:(const typename Type::value_type& operand, Type object)
boost::icl::operator +	icl/concept/interval_associator.hpp	/^operator + (Type object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const OperandT& operand)
boost::icl::operator +	icl/concept/interval_associator.hpp	/^operator + (Type object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const Type& operand)
boost::icl::operator +	icl/concept/interval_associator.hpp	/^operator + (Type&& object, Type&& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, Type&& operand)
boost::icl::operator +	icl/concept/interval_associator.hpp	/^operator + (Type&& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const OperandT& operand)
boost::icl::operator +	icl/concept/interval_associator.hpp	/^operator + (Type&& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const Type& operand)
boost::icl::operator +	icl/concept/interval_associator.hpp	/^operator + (const OperandT& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type object)
boost::icl::operator +	icl/concept/interval_associator.hpp	/^operator + (const OperandT& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type&& object)
boost::icl::operator +	icl/concept/interval_associator.hpp	/^operator + (const OperandT& operand, const Type& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, const Type& object)
boost::icl::operator +	icl/concept/interval_associator.hpp	/^operator + (const Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const OperandT& operand)
boost::icl::operator +	icl/concept/interval_associator.hpp	/^operator + (const Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const Type& operand)
boost::icl::operator +	icl/concept/interval_associator.hpp	/^operator + (const Type& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const Type& operand, Type&& object)
boost::icl::operator ++	icl/gregorian.hpp	/^    inline boost::gregorian::date operator ++(boost::gregorian::date& x)$/;"	f	namespace:boost::icl	signature:(boost::gregorian::date& x)
boost::icl::operator ++	icl/gregorian.hpp	/^    inline boost::gregorian::date_duration operator ++(boost::gregorian::date_duration& x)$/;"	f	namespace:boost::icl	signature:(boost::gregorian::date_duration& x)
boost::icl::operator ++	icl/ptime.hpp	/^    inline boost::posix_time::ptime operator ++(boost::posix_time::ptime& x)$/;"	f	namespace:boost::icl	signature:(boost::posix_time::ptime& x)
boost::icl::operator ++	icl/ptime.hpp	/^    inline boost::posix_time::time_duration operator ++(boost::posix_time::time_duration& x)$/;"	f	namespace:boost::icl	signature:(boost::posix_time::time_duration& x)
boost::icl::operator +=	icl/concept/element_associator.hpp	/^operator += (Type& object, const Type& operand) $/;"	f	namespace:boost::icl	signature:(Type& object, const Type& operand)
boost::icl::operator +=	icl/concept/element_associator.hpp	/^operator += (Type& object, const typename Type::value_type& operand) $/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& operand)
boost::icl::operator +=	icl/concept/interval_associator.hpp	/^operator += (Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
boost::icl::operator -	icl/concept/element_associator.hpp	/^operator - (Type object, const Type& subtrahend) $/;"	f	namespace:boost::icl	signature:(Type object, const Type& subtrahend)
boost::icl::operator -	icl/concept/element_associator.hpp	/^operator - (Type object, const typename Type::value_type& operand) $/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::value_type& operand)
boost::icl::operator -	icl/concept/element_map.hpp	/^operator - (Type object, const typename Type::set_type& subtrahend) $/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::set_type& subtrahend)
boost::icl::operator -	icl/concept/interval_associator.hpp	/^operator - (Type object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const OperandT& operand)
boost::icl::operator -	icl/concept/interval_associator.hpp	/^operator - (Type&& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const OperandT& operand)
boost::icl::operator -	icl/concept/interval_associator.hpp	/^operator - (const Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const OperandT& operand)
boost::icl::operator --	icl/gregorian.hpp	/^    inline boost::gregorian::date operator --(boost::gregorian::date& x)$/;"	f	namespace:boost::icl	signature:(boost::gregorian::date& x)
boost::icl::operator --	icl/gregorian.hpp	/^    inline boost::gregorian::date_duration operator --(boost::gregorian::date_duration& x)$/;"	f	namespace:boost::icl	signature:(boost::gregorian::date_duration& x)
boost::icl::operator --	icl/ptime.hpp	/^    inline boost::posix_time::ptime operator --(boost::posix_time::ptime& x)$/;"	f	namespace:boost::icl	signature:(boost::posix_time::ptime& x)
boost::icl::operator --	icl/ptime.hpp	/^    inline boost::posix_time::time_duration operator --(boost::posix_time::time_duration& x)$/;"	f	namespace:boost::icl	signature:(boost::posix_time::time_duration& x)
boost::icl::operator -=	icl/concept/element_associator.hpp	/^operator -= (Type& object, const Type& subtrahend) $/;"	f	namespace:boost::icl	signature:(Type& object, const Type& subtrahend)
boost::icl::operator -=	icl/concept/element_associator.hpp	/^operator -= (Type& object, const typename Type::value_type& operand) $/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& operand)
boost::icl::operator -=	icl/concept/element_map.hpp	/^operator -= (Type& object, const typename Type::set_type& operand) $/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::set_type& operand)
boost::icl::operator -=	icl/concept/interval_associator.hpp	/^operator -= (Type& object, const IntervalSetT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const IntervalSetT& operand)
boost::icl::operator -=	icl/concept/interval_associator.hpp	/^operator -= (Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
boost::icl::operator -=	icl/concept/interval_associator.hpp	/^operator -=(Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
boost::icl::operator <	icl/concept/element_associator.hpp	/^operator < (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::operator <	icl/concept/interval.hpp	/^operator < (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::operator <	icl/concept/interval_associator.hpp	/^operator < (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::operator <	icl/detail/mapped_reference.hpp	/^operator < (                         const StdPairT& left, $/;"	f	namespace:boost::icl	signature:( const StdPairT& left, const mapped_reference<FirstT, SecondT>& right)
boost::icl::operator <<	icl/concept/element_map.hpp	/^operator << (std::basic_ostream<CharType, CharTraits>& stream, const Type& object)$/;"	f	namespace:boost::icl	signature:(std::basic_ostream<CharType, CharTraits>& stream, const Type& object)
boost::icl::operator <<	icl/concept/element_set.hpp	/^operator << (std::basic_ostream<CharType, CharTraits>& stream, const Type& object)$/;"	f	namespace:boost::icl	signature:(std::basic_ostream<CharType, CharTraits>& stream, const Type& object)
boost::icl::operator <<	icl/concept/interval.hpp	/^operator << (std::basic_ostream<CharType, CharTraits> &stream, Type const& object)$/;"	f	namespace:boost::icl	signature:(std::basic_ostream<CharType, CharTraits> &stream, Type const& object)
boost::icl::operator <<	icl/concept/interval_bounds.hpp	/^inline interval_bounds operator << (interval_bounds bounds, unsigned int shift)$/;"	f	namespace:boost::icl	signature:(interval_bounds bounds, unsigned int shift)
boost::icl::operator <<	icl/concept/interval_bounds.hpp	/^std::basic_ostream<CharType, CharTraits>& operator <<$/;"	f	namespace:boost::icl	signature:(std::basic_ostream<CharType, CharTraits> &stream, interval_bounds const& object)
boost::icl::operator <<	icl/concept/interval_map.hpp	/^operator << (std::basic_ostream<CharType, CharTraits>& stream, const Type& object)$/;"	f	namespace:boost::icl	signature:(std::basic_ostream<CharType, CharTraits>& stream, const Type& object)
boost::icl::operator <<	icl/concept/interval_set.hpp	/^operator << (std::basic_ostream<CharType, CharTraits>& stream, const Type& object)$/;"	f	namespace:boost::icl	signature:(std::basic_ostream<CharType, CharTraits>& stream, const Type& object)
boost::icl::operator <=	icl/concept/comparable.hpp	/^operator <= (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::operator <=	icl/detail/mapped_reference.hpp	/^operator <= (                         const StdPairT& left, $/;"	f	namespace:boost::icl	signature:( const StdPairT& left, const mapped_reference<FirstT, SecondT>& right)
boost::icl::operator ==	icl/concept/element_associator.hpp	/^operator == (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::operator ==	icl/concept/interval.hpp	/^operator == (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::operator ==	icl/concept/interval_associator.hpp	/^operator == (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::operator ==	icl/concept/interval_bounds.hpp	/^inline bool operator == (const interval_bounds x1, const interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(const interval_bounds x1, const interval_bounds x2)
boost::icl::operator ==	icl/detail/mapped_reference.hpp	/^operator == (                         const StdPairT& left, $/;"	f	namespace:boost::icl	signature:( const StdPairT& left, const mapped_reference<FirstT, SecondT>& right)
boost::icl::operator >	icl/concept/comparable.hpp	/^operator > (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::operator >	icl/concept/interval.hpp	/^operator > (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::operator >	icl/detail/mapped_reference.hpp	/^operator > (                         const StdPairT& left, $/;"	f	namespace:boost::icl	signature:( const StdPairT& left, const mapped_reference<FirstT, SecondT>& right)
boost::icl::operator >=	icl/concept/comparable.hpp	/^operator >= (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::operator >=	icl/detail/mapped_reference.hpp	/^operator >= (                         const StdPairT& left, $/;"	f	namespace:boost::icl	signature:( const StdPairT& left, const mapped_reference<FirstT, SecondT>& right)
boost::icl::operator >>	icl/concept/interval_bounds.hpp	/^inline interval_bounds operator >> (interval_bounds bounds, unsigned int shift)$/;"	f	namespace:boost::icl	signature:(interval_bounds bounds, unsigned int shift)
boost::icl::operator ^	icl/concept/element_associator.hpp	/^operator ^ (Type object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const Type& operand)
boost::icl::operator ^	icl/concept/element_associator.hpp	/^operator ^ (Type object, const typename Type::value_type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::value_type& operand)
boost::icl::operator ^	icl/concept/element_associator.hpp	/^operator ^ (const typename Type::value_type& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const typename Type::value_type& operand, Type object)
boost::icl::operator ^	icl/concept/interval_associator.hpp	/^operator ^ (Type object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const OperandT& operand)
boost::icl::operator ^	icl/concept/interval_associator.hpp	/^operator ^ (Type&& object, Type&& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, Type&& operand)
boost::icl::operator ^	icl/concept/interval_associator.hpp	/^operator ^ (Type&& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const OperandT& operand)
boost::icl::operator ^	icl/concept/interval_associator.hpp	/^operator ^ (Type&& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const Type& operand)
boost::icl::operator ^	icl/concept/interval_associator.hpp	/^operator ^ (const OperandT& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type object)
boost::icl::operator ^	icl/concept/interval_associator.hpp	/^operator ^ (const OperandT& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type&& object)
boost::icl::operator ^	icl/concept/interval_associator.hpp	/^operator ^ (const OperandT& operand, const Type& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, const Type& object)
boost::icl::operator ^	icl/concept/interval_associator.hpp	/^operator ^ (const Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const OperandT& operand)
boost::icl::operator ^	icl/concept/interval_associator.hpp	/^operator ^ (const Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const Type& operand)
boost::icl::operator ^	icl/concept/interval_associator.hpp	/^operator ^ (const Type& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const Type& operand, Type&& object)
boost::icl::operator ^	icl/concept/interval_associator.hpp	/^operator ^ (typename Type::overloadable_type object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(typename Type::overloadable_type object, const Type& operand)
boost::icl::operator ^=	icl/concept/element_map.hpp	/^operator ^= (Type& object, const CoType&)$/;"	f	namespace:boost::icl	signature:(Type& object, const CoType&)
boost::icl::operator ^=	icl/concept/element_map.hpp	/^operator ^= (Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const Type& operand)
boost::icl::operator ^=	icl/concept/element_map.hpp	/^operator ^= (Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::operator ^=	icl/concept/element_set.hpp	/^operator ^= (Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const Type& operand)
boost::icl::operator ^=	icl/concept/element_set.hpp	/^operator ^= (Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::operator ^=	icl/concept/interval_associator.hpp	/^operator ^= (Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
boost::icl::operator |	icl/concept/element_associator.hpp	/^operator | (Type object, const Type& operand) $/;"	f	namespace:boost::icl	signature:(Type object, const Type& operand)
boost::icl::operator |	icl/concept/element_associator.hpp	/^operator | (Type object, const typename Type::value_type& operand) $/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::value_type& operand)
boost::icl::operator |	icl/concept/element_associator.hpp	/^operator | (const typename Type::value_type& operand, Type object) $/;"	f	namespace:boost::icl	signature:(const typename Type::value_type& operand, Type object)
boost::icl::operator |	icl/concept/interval_associator.hpp	/^operator | (Type object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const OperandT& operand)
boost::icl::operator |	icl/concept/interval_associator.hpp	/^operator | (Type object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const Type& operand)
boost::icl::operator |	icl/concept/interval_associator.hpp	/^operator | (Type&& object, Type&& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, Type&& operand)
boost::icl::operator |	icl/concept/interval_associator.hpp	/^operator | (Type&& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const OperandT& operand)
boost::icl::operator |	icl/concept/interval_associator.hpp	/^operator | (Type&& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const Type& operand)
boost::icl::operator |	icl/concept/interval_associator.hpp	/^operator | (const OperandT& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type object)
boost::icl::operator |	icl/concept/interval_associator.hpp	/^operator | (const OperandT& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type&& object)
boost::icl::operator |	icl/concept/interval_associator.hpp	/^operator | (const OperandT& operand, const Type& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, const Type& object)
boost::icl::operator |	icl/concept/interval_associator.hpp	/^operator | (const Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const OperandT& operand)
boost::icl::operator |	icl/concept/interval_associator.hpp	/^operator | (const Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const Type& operand)
boost::icl::operator |	icl/concept/interval_associator.hpp	/^operator | (const Type& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const Type& operand, Type&& object)
boost::icl::operator |	icl/concept/interval_bounds.hpp	/^inline interval_bounds operator | (interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
boost::icl::operator |=	icl/concept/element_associator.hpp	/^operator |= (Type& object, const Type& operand) $/;"	f	namespace:boost::icl	signature:(Type& object, const Type& operand)
boost::icl::operator |=	icl/concept/element_associator.hpp	/^operator |= (Type& object, const typename Type::value_type& operand) $/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& operand)
boost::icl::operator |=	icl/concept/interval_associator.hpp	/^operator |= (Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
boost::icl::operator ~	icl/concept/interval_bounds.hpp	/^inline interval_bounds operator ~ (interval_bounds x1)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1)
boost::icl::outer_bounds	icl/concept/interval_bounds.hpp	/^inline interval_bounds outer_bounds(interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
boost::icl::outer_bounds	icl/concept/interval_bounds.hpp	/^outer_bounds(const IntervalT& x1, const IntervalT& x2)$/;"	f	namespace:boost::icl	signature:(const IntervalT& x1, const IntervalT& x2)
boost::icl::partial_absorber	icl/map.hpp	/^struct partial_absorber$/;"	s	namespace:boost::icl
boost::icl::partial_absorber::absorbs_identities	icl/map.hpp	/^    enum { absorbs_identities = true };$/;"	e	enum:boost::icl::partial_absorber::__anon12
boost::icl::partial_absorber::is_total	icl/map.hpp	/^    enum { is_total = false };$/;"	e	enum:boost::icl::partial_absorber::__anon13
boost::icl::partial_enricher	icl/map.hpp	/^struct partial_enricher$/;"	s	namespace:boost::icl
boost::icl::partial_enricher::absorbs_identities	icl/map.hpp	/^    enum { absorbs_identities = false };$/;"	e	enum:boost::icl::partial_enricher::__anon14
boost::icl::partial_enricher::is_total	icl/map.hpp	/^    enum { is_total = false };$/;"	e	enum:boost::icl::partial_enricher::__anon15
boost::icl::pred	icl/type_traits/succ_pred.hpp	/^inline static DecrementableT pred(DecrementableT x) { return --x; }$/;"	f	namespace:boost::icl	signature:(DecrementableT x)
boost::icl::predecessor	icl/type_traits/succ_pred.hpp	/^struct predecessor$/;"	s	namespace:boost::icl
boost::icl::predecessor::apply	icl/type_traits/succ_pred.hpp	/^    inline static DomainT apply(DomainT value)$/;"	f	struct:boost::icl::predecessor	access:public	signature:(DomainT value)
boost::icl::property	icl/type_traits/predicate.hpp	/^    class property : public std::unary_function<Type,bool>{};$/;"	c	namespace:boost::icl	inherits:std::unary_function
boost::icl::relation	icl/type_traits/predicate.hpp	/^    class relation : public std::binary_function<LeftT,RightT,bool>{};$/;"	c	namespace:boost::icl	inherits:std::binary_function
boost::icl::rep_type_of	icl/type_traits/rep_type_of.hpp	/^    struct rep_type_of$/;"	s	namespace:boost::icl
boost::icl::rep_type_of::type	icl/type_traits/rep_type_of.hpp	/^            get_rep_type<Type, has_rep_type<Type>::value>::type type;$/;"	t	struct:boost::icl::rep_type_of	access:public
boost::icl::represents	icl/type_traits/rep_type_of.hpp	/^    struct represents \/\/ Rep represents Type;  Type is_wrapper_of Rep$/;"	s	namespace:boost::icl	inherits:mpl::bool_
boost::icl::represents::BOOST_STATIC_CONSTANT	icl/type_traits/rep_type_of.hpp	/^        BOOST_STATIC_CONSTANT(bool, $/;"	p	struct:boost::icl::represents	access:public	signature:(bool, value = (mpl::and_< has_rep_type<Type> , is_same<typename Type::rep, Rep> >::value) )
boost::icl::represents::type	icl/type_traits/rep_type_of.hpp	/^        typedef represents type;$/;"	t	struct:boost::icl::represents	access:public
boost::icl::reverse_bounded_lower	icl/concept/interval.hpp	/^reverse_bounded_lower(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::reverse_bounded_upper	icl/concept/interval.hpp	/^reverse_bounded_upper(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::right	icl/concept/interval_bounds.hpp	/^inline interval_bounds right(interval_bounds x1)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1)
boost::icl::right_bounds	icl/concept/interval_bounds.hpp	/^inline interval_bounds right_bounds(interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
boost::icl::right_bounds	icl/concept/interval_bounds.hpp	/^right_bounds(const IntervalT& x1, const IntervalT& x2)$/;"	f	namespace:boost::icl	signature:(const IntervalT& x1, const IntervalT& x2)
boost::icl::right_bracket	icl/concept/interval.hpp	/^right_bracket(const Type& object) $/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::right_bracket	icl/concept/interval.hpp	/^right_bracket(const Type&) { return ")"; }$/;"	f	namespace:boost::icl	signature:(const Type&)
boost::icl::right_bracket	icl/concept/interval.hpp	/^right_bracket(const Type&) { return "]"; }$/;"	f	namespace:boost::icl	signature:(const Type&)
boost::icl::right_bracket	icl/concept/interval_bounds.hpp	/^inline std::string right_bracket(interval_bounds bounds)$/;"	f	namespace:boost::icl	signature:(interval_bounds bounds)
boost::icl::right_open_interval	icl/right_open_interval.hpp	/^class right_open_interval$/;"	c	namespace:boost::icl
boost::icl::right_open_interval::_lwb	icl/right_open_interval.hpp	/^    domain_type _lwb;$/;"	m	class:boost::icl::right_open_interval	access:private
boost::icl::right_open_interval::_upb	icl/right_open_interval.hpp	/^    domain_type _upb;$/;"	m	class:boost::icl::right_open_interval	access:private
boost::icl::right_open_interval::domain_compare	icl/right_open_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::right_open_interval	access:public
boost::icl::right_open_interval::domain_type	icl/right_open_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::right_open_interval	access:public
boost::icl::right_open_interval::lower	icl/right_open_interval.hpp	/^    domain_type lower()const{ return _lwb; }$/;"	f	class:boost::icl::right_open_interval	access:public	signature:() const
boost::icl::right_open_interval::right_open_interval	icl/right_open_interval.hpp	/^    explicit right_open_interval(const DomainT& val)$/;"	f	class:boost::icl::right_open_interval	access:public	signature:(const DomainT& val)
boost::icl::right_open_interval::right_open_interval	icl/right_open_interval.hpp	/^    right_open_interval() $/;"	f	class:boost::icl::right_open_interval	access:public	signature:()
boost::icl::right_open_interval::right_open_interval	icl/right_open_interval.hpp	/^    right_open_interval(const DomainT& low, const DomainT& up) :$/;"	f	class:boost::icl::right_open_interval	access:public	signature:(const DomainT& low, const DomainT& up)
boost::icl::right_open_interval::type	icl/right_open_interval.hpp	/^    typedef right_open_interval<DomainT,Compare> type;$/;"	t	class:boost::icl::right_open_interval	access:public
boost::icl::right_open_interval::upper	icl/right_open_interval.hpp	/^    domain_type upper()const{ return _upb; }$/;"	f	class:boost::icl::right_open_interval	access:public	signature:() const
boost::icl::right_subtract	icl/concept/interval.hpp	/^right_subtract(Type left, const Type& right_minuend)$/;"	f	namespace:boost::icl	signature:(Type left, const Type& right_minuend)
boost::icl::right_subtract_bounds	icl/concept/interval_bounds.hpp	/^inline interval_bounds right_subtract_bounds(interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
boost::icl::right_subtract_bounds	icl/concept/interval_bounds.hpp	/^right_subtract_bounds(const IntervalT& x1, const IntervalT& x2)$/;"	f	namespace:boost::icl	signature:(const IntervalT& x1, const IntervalT& x2)
boost::icl::segment_adapter	icl/detail/element_iterator.hpp	/^struct segment_adapter $/;"	s	namespace:boost::icl
boost::icl::segment_adapter	icl/detail/element_iterator.hpp	/^struct segment_adapter<SegmentIteratorT, ICL_INTERVAL_TYPE(Interval,DomainT,Compare) >$/;"	s	namespace:boost::icl
boost::icl::segment_adapter	icl/detail/element_iterator.hpp	/^struct segment_adapter<SegmentIteratorT, std::pair<ICL_INTERVAL_TYPE(Interval,DomainT,Compare)const, CodomainT> >$/;"	s	namespace:boost::icl
boost::icl::segment_adapter::codomain_type	icl/detail/element_iterator.hpp	/^    typedef CodomainT                                      codomain_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::codomain_type	icl/detail/element_iterator.hpp	/^    typedef CodomainT                               codomain_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::codomain_type	icl/detail/element_iterator.hpp	/^    typedef DomainT                                 codomain_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::codomain_type	icl/detail/element_iterator.hpp	/^    typedef domain_type                              codomain_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::domain_difference_type	icl/detail/element_iterator.hpp	/^                                                           domain_difference_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::domain_difference_type	icl/detail/element_iterator.hpp	/^                                                     domain_difference_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::domain_difference_type	icl/detail/element_iterator.hpp	/^                                                    domain_difference_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::domain_difference_type	icl/detail/element_iterator.hpp	/^    typedef typename interval_type::difference_type domain_difference_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::domain_type	icl/detail/element_iterator.hpp	/^    typedef DomainT                                 domain_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::domain_type	icl/detail/element_iterator.hpp	/^    typedef typename interval_traits<interval_type>::domain_type domain_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::element_type	icl/detail/element_iterator.hpp	/^    typedef domain_type                              element_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::element_type	icl/detail/element_iterator.hpp	/^    typedef domain_type                             element_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::element_type	icl/detail/element_iterator.hpp	/^    typedef std::pair<DomainT, CodomainT>           element_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::element_type	icl/detail/element_iterator.hpp	/^    typedef std::pair<domain_type, codomain_type>          element_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::first	icl/detail/element_iterator.hpp	/^    static domain_type     first (const SegmentIteratorT& leaper){ return leaper->first(); } $/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
boost::icl::segment_adapter::first	icl/detail/element_iterator.hpp	/^    static domain_type     first (const SegmentIteratorT& leaper){ return leaper->first.first(); } $/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
boost::icl::segment_adapter::interval_type	icl/detail/element_iterator.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare)               interval_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::interval_type	icl/detail/element_iterator.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare)    interval_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::interval_type	icl/detail/element_iterator.hpp	/^    typedef segment_type                             interval_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::interval_type	icl/detail/element_iterator.hpp	/^    typedef segment_type                            interval_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::last	icl/detail/element_iterator.hpp	/^    static domain_type     last  (const SegmentIteratorT& leaper){ return leaper->first.last();  } $/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
boost::icl::segment_adapter::last	icl/detail/element_iterator.hpp	/^    static domain_type     last  (const SegmentIteratorT& leaper){ return leaper->last();  } $/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
boost::icl::segment_adapter::length	icl/detail/element_iterator.hpp	/^    static domain_difference_type length(const SegmentIteratorT& leaper){ return icl::length(*leaper);}$/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
boost::icl::segment_adapter::length	icl/detail/element_iterator.hpp	/^    static domain_difference_type length(const SegmentIteratorT& leaper){ return icl::length(leaper->first);}$/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
boost::icl::segment_adapter::length	icl/detail/element_iterator.hpp	/^    static domain_difference_type length(const SegmentIteratorT& leaper){ return leaper->first.length();}$/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
boost::icl::segment_adapter::length	icl/detail/element_iterator.hpp	/^    static domain_difference_type length(const SegmentIteratorT& leaper){ return leaper->length();}$/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
boost::icl::segment_adapter::segment_type	icl/detail/element_iterator.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) segment_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::transient_element	icl/detail/element_iterator.hpp	/^    static transit_type transient_element(domain_type& inter_pos, const SegmentIteratorT& leaper, $/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(domain_type& inter_pos, const SegmentIteratorT& leaper, const domain_difference_type& sneaker)
boost::icl::segment_adapter::transient_element	icl/detail/element_iterator.hpp	/^    static transit_type transient_element(domain_type& inter_pos, const SegmentIteratorT& leaper,$/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(domain_type& inter_pos, const SegmentIteratorT& leaper, const domain_difference_type& sneaker)
boost::icl::segment_adapter::transit_type	icl/detail/element_iterator.hpp	/^    typedef domain_type&                             transit_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::transit_type	icl/detail/element_iterator.hpp	/^    typedef domain_type&                            transit_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::transit_type	icl/detail/element_iterator.hpp	/^    typedef mapped_reference<DomainT, CodomainT>    transit_type;    $/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::transit_type	icl/detail/element_iterator.hpp	/^    typedef mapped_reference<domain_type, CodomainT>       transit_type;    $/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::type	icl/detail/element_iterator.hpp	/^    typedef segment_adapter                                type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::type	icl/detail/element_iterator.hpp	/^    typedef segment_adapter                          type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_adapter::type	icl/detail/element_iterator.hpp	/^    typedef segment_adapter                         type;$/;"	t	struct:boost::icl::segment_adapter	access:public
boost::icl::segment_type_of	icl/type_traits/segment_type_of.hpp	/^    struct segment_type_of$/;"	s	namespace:boost::icl
boost::icl::segment_type_of::type	icl/type_traits/segment_type_of.hpp	/^            get_segment_type<Type, has_segment_type<Type>::value>::type type;$/;"	t	struct:boost::icl::segment_type_of	access:public
boost::icl::segmental	icl/concept/joinable.hpp	/^namespace segmental$/;"	n	namespace:boost::icl
boost::icl::segmental	icl/detail/interval_morphism.hpp	/^    namespace segmental$/;"	n	namespace:boost::icl
boost::icl::segmental	icl/detail/interval_set_algo.hpp	/^namespace segmental$/;"	n	namespace:boost::icl
boost::icl::segmental::atomize	icl/detail/interval_morphism.hpp	/^        void atomize(ElementContainerT& result, const IntervalContainerT& src)$/;"	f	namespace:boost::icl::segmental	signature:(ElementContainerT& result, const IntervalContainerT& src)
boost::icl::segmental::atomizer	icl/detail/interval_morphism.hpp	/^        struct atomizer$/;"	s	namespace:boost::icl::segmental
boost::icl::segmental::atomizer::operator ()	icl/detail/interval_morphism.hpp	/^            void operator()(AtomizedType& atomized, const ClusteredType& clustered)$/;"	f	struct:boost::icl::segmental::atomizer	access:public	signature:(AtomizedType& atomized, const ClusteredType& clustered)
boost::icl::segmental::cluster	icl/detail/interval_morphism.hpp	/^        void cluster(IntervalContainerT& result, const ElementContainerT& src)$/;"	f	namespace:boost::icl::segmental	signature:(IntervalContainerT& result, const ElementContainerT& src)
boost::icl::segmental::clusterer	icl/detail/interval_morphism.hpp	/^        struct clusterer$/;"	s	namespace:boost::icl::segmental
boost::icl::segmental::clusterer::operator ()	icl/detail/interval_morphism.hpp	/^            void operator()(ClusteredType& clustered, const AtomizedType& atomized)$/;"	f	struct:boost::icl::segmental::clusterer	access:public	signature:(ClusteredType& clustered, const AtomizedType& atomized)
boost::icl::segmental::identity_absorber	icl/detail/interval_morphism.hpp	/^        struct identity_absorber$/;"	s	namespace:boost::icl::segmental
boost::icl::segmental::identity_absorber::operator ()	icl/detail/interval_morphism.hpp	/^            void operator()(AbsorberType& absorber, EnricherType& enricher)$/;"	f	struct:boost::icl::segmental::identity_absorber	access:public	signature:(AbsorberType& absorber, EnricherType& enricher)
boost::icl::segmental::is_joinable	icl/concept/joinable.hpp	/^    is_joinable(typename Type::iterator it_, typename Type::iterator next_, Type* = 0)$/;"	f	namespace:boost::icl::segmental	signature:(typename Type::iterator it_, typename Type::iterator next_, Type* = 0)
boost::icl::segmental::join_left	icl/detail/interval_set_algo.hpp	/^typename Type::iterator join_left(Type& object, typename Type::iterator& it_)$/;"	f	namespace:boost::icl::segmental	signature:(Type& object, typename Type::iterator& it_)
boost::icl::segmental::join_neighbours	icl/detail/interval_set_algo.hpp	/^typename Type::iterator join_neighbours(Type& object, typename Type::iterator& it_)$/;"	f	namespace:boost::icl::segmental	signature:(Type& object, typename Type::iterator& it_)
boost::icl::segmental::join_nodes	icl/detail/interval_set_algo.hpp	/^inline void join_nodes(Type& object, typename Type::iterator& left_, $/;"	f	namespace:boost::icl::segmental	signature:(Type& object, typename Type::iterator& left_, typename Type::iterator& right_)
boost::icl::segmental::join_on_left	icl/detail/interval_set_algo.hpp	/^    join_on_left(Type& object, typename Type::iterator& left_, $/;"	f	namespace:boost::icl::segmental	signature:(Type& object, typename Type::iterator& left_, typename Type::iterator& right_)
boost::icl::segmental::join_on_right	icl/detail/interval_set_algo.hpp	/^    join_on_right(Type& object, typename Type::iterator& left_, $/;"	f	namespace:boost::icl::segmental	signature:(Type& object, typename Type::iterator& left_, typename Type::iterator& right_)
boost::icl::segmental::join_right	icl/detail/interval_set_algo.hpp	/^typename Type::iterator join_right(Type& object, typename Type::iterator& it_)$/;"	f	namespace:boost::icl::segmental	signature:(Type& object, typename Type::iterator& it_)
boost::icl::segmental::join_under	icl/detail/interval_set_algo.hpp	/^    join_under(Type& object, const typename Type::value_type& addend)$/;"	f	namespace:boost::icl::segmental	signature:(Type& object, const typename Type::value_type& addend)
boost::icl::segmental::join_under	icl/detail/interval_set_algo.hpp	/^    join_under(Type& object, const typename Type::value_type& addend,$/;"	f	namespace:boost::icl::segmental	signature:(Type& object, const typename Type::value_type& addend, typename Type::iterator last_)
boost::icl::segmental::joinable	icl/detail/interval_set_algo.hpp	/^inline bool joinable(const Type& _Type, typename Type::iterator& some, typename Type::iterator& next)$/;"	f	namespace:boost::icl::segmental	signature:(const Type& _Type, typename Type::iterator& some, typename Type::iterator& next)
boost::icl::segmental::joiner	icl/detail/interval_morphism.hpp	/^        struct joiner$/;"	s	namespace:boost::icl::segmental
boost::icl::segmental::joiner::operator ()	icl/detail/interval_morphism.hpp	/^            void operator()(JointType& joint, SplitType& split)$/;"	f	struct:boost::icl::segmental::joiner	access:public	signature:(JointType& joint, SplitType& split)
boost::icl::segmentational_fineness	icl/type_traits/is_combinable.hpp	/^template<class Type>struct segmentational_fineness$/;"	s	namespace:boost::icl
boost::icl::segmentational_fineness::type	icl/type_traits/is_combinable.hpp	/^    typedef segmentational_fineness<Type> type;$/;"	t	struct:boost::icl::segmentational_fineness	access:public
boost::icl::segmentational_fineness::value	icl/type_traits/is_combinable.hpp	/^    static const int value = $/;"	m	struct:boost::icl::segmentational_fineness	access:public
boost::icl::separate_interval_set	icl/separate_interval_set.hpp	/^class separate_interval_set: $/;"	c	namespace:boost::icl	inherits:interval_base_set
boost::icl::separate_interval_set::ImplSetT	icl/separate_interval_set.hpp	/^    typedef typename base_type::ImplSetT ImplSetT;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::add_over	icl/separate_interval_set.hpp	/^    iterator add_over(const interval_type& addend)$/;"	f	class:boost::icl::separate_interval_set	access:private	signature:(const interval_type& addend)
boost::icl::separate_interval_set::add_over	icl/separate_interval_set.hpp	/^    iterator add_over(const interval_type& addend, iterator last_)$/;"	f	class:boost::icl::separate_interval_set	access:private	signature:(const interval_type& addend, iterator last_)
boost::icl::separate_interval_set::allocator_type	icl/separate_interval_set.hpp	/^    typedef Alloc<interval_type> allocator_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::assign	icl/separate_interval_set.hpp	/^    void assign(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
boost::icl::separate_interval_set::atomized_type	icl/separate_interval_set.hpp	/^    typedef typename base_type::atomized_type atomized_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::base_type	icl/separate_interval_set.hpp	/^    typedef interval_base_set<type,DomainT,Compare,Interval,Alloc> base_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::codomain_type	icl/separate_interval_set.hpp	/^    typedef DomainT   codomain_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::const_iterator	icl/separate_interval_set.hpp	/^    typedef typename ImplSetT::const_iterator const_iterator;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::data_type	icl/separate_interval_set.hpp	/^    typedef typename ImplSetT::value_type data_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::domain_allocator_type	icl/separate_interval_set.hpp	/^    typedef Alloc<DomainT> domain_allocator_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::domain_compare	icl/separate_interval_set.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::domain_type	icl/separate_interval_set.hpp	/^    typedef DomainT   domain_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::element_type	icl/separate_interval_set.hpp	/^    typedef DomainT   element_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::fineness	icl/separate_interval_set.hpp	/^    enum { fineness = 2 };$/;"	e	enum:boost::icl::separate_interval_set::__anon8
boost::icl::separate_interval_set::handle_inserted	icl/separate_interval_set.hpp	/^    iterator handle_inserted(iterator inserted_)$/;"	f	class:boost::icl::separate_interval_set	access:private	signature:(iterator inserted_)
boost::icl::separate_interval_set::interval_compare	icl/separate_interval_set.hpp	/^    typedef exclusive_less_than<interval_type> interval_compare;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::interval_type	icl/separate_interval_set.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) interval_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::iterator	icl/separate_interval_set.hpp	/^    typedef typename ImplSetT::iterator iterator;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::joint_type	icl/separate_interval_set.hpp	/^    typedef interval_set<DomainT,Compare,Interval,Alloc> joint_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::key_compare	icl/separate_interval_set.hpp	/^    typedef exclusive_less_than<interval_type> key_compare;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::key_object_type	icl/separate_interval_set.hpp	/^    typedef type key_object_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::key_type	icl/separate_interval_set.hpp	/^    typedef typename ImplSetT::key_type   key_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::operator =	icl/separate_interval_set.hpp	/^    separate_interval_set& operator = (const separate_interval_set& src)$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(const separate_interval_set& src)
boost::icl::separate_interval_set::operator =	icl/separate_interval_set.hpp	/^    separate_interval_set& operator = (separate_interval_set&& src)$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(separate_interval_set&& src)
boost::icl::separate_interval_set::operator =	icl/separate_interval_set.hpp	/^    separate_interval_set& operator =$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
boost::icl::separate_interval_set::overloadable_type	icl/separate_interval_set.hpp	/^    typedef type overloadable_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::segment_type	icl/separate_interval_set.hpp	/^    typedef interval_type   segment_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::separate_interval_set	icl/separate_interval_set.hpp	/^    explicit separate_interval_set(const domain_type& elem): base_type() { this->add(elem); }$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(const domain_type& elem)
boost::icl::separate_interval_set::separate_interval_set	icl/separate_interval_set.hpp	/^    explicit separate_interval_set(const interval_type& itv): base_type() { this->add(itv); }$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(const interval_type& itv)
boost::icl::separate_interval_set::separate_interval_set	icl/separate_interval_set.hpp	/^    separate_interval_set$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
boost::icl::separate_interval_set::separate_interval_set	icl/separate_interval_set.hpp	/^    separate_interval_set(): base_type() {}$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:()
boost::icl::separate_interval_set::separate_interval_set	icl/separate_interval_set.hpp	/^    separate_interval_set(const separate_interval_set& src): base_type(src) {}$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(const separate_interval_set& src)
boost::icl::separate_interval_set::separate_interval_set	icl/separate_interval_set.hpp	/^    separate_interval_set(separate_interval_set&& src)$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(separate_interval_set&& src)
boost::icl::separate_interval_set::type	icl/separate_interval_set.hpp	/^    typedef separate_interval_set<DomainT,Compare,Interval,Alloc> type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::separate_interval_set::value_type	icl/separate_interval_set.hpp	/^    typedef typename ImplSetT::value_type value_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
boost::icl::set_at	icl/concept/element_map.hpp	/^set_at(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::set_at	icl/concept/interval_map.hpp	/^set_at(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::set_at	icl/concept/interval_map.hpp	/^set_at(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
boost::icl::shift_lower	icl/concept/interval_bounds.hpp	/^shift_lower(interval_bounds decl, interval_bounds repr, const Type& low)$/;"	f	namespace:boost::icl	signature:(interval_bounds decl, interval_bounds repr, const Type& low)
boost::icl::shift_upper	icl/concept/interval_bounds.hpp	/^shift_upper(interval_bounds decl, interval_bounds repr, const Type& up)$/;"	f	namespace:boost::icl	signature:(interval_bounds decl, interval_bounds repr, const Type& up)
boost::icl::singleton	icl/concept/interval.hpp	/^singleton(const typename interval_traits<Type>::domain_type& value)$/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& value)
boost::icl::size	icl/concept/element_associator.hpp	/^size(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::size	icl/concept/interval.hpp	/^size(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::size	icl/concept/interval_associator.hpp	/^size(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::size	icl/type_traits/size.hpp	/^    template <class Type> struct size{ typedef std::size_t type; };$/;"	s	namespace:boost::icl
boost::icl::size::type	icl/type_traits/size.hpp	/^    template <class Type> struct size{ typedef std::size_t type; };$/;"	t	struct:boost::icl::size	access:public
boost::icl::size_type_of	icl/gregorian.hpp	/^    struct size_type_of<boost::gregorian::date> $/;"	s	namespace:boost::icl
boost::icl::size_type_of	icl/gregorian.hpp	/^    struct size_type_of<boost::gregorian::date_duration> $/;"	s	namespace:boost::icl
boost::icl::size_type_of	icl/interval_traits.hpp	/^struct size_type_of<interval_traits<Type> >$/;"	s	namespace:boost::icl
boost::icl::size_type_of	icl/ptime.hpp	/^    struct size_type_of<boost::posix_time::ptime> $/;"	s	namespace:boost::icl
boost::icl::size_type_of	icl/ptime.hpp	/^    struct size_type_of<boost::posix_time::time_duration> $/;"	s	namespace:boost::icl
boost::icl::size_type_of	icl/type_traits/size_type_of.hpp	/^    struct size_type_of$/;"	s	namespace:boost::icl
boost::icl::size_type_of::domain_type	icl/interval_traits.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::size_type_of	access:public
boost::icl::size_type_of::type	icl/gregorian.hpp	/^        typedef boost::gregorian::date_duration type; $/;"	t	struct:boost::icl::size_type_of	access:public
boost::icl::size_type_of::type	icl/gregorian.hpp	/^    { typedef boost::gregorian::date_duration type; };  $/;"	t	struct:boost::icl::size_type_of	access:public
boost::icl::size_type_of::type	icl/interval_traits.hpp	/^    typedef typename size_type_of<domain_type>::type type;$/;"	t	struct:boost::icl::size_type_of	access:public
boost::icl::size_type_of::type	icl/ptime.hpp	/^        typedef boost::posix_time::time_duration type; $/;"	t	struct:boost::icl::size_type_of	access:public
boost::icl::size_type_of::type	icl/type_traits/size_type_of.hpp	/^                         >::type type;$/;"	t	struct:boost::icl::size_type_of	access:public
boost::icl::span	icl/concept/interval.hpp	/^span(const typename interval_traits<Type>::domain_type& left,$/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& left, const typename interval_traits<Type>::domain_type& right)
boost::icl::split_interval_map	icl/split_interval_map.hpp	/^class split_interval_map:$/;"	c	namespace:boost::icl	inherits:interval_base_map
boost::icl::split_interval_map::ImplMapT	icl/split_interval_map.hpp	/^    typedef typename base_type::ImplMapT ImplMapT;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::assign	icl/split_interval_map.hpp	/^    void assign(const interval_base_map<SubType,DomainT,CodomainT,$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(const interval_base_map<SubType,DomainT,CodomainT, Traits,Compare,Combine,Section,Interval,Alloc>& src)
boost::icl::split_interval_map::base_type	icl/split_interval_map.hpp	/^                               DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> base_type;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::codomain_combine	icl/split_interval_map.hpp	/^    typedef typename base_type::codomain_combine codomain_combine;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::codomain_type	icl/split_interval_map.hpp	/^    typedef CodomainT codomain_type;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::domain_mapping_type	icl/split_interval_map.hpp	/^    typedef typename base_type::domain_mapping_type    domain_mapping_type;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::domain_type	icl/split_interval_map.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::element_type	icl/split_interval_map.hpp	/^    typedef typename base_type::element_type element_type;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::fineness	icl/split_interval_map.hpp	/^    enum { fineness = 3 };$/;"	e	enum:boost::icl::split_interval_map::__anon11
boost::icl::split_interval_map::gap_insert_at	icl/split_interval_map.hpp	/^    void gap_insert_at(iterator& it_, iterator prior_, $/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator& it_, iterator prior_, const interval_type& end_gap, const codomain_type& co_val)
boost::icl::split_interval_map::handle_combined	icl/split_interval_map.hpp	/^    void handle_combined(iterator it_)$/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator it_)
boost::icl::split_interval_map::handle_inserted	icl/split_interval_map.hpp	/^    iterator handle_inserted(iterator it_)const { return it_; }$/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator it_) const
boost::icl::split_interval_map::handle_inserted	icl/split_interval_map.hpp	/^    void handle_inserted(iterator, iterator)const{ }$/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator, iterator) const
boost::icl::split_interval_map::handle_left_combined	icl/split_interval_map.hpp	/^    void handle_left_combined(iterator it_)$/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator it_)
boost::icl::split_interval_map::handle_preceeded_combined	icl/split_interval_map.hpp	/^    void handle_preceeded_combined(iterator prior_, iterator& it_)$/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator prior_, iterator& it_)
boost::icl::split_interval_map::handle_reinserted	icl/split_interval_map.hpp	/^    void handle_reinserted(iterator){}$/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator)
boost::icl::split_interval_map::handle_succeeded_combined	icl/split_interval_map.hpp	/^    void handle_succeeded_combined(iterator it_, iterator)$/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator it_, iterator)
boost::icl::split_interval_map::interval_mapping_type	icl/split_interval_map.hpp	/^    typedef typename base_type::interval_mapping_type  interval_mapping_type;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::interval_set_type	icl/split_interval_map.hpp	/^    typedef interval_set<DomainT,Compare,Interval,Alloc> interval_set_type;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::interval_type	icl/split_interval_map.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) interval_type;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::iterator	icl/split_interval_map.hpp	/^    typedef typename base_type::iterator iterator;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::joint_type	icl/split_interval_map.hpp	/^    typedef       interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> joint_type;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::key_object_type	icl/split_interval_map.hpp	/^    typedef set_type          key_object_type;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::operator =	icl/split_interval_map.hpp	/^    split_interval_map& operator = (const split_interval_map& src)$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(const split_interval_map& src)
boost::icl::split_interval_map::operator =	icl/split_interval_map.hpp	/^    split_interval_map& operator = (split_interval_map&& src)$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(split_interval_map&& src)
boost::icl::split_interval_map::operator =	icl/split_interval_map.hpp	/^    split_interval_map& operator =$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(const interval_base_map<SubType,DomainT,CodomainT, Traits,Compare,Combine,Section,Interval,Alloc>& src)
boost::icl::split_interval_map::overloadable_type	icl/split_interval_map.hpp	/^    typedef type overloadable_type;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::segment_type	icl/split_interval_map.hpp	/^    typedef typename base_type::segment_type segment_type;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::set_type	icl/split_interval_map.hpp	/^    typedef interval_set_type set_type;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::split_interval_map	icl/split_interval_map.hpp	/^    explicit split_interval_map(const domain_mapping_type& base_pair): base_type()$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(const domain_mapping_type& base_pair)
boost::icl::split_interval_map::split_interval_map	icl/split_interval_map.hpp	/^    explicit split_interval_map(const value_type& value_pair): base_type()$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(const value_type& value_pair)
boost::icl::split_interval_map::split_interval_map	icl/split_interval_map.hpp	/^    split_interval_map(): base_type() {}$/;"	f	class:boost::icl::split_interval_map	access:public	signature:()
boost::icl::split_interval_map::split_interval_map	icl/split_interval_map.hpp	/^    split_interval_map(const split_interval_map& src): base_type(src) {}$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(const split_interval_map& src)
boost::icl::split_interval_map::split_interval_map	icl/split_interval_map.hpp	/^    split_interval_map(split_interval_map&& src)$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(split_interval_map&& src)
boost::icl::split_interval_map::traits	icl/split_interval_map.hpp	/^    typedef Traits traits;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::type	icl/split_interval_map.hpp	/^    typedef split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> type;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_map::value_type	icl/split_interval_map.hpp	/^    typedef typename base_type::value_type value_type;$/;"	t	class:boost::icl::split_interval_map	access:public
boost::icl::split_interval_set	icl/split_interval_set.hpp	/^class split_interval_set: $/;"	c	namespace:boost::icl	inherits:interval_base_set
boost::icl::split_interval_set::ImplSetT	icl/split_interval_set.hpp	/^    typedef typename base_type::ImplSetT ImplSetT;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::add_over	icl/split_interval_set.hpp	/^    iterator add_over(const interval_type& addend)$/;"	f	class:boost::icl::split_interval_set	access:private	signature:(const interval_type& addend)
boost::icl::split_interval_set::add_over	icl/split_interval_set.hpp	/^    iterator add_over(const interval_type& addend, iterator last_)$/;"	f	class:boost::icl::split_interval_set	access:private	signature:(const interval_type& addend, iterator last_)
boost::icl::split_interval_set::allocator_type	icl/split_interval_set.hpp	/^    typedef Alloc<interval_type> allocator_type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::assign	icl/split_interval_set.hpp	/^    void assign(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
boost::icl::split_interval_set::atomized_type	icl/split_interval_set.hpp	/^    typedef typename base_type::atomized_type atomized_type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::base_type	icl/split_interval_set.hpp	/^    typedef interval_base_set<type,DomainT,Compare,Interval,Alloc> base_type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::codomain_type	icl/split_interval_set.hpp	/^    typedef DomainT   codomain_type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::const_iterator	icl/split_interval_set.hpp	/^    typedef typename ImplSetT::const_iterator const_iterator;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::data_type	icl/split_interval_set.hpp	/^    typedef typename ImplSetT::value_type data_type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::domain_allocator_type	icl/split_interval_set.hpp	/^    typedef Alloc<DomainT> domain_allocator_type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::domain_compare	icl/split_interval_set.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::domain_type	icl/split_interval_set.hpp	/^    typedef DomainT   domain_type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::element_type	icl/split_interval_set.hpp	/^    typedef DomainT   element_type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::fineness	icl/split_interval_set.hpp	/^    enum { fineness = 3 };$/;"	e	enum:boost::icl::split_interval_set::__anon9
boost::icl::split_interval_set::handle_inserted	icl/split_interval_set.hpp	/^    iterator handle_inserted(iterator inserted_)$/;"	f	class:boost::icl::split_interval_set	access:private	signature:(iterator inserted_)
boost::icl::split_interval_set::interval_compare	icl/split_interval_set.hpp	/^    typedef exclusive_less_than<interval_type> interval_compare;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::interval_type	icl/split_interval_set.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) interval_type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::iterator	icl/split_interval_set.hpp	/^    typedef typename ImplSetT::iterator iterator;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::joint_type	icl/split_interval_set.hpp	/^    typedef interval_set<DomainT,Compare,Interval,Alloc> joint_type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::key_compare	icl/split_interval_set.hpp	/^    typedef exclusive_less_than<interval_type> key_compare;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::key_object_type	icl/split_interval_set.hpp	/^    typedef type key_object_type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::key_type	icl/split_interval_set.hpp	/^    typedef typename ImplSetT::key_type   key_type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::operator =	icl/split_interval_set.hpp	/^    split_interval_set& operator = (const split_interval_set& src)$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(const split_interval_set& src)
boost::icl::split_interval_set::operator =	icl/split_interval_set.hpp	/^    split_interval_set& operator = (split_interval_set&& src)$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(split_interval_set&& src)
boost::icl::split_interval_set::operator =	icl/split_interval_set.hpp	/^    split_interval_set& operator =$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
boost::icl::split_interval_set::overloadable_type	icl/split_interval_set.hpp	/^    typedef type overloadable_type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::segment_type	icl/split_interval_set.hpp	/^    typedef interval_type   segment_type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::split_interval_set	icl/split_interval_set.hpp	/^    explicit split_interval_set(const domain_type& itv): base_type() { this->add(itv); }$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(const domain_type& itv)
boost::icl::split_interval_set::split_interval_set	icl/split_interval_set.hpp	/^    explicit split_interval_set(const interval_type& elem): base_type() { this->add(elem); }$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(const interval_type& elem)
boost::icl::split_interval_set::split_interval_set	icl/split_interval_set.hpp	/^    split_interval_set$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
boost::icl::split_interval_set::split_interval_set	icl/split_interval_set.hpp	/^    split_interval_set(): base_type() {}$/;"	f	class:boost::icl::split_interval_set	access:public	signature:()
boost::icl::split_interval_set::split_interval_set	icl/split_interval_set.hpp	/^    split_interval_set(const split_interval_set& src): base_type(src) {}$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(const split_interval_set& src)
boost::icl::split_interval_set::split_interval_set	icl/split_interval_set.hpp	/^    split_interval_set(split_interval_set&& src)$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(split_interval_set&& src)
boost::icl::split_interval_set::type	icl/split_interval_set.hpp	/^    typedef split_interval_set<DomainT,Compare,Interval,Alloc> type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::split_interval_set::value_type	icl/split_interval_set.hpp	/^    typedef typename ImplSetT::value_type value_type;$/;"	t	class:boost::icl::split_interval_set	access:public
boost::icl::static_interval	icl/interval.hpp	/^    struct static_interval<IntervalT, false, PretendedBounds, RepresentedBounds>$/;"	s	namespace:boost::icl
boost::icl::static_interval	icl/interval.hpp	/^    struct static_interval<IntervalT, true, PretendedBounds, RepresentedBounds>$/;"	s	namespace:boost::icl
boost::icl::static_interval::construct	icl/interval.hpp	/^        static inline IntervalT construct(const domain_type& low, const domain_type& up)$/;"	f	struct:boost::icl::static_interval	access:public	signature:(const domain_type& low, const domain_type& up)
boost::icl::static_interval::domain_type	icl/interval.hpp	/^        typedef typename interval_traits<IntervalT>::domain_type domain_type;$/;"	t	struct:boost::icl::static_interval	access:public
boost::icl::std_equal	icl/predicates/std_equal.hpp	/^    template <class Type> struct std_equal : public relation<Type,Type>$/;"	s	namespace:boost::icl	inherits:relation
boost::icl::std_equal::operator ()	icl/predicates/std_equal.hpp	/^        bool operator()(const Type& lhs, const Type& rhs)const$/;"	f	struct:boost::icl::std_equal	access:public	signature:(const Type& lhs, const Type& rhs) const
boost::icl::sub_super_set	icl/predicates/sub_super_set.hpp	/^    struct sub_super_set : public relation<Type,Type>$/;"	s	namespace:boost::icl	inherits:relation
boost::icl::sub_super_set::operator ()	icl/predicates/sub_super_set.hpp	/^        bool operator()(const Type& sub, const Type& super)const$/;"	f	struct:boost::icl::sub_super_set	access:public	signature:(const Type& sub, const Type& super) const
boost::icl::subtract	icl/concept/element_map.hpp	/^subtract(Type& object, const typename Type::domain_type& key_value)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::domain_type& key_value)
boost::icl::subtract	icl/concept/element_map.hpp	/^subtract(Type& object, const typename Type::element_type& operand) $/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::subtract	icl/concept/element_set.hpp	/^subtract(Type& object, const typename Type::value_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& operand)
boost::icl::subtract	icl/concept/interval_map.hpp	/^subtract(Type& object, const typename Type::domain_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::domain_type& operand)
boost::icl::subtract	icl/concept/interval_map.hpp	/^subtract(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::subtract	icl/concept/interval_map.hpp	/^subtract(Type& object, const typename Type::interval_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::interval_type& operand)
boost::icl::subtract	icl/concept/interval_map.hpp	/^subtract(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
boost::icl::subtract	icl/concept/interval_set.hpp	/^subtract(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
boost::icl::subtract	icl/concept/interval_set.hpp	/^subtract(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
boost::icl::succ	icl/type_traits/succ_pred.hpp	/^inline static IncrementableT succ(IncrementableT x) { return ++x; }$/;"	f	namespace:boost::icl	signature:(IncrementableT x)
boost::icl::successor	icl/type_traits/succ_pred.hpp	/^struct successor$/;"	s	namespace:boost::icl
boost::icl::successor::apply	icl/type_traits/succ_pred.hpp	/^    inline static DomainT apply(DomainT value)$/;"	f	struct:boost::icl::successor	access:public	signature:(DomainT value)
boost::icl::super_sub_set	icl/predicates/sub_super_set.hpp	/^    struct super_sub_set : public relation<Type,Type>$/;"	s	namespace:boost::icl	inherits:relation
boost::icl::super_sub_set::operator ()	icl/predicates/sub_super_set.hpp	/^        bool operator()(const Type& super, const Type& sub)const$/;"	f	struct:boost::icl::super_sub_set	access:public	signature:(const Type& super, const Type& sub) const
boost::icl::swap	icl/concept/container.hpp	/^swap(Type& left, Type& right)$/;"	f	namespace:boost::icl	signature:(Type& left, Type& right)
boost::icl::to_string	icl/type_traits/to_string.hpp	/^struct to_string$/;"	s	namespace:boost::icl
boost::icl::to_string::apply	icl/type_traits/to_string.hpp	/^    static std::string apply(const Type& value)$/;"	f	struct:boost::icl::to_string	access:public	signature:(const Type& value)
boost::icl::total_absorber	icl/map.hpp	/^struct total_absorber$/;"	s	namespace:boost::icl
boost::icl::total_absorber::absorbs_identities	icl/map.hpp	/^    enum { absorbs_identities = true };$/;"	e	enum:boost::icl::total_absorber::__anon16
boost::icl::total_absorber::is_total	icl/map.hpp	/^    enum { is_total = true };$/;"	e	enum:boost::icl::total_absorber::__anon17
boost::icl::total_enricher	icl/map.hpp	/^struct total_enricher$/;"	s	namespace:boost::icl
boost::icl::total_enricher::absorbs_identities	icl/map.hpp	/^    enum { absorbs_identities = false };$/;"	e	enum:boost::icl::total_enricher::__anon18
boost::icl::total_enricher::is_total	icl/map.hpp	/^    enum { is_total = true };$/;"	e	enum:boost::icl::total_enricher::__anon19
boost::icl::touches	icl/concept/interval.hpp	/^touches(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::type_to_string	icl/closed_interval.hpp	/^struct type_to_string<icl::closed_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/continuous_interval.hpp	/^struct type_to_string<icl::continuous_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/detail/std_set.hpp	/^struct type_to_string<std::set<Type, std::greater<Type> > >$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/detail/std_set.hpp	/^struct type_to_string<std::set<Type> >$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/discrete_interval.hpp	/^struct type_to_string<icl::discrete_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/interval_map.hpp	/^struct type_to_string<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/interval_set.hpp	/^struct type_to_string<icl::interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/left_open_interval.hpp	/^struct type_to_string<icl::left_open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/map.hpp	/^struct type_to_string<icl::map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/open_interval.hpp	/^struct type_to_string<icl::open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/right_open_interval.hpp	/^struct type_to_string<icl::right_open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/separate_interval_set.hpp	/^struct type_to_string<icl::separate_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/split_interval_map.hpp	/^struct type_to_string<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/split_interval_set.hpp	/^struct type_to_string<icl::split_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/type_traits/type_to_string.hpp	/^    struct type_to_string$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/type_traits/type_to_string.hpp	/^    struct type_to_string<Binary<Type1, Type2> >$/;"	s	namespace:boost::icl
boost::icl::type_to_string	icl/type_traits/type_to_string.hpp	/^    struct type_to_string<Unary<Type> >$/;"	s	namespace:boost::icl
boost::icl::type_to_string::apply	icl/closed_interval.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::type_to_string::apply	icl/continuous_interval.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::type_to_string::apply	icl/detail/std_set.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::type_to_string::apply	icl/discrete_interval.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::type_to_string::apply	icl/interval_map.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::type_to_string::apply	icl/interval_set.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::type_to_string::apply	icl/left_open_interval.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::type_to_string::apply	icl/map.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::type_to_string::apply	icl/map.hpp	/^inline std::string type_to_string<partial_absorber>::apply() { return "@0"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/map.hpp	/^inline std::string type_to_string<partial_enricher>::apply() { return "e0"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/map.hpp	/^inline std::string type_to_string<total_absorber>::apply() { return "^0"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/map.hpp	/^inline std::string type_to_string<total_enricher>::apply() { return "e^0"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/open_interval.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::type_to_string::apply	icl/right_open_interval.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::type_to_string::apply	icl/separate_interval_set.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::type_to_string::apply	icl/split_interval_map.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::type_to_string::apply	icl/split_interval_set.hpp	/^    static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^        static std::string apply()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^        static std::string apply();$/;"	p	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<bool>::apply() { return "bool"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<char>::apply() { return "char"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<double>::apply() { return "dbl"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<float>::apply() { return "flt"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<int>::apply()  { return "int"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<long long>::apply(){ return "Long"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<long>::apply() { return "long"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<short>::apply(){ return "short"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<std::string>::apply() { return "string"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<unsigned char>::apply(){ return "char+"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<unsigned int>::apply()  { return "int+"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<unsigned long long>::apply(){ return "Long+"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<unsigned long>::apply() { return "long+"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::apply	icl/type_traits/type_to_string.hpp	/^    template<>inline std::string type_to_string<unsigned short>::apply(){ return "short+"; }$/;"	f	class:boost::icl::type_to_string	signature:()
boost::icl::type_to_string::to_string	icl/type_traits/type_to_string.hpp	/^        static std::string to_string()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
boost::icl::unary_template_to_string	icl/type_traits/type_to_string.hpp	/^    struct unary_template_to_string$/;"	s	namespace:boost::icl
boost::icl::unary_template_to_string::apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_bit_add>::apply() { return "b|="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_bit_and>::apply() { return "b&="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_bit_subtract>::apply() { return "b-="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_caret>::apply() { return "^="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_erase>::apply() { return "ers="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_erasure>::apply() $/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_et>::apply() { return "&="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_identity>::apply() $/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_insert>::apply() { return "ins="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_max>::apply() { return "max="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_min>::apply() { return "min="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_minus>::apply() { return "-="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_plus>::apply() { return "+="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_slash>::apply() { return "\/="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/functors.hpp	/^    inline std::string unary_template_to_string<inplace_star>::apply() { return "*="; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/predicates/distinct_equal.hpp	/^    inline std::string unary_template_to_string<icl::distinct_equal>::apply()  $/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/predicates/element_equal.hpp	/^    inline std::string unary_template_to_string<icl::element_equal>::apply()  $/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/predicates/std_equal.hpp	/^    inline std::string unary_template_to_string<icl::std_equal>::apply()$/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/predicates/sub_super_set.hpp	/^    inline std::string unary_template_to_string<icl::sub_super_set>::apply()  $/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/predicates/sub_super_set.hpp	/^    inline std::string unary_template_to_string<icl::super_sub_set>::apply()  $/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/type_traits/identity_element.hpp	/^    inline std::string unary_template_to_string<identity_element>::apply() { return "0"; }$/;"	f	class:boost::icl::unary_template_to_string	signature:()
boost::icl::unary_template_to_string::apply	icl/type_traits/type_to_string.hpp	/^        static std::string apply();$/;"	p	struct:boost::icl::unary_template_to_string	access:public	signature:()
boost::icl::unit_element	icl/type_traits/unit_element.hpp	/^    template <class Type> struct unit_element{ static Type value(); };$/;"	s	namespace:boost::icl
boost::icl::unit_element::value	icl/type_traits/unit_element.hpp	/^    inline Type unit_element<Type>::value()$/;"	f	class:boost::icl::unit_element	signature:()
boost::icl::unit_element::value	icl/type_traits/unit_element.hpp	/^    inline std::string unit_element<std::string>::value()$/;"	f	class:boost::icl::unit_element	signature:()
boost::icl::unit_element::value	icl/type_traits/unit_element.hpp	/^    template <class Type> struct unit_element{ static Type value(); };$/;"	p	struct:boost::icl::unit_element	access:public	signature:()
boost::icl::unit_element::value	icl/type_traits/unit_element.hpp	/^    template<> inline bool   unit_element<bool>::value()   { return true;}$/;"	f	class:boost::icl::unit_element	signature:()
boost::icl::unit_element::value	icl/type_traits/unit_element.hpp	/^    template<> inline double unit_element<double>::value() { return 1.0; }$/;"	f	class:boost::icl::unit_element	signature:()
boost::icl::unit_element::value	icl/type_traits/unit_element.hpp	/^    template<> inline float  unit_element<float>::value()  { return 1.0; }$/;"	f	class:boost::icl::unit_element	signature:()
boost::icl::unit_element::value	icl/type_traits/unit_element.hpp	/^    template<> inline long double unit_element<long double>::value() $/;"	f	class:boost::icl::unit_element	signature:()
boost::icl::unit_element_based_inplace_combine	icl/functors.hpp	/^    template <typename Type> struct unit_element_based_inplace_combine $/;"	s	namespace:boost::icl	inherits:std::binary_function
boost::icl::unit_element_based_inplace_combine::identity_element	icl/functors.hpp	/^        inline static Type identity_element() { return boost::icl::unit_element<Type>::value(); }$/;"	f	struct:boost::icl::unit_element_based_inplace_combine	access:public	signature:()
boost::icl::unknown_fineness	icl/type_traits/is_combinable.hpp	/^template<class Type> struct unknown_fineness$/;"	s	namespace:boost::icl
boost::icl::unknown_fineness::type	icl/type_traits/is_combinable.hpp	/^    typedef unknown_fineness<Type> type;$/;"	t	struct:boost::icl::unknown_fineness	access:public
boost::icl::unknown_fineness::value	icl/type_traits/is_combinable.hpp	/^    static const int value = 0;$/;"	m	struct:boost::icl::unknown_fineness	access:public
boost::icl::upper	icl/concept/interval.hpp	/^upper(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::upper	icl/concept/interval_associator.hpp	/^upper(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
boost::icl::upper_equal	icl/concept/interval.hpp	/^upper_equal(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::upper_less	icl/concept/interval.hpp	/^upper_less(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::upper_less_equal	icl/concept/interval.hpp	/^upper_less_equal(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::upper_max	icl/concept/interval.hpp	/^upper_max(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::upper_min	icl/concept/interval.hpp	/^upper_min(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
boost::icl::value_size	icl/closed_interval.hpp	/^struct value_size<icl::closed_interval<DomainT> >$/;"	s	namespace:boost::icl
boost::icl::value_size	icl/continuous_interval.hpp	/^struct value_size<icl::continuous_interval<DomainT> >$/;"	s	namespace:boost::icl
boost::icl::value_size	icl/discrete_interval.hpp	/^struct value_size<icl::discrete_interval<DomainT> >$/;"	s	namespace:boost::icl
boost::icl::value_size	icl/left_open_interval.hpp	/^struct value_size<icl::left_open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::value_size	icl/open_interval.hpp	/^struct value_size<icl::open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::value_size	icl/right_open_interval.hpp	/^struct value_size<icl::right_open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
boost::icl::value_size	icl/type_traits/value_size.hpp	/^struct value_size$/;"	s	namespace:boost::icl
boost::icl::value_size::apply	icl/closed_interval.hpp	/^    static std::size_t apply(const icl::closed_interval<DomainT>&) $/;"	f	struct:boost::icl::value_size	access:public	signature:(const icl::closed_interval<DomainT>&)
boost::icl::value_size::apply	icl/continuous_interval.hpp	/^    static std::size_t apply(const icl::continuous_interval<DomainT>&) $/;"	f	struct:boost::icl::value_size	access:public	signature:(const icl::continuous_interval<DomainT>&)
boost::icl::value_size::apply	icl/discrete_interval.hpp	/^    static std::size_t apply(const icl::discrete_interval<DomainT>&) $/;"	f	struct:boost::icl::value_size	access:public	signature:(const icl::discrete_interval<DomainT>&)
boost::icl::value_size::apply	icl/left_open_interval.hpp	/^    static std::size_t apply(const icl::left_open_interval<DomainT>&) $/;"	f	struct:boost::icl::value_size	access:public	signature:(const icl::left_open_interval<DomainT>&)
boost::icl::value_size::apply	icl/open_interval.hpp	/^    static std::size_t apply(const icl::open_interval<DomainT>&) $/;"	f	struct:boost::icl::value_size	access:public	signature:(const icl::open_interval<DomainT>&)
boost::icl::value_size::apply	icl/right_open_interval.hpp	/^    static std::size_t apply(const icl::right_open_interval<DomainT>&) $/;"	f	struct:boost::icl::value_size	access:public	signature:(const icl::right_open_interval<DomainT>&)
boost::icl::value_size::apply	icl/type_traits/value_size.hpp	/^    static std::size_t apply(const Type& val);$/;"	p	struct:boost::icl::value_size	access:public	signature:(const Type& val)
boost::icl::value_size::apply	icl/type_traits/value_size.hpp	/^inline std::size_t value_size<Type>::apply(const Type& value)$/;"	f	class:boost::icl::value_size	signature:(const Type& value)
boost::icl::value_size::apply	icl/type_traits/value_size.hpp	/^template<> inline std::size_t value_size<double>::apply(const double& value) $/;"	f	class:boost::icl::value_size	signature:(const double& value)
boost::icl::value_size::apply	icl/type_traits/value_size.hpp	/^template<> inline std::size_t value_size<int>::apply(const int& value) $/;"	f	class:boost::icl::value_size	signature:(const int& value)
boost::icl::value_type_of	icl/type_traits/element_type_of.hpp	/^    struct value_type_of$/;"	s	namespace:boost::icl
boost::icl::value_type_of::type	icl/type_traits/element_type_of.hpp	/^            get_value_type<Type, has_value_type<Type>::value>::type type;$/;"	t	struct:boost::icl::value_type_of	access:public
boost::icl::version	icl/functors.hpp	/^    struct version<icl::inplace_minus<Type> > : public conversion<icl::inplace_minus<Type> >$/;"	s	namespace:boost::icl	inherits:conversion
boost::icl::version	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<double     > >{double      operator()(double      val){return -val;}};$/;"	s	namespace:boost::icl
boost::icl::version	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<float      > >{float       operator()(float       val){return -val;}};$/;"	s	namespace:boost::icl
boost::icl::version	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<int        > >{int         operator()(int         val){return -val;}};$/;"	s	namespace:boost::icl
boost::icl::version	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<long       > >{long        operator()(long        val){return -val;}};$/;"	s	namespace:boost::icl
boost::icl::version	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<long double> >{long double operator()(long double val){return -val;}};$/;"	s	namespace:boost::icl
boost::icl::version	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<long long  > >{long long   operator()(long long   val){return -val;}};$/;"	s	namespace:boost::icl
boost::icl::version	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<short      > >{short       operator()(short       val){return -val;}};$/;"	s	namespace:boost::icl
boost::icl::version	icl/functors.hpp	/^    template<class Combiner> struct version : public conversion<Combiner>$/;"	s	namespace:boost::icl	inherits:conversion
boost::icl::version::argument_type	icl/functors.hpp	/^        typedef typename base_type::argument_type argument_type;$/;"	t	struct:boost::icl::version	access:public
boost::icl::version::base_type	icl/functors.hpp	/^        typedef conversion<Combiner> base_type;$/;"	t	struct:boost::icl::version	access:public
boost::icl::version::base_type	icl/functors.hpp	/^        typedef conversion<icl::inplace_minus<Type> > base_type;$/;"	t	struct:boost::icl::version	access:public
boost::icl::version::operator ()	icl/functors.hpp	/^        Type operator()(const Type& value)$/;"	f	struct:boost::icl::version	access:public	signature:(const Type& value)
boost::icl::version::operator ()	icl/functors.hpp	/^        argument_type operator()(const argument_type& value)$/;"	f	struct:boost::icl::version	access:public	signature:(const argument_type& value)
boost::icl::version::operator ()	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<double     > >{double      operator()(double      val){return -val;}};$/;"	f	struct:boost::icl::version	access:public	signature:(double val)
boost::icl::version::operator ()	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<float      > >{float       operator()(float       val){return -val;}};$/;"	f	struct:boost::icl::version	access:public	signature:(float val)
boost::icl::version::operator ()	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<int        > >{int         operator()(int         val){return -val;}};$/;"	f	struct:boost::icl::version	access:public	signature:(int val)
boost::icl::version::operator ()	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<long       > >{long        operator()(long        val){return -val;}};$/;"	f	struct:boost::icl::version	access:public	signature:(long val)
boost::icl::version::operator ()	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<long double> >{long double operator()(long double val){return -val;}};$/;"	f	struct:boost::icl::version	access:public	signature:(long double val)
boost::icl::version::operator ()	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<long long  > >{long long   operator()(long long   val){return -val;}};$/;"	f	struct:boost::icl::version	access:public	signature:(long long val)
boost::icl::version::operator ()	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<short      > >{short       operator()(short       val){return -val;}};$/;"	f	struct:boost::icl::version	access:public	signature:(short val)
boost::icl::version::type	icl/functors.hpp	/^        typedef    version<Combiner> type;$/;"	t	struct:boost::icl::version	access:public
boost::icl::version::type	icl/functors.hpp	/^        typedef    version<icl::inplace_minus<Type> > type;$/;"	t	struct:boost::icl::version	access:public
boost::icl::within	icl/concept/element_associator.hpp	/^within(const SubT& sub, const SuperT& super)$/;"	f	namespace:boost::icl	signature:(const SubT& sub, const SuperT& super)
boost::icl::within	icl/concept/element_associator.hpp	/^within(const typename Type::key_type& key, const Type& super)$/;"	f	namespace:boost::icl	signature:(const typename Type::key_type& key, const Type& super)
boost::icl::within	icl/concept/element_map.hpp	/^within(const typename Type::element_type& value_pair, const Type& super)$/;"	f	namespace:boost::icl	signature:(const typename Type::element_type& value_pair, const Type& super)
boost::icl::within	icl/concept/interval.hpp	/^within(const Type& sub, const Type& super)$/;"	f	namespace:boost::icl	signature:(const Type& sub, const Type& super)
boost::icl::within	icl/concept/interval_associator.hpp	/^within(const SubT& sub, const SuperT& super)$/;"	f	namespace:boost::icl	signature:(const SubT& sub, const SuperT& super)
bound	icl/interval_bounds.hpp	/^    interval_bounds bound()const { return _bound; }$/;"	f	class:boost::icl::bounded_value	access:public	signature:() const
bound_type	icl/interval_bounds.hpp	/^typedef unsigned char bound_type;$/;"	t	namespace:boost::icl
bounded_domain_type	icl/continuous_interval.hpp	/^    typedef typename bounded_value<DomainT>::type bounded_domain_type;$/;"	t	class:boost::icl::continuous_interval	access:public
bounded_domain_type	icl/discrete_interval.hpp	/^    typedef typename bounded_value<DomainT>::type bounded_domain_type;$/;"	t	class:boost::icl::discrete_interval	access:public
bounded_lower	icl/concept/interval.hpp	/^bounded_lower(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
bounded_upper	icl/concept/interval.hpp	/^bounded_upper(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
bounded_value	icl/interval_bounds.hpp	/^    bounded_value(const domain_type& value, interval_bounds bound)$/;"	f	class:boost::icl::bounded_value	access:public	signature:(const domain_type& value, interval_bounds bound)
bounded_value	icl/interval_bounds.hpp	/^class bounded_value$/;"	c	namespace:boost::icl
bounds	icl/concept/interval.hpp	/^bounds(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
bounds	icl/concept/interval.hpp	/^bounds(const Type&)$/;"	f	namespace:boost::icl	signature:(const Type&)
bounds	icl/continuous_interval.hpp	/^    interval_bounds bounds()const{ return _bounds; }$/;"	f	class:boost::icl::continuous_interval	access:public	signature:() const
bounds	icl/discrete_interval.hpp	/^    interval_bounds bounds()const{ return _bounds; }$/;"	f	class:boost::icl::discrete_interval	access:public	signature:() const
cardinality	icl/concept/element_associator.hpp	/^cardinality(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
cardinality	icl/concept/interval.hpp	/^cardinality(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
cardinality	icl/concept/interval_associator.hpp	/^cardinality(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
clear	icl/concept/container.hpp	/^clear(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
clear	icl/interval_base_map.hpp	/^    void clear() { icl::clear(*that()); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:()
clear	icl/interval_base_set.hpp	/^    void clear() { icl::clear(*that()); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:()
closed	icl/continuous_interval.hpp	/^    static continuous_interval closed   (const DomainT& lo, const DomainT& up){ return continuous_interval(lo, up, interval_bounds::closed());    }$/;"	f	class:boost::icl::continuous_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
closed	icl/discrete_interval.hpp	/^    static discrete_interval closed    (const DomainT& lo, const DomainT& up){ return discrete_interval(lo, up, interval_bounds::closed());    }$/;"	f	class:boost::icl::discrete_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
closed	icl/interval.hpp	/^        static inline interval_type closed(const DomainT& low, const DomainT& up)$/;"	f	struct:boost::icl::interval	access:public	signature:(const DomainT& low, const DomainT& up)
closed	icl/interval_bounds.hpp	/^    static interval_bounds closed()    { return interval_bounds(_closed);   }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:()
closed_interval	icl/closed_interval.hpp	/^    closed_interval() $/;"	f	class:boost::icl::closed_interval	access:public	signature:()
closed_interval	icl/closed_interval.hpp	/^    closed_interval(const DomainT& low, const DomainT& up) :$/;"	f	class:boost::icl::closed_interval	access:public	signature:(const DomainT& low, const DomainT& up)
closed_interval	icl/closed_interval.hpp	/^    explicit closed_interval(const DomainT& val)$/;"	f	class:boost::icl::closed_interval	access:public	signature:(const DomainT& val)
closed_interval	icl/closed_interval.hpp	/^class closed_interval$/;"	c	namespace:boost::icl
cluster	icl/detail/interval_morphism.hpp	/^        void cluster(IntervalContainerT& result, const ElementContainerT& src)$/;"	f	namespace:boost::icl::segmental	signature:(IntervalContainerT& result, const ElementContainerT& src)
clusterer	icl/detail/interval_morphism.hpp	/^        struct clusterer$/;"	s	namespace:boost::icl::segmental
co_compare	icl/detail/interval_subset_comparer.hpp	/^    int co_compare(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
co_compare	icl/detail/subset_comparer.hpp	/^    int co_compare(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Set::subset_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
co_equal	icl/detail/associated_value.hpp	/^co_equal(typename Type::const_iterator left_, typename CoType::const_iterator right_, $/;"	f	namespace:boost::icl	signature:(typename Type::const_iterator left_, typename CoType::const_iterator right_, const Type* = 0, const CoType* = 0)
co_equal	icl/detail/associated_value.hpp	/^co_equal(typename Type::const_iterator, typename CoType::const_iterator,$/;"	f	namespace:boost::icl	signature:(typename Type::const_iterator, typename CoType::const_iterator, const Type* = 0, const CoType* = 0)
co_value	icl/concept/element_set_value.hpp	/^co_value(Iterator it_)$/;"	f	namespace:boost::icl	signature:(Iterator it_)
co_value	icl/concept/interval_set_value.hpp	/^co_value(Iterator value_)$/;"	f	namespace:boost::icl	signature:(Iterator value_)
co_value	icl/concept/map_value.hpp	/^co_value(Iterator it_)$/;"	f	namespace:boost::icl	signature:(Iterator it_)
codomain_combine	icl/detail/on_absorbtion.hpp	/^    typedef typename Type::codomain_combine codomain_combine;$/;"	t	struct:boost::icl::on_absorbtion	access:public
codomain_combine	icl/interval_base_map.hpp	/^        typedef typename Type::codomain_combine codomain_combine;$/;"	t	struct:boost::icl::interval_base_map::on_codomain_model	access:public
codomain_combine	icl/interval_base_map.hpp	/^    typedef ICL_COMBINE_CODOMAIN(Combine,CodomainT)  codomain_combine;$/;"	t	class:boost::icl::interval_base_map	access:public
codomain_combine	icl/interval_map.hpp	/^    typedef typename base_type::codomain_combine codomain_combine;$/;"	t	class:boost::icl::interval_map	access:public
codomain_combine	icl/map.hpp	/^    typedef ICL_COMBINE_CODOMAIN(Combine,CodomainT)     codomain_combine;$/;"	t	class:boost::icl::map	access:public
codomain_combine	icl/split_interval_map.hpp	/^    typedef typename base_type::codomain_combine codomain_combine;$/;"	t	class:boost::icl::split_interval_map	access:public
codomain_intersect	icl/interval_base_map.hpp	/^    >::type                                            codomain_intersect;$/;"	t	class:boost::icl::interval_base_map	access:public
codomain_intersect	icl/map.hpp	/^        >::type                                         codomain_intersect;$/;"	t	class:boost::icl::map	access:public
codomain_type	icl/detail/element_iterator.hpp	/^        typedef CodomainT                                       codomain_type;$/;"	t	struct:boost::icl::elemental	access:public
codomain_type	icl/detail/element_iterator.hpp	/^        typedef DomainT                   codomain_type;$/;"	t	struct:boost::icl::elemental	access:public
codomain_type	icl/detail/element_iterator.hpp	/^        typedef domain_type                         codomain_type;$/;"	t	struct:boost::icl::elemental	access:public
codomain_type	icl/detail/element_iterator.hpp	/^    typedef CodomainT                                      codomain_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
codomain_type	icl/detail/element_iterator.hpp	/^    typedef CodomainT                               codomain_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
codomain_type	icl/detail/element_iterator.hpp	/^    typedef DomainT                                 codomain_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
codomain_type	icl/detail/element_iterator.hpp	/^    typedef domain_type                              codomain_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
codomain_type	icl/detail/element_iterator.hpp	/^    typedef typename elemental<segment_type>::codomain_type codomain_type;$/;"	t	class:boost::icl::element_iterator	access:public
codomain_type	icl/detail/on_absorbtion.hpp	/^    typedef typename Type::codomain_type codomain_type;$/;"	t	struct:boost::icl::on_absorbtion	access:public
codomain_type	icl/interval_base_map.hpp	/^        typedef typename Type::codomain_type  codomain_type;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
codomain_type	icl/interval_base_map.hpp	/^        typedef typename Type::codomain_type codomain_type;$/;"	t	struct:boost::icl::interval_base_map::on_codomain_model	access:public
codomain_type	icl/interval_base_map.hpp	/^        typedef typename Type::codomain_type codomain_type;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
codomain_type	icl/interval_base_map.hpp	/^    typedef CodomainT codomain_type;$/;"	t	class:boost::icl::interval_base_map	access:public
codomain_type	icl/interval_base_set.hpp	/^    typedef DomainT   codomain_type;$/;"	t	class:boost::icl::interval_base_set	access:public
codomain_type	icl/interval_map.hpp	/^    typedef typename base_type::codomain_type codomain_type;$/;"	t	class:boost::icl::interval_map	access:public
codomain_type	icl/interval_set.hpp	/^    typedef DomainT   codomain_type;$/;"	t	class:boost::icl::interval_set	access:public
codomain_type	icl/map.hpp	/^        typedef typename Type::codomain_type  codomain_type;$/;"	t	struct:boost::icl::map::on_total_absorbable	access:public
codomain_type	icl/map.hpp	/^        typedef typename Type::codomain_type codomain_type;$/;"	t	struct:boost::icl::map::on_total_absorbable	access:public
codomain_type	icl/map.hpp	/^    typedef CodomainT                                   codomain_type;$/;"	t	class:boost::icl::map	access:public
codomain_type	icl/separate_interval_set.hpp	/^    typedef DomainT   codomain_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
codomain_type	icl/split_interval_map.hpp	/^    typedef CodomainT codomain_type;$/;"	t	class:boost::icl::split_interval_map	access:public
codomain_type	icl/split_interval_set.hpp	/^    typedef DomainT   codomain_type;$/;"	t	class:boost::icl::split_interval_set	access:public
codomain_type_of	icl/type_traits/codomain_type_of.hpp	/^    struct codomain_type_of$/;"	s	namespace:boost::icl
combines_right_to_interval_container	icl/type_traits/is_combinable.hpp	/^struct combines_right_to_interval_container$/;"	s	namespace:boost::icl
combines_right_to_interval_map	icl/type_traits/is_combinable.hpp	/^struct combines_right_to_interval_map$/;"	s	namespace:boost::icl
combines_right_to_interval_set	icl/type_traits/is_combinable.hpp	/^struct combines_right_to_interval_set$/;"	s	namespace:boost::icl
common_range	icl/detail/set_algo.hpp	/^bool common_range(IteratorT& lwb, IteratorT& upb, ObjectT& x1, const ConstObjectT& x2)$/;"	f	namespace:boost::icl::Set	signature:(IteratorT& lwb, IteratorT& upb, ObjectT& x1, const ConstObjectT& x2)
comparison	icl/detail/relation_state.hpp	/^    namespace comparison$/;"	n	namespace:boost::icl
const_iterator	icl/interval_base_map.hpp	/^        typedef typename Type::const_iterator const_iterator;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
const_iterator	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::const_iterator const_iterator;$/;"	t	class:boost::icl::interval_base_map	access:public
const_iterator	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::const_iterator const_iterator;$/;"	t	class:boost::icl::interval_base_set	access:public
const_iterator	icl/interval_set.hpp	/^    typedef typename ImplSetT::const_iterator const_iterator;$/;"	t	class:boost::icl::interval_set	access:public
const_iterator	icl/map.hpp	/^    typedef typename base_type::const_iterator          const_iterator;$/;"	t	class:boost::icl::map	access:public
const_iterator	icl/separate_interval_set.hpp	/^    typedef typename ImplSetT::const_iterator const_iterator;$/;"	t	class:boost::icl::separate_interval_set	access:public
const_iterator	icl/split_interval_set.hpp	/^    typedef typename ImplSetT::const_iterator const_iterator;$/;"	t	class:boost::icl::split_interval_set	access:public
const_pointer	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::const_pointer   const_pointer;$/;"	t	class:boost::icl::interval_base_map	access:public
const_pointer	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::const_pointer   const_pointer;$/;"	t	class:boost::icl::interval_base_set	access:public
const_pointer	icl/map.hpp	/^    typedef typename base_type::const_pointer           const_pointer;$/;"	t	class:boost::icl::map	access:public
const_reference	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::const_reference const_reference;$/;"	t	class:boost::icl::interval_base_map	access:public
const_reference	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::const_reference const_reference;$/;"	t	class:boost::icl::interval_base_set	access:public
const_reference	icl/map.hpp	/^    typedef typename base_type::const_reference         const_reference;$/;"	t	class:boost::icl::map	access:public
const_reverse_iterator	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::const_reverse_iterator const_reverse_iterator;$/;"	t	class:boost::icl::interval_base_map	access:public
const_reverse_iterator	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::const_reverse_iterator const_reverse_iterator;$/;"	t	class:boost::icl::interval_base_set	access:public
const_reverse_iterator	icl/map.hpp	/^    typedef typename base_type::const_reverse_iterator  const_reverse_iterator;$/;"	t	class:boost::icl::map	access:public
construct	icl/closed_interval.hpp	/^    static interval_type construct(const domain_type& lo, const domain_type& up)$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up)
construct	icl/concept/interval.hpp	/^construct(const typename Type::bounded_domain_type& low,$/;"	f	namespace:boost::icl	signature:(const typename Type::bounded_domain_type& low, const typename Type::bounded_domain_type& up)
construct	icl/concept/interval.hpp	/^construct(const typename interval_traits<Type>::domain_type& low,$/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& low, const typename interval_traits<Type>::domain_type& up )
construct	icl/concept/interval.hpp	/^construct(const typename interval_traits<Type>::domain_type& low,$/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& low, const typename interval_traits<Type>::domain_type& up, interval_bounds bounds = interval_bounds::right_open())
construct	icl/continuous_interval.hpp	/^    static interval_type construct(const domain_type lo, const domain_type up, interval_bounds bounds)$/;"	f	struct:boost::icl::dynamic_interval_traits	access:public	signature:(const domain_type lo, const domain_type up, interval_bounds bounds)
construct	icl/continuous_interval.hpp	/^    static interval_type construct(const domain_type& lo, const domain_type& up)$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up)
construct	icl/discrete_interval.hpp	/^    static interval_type construct(const domain_type& lo, const domain_type& up)$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up)
construct	icl/discrete_interval.hpp	/^    static interval_type construct(const domain_type& lo, const domain_type& up, interval_bounds bounds)$/;"	f	struct:boost::icl::dynamic_interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up, interval_bounds bounds)
construct	icl/dynamic_interval_traits.hpp	/^    static Type construct(const domain_type& lo, const domain_type& up, interval_bounds bounds);$/;"	p	struct:boost::icl::dynamic_interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up, interval_bounds bounds)
construct	icl/interval.hpp	/^        static inline IntervalT construct(const domain_type& low, const domain_type& up)$/;"	f	struct:boost::icl::static_interval	access:public	signature:(const domain_type& low, const domain_type& up)
construct	icl/interval.hpp	/^        static inline interval_type construct(const DomainT& low, const DomainT& up)$/;"	f	struct:boost::icl::interval	access:public	signature:(const DomainT& low, const DomainT& up)
construct	icl/interval_traits.hpp	/^    static Type construct(const domain_type& lo, const domain_type& up);$/;"	p	struct:boost::icl::interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up)
construct	icl/left_open_interval.hpp	/^    static interval_type construct(const domain_type& lo, const domain_type& up)$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up)
construct	icl/open_interval.hpp	/^    static interval_type construct(const domain_type& lo, const domain_type& up)$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up)
construct	icl/right_open_interval.hpp	/^    static interval_type construct(const domain_type& lo, const domain_type& up)$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const domain_type& lo, const domain_type& up)
construct_bounded	icl/continuous_interval.hpp	/^    static interval_type construct_bounded(const bounded_value<DomainT>& lo, $/;"	f	struct:boost::icl::dynamic_interval_traits	access:public	signature:(const bounded_value<DomainT>& lo, const bounded_value<DomainT>& up)
construct_bounded	icl/discrete_interval.hpp	/^    static interval_type construct_bounded(const bounded_value<DomainT>& lo, $/;"	f	struct:boost::icl::dynamic_interval_traits	access:public	signature:(const bounded_value<DomainT>& lo, const bounded_value<DomainT>& up)
construct_bounded	icl/dynamic_interval_traits.hpp	/^    static Type construct_bounded(const bounded_value<domain_type>& lo, $/;"	p	struct:boost::icl::dynamic_interval_traits	access:public	signature:(const bounded_value<domain_type>& lo, const bounded_value<domain_type>& up)
container_type	icl/iterator.hpp	/^    typedef ContainerT container_type;$/;"	t	class:boost::icl::add_iterator	access:public
container_type	icl/iterator.hpp	/^    typedef ContainerT container_type;$/;"	t	class:boost::icl::insert_iterator	access:public
contains	icl/concept/element_associator.hpp	/^contains(const SuperT& super, const SubT& sub)$/;"	f	namespace:boost::icl	signature:(const SuperT& super, const SubT& sub)
contains	icl/concept/element_associator.hpp	/^contains(const Type& super, const typename Type::key_type& key)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::key_type& key)
contains	icl/concept/element_map.hpp	/^contains(const Type& super, const typename Type::element_type& value_pair)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::element_type& value_pair)
contains	icl/concept/interval.hpp	/^    contains(const Type& super, const Type& sub)$/;"	f	namespace:boost::icl::non_empty	signature:(const Type& super, const Type& sub)
contains	icl/concept/interval.hpp	/^contains(const Type& super, const Type& sub)$/;"	f	namespace:boost::icl	signature:(const Type& super, const Type& sub)
contains	icl/concept/interval.hpp	/^contains(const Type& super, const typename interval_traits<Type>::domain_type& element)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename interval_traits<Type>::domain_type& element)
contains	icl/concept/interval_map.hpp	/^contains(const Type& super, const CoType& sub)$/;"	f	namespace:boost::icl	signature:(const Type& super, const CoType& sub)
contains	icl/concept/interval_map.hpp	/^contains(const Type& super, const KeyT& sub)$/;"	f	namespace:boost::icl	signature:(const Type& super, const KeyT& sub)
contains	icl/concept/interval_map.hpp	/^contains(const Type& super, const typename Type::domain_type& key)    $/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::domain_type& key)
contains	icl/concept/interval_map.hpp	/^contains(const Type& super, const typename Type::element_type& key_value_pair)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::element_type& key_value_pair)
contains	icl/concept/interval_map.hpp	/^contains(const Type& super, const typename Type::interval_type& sub_interval)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::interval_type& sub_interval)
contains	icl/concept/interval_map.hpp	/^contains(const Type& super, const typename Type::segment_type& sub_segment)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::segment_type& sub_segment)
contains	icl/concept/interval_map.hpp	/^contains(const Type&, const CoType&)$/;"	f	namespace:boost::icl	signature:(const Type&, const CoType&)
contains	icl/concept/interval_set.hpp	/^contains(const Type& super, const OperandT& sub)$/;"	f	namespace:boost::icl	signature:(const Type& super, const OperandT& sub)
contains	icl/concept/interval_set.hpp	/^contains(const Type& super, const typename Type::element_type& element)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::element_type& element)
contains	icl/concept/interval_set.hpp	/^contains(const Type& super, const typename Type::segment_type& inter_val)$/;"	f	namespace:boost::icl	signature:(const Type& super, const typename Type::segment_type& inter_val)
contains	icl/detail/interval_map_algo.hpp	/^bool contains(const IntervalMapT& container, $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT& container, const typename IntervalMapT::element_type& key_value_pair)
contains	icl/detail/interval_map_algo.hpp	/^bool contains(const IntervalMapT& container, $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT& container, const typename IntervalMapT::segment_type sub_segment)
contains	icl/detail/interval_map_algo.hpp	/^bool contains(const IntervalMapT& super, const IntervalMapT& sub) $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT& super, const IntervalMapT& sub)
contains	icl/detail/interval_map_algo.hpp	/^contains(const IntervalMapT& container, $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT& container, const typename IntervalMapT::domain_type& key)
contains	icl/detail/interval_map_algo.hpp	/^contains(const IntervalMapT& container, $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT& container, const typename IntervalMapT::interval_type& sub_interval)
contains	icl/detail/interval_map_algo.hpp	/^contains(const IntervalMapT& super_map, const IntervalSetT& sub_set) $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT& super_map, const IntervalSetT& sub_set)
contains	icl/detail/interval_map_algo.hpp	/^contains(const IntervalMapT&, $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT&, const typename IntervalMapT::domain_type&)
contains	icl/detail/interval_map_algo.hpp	/^contains(const IntervalMapT&, $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT&, const typename IntervalMapT::interval_type&)
contains	icl/detail/interval_map_algo.hpp	/^contains(const IntervalMapT&, const IntervalSetT&) $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT&, const IntervalSetT&)
contains	icl/detail/interval_set_algo.hpp	/^contains(const LeftT& super, const RightT& sub)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT& super, const RightT& sub)
contains	icl/detail/interval_set_algo.hpp	/^contains(const LeftT&, const RightT&)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT&, const RightT&)
contains	icl/map.hpp	/^    bool contains(const SubObject& sub)const $/;"	f	class:boost::icl::map	access:public	signature:(const SubObject& sub) const
content_is_identity_element	icl/concept/map_value.hpp	/^class content_is_identity_element: public property<Type>$/;"	c	namespace:boost::icl	inherits:property
continuous_interval	icl/continuous_interval.hpp	/^    continuous_interval()$/;"	f	class:boost::icl::continuous_interval	access:public	signature:()
continuous_interval	icl/continuous_interval.hpp	/^    continuous_interval(const DomainT& low, const DomainT& up, $/;"	f	class:boost::icl::continuous_interval	access:public	signature:(const DomainT& low, const DomainT& up, interval_bounds bounds = interval_bounds::right_open(), continuous_interval* = 0)
continuous_interval	icl/continuous_interval.hpp	/^    explicit continuous_interval(const DomainT& val)$/;"	f	class:boost::icl::continuous_interval	access:public	signature:(const DomainT& val)
continuous_interval	icl/continuous_interval.hpp	/^class continuous_interval$/;"	c	namespace:boost::icl
conversion	icl/functors.hpp	/^    struct conversion$/;"	s	namespace:boost::icl
covalues_are_equal	icl/detail/element_comparer.hpp	/^    bool covalues_are_equal(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::element_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
cyclic_prior	icl/concept/container.hpp	/^cyclic_prior(Type& object, typename Type::iterator it_)$/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator it_)
cyclic_prior	icl/concept/container.hpp	/^cyclic_prior(const Type& object, typename Type::const_iterator it_)$/;"	f	namespace:boost::icl	signature:(const Type& object, typename Type::const_iterator it_)
data	icl/interval_base_map.hpp	/^    CodomainT data;$/;"	m	struct:boost::icl::mapping_pair	access:public
data_type	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::value_type::second_type data_type;$/;"	t	class:boost::icl::interval_base_map	access:public
data_type	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::key_type   data_type;$/;"	t	class:boost::icl::interval_base_set	access:public
data_type	icl/interval_set.hpp	/^    typedef typename ImplSetT::value_type data_type;$/;"	t	class:boost::icl::interval_set	access:public
data_type	icl/map.hpp	/^    typedef CodomainT                                   data_type;$/;"	t	class:boost::icl::map	access:public
data_type	icl/separate_interval_set.hpp	/^    typedef typename ImplSetT::value_type data_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
data_type	icl/split_interval_set.hpp	/^    typedef typename ImplSetT::value_type data_type;$/;"	t	class:boost::icl::split_interval_set	access:public
decrement	icl/detail/element_iterator.hpp	/^    void decrement()$/;"	f	class:boost::icl::element_iterator	access:private	signature:()
dereference	icl/detail/element_iterator.hpp	/^    value_type dereference()const$/;"	f	class:boost::icl::element_iterator	access:private	signature:() const
detail	icl/concept/interval.hpp	/^namespace detail$/;"	n	namespace:boost::icl
detail	icl/type_traits/codomain_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
detail	icl/type_traits/difference_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
detail	icl/type_traits/domain_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
detail	icl/type_traits/element_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
detail	icl/type_traits/interval_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
detail	icl/type_traits/is_container.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
detail	icl/type_traits/is_key_container_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
detail	icl/type_traits/rep_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
detail	icl/type_traits/segment_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
detail	icl/type_traits/size_type_of.hpp	/^    namespace detail$/;"	n	namespace:boost::icl
detail	icl/type_traits/succ_pred.hpp	/^namespace detail$/;"	n	namespace:boost::icl
difference	icl/type_traits/difference.hpp	/^    template <class Type> struct difference{ typedef Type type; };$/;"	s	namespace:boost::icl
difference_type	icl/interval_base_map.hpp	/^    typedef typename difference_type_of<domain_type>::type difference_type;$/;"	t	class:boost::icl::interval_base_map	access:public
difference_type	icl/interval_base_set.hpp	/^    typedef typename difference_type_of<domain_type>::type difference_type;$/;"	t	class:boost::icl::interval_base_set	access:public
difference_type	icl/map.hpp	/^    typedef typename base_type::difference_type         difference_type;$/;"	t	class:boost::icl::map	access:public
difference_type	icl/type_traits/infinity.hpp	/^    typedef typename Type::difference_type difference_type;$/;"	t	struct:boost::icl::get_infinity	access:public
difference_type_of	icl/gregorian.hpp	/^    struct difference_type_of<boost::gregorian::date> $/;"	s	namespace:boost::icl
difference_type_of	icl/interval_traits.hpp	/^struct difference_type_of<interval_traits<Type> >$/;"	s	namespace:boost::icl
difference_type_of	icl/ptime.hpp	/^    struct difference_type_of<boost::posix_time::ptime> $/;"	s	namespace:boost::icl
difference_type_of	icl/type_traits/difference_type_of.hpp	/^    struct difference_type_of$/;"	s	namespace:boost::icl
discrete_interval	icl/discrete_interval.hpp	/^    discrete_interval()$/;"	f	class:boost::icl::discrete_interval	access:public	signature:()
discrete_interval	icl/discrete_interval.hpp	/^    discrete_interval(const DomainT& low, const DomainT& up, $/;"	f	class:boost::icl::discrete_interval	access:public	signature:(const DomainT& low, const DomainT& up, interval_bounds bounds = interval_bounds::right_open(), discrete_interval* = 0)
discrete_interval	icl/discrete_interval.hpp	/^    explicit discrete_interval(const DomainT& val)$/;"	f	class:boost::icl::discrete_interval	access:public	signature:(const DomainT& val)
discrete_interval	icl/discrete_interval.hpp	/^class discrete_interval$/;"	c	namespace:boost::icl
disjoint	icl/concept/element_associator.hpp	/^disjoint(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
disjoint	icl/concept/interval.hpp	/^disjoint(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
disjoint	icl/concept/interval_associator.hpp	/^disjoint(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
disjoint	icl/concept/interval_associator.hpp	/^disjoint(const Type& left, const AssociateT& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const AssociateT& right)
distance	icl/concept/interval.hpp	/^distance(const Type& x1, const Type& x2)$/;"	f	namespace:boost::icl	signature:(const Type& x1, const Type& x2)
distance	icl/concept/interval_associator.hpp	/^distance(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
distinct_equal	icl/predicates/distinct_equal.hpp	/^    struct distinct_equal : public relation<Type,Type>$/;"	s	namespace:boost::icl	inherits:relation
domain	icl/concept/element_map.hpp	/^domain(typename Type::set_type& domain_set, const Type& object)$/;"	f	namespace:boost::icl	signature:(typename Type::set_type& domain_set, const Type& object)
domain	icl/concept/interval_map.hpp	/^domain(SetT& result, const Type& object)$/;"	f	namespace:boost::icl	signature:(SetT& result, const Type& object)
domain	icl/concept/interval_set.hpp	/^domain(Type& dom, const Type& object)$/;"	f	namespace:boost::icl	signature:(Type& dom, const Type& object)
domain_allocator_type	icl/interval_base_set.hpp	/^    typedef Alloc<DomainT> domain_allocator_type;$/;"	t	class:boost::icl::interval_base_set	access:public
domain_allocator_type	icl/interval_set.hpp	/^    typedef Alloc<DomainT> domain_allocator_type;$/;"	t	class:boost::icl::interval_set	access:public
domain_allocator_type	icl/separate_interval_set.hpp	/^    typedef Alloc<DomainT> domain_allocator_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
domain_allocator_type	icl/split_interval_set.hpp	/^    typedef Alloc<DomainT> domain_allocator_type;$/;"	t	class:boost::icl::split_interval_set	access:public
domain_compare	icl/closed_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::closed_interval	access:public
domain_compare	icl/closed_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::interval_traits	access:public
domain_compare	icl/continuous_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::continuous_interval	access:public
domain_compare	icl/continuous_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
domain_compare	icl/continuous_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::interval_traits	access:public
domain_compare	icl/discrete_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::discrete_interval	access:public
domain_compare	icl/discrete_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
domain_compare	icl/discrete_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::interval_traits	access:public
domain_compare	icl/dynamic_interval_traits.hpp	/^    typedef typename Type::domain_compare domain_compare;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
domain_compare	icl/interval_base_map.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT)      domain_compare;$/;"	t	class:boost::icl::interval_base_map	access:public
domain_compare	icl/interval_base_set.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT)      domain_compare;$/;"	t	class:boost::icl::interval_base_set	access:public
domain_compare	icl/interval_set.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::interval_set	access:public
domain_compare	icl/left_open_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::left_open_interval	access:public
domain_compare	icl/left_open_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::interval_traits	access:public
domain_compare	icl/map.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT)         domain_compare;$/;"	t	class:boost::icl::map	access:public
domain_compare	icl/open_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::open_interval	access:public
domain_compare	icl/open_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::interval_traits	access:public
domain_compare	icl/right_open_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::right_open_interval	access:public
domain_compare	icl/right_open_interval.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	struct:boost::icl::interval_traits	access:public
domain_compare	icl/separate_interval_set.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::separate_interval_set	access:public
domain_compare	icl/split_interval_set.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;$/;"	t	class:boost::icl::split_interval_set	access:public
domain_difference_type	icl/detail/element_iterator.hpp	/^                                                            domain_difference_type;$/;"	t	class:boost::icl::element_iterator	access:public
domain_difference_type	icl/detail/element_iterator.hpp	/^                                                           domain_difference_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
domain_difference_type	icl/detail/element_iterator.hpp	/^                                                     domain_difference_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
domain_difference_type	icl/detail/element_iterator.hpp	/^                                                    domain_difference_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
domain_difference_type	icl/detail/element_iterator.hpp	/^    typedef typename interval_type::difference_type domain_difference_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
domain_equal	icl/concept/interval.hpp	/^domain_equal(const typename interval_traits<Type>::domain_type& left, $/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& left, const typename interval_traits<Type>::domain_type& right)
domain_less	icl/concept/interval.hpp	/^domain_less(const typename interval_traits<Type>::domain_type& left, $/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& left, const typename interval_traits<Type>::domain_type& right)
domain_less_equal	icl/concept/interval.hpp	/^domain_less_equal(const typename interval_traits<Type>::domain_type& left, $/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& left, const typename interval_traits<Type>::domain_type& right)
domain_mapping_type	icl/interval_base_map.hpp	/^    typedef mapping_pair<domain_type,codomain_type> domain_mapping_type;$/;"	t	class:boost::icl::interval_base_map	access:public
domain_mapping_type	icl/interval_map.hpp	/^    typedef typename base_type::domain_mapping_type domain_mapping_type;$/;"	t	class:boost::icl::interval_map	access:public
domain_mapping_type	icl/split_interval_map.hpp	/^    typedef typename base_type::domain_mapping_type    domain_mapping_type;$/;"	t	class:boost::icl::split_interval_map	access:public
domain_next	icl/concept/interval.hpp	/^domain_next(const typename interval_traits<Type>::domain_type value) $/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type value)
domain_param	icl/interval_base_map.hpp	/^    typedef typename boost::call_traits<DomainT>::param_type domain_param;$/;"	t	class:boost::icl::interval_base_map	access:public
domain_param	icl/map.hpp	/^    typedef typename boost::call_traits<DomainT>::param_type domain_param;$/;"	t	class:boost::icl::map	access:public
domain_prior	icl/concept/interval.hpp	/^domain_prior(const typename interval_traits<Type>::domain_type value) $/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type value)
domain_type	icl/closed_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::closed_interval	access:public
domain_type	icl/closed_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::interval_traits	access:public
domain_type	icl/continuous_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::continuous_interval	access:public
domain_type	icl/continuous_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
domain_type	icl/continuous_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::interval_traits	access:public
domain_type	icl/detail/element_iterator.hpp	/^        typedef DomainT                                         domain_type;$/;"	t	struct:boost::icl::elemental	access:public
domain_type	icl/detail/element_iterator.hpp	/^        typedef DomainT                   domain_type;$/;"	t	struct:boost::icl::elemental	access:public
domain_type	icl/detail/element_iterator.hpp	/^        typedef typename interval_traits<interval_type>::domain_type domain_type;$/;"	t	struct:boost::icl::elemental	access:public
domain_type	icl/detail/element_iterator.hpp	/^    typedef DomainT                                 domain_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
domain_type	icl/detail/element_iterator.hpp	/^    typedef typename elemental<segment_type>::domain_type   domain_type;$/;"	t	class:boost::icl::element_iterator	access:public
domain_type	icl/detail/element_iterator.hpp	/^    typedef typename interval_traits<interval_type>::domain_type domain_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
domain_type	icl/discrete_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::discrete_interval	access:public
domain_type	icl/discrete_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
domain_type	icl/discrete_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::interval_traits	access:public
domain_type	icl/dynamic_interval_traits.hpp	/^    typedef typename Type::domain_type    domain_type;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
domain_type	icl/interval.hpp	/^        typedef typename interval_traits<IntervalT>::domain_type domain_type;$/;"	t	struct:boost::icl::static_interval	access:public
domain_type	icl/interval_base_map.hpp	/^    typedef DomainT   domain_type;$/;"	t	class:boost::icl::interval_base_map	access:public
domain_type	icl/interval_base_set.hpp	/^    typedef DomainT   domain_type;$/;"	t	class:boost::icl::interval_base_set	access:public
domain_type	icl/interval_bounds.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::bounded_value	access:public
domain_type	icl/interval_map.hpp	/^    typedef typename base_type::domain_type   domain_type;$/;"	t	class:boost::icl::interval_map	access:public
domain_type	icl/interval_set.hpp	/^    typedef DomainT   domain_type;$/;"	t	class:boost::icl::interval_set	access:public
domain_type	icl/interval_traits.hpp	/^    typedef typename domain_type_of<Type>::type domain_type;$/;"	t	struct:boost::icl::interval_traits	access:public
domain_type	icl/interval_traits.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::difference_type_of	access:public
domain_type	icl/interval_traits.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::size_type_of	access:public
domain_type	icl/left_open_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::left_open_interval	access:public
domain_type	icl/left_open_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::interval_traits	access:public
domain_type	icl/map.hpp	/^    typedef DomainT                                     domain_type;$/;"	t	class:boost::icl::map	access:public
domain_type	icl/open_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::open_interval	access:public
domain_type	icl/open_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::interval_traits	access:public
domain_type	icl/right_open_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::right_open_interval	access:public
domain_type	icl/right_open_interval.hpp	/^    typedef DomainT domain_type;$/;"	t	struct:boost::icl::interval_traits	access:public
domain_type	icl/separate_interval_set.hpp	/^    typedef DomainT   domain_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
domain_type	icl/split_interval_map.hpp	/^    typedef DomainT domain_type;$/;"	t	class:boost::icl::split_interval_map	access:public
domain_type	icl/split_interval_set.hpp	/^    typedef DomainT   domain_type;$/;"	t	class:boost::icl::split_interval_set	access:public
domain_type	icl/type_traits/is_interval.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::is_continuous_left_open	access:public
domain_type	icl/type_traits/is_interval.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::is_continuous_right_open	access:public
domain_type	icl/type_traits/is_interval.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::is_continuous_static	access:public
domain_type	icl/type_traits/is_interval.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::is_discrete_static	access:public
domain_type	icl/type_traits/is_interval.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::is_discrete_static_closed	access:public
domain_type	icl/type_traits/is_interval.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::is_discrete_static_open	access:public
domain_type	icl/type_traits/is_interval.hpp	/^    typedef typename interval_traits<Type>::domain_type domain_type;$/;"	t	struct:boost::icl::is_singelizable	access:public
domain_type_of	icl/interval_traits.hpp	/^struct domain_type_of<interval_traits<Type> >$/;"	s	namespace:boost::icl
domain_type_of	icl/type_traits/domain_type_of.hpp	/^    struct domain_type_of$/;"	s	namespace:boost::icl
dynamic_interval_traits	icl/continuous_interval.hpp	/^struct dynamic_interval_traits<boost::icl::continuous_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
dynamic_interval_traits	icl/discrete_interval.hpp	/^struct dynamic_interval_traits<boost::icl::discrete_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
dynamic_interval_traits	icl/dynamic_interval_traits.hpp	/^struct dynamic_interval_traits$/;"	s	namespace:boost::icl
element_compare	icl/detail/element_comparer.hpp	/^int element_compare$/;"	f	namespace:boost::icl::Interval_Set	signature:( const LeftT& left, const RightT& right, typename LeftT::const_iterator left_begin, typename LeftT::const_iterator left_end, typename RightT::const_iterator right_begin, typename RightT::const_iterator right_end )
element_compare	icl/map.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,element_type)    element_compare;$/;"	t	class:boost::icl::map	access:public
element_comparer	icl/detail/element_comparer.hpp	/^    element_comparer(const LeftT&      left,$/;"	f	class:boost::icl::Interval_Set::element_comparer	access:public	signature:(const LeftT& left, const RightT& right, const LeftIterT& left_end, const RightIterT& right_end)
element_comparer	icl/detail/element_comparer.hpp	/^class element_comparer$/;"	c	namespace:boost::icl::Interval_Set
element_const_iterator	icl/interval_base_map.hpp	/^    typedef boost::icl::element_iterator<const_iterator> element_const_iterator; $/;"	t	class:boost::icl::interval_base_map	access:public
element_const_iterator	icl/interval_base_set.hpp	/^    typedef boost::icl::element_iterator<const_iterator> element_const_iterator; $/;"	t	class:boost::icl::interval_base_set	access:public
element_const_reverse_iterator	icl/interval_base_map.hpp	/^    typedef boost::icl::element_iterator<const_reverse_iterator> element_const_reverse_iterator; $/;"	t	class:boost::icl::interval_base_map	access:public
element_const_reverse_iterator	icl/interval_base_set.hpp	/^    typedef boost::icl::element_iterator<const_reverse_iterator> element_const_reverse_iterator; $/;"	t	class:boost::icl::interval_base_set	access:public
element_equal	icl/predicates/element_equal.hpp	/^    struct element_equal : public relation<Type,Type>$/;"	s	namespace:boost::icl	inherits:relation
element_iterator	icl/detail/element_iterator.hpp	/^    element_iterator$/;"	f	class:boost::icl::element_iterator	access:public	signature:( element_iterator<SaltatorT> const& other , typename enable_if<boost::is_convertible<SaltatorT*,SegmentIteratorT*>, enabler>::type = enabler())
element_iterator	icl/detail/element_iterator.hpp	/^    element_iterator()$/;"	f	class:boost::icl::element_iterator	access:public	signature:()
element_iterator	icl/detail/element_iterator.hpp	/^    explicit element_iterator(segment_iterator jumper)$/;"	f	class:boost::icl::element_iterator	access:public	signature:(segment_iterator jumper)
element_iterator	icl/detail/element_iterator.hpp	/^class element_iterator$/;"	c	namespace:boost::icl	inherits:boost::iterator_facade
element_iterator	icl/interval_base_map.hpp	/^    typedef boost::icl::element_iterator<iterator> element_iterator; $/;"	t	class:boost::icl::interval_base_map	access:public
element_iterator	icl/interval_base_set.hpp	/^    typedef boost::icl::element_iterator<iterator> element_iterator; $/;"	t	class:boost::icl::interval_base_set	access:public
element_reverse_iterator	icl/interval_base_map.hpp	/^    typedef boost::icl::element_iterator<reverse_iterator> element_reverse_iterator; $/;"	t	class:boost::icl::interval_base_map	access:public
element_reverse_iterator	icl/interval_base_set.hpp	/^    typedef boost::icl::element_iterator<reverse_iterator> element_reverse_iterator; $/;"	t	class:boost::icl::interval_base_set	access:public
element_type	icl/detail/element_iterator.hpp	/^    typedef domain_type                              element_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
element_type	icl/detail/element_iterator.hpp	/^    typedef domain_type                             element_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
element_type	icl/detail/element_iterator.hpp	/^    typedef std::pair<DomainT, CodomainT>           element_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
element_type	icl/detail/element_iterator.hpp	/^    typedef std::pair<domain_type, codomain_type>          element_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
element_type	icl/detail/element_iterator.hpp	/^    typedef typename elemental<segment_type>::type          element_type;$/;"	t	class:boost::icl::element_iterator	access:public
element_type	icl/interval_base_map.hpp	/^    typedef domain_mapping_type element_type;$/;"	t	class:boost::icl::interval_base_map	access:public
element_type	icl/interval_base_set.hpp	/^    typedef DomainT   element_type;$/;"	t	class:boost::icl::interval_base_set	access:public
element_type	icl/interval_map.hpp	/^    typedef typename base_type::element_type  element_type;$/;"	t	class:boost::icl::interval_map	access:public
element_type	icl/interval_set.hpp	/^    typedef DomainT   element_type;$/;"	t	class:boost::icl::interval_set	access:public
element_type	icl/map.hpp	/^        typedef typename Type::element_type   element_type;$/;"	t	struct:boost::icl::map::on_total_absorbable	access:public
element_type	icl/map.hpp	/^        typedef typename Type::element_type  element_type;$/;"	t	struct:boost::icl::map::on_total_absorbable	access:public
element_type	icl/map.hpp	/^        typedef typename Type::element_type element_type;$/;"	t	struct:boost::icl::map::on_invertible	access:public
element_type	icl/map.hpp	/^    typedef std::pair<const DomainT, CodomainT>         element_type;$/;"	t	class:boost::icl::map	access:public
element_type	icl/separate_interval_set.hpp	/^    typedef DomainT   element_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
element_type	icl/split_interval_map.hpp	/^    typedef typename base_type::element_type element_type;$/;"	t	class:boost::icl::split_interval_map	access:public
element_type	icl/split_interval_set.hpp	/^    typedef DomainT   element_type;$/;"	t	class:boost::icl::split_interval_set	access:public
element_type_of	icl/type_traits/element_type_of.hpp	/^    struct element_type_of$/;"	s	namespace:boost::icl
elemental	icl/detail/element_iterator.hpp	/^    struct elemental$/;"	s	namespace:boost::icl
elemental	icl/detail/element_iterator.hpp	/^    struct elemental<ICL_INTERVAL_TYPE(Interval,DomainT,Compare) >$/;"	s	namespace:boost::icl
elemental	icl/detail/element_iterator.hpp	/^    struct elemental<std::pair<ICL_INTERVAL_TYPE(Interval,DomainT,Compare)const, CodomainT> >$/;"	s	namespace:boost::icl
elements_begin	icl/concept/interval_associator.hpp	/^elements_begin(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
elements_begin	icl/concept/interval_associator.hpp	/^elements_begin(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
elements_end	icl/concept/interval_associator.hpp	/^elements_end(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
elements_end	icl/concept/interval_associator.hpp	/^elements_end(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
elements_rbegin	icl/concept/interval_associator.hpp	/^elements_rbegin(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
elements_rbegin	icl/concept/interval_associator.hpp	/^elements_rbegin(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
elements_rend	icl/concept/interval_associator.hpp	/^elements_rend(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
elements_rend	icl/concept/interval_associator.hpp	/^elements_rend(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
empty	icl/interval_base_map.hpp	/^    bool empty()const { return icl::is_empty(*that()); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:() const
empty	icl/interval_base_set.hpp	/^    bool empty()const { return icl::is_empty(*that()); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:() const
empty_codomain_compare	icl/detail/interval_subset_comparer.hpp	/^struct empty_codomain_compare$/;"	s	namespace:boost::icl::Interval_Set
empty_codomain_compare	icl/detail/subset_comparer.hpp	/^struct empty_codomain_compare$/;"	s	namespace:boost::icl::Set
enabler	icl/detail/element_iterator.hpp	/^    struct enabler{};$/;"	s	class:boost::icl::element_iterator	access:private
end	icl/interval_base_map.hpp	/^    const_iterator end()const   { return _map.end(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:() const
end	icl/interval_base_map.hpp	/^    iterator end()   { return _map.end(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:()
end	icl/interval_base_set.hpp	/^    const_iterator end()const   { return _set.end(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:() const
end	icl/interval_base_set.hpp	/^    iterator end()   { return _set.end(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:()
equal	icl/detail/element_comparer.hpp	/^        equal   = comparison::equal, $/;"	e	enum:boost::icl::Interval_Set::element_comparer::__anon7
equal	icl/detail/element_iterator.hpp	/^    bool equal(element_iterator<SaltatorT> const& other) const$/;"	f	class:boost::icl::element_iterator	access:private	signature:(element_iterator<SaltatorT> const& other) const
equal	icl/detail/interval_subset_comparer.hpp	/^        equal      = inclusion::equal       \/\/ equal = subset | superset$/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon3
equal	icl/detail/relation_state.hpp	/^        static const int equal     =  3;$/;"	m	namespace:boost::icl::inclusion
equal	icl/detail/relation_state.hpp	/^        static const int equal   =  0;$/;"	m	namespace:boost::icl::comparison
equal	icl/detail/subset_comparer.hpp	/^        equal      = inclusion::equal       \/\/ equal = subset | superset$/;"	e	enum:boost::icl::Set::subset_comparer::__anon5
equal_range	icl/interval_base_map.hpp	/^        equal_range(const key_type& interval)const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const key_type& interval) const
equal_range	icl/interval_base_map.hpp	/^    std::pair<iterator,iterator> equal_range(const key_type& interval)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const key_type& interval)
equal_range	icl/interval_base_set.hpp	/^        equal_range(const key_type& interval)const$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const key_type& interval) const
equal_range	icl/interval_base_set.hpp	/^    std::pair<iterator,iterator> equal_range(const key_type& interval)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const key_type& interval)
erase	icl/concept/element_associator.hpp	/^erase(Type& object, const Type& erasure)$/;"	f	namespace:boost::icl	signature:(Type& object, const Type& erasure)
erase	icl/concept/element_associator.hpp	/^erase(Type& object, const typename Type::key_type& key_value)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::key_type& key_value)
erase	icl/concept/element_map.hpp	/^erase(Type& object, const typename Type::element_type& value_pair)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& value_pair)
erase	icl/concept/element_map.hpp	/^erase(Type& object, const typename Type::set_type& erasure)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::set_type& erasure)
erase	icl/concept/interval_associator.hpp	/^erase(Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
erase	icl/concept/interval_map.hpp	/^erase(Type& object, const typename Type::domain_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::domain_type& operand)
erase	icl/concept/interval_map.hpp	/^erase(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
erase	icl/concept/interval_map.hpp	/^erase(Type& object, const typename Type::interval_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::interval_type& operand)
erase	icl/concept/interval_map.hpp	/^erase(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
erase	icl/concept/interval_set.hpp	/^erase(Type& object, const typename Type::element_type& minuend)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& minuend)
erase	icl/concept/interval_set.hpp	/^erase(Type& object, const typename Type::segment_type& minuend)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& minuend)
erase	icl/interval_base_map.hpp	/^    ::erase(const interval_type& minuend)$/;"	f	class:boost::icl::interval_base_map	signature:(const interval_type& minuend)
erase	icl/interval_base_map.hpp	/^    ::erase(const segment_type& minuend)$/;"	f	class:boost::icl::interval_base_map	signature:(const segment_type& minuend)
erase	icl/interval_base_map.hpp	/^    SubType& erase(const domain_type& key) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const domain_type& key)
erase	icl/interval_base_map.hpp	/^    SubType& erase(const element_type& key_value_pair) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const element_type& key_value_pair)
erase	icl/interval_base_map.hpp	/^    SubType& erase(const interval_type& inter_val);$/;"	p	class:boost::icl::interval_base_map	access:public	signature:(const interval_type& inter_val)
erase	icl/interval_base_map.hpp	/^    SubType& erase(const segment_type& interval_value_pair);$/;"	p	class:boost::icl::interval_base_map	access:public	signature:(const segment_type& interval_value_pair)
erase	icl/interval_base_map.hpp	/^    void erase(iterator first, iterator past){ this->_map.erase(first, past); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(iterator first, iterator past)
erase	icl/interval_base_map.hpp	/^    void erase(iterator position){ this->_map.erase(position); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(iterator position)
erase	icl/interval_base_set.hpp	/^    SubType& erase(const element_type& key) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const element_type& key)
erase	icl/interval_base_set.hpp	/^    SubType& erase(const segment_type& inter_val) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const segment_type& inter_val)
erase	icl/interval_base_set.hpp	/^    void erase(iterator first, iterator past)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(iterator first, iterator past)
erase	icl/interval_base_set.hpp	/^    void erase(iterator position)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(iterator position)
erase	icl/map.hpp	/^    size_type erase(const element_type& key_value_pair)$/;"	f	class:boost::icl::map	access:public	signature:(const element_type& key_value_pair)
erase_if	icl/concept/element_associator.hpp	/^erase_if(const Predicate& pred, Type& object)$/;"	f	namespace:boost::icl	signature:(const Predicate& pred, Type& object)
erase_if	icl/concept/element_map.hpp	/^erase_if(const Predicate& pred, Type& object);$/;"	p	namespace:boost::icl	signature:(const Predicate& pred, Type& object)
erase_if	icl/concept/interval_map.hpp	/^erase_if(const Predicate& pred, MapT& object)$/;"	f	namespace:boost::icl	signature:(const Predicate& pred, MapT& object)
erase_rest	icl/interval_base_map.hpp	/^    ::erase_rest(interval_type& inter_val, const CodomainT& co_val, $/;"	f	class:boost::icl::interval_base_map	signature:(interval_type& inter_val, const CodomainT& co_val, iterator& it_, const iterator& last_)
erase_rest	icl/interval_base_map.hpp	/^    void erase_rest (      interval_type&, const CodomainT&, iterator&, const iterator&);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:( interval_type&, const CodomainT&, iterator&, const iterator&)
exclusive_less	icl/concept/interval.hpp	/^    exclusive_less(const Type& left, const Type& right)$/;"	f	namespace:boost::icl::non_empty	signature:(const Type& left, const Type& right)
exclusive_less	icl/concept/interval.hpp	/^exclusive_less(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
exclusive_less_than	icl/detail/exclusive_less_than.hpp	/^struct exclusive_less_than $/;"	s	namespace:boost::icl
find	icl/concept/interval_associator_base.hpp	/^find(const Type& object, const typename domain_type_of<Type>::type& key_val)$/;"	f	namespace:boost::icl	signature:(const Type& object, const typename domain_type_of<Type>::type& key_val)
find	icl/concept/interval_associator_base.hpp	/^find(const Type& object, const typename interval_type_of<Type>::type& inter_val)$/;"	f	namespace:boost::icl	signature:(const Type& object, const typename interval_type_of<Type>::type& inter_val)
find	icl/interval_base_map.hpp	/^    const_iterator find(const domain_type& key_value)const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const domain_type& key_value) const
find	icl/interval_base_map.hpp	/^    const_iterator find(const interval_type& key_interval)const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const interval_type& key_interval) const
find	icl/interval_base_set.hpp	/^    const_iterator find(const element_type& key_value)const$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const element_type& key_value) const
find	icl/interval_base_set.hpp	/^    const_iterator find(const interval_type& key_interval)const$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const interval_type& key_interval) const
fineness	icl/interval_map.hpp	/^    enum { fineness = 1 };$/;"	e	enum:boost::icl::interval_map::__anon1
fineness	icl/interval_set.hpp	/^    enum { fineness = 1 };$/;"	e	enum:boost::icl::interval_set::__anon10
fineness	icl/separate_interval_set.hpp	/^    enum { fineness = 2 };$/;"	e	enum:boost::icl::separate_interval_set::__anon8
fineness	icl/split_interval_map.hpp	/^    enum { fineness = 3 };$/;"	e	enum:boost::icl::split_interval_map::__anon11
fineness	icl/split_interval_set.hpp	/^    enum { fineness = 3 };$/;"	e	enum:boost::icl::split_interval_set::__anon9
first	icl/closed_interval.hpp	/^    DomainT first()const{ return _lwb; }$/;"	f	class:boost::icl::closed_interval	access:public	signature:() const
first	icl/concept/interval.hpp	/^first(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
first	icl/concept/interval_associator.hpp	/^first(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
first	icl/detail/element_iterator.hpp	/^    static domain_type     first (const SegmentIteratorT& leaper){ return leaper->first(); } $/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
first	icl/detail/element_iterator.hpp	/^    static domain_type     first (const SegmentIteratorT& leaper){ return leaper->first.first(); } $/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
first	icl/detail/mapped_reference.hpp	/^    const first_type&     first ;$/;"	m	class:boost::icl::mapped_reference	access:public
first_element	icl/detail/element_iterator.hpp	/^struct first_element$/;"	s	namespace:boost::icl
first_element	icl/detail/element_iterator.hpp	/^struct first_element<std::pair<FirstT, SecondT> >$/;"	s	namespace:boost::icl
first_type	icl/detail/mapped_reference.hpp	/^    typedef FirstT  first_type;   $/;"	t	class:boost::icl::mapped_reference	access:public
flip	icl/concept/element_map.hpp	/^flip(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
flip	icl/concept/element_set.hpp	/^flip(Type& object, const typename Type::value_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& operand)
flip	icl/concept/interval_map.hpp	/^flip(Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
flip	icl/concept/interval_map.hpp	/^flip(Type& object, const OperandT&)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT&)
flip	icl/concept/interval_map.hpp	/^flip(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
flip	icl/concept/interval_map.hpp	/^flip(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
flip	icl/concept/interval_set.hpp	/^flip(Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
flip	icl/concept/interval_set.hpp	/^flip(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
flip	icl/concept/interval_set.hpp	/^flip(Type& object, const typename Type::segment_type& segment)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& segment)
flip	icl/interval_base_map.hpp	/^        static void flip(Type& object, const segment_type& interval_value_pair)$/;"	f	struct:boost::icl::interval_base_map::on_total_absorbable	access:public	signature:(Type& object, const segment_type& interval_value_pair)
flip	icl/interval_base_map.hpp	/^        static void flip(Type& object, const segment_type& operand)$/;"	f	struct:boost::icl::interval_base_map::on_total_absorbable	access:public	signature:(Type& object, const segment_type& operand)
flip	icl/interval_base_map.hpp	/^        static void flip(Type& object, const typename Type::segment_type&)$/;"	f	struct:boost::icl::interval_base_map::on_total_absorbable	access:public	signature:(Type& object, const typename Type::segment_type&)
flip	icl/interval_base_map.hpp	/^    SubType& flip(const element_type& key_value_pair)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const element_type& key_value_pair)
flip	icl/interval_base_map.hpp	/^    SubType& flip(const segment_type& interval_value_pair)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const segment_type& interval_value_pair)
flip	icl/interval_base_set.hpp	/^    SubType& flip(const element_type& key)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const element_type& key)
flip	icl/interval_base_set.hpp	/^    SubType& flip(const segment_type& inter_val)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const segment_type& inter_val)
flip	icl/map.hpp	/^        static void flip(Type& object, const element_type& operand)$/;"	f	struct:boost::icl::map::on_total_absorbable	access:public	signature:(Type& object, const element_type& operand)
flip	icl/map.hpp	/^        static void flip(Type& object, const typename Type::element_type&)$/;"	f	struct:boost::icl::map::on_total_absorbable	access:public	signature:(Type& object, const typename Type::element_type&)
flip	icl/map.hpp	/^    map& flip(const element_type& operand)$/;"	f	class:boost::icl::map	access:public	signature:(const element_type& operand)
gap_insert	icl/interval_base_map.hpp	/^    iterator gap_insert(iterator prior_, const interval_type& inter_val, $/;"	f	class:boost::icl::interval_base_map	access:protected	signature:(iterator prior_, const interval_type& inter_val, const codomain_type& co_val )
gap_insert_at	icl/interval_map.hpp	/^    void gap_insert_at(iterator& it_, iterator prior_, $/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator& it_, iterator prior_, const interval_type& end_gap, const codomain_type& co_val)
gap_insert_at	icl/split_interval_map.hpp	/^    void gap_insert_at(iterator& it_, iterator prior_, $/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator& it_, iterator prior_, const interval_type& end_gap, const codomain_type& co_val)
get_codomain_type	icl/type_traits/codomain_type_of.hpp	/^    struct get_codomain_type<Type, false, false>$/;"	s	namespace:boost::icl
get_codomain_type	icl/type_traits/codomain_type_of.hpp	/^    struct get_codomain_type<Type, false, true>$/;"	s	namespace:boost::icl
get_codomain_type	icl/type_traits/codomain_type_of.hpp	/^    struct get_codomain_type<Type, true, is_std_set>$/;"	s	namespace:boost::icl
get_difference_type	icl/type_traits/difference_type_of.hpp	/^    struct get_difference_type<Type*, true, false>$/;"	s	namespace:boost::icl
get_difference_type	icl/type_traits/difference_type_of.hpp	/^    struct get_difference_type<Type, false, false>$/;"	s	namespace:boost::icl
get_difference_type	icl/type_traits/difference_type_of.hpp	/^    struct get_difference_type<Type, true, false>$/;"	s	namespace:boost::icl
get_difference_type	icl/type_traits/difference_type_of.hpp	/^    struct get_difference_type<Type, true, true>$/;"	s	namespace:boost::icl
get_domain_type	icl/type_traits/domain_type_of.hpp	/^    struct get_domain_type<Type, false>$/;"	s	namespace:boost::icl
get_domain_type	icl/type_traits/domain_type_of.hpp	/^    struct get_domain_type<Type, true>$/;"	s	namespace:boost::icl
get_element_type	icl/type_traits/element_type_of.hpp	/^    struct get_element_type<Type, false>$/;"	s	namespace:boost::icl
get_element_type	icl/type_traits/element_type_of.hpp	/^    struct get_element_type<Type, true>$/;"	s	namespace:boost::icl
get_infinity	icl/type_traits/infinity.hpp	/^struct get_infinity<Type, false, false, false, false>$/;"	s	namespace:boost::icl
get_infinity	icl/type_traits/infinity.hpp	/^struct get_infinity<Type, false, false, false, true>$/;"	s	namespace:boost::icl
get_infinity	icl/type_traits/infinity.hpp	/^struct get_infinity<Type, false, false, true, has_diff>$/;"	s	namespace:boost::icl
get_infinity	icl/type_traits/infinity.hpp	/^struct get_infinity<Type, false, true, has_size, has_diff>$/;"	s	namespace:boost::icl
get_infinity	icl/type_traits/infinity.hpp	/^struct get_infinity<Type, true, has_repr_inf, has_size, has_diff>$/;"	s	namespace:boost::icl
get_interval_type	icl/type_traits/interval_type_of.hpp	/^    struct get_interval_type<Type, false>$/;"	s	namespace:boost::icl
get_interval_type	icl/type_traits/interval_type_of.hpp	/^    struct get_interval_type<Type, true>$/;"	s	namespace:boost::icl
get_key_object_type	icl/type_traits/is_key_container_of.hpp	/^    struct get_key_object_type<Type, false, false>$/;"	s	namespace:boost::icl
get_key_object_type	icl/type_traits/is_key_container_of.hpp	/^    struct get_key_object_type<Type, false, true>$/;"	s	namespace:boost::icl
get_key_object_type	icl/type_traits/is_key_container_of.hpp	/^    struct get_key_object_type<Type, true, IsSet>$/;"	s	namespace:boost::icl
get_key_type	icl/type_traits/element_type_of.hpp	/^    struct get_key_type<Type, false>$/;"	s	namespace:boost::icl
get_key_type	icl/type_traits/element_type_of.hpp	/^    struct get_key_type<Type, true>$/;"	s	namespace:boost::icl
get_numeric_infinity	icl/type_traits/infinity.hpp	/^struct get_numeric_infinity<Type, false, false>$/;"	s	namespace:boost::icl
get_numeric_infinity	icl/type_traits/infinity.hpp	/^struct get_numeric_infinity<Type, false, true>$/;"	s	namespace:boost::icl
get_numeric_infinity	icl/type_traits/infinity.hpp	/^struct get_numeric_infinity<Type, true, has_std_max>$/;"	s	namespace:boost::icl
get_rep_type	icl/type_traits/rep_type_of.hpp	/^    struct get_rep_type<Type, false>$/;"	s	namespace:boost::icl
get_rep_type	icl/type_traits/rep_type_of.hpp	/^    struct get_rep_type<Type, true>$/;"	s	namespace:boost::icl
get_segment_type	icl/type_traits/segment_type_of.hpp	/^    struct get_segment_type<Type, false>$/;"	s	namespace:boost::icl
get_segment_type	icl/type_traits/segment_type_of.hpp	/^    struct get_segment_type<Type, true>$/;"	s	namespace:boost::icl
get_size_type	icl/type_traits/size_type_of.hpp	/^    struct get_size_type<Type, false, false, false>$/;"	s	namespace:boost::icl
get_size_type	icl/type_traits/size_type_of.hpp	/^    struct get_size_type<Type, false, false, true>$/;"	s	namespace:boost::icl
get_size_type	icl/type_traits/size_type_of.hpp	/^    struct get_size_type<Type, false, true, has_rep>$/;"	s	namespace:boost::icl
get_size_type	icl/type_traits/size_type_of.hpp	/^    struct get_size_type<Type, true, has_diff, has_rep>$/;"	s	namespace:boost::icl
get_value_type	icl/type_traits/element_type_of.hpp	/^    struct get_value_type<Type, false>$/;"	s	namespace:boost::icl
get_value_type	icl/type_traits/element_type_of.hpp	/^    struct get_value_type<Type, true>$/;"	s	namespace:boost::icl
greater	icl/detail/element_comparer.hpp	/^        greater = comparison::greater$/;"	e	enum:boost::icl::Interval_Set::element_comparer::__anon7
greater	icl/detail/relation_state.hpp	/^        static const int greater =  1;$/;"	m	namespace:boost::icl::comparison
handle_combined	icl/interval_map.hpp	/^    void handle_combined(iterator it_)$/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator it_)
handle_combined	icl/split_interval_map.hpp	/^    void handle_combined(iterator it_)$/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator it_)
handle_inserted	icl/detail/interval_set_algo.hpp	/^    inline static iterator handle_inserted(Type& object, iterator inserted_)$/;"	f	struct:boost::icl::Interval_Set::on_style	access:public	signature:(Type& object, iterator inserted_)
handle_inserted	icl/detail/interval_set_algo.hpp	/^    inline static iterator handle_inserted(Type&, iterator inserted_)$/;"	f	struct:boost::icl::Interval_Set::on_style	access:public	signature:(Type&, iterator inserted_)
handle_inserted	icl/interval_map.hpp	/^    iterator handle_inserted(iterator it_)$/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator it_)
handle_inserted	icl/interval_map.hpp	/^    void handle_inserted(iterator prior_, iterator it_)$/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator prior_, iterator it_)
handle_inserted	icl/interval_set.hpp	/^    iterator handle_inserted(iterator it_)$/;"	f	class:boost::icl::interval_set	access:private	signature:(iterator it_)
handle_inserted	icl/separate_interval_set.hpp	/^    iterator handle_inserted(iterator inserted_)$/;"	f	class:boost::icl::separate_interval_set	access:private	signature:(iterator inserted_)
handle_inserted	icl/split_interval_map.hpp	/^    iterator handle_inserted(iterator it_)const { return it_; }$/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator it_) const
handle_inserted	icl/split_interval_map.hpp	/^    void handle_inserted(iterator, iterator)const{ }$/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator, iterator) const
handle_inserted	icl/split_interval_set.hpp	/^    iterator handle_inserted(iterator inserted_)$/;"	f	class:boost::icl::split_interval_set	access:private	signature:(iterator inserted_)
handle_left_combined	icl/interval_map.hpp	/^    void handle_left_combined(iterator it_)$/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator it_)
handle_left_combined	icl/split_interval_map.hpp	/^    void handle_left_combined(iterator it_)$/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator it_)
handle_preceeded_combined	icl/interval_map.hpp	/^    void handle_preceeded_combined(iterator prior_, iterator& it_)$/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator prior_, iterator& it_)
handle_preceeded_combined	icl/split_interval_map.hpp	/^    void handle_preceeded_combined(iterator prior_, iterator& it_)$/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator prior_, iterator& it_)
handle_reinserted	icl/interval_map.hpp	/^    void handle_reinserted(iterator insertion_)$/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator insertion_)
handle_reinserted	icl/split_interval_map.hpp	/^    void handle_reinserted(iterator){}$/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator)
handle_succeeded_combined	icl/interval_map.hpp	/^    void handle_succeeded_combined(iterator it_, iterator next_)$/;"	f	class:boost::icl::interval_map	access:private	signature:(iterator it_, iterator next_)
handle_succeeded_combined	icl/split_interval_map.hpp	/^    void handle_succeeded_combined(iterator it_, iterator)$/;"	f	class:boost::icl::split_interval_map	access:private	signature:(iterator it_, iterator)
has_asymmetric_bounds	icl/type_traits/is_interval.hpp	/^template <class Type> struct has_asymmetric_bounds$/;"	s	namespace:boost::icl
has_codomain_type	icl/type_traits/codomain_type_of.hpp	/^    struct has_codomain_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
has_difference	icl/gregorian.hpp	/^    struct has_difference<boost::gregorian::date> $/;"	s	namespace:boost::icl
has_difference	icl/gregorian.hpp	/^    struct has_difference<boost::gregorian::date_duration> $/;"	s	namespace:boost::icl
has_difference	icl/ptime.hpp	/^    struct has_difference<boost::posix_time::ptime> $/;"	s	namespace:boost::icl
has_difference	icl/ptime.hpp	/^    struct has_difference<boost::posix_time::time_duration> $/;"	s	namespace:boost::icl
has_difference	icl/type_traits/difference_type_of.hpp	/^    struct has_difference$/;"	s	namespace:boost::icl
has_difference_type	icl/type_traits/difference_type_of.hpp	/^    struct has_difference_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
has_domain_type	icl/type_traits/domain_type_of.hpp	/^    struct has_domain_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
has_dynamic_bounds	icl/type_traits/is_interval.hpp	/^template <class Type> struct has_dynamic_bounds$/;"	s	namespace:boost::icl
has_element_type	icl/type_traits/element_type_of.hpp	/^    struct has_element_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
has_interval_type	icl/type_traits/interval_type_of.hpp	/^    struct has_interval_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
has_inverse	icl/interval_base_map.hpp	/^struct has_inverse<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
has_inverse	icl/interval_map.hpp	/^struct has_inverse<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
has_inverse	icl/map.hpp	/^struct has_inverse<icl::map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc> >$/;"	s	namespace:boost::icl
has_inverse	icl/rational.hpp	/^    struct has_inverse<boost::rational<Integral> >$/;"	s	namespace:boost::icl
has_inverse	icl/split_interval_map.hpp	/^struct has_inverse<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
has_inverse	icl/type_traits/has_inverse.hpp	/^    template <class Type> struct has_inverse$/;"	s	namespace:boost::icl
has_key_object_type	icl/type_traits/is_key_container_of.hpp	/^    struct has_key_object_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
has_key_type	icl/type_traits/element_type_of.hpp	/^    struct has_key_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
has_max_infinity	icl/type_traits/infinity.hpp	/^template<class Type> struct has_max_infinity$/;"	s	namespace:boost::icl
has_rep_type	icl/type_traits/rep_type_of.hpp	/^    struct has_rep_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
has_same_concept	icl/type_traits/is_concept_equivalent.hpp	/^    struct has_same_concept$/;"	s	namespace:boost::icl
has_segment_type	icl/type_traits/segment_type_of.hpp	/^    struct has_segment_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
has_set_semantics	icl/type_traits/has_set_semantics.hpp	/^    template <class Type> struct has_set_semantics$/;"	s	namespace:boost::icl
has_size_type	icl/type_traits/size_type_of.hpp	/^    struct has_size_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
has_static_bounds	icl/type_traits/is_interval.hpp	/^template <class Type> struct has_static_bounds$/;"	s	namespace:boost::icl
has_std_infinity	icl/type_traits/infinity.hpp	/^template<class Type> struct has_std_infinity$/;"	s	namespace:boost::icl
has_symmetric_bounds	icl/type_traits/is_interval.hpp	/^template <class Type> struct has_symmetric_bounds$/;"	s	namespace:boost::icl
has_value_type	icl/type_traits/element_type_of.hpp	/^    struct has_value_type $/;"	s	namespace:boost::icl	inherits:mpl::bool_
hull	icl/concept/interval.hpp	/^hull(Type left, const Type& right)$/;"	f	namespace:boost::icl	signature:(Type left, const Type& right)
hull	icl/concept/interval.hpp	/^hull(const typename interval_traits<Type>::domain_type& left,$/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& left, const typename interval_traits<Type>::domain_type& right)
hull	icl/concept/interval_associator.hpp	/^hull(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
icl	icl/closed_interval.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/concept/comparable.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/concept/container.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/concept/element_associator.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/concept/element_map.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/concept/element_set.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/concept/element_set_value.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/concept/interval.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/concept/interval_associator.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/concept/interval_associator_base.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/concept/interval_bounds.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/concept/interval_map.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/concept/interval_set.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/concept/interval_set_value.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/concept/joinable.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/concept/map_value.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/concept/set_value.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/continuous_interval.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/detail/associated_value.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/detail/concept_check.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/detail/element_comparer.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/detail/element_iterator.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/detail/exclusive_less_than.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/detail/interval_map_algo.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/detail/interval_morphism.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/detail/interval_set_algo.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/detail/interval_subset_comparer.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/detail/map_algo.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/detail/mapped_reference.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/detail/notate.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/detail/on_absorbtion.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/detail/relation_state.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/detail/set_algo.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/detail/std_set.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/detail/subset_comparer.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/discrete_interval.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/dynamic_interval_traits.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/functors.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/gregorian.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/interval.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/interval_base_map.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/interval_base_set.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/interval_bounds.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/interval_combining_style.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/interval_map.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/interval_set.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/interval_traits.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/iterator.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/left_open_interval.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/map.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/open_interval.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/predicates/distinct_equal.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/predicates/element_equal.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/predicates/std_equal.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/predicates/sub_super_set.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/ptime.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/rational.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/right_open_interval.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/separate_interval_set.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/split_interval_map.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/split_interval_set.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/absorbs_identities.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/adds_inversely.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/codomain_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/difference.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/difference_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/domain_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/element_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/has_inverse.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/has_set_semantics.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/identity_element.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/infinity.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/interval_type_default.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/interval_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_associative_element_container.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_asymmetric_interval.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_combinable.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_concept_equivalent.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_container.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_continuous.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_continuous_interval.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_discrete.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_discrete_interval.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_element_container.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_icl_container.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_increasing.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_interval.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_interval_container.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_interval_joiner.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_interval_separator.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_interval_splitter.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_key_container_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_map.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_numeric.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_set.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/is_total.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/no_type.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/predicate.hpp	/^namespace boost{namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/rep_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/segment_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/size.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/size_type_of.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/succ_pred.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/to_string.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/type_to_string.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/unit_element.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
icl	icl/type_traits/value_size.hpp	/^namespace boost{ namespace icl$/;"	n	namespace:boost
identity_absorber	icl/detail/interval_morphism.hpp	/^        struct identity_absorber$/;"	s	namespace:boost::icl::segmental
identity_based_inplace_combine	icl/functors.hpp	/^    template <typename Type> struct identity_based_inplace_combine $/;"	s	namespace:boost::icl	inherits:std::binary_function
identity_element	icl/functors.hpp	/^        inline static Type identity_element() { return boost::icl::identity_element<Type>::value(); }$/;"	f	struct:boost::icl::identity_based_inplace_combine	access:public	signature:()
identity_element	icl/functors.hpp	/^        inline static Type identity_element() { return boost::icl::unit_element<Type>::value(); }$/;"	f	struct:boost::icl::unit_element_based_inplace_combine	access:public	signature:()
identity_element	icl/gregorian.hpp	/^    struct identity_element<boost::gregorian::date_duration>$/;"	s	namespace:boost::icl
identity_element	icl/type_traits/identity_element.hpp	/^    template <class Type> struct identity_element$/;"	s	namespace:boost::icl
inclusion	icl/detail/relation_state.hpp	/^    namespace inclusion$/;"	n	namespace:boost::icl
inclusion_compare	icl/concept/element_associator.hpp	/^inclusion_compare(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
inclusion_compare	icl/concept/interval_associator.hpp	/^inclusion_compare(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
increment	icl/detail/element_iterator.hpp	/^    void increment()$/;"	f	class:boost::icl::element_iterator	access:private	signature:()
infinity	icl/type_traits/infinity.hpp	/^struct infinity<std::string>$/;"	s	namespace:boost::icl
infinity	icl/type_traits/infinity.hpp	/^template <class Type> struct infinity$/;"	s	namespace:boost::icl
inner_bounds	icl/concept/interval_bounds.hpp	/^inline interval_bounds inner_bounds(interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
inner_bounds	icl/concept/interval_bounds.hpp	/^inner_bounds(const IntervalT& x1, const IntervalT& x2)$/;"	f	namespace:boost::icl	signature:(const IntervalT& x1, const IntervalT& x2)
inner_complement	icl/concept/interval.hpp	/^inner_complement(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
inplace_bit_add	icl/functors.hpp	/^    template <typename Type> struct inplace_bit_add$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inplace_bit_and	icl/functors.hpp	/^    template <typename Type> struct inplace_bit_and$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inplace_bit_subtract	icl/functors.hpp	/^    template <typename Type> struct inplace_bit_subtract$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inplace_bit_xor	icl/functors.hpp	/^    template <typename Type> struct inplace_bit_xor$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inplace_caret	icl/functors.hpp	/^    template <typename Type> struct inplace_caret$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inplace_erase	icl/functors.hpp	/^    template <typename Type> struct inplace_erase$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inplace_erasure	icl/functors.hpp	/^    template <typename Type> struct inplace_erasure $/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inplace_et	icl/functors.hpp	/^    template <typename Type> struct inplace_et$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inplace_identity	icl/functors.hpp	/^    template <typename Type> struct inplace_identity $/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inplace_insert	icl/functors.hpp	/^    template <typename Type> struct inplace_insert$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inplace_max	icl/functors.hpp	/^    template <typename Type> struct inplace_max$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inplace_min	icl/functors.hpp	/^    template <typename Type> struct inplace_min$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inplace_minus	icl/functors.hpp	/^    template <typename Type> struct inplace_minus $/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inplace_plus	icl/functors.hpp	/^    template <typename Type> struct inplace_plus $/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inplace_slash	icl/functors.hpp	/^    template <typename Type> struct inplace_slash$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inplace_star	icl/functors.hpp	/^    template <typename Type> struct inplace_star$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
insert	icl/concept/element_associator.hpp	/^insert(Type& object, const Type& addend)$/;"	f	namespace:boost::icl	signature:(Type& object, const Type& addend)
insert	icl/concept/element_associator.hpp	/^insert(Type& object, const typename Type::value_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& operand)
insert	icl/concept/element_associator.hpp	/^insert(Type& object, typename Type::iterator      prior, $/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator prior, const typename Type::value_type& operand)
insert	icl/concept/interval_associator.hpp	/^insert(Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
insert	icl/concept/interval_map.hpp	/^insert(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
insert	icl/concept/interval_map.hpp	/^insert(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
insert	icl/concept/interval_map.hpp	/^insert(Type& object, typename Type::iterator      prior,$/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator prior, const typename Type::segment_type& operand)
insert	icl/concept/interval_set.hpp	/^insert(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
insert	icl/concept/interval_set.hpp	/^insert(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
insert	icl/concept/interval_set.hpp	/^insert(Type& object, typename Type::iterator      prior,$/;"	f	namespace:boost::icl	signature:(Type& object, typename Type::iterator prior, const typename Type::segment_type& operand)
insert	icl/interval_base_map.hpp	/^    SubType& insert(const element_type& key_value_pair) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const element_type& key_value_pair)
insert	icl/interval_base_map.hpp	/^    SubType& insert(const segment_type& interval_value_pair)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const segment_type& interval_value_pair)
insert	icl/interval_base_map.hpp	/^    iterator insert(iterator prior, const segment_type& interval_value_pair)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(iterator prior, const segment_type& interval_value_pair)
insert	icl/interval_base_set.hpp	/^    SubType& insert(const element_type& key) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const element_type& key)
insert	icl/interval_base_set.hpp	/^    SubType& insert(const segment_type& inter_val) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const segment_type& inter_val)
insert	icl/interval_base_set.hpp	/^    iterator insert(iterator prior_, const segment_type& inter_val) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(iterator prior_, const segment_type& inter_val)
insert	icl/map.hpp	/^    iterator insert(Iterator first, Iterator last)$/;"	f	class:boost::icl::map	access:public	signature:(Iterator first, Iterator last)
insert	icl/map.hpp	/^    iterator insert(iterator prior, const value_type& value_pair)$/;"	f	class:boost::icl::map	access:public	signature:(iterator prior, const value_type& value_pair)
insert	icl/map.hpp	/^    std::pair<iterator,bool> insert(const value_type& value_pair)$/;"	f	class:boost::icl::map	access:public	signature:(const value_type& value_pair)
insert_at	icl/interval_base_map.hpp	/^    insert_at(const iterator& prior_, const interval_type& inter_val, $/;"	f	class:boost::icl::interval_base_map	access:protected	signature:(const iterator& prior_, const interval_type& inter_val, const codomain_type& co_val )
insert_iterator	icl/iterator.hpp	/^    insert_iterator(ContainerT& cont, typename ContainerT::iterator iter)$/;"	f	class:boost::icl::insert_iterator	access:public	signature:(ContainerT& cont, typename ContainerT::iterator iter)
insert_iterator	icl/iterator.hpp	/^template<class ContainerT> class insert_iterator$/;"	c	namespace:boost::icl	inherits:std::iterator
insert_main	icl/interval_base_map.hpp	/^    ::insert_main(const interval_type& inter_val, const CodomainT& co_val, $/;"	f	class:boost::icl::interval_base_map	signature:(const interval_type& inter_val, const CodomainT& co_val, iterator& it_, const iterator& last_)
insert_main	icl/interval_base_map.hpp	/^    void insert_main(const interval_type&, const CodomainT&, iterator&, const iterator&);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const interval_type&, const CodomainT&, iterator&, const iterator&)
inserter	icl/iterator.hpp	/^inline insert_iterator<ContainerT> inserter(ContainerT& cont, IteratorT iter_)$/;"	f	namespace:boost::icl	signature:(ContainerT& cont, IteratorT iter_)
inter_section	icl/functors.hpp	/^    template<class Type> struct inter_section$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
intersects	icl/concept/element_map.hpp	/^intersects(const Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const Type& operand)
intersects	icl/concept/element_map.hpp	/^intersects(const Type& object, const typename Type::domain_type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const typename Type::domain_type& operand)
intersects	icl/concept/element_map.hpp	/^intersects(const Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const typename Type::element_type& operand)
intersects	icl/concept/element_map.hpp	/^intersects(const Type& object, const typename Type::set_type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const typename Type::set_type& operand)
intersects	icl/concept/element_map.hpp	/^intersects(const Type&, const CoType&)$/;"	f	namespace:boost::icl	signature:(const Type&, const CoType&)
intersects	icl/concept/element_set.hpp	/^intersects(const Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const Type& operand)
intersects	icl/concept/element_set.hpp	/^intersects(const Type& object, const typename Type::key_type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const typename Type::key_type& operand)
intersects	icl/concept/interval.hpp	/^intersects(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
intersects	icl/concept/interval_associator.hpp	/^intersects(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
intersects	icl/concept/interval_associator.hpp	/^intersects(const LeftT&, const RightT&)$/;"	f	namespace:boost::icl	signature:(const LeftT&, const RightT&)
intersects	icl/concept/interval_associator.hpp	/^intersects(const Type& left, const CoType& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const CoType& right)
intersects	icl/concept/interval_map.hpp	/^intersects(const Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const OperandT& operand)
intersects	icl/concept/interval_map.hpp	/^intersects(const Type&, const OperandT&)$/;"	f	namespace:boost::icl	signature:(const Type&, const OperandT&)
intersects	icl/detail/map_algo.hpp	/^bool intersects(const ObjectT& left, const CoObjectT& right)$/;"	f	namespace:boost::icl::Map	signature:(const ObjectT& left, const CoObjectT& right)
intersects	icl/detail/set_algo.hpp	/^bool intersects(const SetType& left, const SetType& right)$/;"	f	namespace:boost::icl::Set	signature:(const SetType& left, const SetType& right)
interval	icl/interval.hpp	/^    struct interval$/;"	s	namespace:boost::icl
interval_base_map	icl/interval_base_map.hpp	/^    interval_base_map()$/;"	f	class:boost::icl::interval_base_map	access:public	signature:()
interval_base_map	icl/interval_base_map.hpp	/^    interval_base_map(const interval_base_map& src): _map(src._map)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const interval_base_map& src)
interval_base_map	icl/interval_base_map.hpp	/^    interval_base_map(interval_base_map&& src): _map(boost::move(src._map))$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(interval_base_map&& src)
interval_base_map	icl/interval_base_map.hpp	/^class interval_base_map$/;"	c	namespace:boost::icl
interval_base_set	icl/interval_base_set.hpp	/^    interval_base_set(){}$/;"	f	class:boost::icl::interval_base_set	access:public	signature:()
interval_base_set	icl/interval_base_set.hpp	/^    interval_base_set(const interval_base_set& src): _set(src._set)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const interval_base_set& src)
interval_base_set	icl/interval_base_set.hpp	/^    interval_base_set(interval_base_set&& src): _set(boost::move(src._set))$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(interval_base_set&& src)
interval_base_set	icl/interval_base_set.hpp	/^class interval_base_set$/;"	c	namespace:boost::icl
interval_bound_type	icl/closed_interval.hpp	/^struct interval_bound_type< closed_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
interval_bound_type	icl/continuous_interval.hpp	/^struct interval_bound_type< continuous_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
interval_bound_type	icl/discrete_interval.hpp	/^struct interval_bound_type< discrete_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
interval_bound_type	icl/left_open_interval.hpp	/^struct interval_bound_type< left_open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
interval_bound_type	icl/open_interval.hpp	/^struct interval_bound_type< open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
interval_bound_type	icl/right_open_interval.hpp	/^struct interval_bound_type< right_open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
interval_bound_type	icl/type_traits/is_interval.hpp	/^struct interval_bound_type$/;"	s	namespace:boost::icl
interval_bounds	icl/interval_bounds.hpp	/^    explicit interval_bounds(bound_type bounds): _bits(bounds){}$/;"	f	class:boost::icl::interval_bounds	access:public	signature:(bound_type bounds)
interval_bounds	icl/interval_bounds.hpp	/^    interval_bounds():_bits(){}$/;"	f	class:boost::icl::interval_bounds	access:public	signature:()
interval_bounds	icl/interval_bounds.hpp	/^class interval_bounds$/;"	c	namespace:boost::icl
interval_combine	icl/interval_combining_style.hpp	/^namespace interval_combine$/;"	n	namespace:boost::icl
interval_compare	icl/interval_base_map.hpp	/^    typedef exclusive_less_than<interval_type> interval_compare;$/;"	t	class:boost::icl::interval_base_map	access:public
interval_compare	icl/interval_base_set.hpp	/^    typedef exclusive_less_than<interval_type>       interval_compare;$/;"	t	class:boost::icl::interval_base_set	access:public
interval_compare	icl/interval_set.hpp	/^    typedef exclusive_less_than<interval_type> interval_compare;$/;"	t	class:boost::icl::interval_set	access:public
interval_compare	icl/separate_interval_set.hpp	/^    typedef exclusive_less_than<interval_type> interval_compare;$/;"	t	class:boost::icl::separate_interval_set	access:public
interval_compare	icl/split_interval_set.hpp	/^    typedef exclusive_less_than<interval_type> interval_compare;$/;"	t	class:boost::icl::split_interval_set	access:public
interval_count	icl/concept/interval_associator.hpp	/^interval_count(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
interval_map	icl/interval_map.hpp	/^    explicit interval_map$/;"	f	class:boost::icl::interval_map	access:public	signature:(const interval_base_map<SubType,DomainT,CodomainT, Traits,Compare,Combine,Section,Interval,Alloc>& src)
interval_map	icl/interval_map.hpp	/^    explicit interval_map(const domain_mapping_type& base_pair): base_type()$/;"	f	class:boost::icl::interval_map	access:public	signature:(const domain_mapping_type& base_pair)
interval_map	icl/interval_map.hpp	/^    explicit interval_map(const value_type& value_pair): base_type()$/;"	f	class:boost::icl::interval_map	access:public	signature:(const value_type& value_pair)
interval_map	icl/interval_map.hpp	/^    interval_map(): base_type() {}$/;"	f	class:boost::icl::interval_map	access:public	signature:()
interval_map	icl/interval_map.hpp	/^    interval_map(const interval_map& src): base_type(src) {}$/;"	f	class:boost::icl::interval_map	access:public	signature:(const interval_map& src)
interval_map	icl/interval_map.hpp	/^    interval_map(interval_map&& src)$/;"	f	class:boost::icl::interval_map	access:public	signature:(interval_map&& src)
interval_map	icl/interval_map.hpp	/^class interval_map:$/;"	c	namespace:boost::icl	inherits:interval_base_map
interval_mapping_type	icl/interval_base_map.hpp	/^    typedef std::pair<interval_type,CodomainT> interval_mapping_type;$/;"	t	class:boost::icl::interval_base_map	access:public
interval_mapping_type	icl/interval_map.hpp	/^    typedef typename base_type::interval_mapping_type interval_mapping_type;$/;"	t	class:boost::icl::interval_map	access:public
interval_mapping_type	icl/split_interval_map.hpp	/^    typedef typename base_type::interval_mapping_type  interval_mapping_type;$/;"	t	class:boost::icl::split_interval_map	access:public
interval_set	icl/interval_set.hpp	/^    explicit interval_set$/;"	f	class:boost::icl::interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
interval_set	icl/interval_set.hpp	/^    explicit interval_set(const domain_type& value): base_type() $/;"	f	class:boost::icl::interval_set	access:public	signature:(const domain_type& value)
interval_set	icl/interval_set.hpp	/^    explicit interval_set(const interval_type& itv): base_type() $/;"	f	class:boost::icl::interval_set	access:public	signature:(const interval_type& itv)
interval_set	icl/interval_set.hpp	/^    interval_set(): base_type() {}$/;"	f	class:boost::icl::interval_set	access:public	signature:()
interval_set	icl/interval_set.hpp	/^    interval_set(const interval_set& src): base_type(src) {}$/;"	f	class:boost::icl::interval_set	access:public	signature:(const interval_set& src)
interval_set	icl/interval_set.hpp	/^    interval_set(interval_set&& src)$/;"	f	class:boost::icl::interval_set	access:public	signature:(interval_set&& src)
interval_set	icl/interval_set.hpp	/^class interval_set: $/;"	c	namespace:boost::icl	inherits:interval_base_set
interval_set_type	icl/interval_map.hpp	/^    typedef interval_set<DomainT,Compare,Interval,Alloc> interval_set_type;$/;"	t	class:boost::icl::interval_map	access:public
interval_set_type	icl/split_interval_map.hpp	/^    typedef interval_set<DomainT,Compare,Interval,Alloc> interval_set_type;$/;"	t	class:boost::icl::split_interval_map	access:public
interval_traits	icl/closed_interval.hpp	/^struct interval_traits< icl::closed_interval<DomainT, Compare> >$/;"	s	namespace:boost::icl
interval_traits	icl/continuous_interval.hpp	/^struct interval_traits< icl::continuous_interval<DomainT, Compare> >$/;"	s	namespace:boost::icl
interval_traits	icl/discrete_interval.hpp	/^struct interval_traits< icl::discrete_interval<DomainT, Compare> >$/;"	s	namespace:boost::icl
interval_traits	icl/interval_traits.hpp	/^template<class Type> struct interval_traits$/;"	s	namespace:boost::icl
interval_traits	icl/left_open_interval.hpp	/^struct interval_traits< icl::left_open_interval<DomainT, Compare> >$/;"	s	namespace:boost::icl
interval_traits	icl/open_interval.hpp	/^struct interval_traits< icl::open_interval<DomainT, Compare> >$/;"	s	namespace:boost::icl
interval_traits	icl/right_open_interval.hpp	/^struct interval_traits< icl::right_open_interval<DomainT, Compare> >$/;"	s	namespace:boost::icl
interval_type	icl/closed_interval.hpp	/^    typedef icl::closed_interval<DomainT, Compare> interval_type;$/;"	t	struct:boost::icl::interval_traits	access:public
interval_type	icl/continuous_interval.hpp	/^    typedef boost::icl::continuous_interval<DomainT,Compare> interval_type;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
interval_type	icl/continuous_interval.hpp	/^    typedef icl::continuous_interval<DomainT, Compare> interval_type;$/;"	t	struct:boost::icl::interval_traits	access:public
interval_type	icl/detail/element_iterator.hpp	/^        typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare)                       interval_type;$/;"	t	struct:boost::icl::elemental	access:public
interval_type	icl/detail/element_iterator.hpp	/^        typedef segment_type                        interval_type;$/;"	t	struct:boost::icl::elemental	access:public
interval_type	icl/detail/element_iterator.hpp	/^        typedef segment_type              interval_type;$/;"	t	struct:boost::icl::elemental	access:public
interval_type	icl/detail/element_iterator.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare)               interval_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
interval_type	icl/detail/element_iterator.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare)    interval_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
interval_type	icl/detail/element_iterator.hpp	/^    typedef segment_type                             interval_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
interval_type	icl/detail/element_iterator.hpp	/^    typedef segment_type                            interval_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
interval_type	icl/detail/element_iterator.hpp	/^    typedef typename first_element<segment_type>::type      interval_type;$/;"	t	class:boost::icl::element_iterator	access:public
interval_type	icl/detail/interval_set_algo.hpp	/^    typedef typename Type::interval_type interval_type;$/;"	t	struct:boost::icl::Interval_Set::on_style	access:public
interval_type	icl/discrete_interval.hpp	/^    typedef boost::icl::discrete_interval<DomainT,Compare> interval_type;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
interval_type	icl/discrete_interval.hpp	/^    typedef icl::discrete_interval<DomainT, Compare> interval_type;$/;"	t	struct:boost::icl::interval_traits	access:public
interval_type	icl/interval.hpp	/^        typedef typename interval_type_default<DomainT,Compare>::type interval_type;$/;"	t	struct:boost::icl::interval	access:public
interval_type	icl/interval_base_map.hpp	/^        typedef typename Type::interval_type  interval_type;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
interval_type	icl/interval_base_map.hpp	/^        typedef typename Type::interval_type interval_type;$/;"	t	struct:boost::icl::interval_base_map::on_codomain_model	access:public
interval_type	icl/interval_base_map.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) interval_type;$/;"	t	class:boost::icl::interval_base_map	access:public
interval_type	icl/interval_base_set.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) interval_type;$/;"	t	class:boost::icl::interval_base_set	access:public
interval_type	icl/interval_map.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) interval_type;$/;"	t	class:boost::icl::interval_map	access:public
interval_type	icl/interval_set.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) interval_type;$/;"	t	class:boost::icl::interval_set	access:public
interval_type	icl/left_open_interval.hpp	/^    typedef icl::left_open_interval<DomainT, Compare> interval_type;$/;"	t	struct:boost::icl::interval_traits	access:public
interval_type	icl/open_interval.hpp	/^    typedef icl::open_interval<DomainT, Compare> interval_type;$/;"	t	struct:boost::icl::interval_traits	access:public
interval_type	icl/right_open_interval.hpp	/^    typedef icl::right_open_interval<DomainT, Compare> interval_type;$/;"	t	struct:boost::icl::interval_traits	access:public
interval_type	icl/separate_interval_set.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) interval_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
interval_type	icl/split_interval_map.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) interval_type;$/;"	t	class:boost::icl::split_interval_map	access:public
interval_type	icl/split_interval_set.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) interval_type;$/;"	t	class:boost::icl::split_interval_set	access:public
interval_type_default	icl/type_traits/interval_type_default.hpp	/^    struct interval_type_default$/;"	s	namespace:boost::icl
interval_type_of	icl/type_traits/interval_type_of.hpp	/^    struct interval_type_of$/;"	s	namespace:boost::icl
inverse	icl/functors.hpp	/^    struct inverse$/;"	s	namespace:boost::icl
inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_bit_add<Type> >$/;"	s	namespace:boost::icl
inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_bit_and<Type> >$/;"	s	namespace:boost::icl
inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_bit_subtract<Type> >$/;"	s	namespace:boost::icl
inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_bit_xor<Type> >$/;"	s	namespace:boost::icl
inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_caret<Type> >$/;"	s	namespace:boost::icl
inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_et<Type> >$/;"	s	namespace:boost::icl
inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_identity<Type> >$/;"	s	namespace:boost::icl
inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_max<Type> >$/;"	s	namespace:boost::icl
inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_min<Type> >$/;"	s	namespace:boost::icl
inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_minus<Type> >$/;"	s	namespace:boost::icl
inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_plus<Type> >$/;"	s	namespace:boost::icl
inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_slash<Type> >$/;"	s	namespace:boost::icl
inverse	icl/functors.hpp	/^    struct inverse<icl::inplace_star<Type> >$/;"	s	namespace:boost::icl
inverse	icl/functors.hpp	/^    struct inverse<icl::inter_section<Type> >$/;"	s	namespace:boost::icl	inherits:identity_based_inplace_combine
inverse_codomain_combine	icl/interval_base_map.hpp	/^        typedef typename Type::inverse_codomain_combine inverse_codomain_combine;$/;"	t	struct:boost::icl::interval_base_map::on_invertible	access:public
inverse_codomain_combine	icl/interval_base_map.hpp	/^    typedef typename inverse<codomain_combine>::type inverse_codomain_combine;$/;"	t	class:boost::icl::interval_base_map	access:public
inverse_codomain_combine	icl/map.hpp	/^        typedef typename Type::inverse_codomain_combine inverse_codomain_combine;$/;"	t	struct:boost::icl::map::on_invertible	access:public
inverse_codomain_combine	icl/map.hpp	/^    typedef typename inverse<codomain_combine >::type   inverse_codomain_combine;$/;"	t	class:boost::icl::map	access:public
inverse_codomain_intersect	icl/interval_base_map.hpp	/^        typedef typename Type::inverse_codomain_intersect inverse_codomain_intersect;$/;"	t	struct:boost::icl::interval_base_map::on_codomain_model	access:public
inverse_codomain_intersect	icl/interval_base_map.hpp	/^        typedef typename Type::inverse_codomain_intersect inverse_codomain_intersect;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
inverse_codomain_intersect	icl/interval_base_map.hpp	/^    typedef typename inverse<codomain_intersect>::type inverse_codomain_intersect;$/;"	t	class:boost::icl::interval_base_map	access:public
inverse_codomain_intersect	icl/map.hpp	/^        typedef typename Type::inverse_codomain_intersect inverse_codomain_intersect;$/;"	t	struct:boost::icl::map::on_codomain_model	access:public
inverse_codomain_intersect	icl/map.hpp	/^        typedef typename Type::inverse_codomain_intersect inverse_codomain_intersect;$/;"	t	struct:boost::icl::map::on_total_absorbable	access:public
inverse_codomain_intersect	icl/map.hpp	/^    typedef typename inverse<codomain_intersect>::type  inverse_codomain_intersect;$/;"	t	class:boost::icl::map	access:public
inversion	icl/functors.hpp	/^        static argument_type inversion(const argument_type& value)$/;"	f	struct:boost::icl::conversion	access:public	signature:(const argument_type& value)
is_absorbable	icl/detail/on_absorbtion.hpp	/^    static bool is_absorbable(const codomain_type& co_value)$/;"	f	struct:boost::icl::on_absorbtion	access:public	signature:(const codomain_type& co_value)
is_absorbable	icl/detail/on_absorbtion.hpp	/^    static bool is_absorbable(const codomain_type&){ return false; }$/;"	f	struct:boost::icl::on_absorbtion	access:public	signature:(const codomain_type&)
is_associative_element_container	icl/type_traits/is_associative_element_container.hpp	/^    struct is_associative_element_container$/;"	s	namespace:boost::icl
is_asymmetric_interval	icl/type_traits/is_asymmetric_interval.hpp	/^template <class Type> struct is_asymmetric_interval$/;"	s	namespace:boost::icl
is_binary_cross_combinable	icl/type_traits/is_combinable.hpp	/^struct is_binary_cross_combinable$/;"	s	namespace:boost::icl
is_binary_inter_combinable	icl/type_traits/is_combinable.hpp	/^struct is_binary_inter_combinable$/;"	s	namespace:boost::icl
is_binary_interval_map_combinable	icl/type_traits/is_combinable.hpp	/^struct is_binary_interval_map_combinable$/;"	s	namespace:boost::icl
is_binary_interval_set_combinable	icl/type_traits/is_combinable.hpp	/^struct is_binary_interval_set_combinable$/;"	s	namespace:boost::icl
is_binary_intra_combinable	icl/type_traits/is_combinable.hpp	/^struct is_binary_intra_combinable$/;"	s	namespace:boost::icl
is_coarser_interval_map_companion	icl/type_traits/is_combinable.hpp	/^struct is_coarser_interval_map_companion$/;"	s	namespace:boost::icl
is_coarser_interval_set_companion	icl/type_traits/is_combinable.hpp	/^struct is_coarser_interval_set_companion$/;"	s	namespace:boost::icl
is_codomain_equal	icl/type_traits/is_combinable.hpp	/^struct is_codomain_equal$/;"	s	namespace:boost::icl
is_codomain_type_equal	icl/type_traits/is_combinable.hpp	/^struct is_codomain_type_equal$/;"	s	namespace:boost::icl
is_complementary	icl/concept/interval_bounds.hpp	/^inline bool is_complementary(interval_bounds x1)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1)
is_concept_combinable	icl/type_traits/is_combinable.hpp	/^struct is_concept_combinable$/;"	s	namespace:boost::icl
is_concept_compatible	icl/type_traits/is_combinable.hpp	/^struct is_concept_compatible$/;"	s	namespace:boost::icl
is_concept_equivalent	icl/type_traits/is_concept_equivalent.hpp	/^    struct is_concept_equivalent$/;"	s	namespace:boost::icl
is_container	icl/type_traits/is_container.hpp	/^    struct is_container $/;"	s	namespace:boost::icl	inherits:mpl::bool_
is_continuous	icl/rational.hpp	/^    struct is_continuous<boost::rational<Integral> >$/;"	s	namespace:boost::icl
is_continuous	icl/type_traits/is_continuous.hpp	/^    template <class Type> struct is_continuous$/;"	s	namespace:boost::icl
is_continuous_asymmetric	icl/type_traits/is_asymmetric_interval.hpp	/^template <class Type> struct is_continuous_asymmetric$/;"	s	namespace:boost::icl
is_continuous_interval	icl/continuous_interval.hpp	/^struct is_continuous_interval<continuous_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
is_continuous_interval	icl/type_traits/is_continuous_interval.hpp	/^template <class Type> struct is_continuous_interval$/;"	s	namespace:boost::icl
is_continuous_left_open	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_continuous_left_open$/;"	s	namespace:boost::icl
is_continuous_right_open	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_continuous_right_open$/;"	s	namespace:boost::icl
is_continuous_static	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_continuous_static$/;"	s	namespace:boost::icl
is_cross_combinable	icl/type_traits/is_combinable.hpp	/^struct is_cross_combinable$/;"	s	namespace:boost::icl
is_cross_derivative	icl/type_traits/is_combinable.hpp	/^struct is_cross_derivative$/;"	s	namespace:boost::icl
is_dense	icl/detail/interval_set_algo.hpp	/^bool is_dense(const IntervalContainerT& container, $/;"	f	namespace:boost::icl::Interval_Set	signature:(const IntervalContainerT& container, typename IntervalContainerT::const_iterator first, typename IntervalContainerT::const_iterator past)
is_discrete	icl/gregorian.hpp	/^    template<> struct is_discrete<boost::gregorian::date>$/;"	s	namespace:boost::icl
is_discrete	icl/gregorian.hpp	/^    template<> struct is_discrete<boost::gregorian::date_duration>$/;"	s	namespace:boost::icl
is_discrete	icl/ptime.hpp	/^    template<> struct is_discrete<boost::posix_time::ptime>$/;"	s	namespace:boost::icl
is_discrete	icl/ptime.hpp	/^    template<> struct is_discrete<boost::posix_time::time_duration>$/;"	s	namespace:boost::icl
is_discrete	icl/rational.hpp	/^    struct is_discrete<boost::rational<Integral> >$/;"	s	namespace:boost::icl
is_discrete	icl/type_traits/is_discrete.hpp	/^    template <class Type> struct is_discrete$/;"	s	namespace:boost::icl
is_discrete_asymmetric	icl/type_traits/is_asymmetric_interval.hpp	/^template <class Type> struct is_discrete_asymmetric$/;"	s	namespace:boost::icl
is_discrete_interval	icl/discrete_interval.hpp	/^struct is_discrete_interval<discrete_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
is_discrete_interval	icl/type_traits/is_discrete_interval.hpp	/^template <class Type> struct is_discrete_interval$/;"	s	namespace:boost::icl
is_discrete_static	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_discrete_static$/;"	s	namespace:boost::icl
is_discrete_static_closed	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_discrete_static_closed$/;"	s	namespace:boost::icl
is_discrete_static_open	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_discrete_static_open$/;"	s	namespace:boost::icl
is_distinct_equal	icl/concept/element_map.hpp	/^is_distinct_equal(const Type& lhs, const Type& rhs)$/;"	f	namespace:boost::icl	signature:(const Type& lhs, const Type& rhs)
is_distinct_equal	icl/concept/interval_associator.hpp	/^is_distinct_equal(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
is_element_container	icl/type_traits/is_element_container.hpp	/^    struct is_element_container$/;"	s	namespace:boost::icl
is_element_equal	icl/concept/element_associator.hpp	/^is_element_equal(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
is_element_equal	icl/concept/interval_associator.hpp	/^is_element_equal(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
is_element_equal	icl/detail/interval_set_algo.hpp	/^bool is_element_equal(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT& left, const RightT& right)
is_element_greater	icl/concept/interval_associator.hpp	/^is_element_greater(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
is_element_greater	icl/detail/interval_set_algo.hpp	/^bool is_element_greater(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT& left, const RightT& right)
is_element_less	icl/concept/interval_associator.hpp	/^is_element_less(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl	signature:(const LeftT& left, const RightT& right)
is_element_less	icl/detail/interval_set_algo.hpp	/^bool is_element_less(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT& left, const RightT& right)
is_element_map	icl/type_traits/is_element_container.hpp	/^    struct is_element_map$/;"	s	namespace:boost::icl
is_element_set	icl/type_traits/is_element_container.hpp	/^    struct is_element_set$/;"	s	namespace:boost::icl
is_empty	icl/concept/container.hpp	/^is_empty(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
is_empty	icl/concept/interval.hpp	/^is_empty(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
is_fixed_numeric	icl/type_traits/is_numeric.hpp	/^template <class Type> struct is_fixed_numeric$/;"	s	namespace:boost::icl
is_fragment_of	icl/type_traits/is_combinable.hpp	/^struct is_fragment_of$/;"	s	namespace:boost::icl
is_fragment_of	icl/type_traits/is_combinable.hpp	/^struct is_fragment_of<typename Type::element_type, Type>$/;"	s	namespace:boost::icl
is_fragment_of	icl/type_traits/is_combinable.hpp	/^struct is_fragment_of<typename Type::segment_type, Type>$/;"	s	namespace:boost::icl
is_icl_container	icl/type_traits/is_icl_container.hpp	/^    struct is_icl_container$/;"	s	namespace:boost::icl
is_inclusion_equal	icl/detail/interval_set_algo.hpp	/^bool is_inclusion_equal(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT& left, const RightT& right)
is_increasing	icl/type_traits/is_increasing.hpp	/^struct is_increasing$/;"	s	namespace:boost::icl
is_increasing	icl/type_traits/is_increasing.hpp	/^struct is_increasing<DomainT, std::greater<DomainT> >$/;"	s	namespace:boost::icl
is_inter_combinable	icl/type_traits/is_combinable.hpp	/^struct is_inter_combinable$/;"	s	namespace:boost::icl
is_inter_derivative	icl/type_traits/is_combinable.hpp	/^struct is_inter_derivative$/;"	s	namespace:boost::icl
is_interval	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_interval$/;"	s	namespace:boost::icl
is_interval_container	icl/interval_base_map.hpp	/^struct is_interval_container<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_interval_container	icl/interval_base_set.hpp	/^struct is_interval_container<icl::interval_base_set<SubType,DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_interval_container	icl/interval_map.hpp	/^struct is_interval_container<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_interval_container	icl/interval_set.hpp	/^struct is_interval_container<icl::interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_interval_container	icl/separate_interval_set.hpp	/^struct is_interval_container<icl::separate_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_interval_container	icl/split_interval_map.hpp	/^struct is_interval_container<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_interval_container	icl/split_interval_set.hpp	/^struct is_interval_container<icl::split_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_interval_container	icl/type_traits/is_interval_container.hpp	/^    template <class Type> struct is_interval_container$/;"	s	namespace:boost::icl
is_interval_joiner	icl/interval_set.hpp	/^struct is_interval_joiner<icl::interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_interval_joiner	icl/type_traits/is_interval_joiner.hpp	/^    template <class Type> struct is_interval_joiner$/;"	s	namespace:boost::icl
is_interval_map	icl/type_traits/is_interval_container.hpp	/^    struct is_interval_map$/;"	s	namespace:boost::icl
is_interval_map_companion	icl/type_traits/is_combinable.hpp	/^template<class GuideT, class CompanionT> struct is_interval_map_companion$/;"	s	namespace:boost::icl
is_interval_map_derivative	icl/type_traits/is_combinable.hpp	/^struct is_interval_map_derivative$/;"	s	namespace:boost::icl
is_interval_map_derivative	icl/type_traits/is_combinable.hpp	/^struct is_interval_map_derivative<Type, typename Type::domain_mapping_type>$/;"	s	namespace:boost::icl
is_interval_map_derivative	icl/type_traits/is_combinable.hpp	/^struct is_interval_map_derivative<Type, typename Type::interval_mapping_type>$/;"	s	namespace:boost::icl
is_interval_map_derivative	icl/type_traits/is_combinable.hpp	/^struct is_interval_map_derivative<Type, typename Type::value_type>$/;"	s	namespace:boost::icl
is_interval_map_right_cross_combinable	icl/type_traits/is_combinable.hpp	/^struct is_interval_map_right_cross_combinable \/\/NOTE equivalent to key_type_of<Comp, Guide>$/;"	s	namespace:boost::icl
is_interval_map_right_inter_combinable	icl/type_traits/is_combinable.hpp	/^struct is_interval_map_right_inter_combinable$/;"	s	namespace:boost::icl
is_interval_map_right_intra_combinable	icl/type_traits/is_combinable.hpp	/^struct is_interval_map_right_intra_combinable \/\/NOTE equivalent to is_fragment_type_of$/;"	s	namespace:boost::icl
is_interval_separator	icl/separate_interval_set.hpp	/^struct is_interval_separator<icl::separate_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_interval_separator	icl/type_traits/is_interval_separator.hpp	/^    template <class Type> struct is_interval_separator$/;"	s	namespace:boost::icl
is_interval_set	icl/type_traits/is_interval_container.hpp	/^    struct is_interval_set$/;"	s	namespace:boost::icl
is_interval_set_companion	icl/type_traits/is_combinable.hpp	/^template<class GuideT, class CompanionT> struct is_interval_set_companion$/;"	s	namespace:boost::icl
is_interval_set_derivative	icl/type_traits/is_combinable.hpp	/^struct is_interval_set_derivative$/;"	s	namespace:boost::icl
is_interval_set_derivative	icl/type_traits/is_combinable.hpp	/^struct is_interval_set_derivative<Type, typename Type::domain_type>$/;"	s	namespace:boost::icl
is_interval_set_derivative	icl/type_traits/is_combinable.hpp	/^struct is_interval_set_derivative<Type, typename Type::interval_type>$/;"	s	namespace:boost::icl
is_interval_set_right_combinable	icl/type_traits/is_combinable.hpp	/^struct is_interval_set_right_combinable$/;"	s	namespace:boost::icl
is_interval_splitter	icl/split_interval_map.hpp	/^struct is_interval_splitter<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_interval_splitter	icl/split_interval_set.hpp	/^struct is_interval_splitter<icl::split_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_interval_splitter	icl/type_traits/is_interval_splitter.hpp	/^    template <class Type> struct is_interval_splitter$/;"	s	namespace:boost::icl
is_intra_combinable	icl/type_traits/is_combinable.hpp	/^struct is_intra_combinable$/;"	s	namespace:boost::icl
is_intra_derivative	icl/type_traits/is_combinable.hpp	/^struct is_intra_derivative$/;"	s	namespace:boost::icl
is_joinable	icl/concept/joinable.hpp	/^    is_joinable(typename Type::iterator it_, typename Type::iterator next_, Type* = 0)$/;"	f	namespace:boost::icl::segmental	signature:(typename Type::iterator it_, typename Type::iterator next_, Type* = 0)
is_joinable	icl/detail/interval_map_algo.hpp	/^bool is_joinable(const IntervalMapT& container, $/;"	f	namespace:boost::icl::Interval_Map	signature:(const IntervalMapT& container, typename IntervalMapT::const_iterator first, typename IntervalMapT::const_iterator past)
is_joinable	icl/detail/interval_set_algo.hpp	/^bool is_joinable(const IntervalContainerT& container, $/;"	f	namespace:boost::icl::Interval_Set	signature:(const IntervalContainerT& container, typename IntervalContainerT::const_iterator first, typename IntervalContainerT::const_iterator past)
is_key_compare_equal	icl/type_traits/is_combinable.hpp	/^struct is_key_compare_equal$/;"	s	namespace:boost::icl
is_key_container_of	icl/type_traits/is_key_container_of.hpp	/^    struct is_key_container_of \/\/ set is_key_container_of (set or map)$/;"	s	namespace:boost::icl
is_key_of	icl/type_traits/is_combinable.hpp	/^struct is_key_of$/;"	s	namespace:boost::icl
is_key_of	icl/type_traits/is_combinable.hpp	/^struct is_key_of<typename Type::domain_type, Type>$/;"	s	namespace:boost::icl
is_key_of	icl/type_traits/is_combinable.hpp	/^struct is_key_of<typename Type::interval_type, Type>$/;"	s	namespace:boost::icl
is_left_closed	icl/concept/interval_bounds.hpp	/^inline bool is_left_closed(interval_bounds bounds)$/;"	f	namespace:boost::icl	signature:(interval_bounds bounds)
is_less_than	icl/type_traits/is_numeric.hpp	/^    static bool is_less_than(Type value)$/;"	f	struct:boost::icl::numeric_minimum	access:public	signature:(Type value)
is_less_than	icl/type_traits/is_numeric.hpp	/^    static bool is_less_than(Type){ return true; }$/;"	f	struct:boost::icl::numeric_minimum	access:public	signature:(Type)
is_less_than_or	icl/type_traits/is_numeric.hpp	/^    static bool is_less_than_or(Type value, bool cond)$/;"	f	struct:boost::icl::numeric_minimum	access:public	signature:(Type value, bool cond)
is_less_than_or	icl/type_traits/is_numeric.hpp	/^    static bool is_less_than_or(Type, bool){ return true; }$/;"	f	struct:boost::icl::numeric_minimum	access:public	signature:(Type, bool)
is_map	icl/interval_base_map.hpp	/^struct is_map<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_map	icl/interval_map.hpp	/^struct is_map<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_map	icl/map.hpp	/^struct is_map<icl::map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc> >$/;"	s	namespace:boost::icl
is_map	icl/split_interval_map.hpp	/^struct is_map<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_map	icl/type_traits/is_map.hpp	/^    template <class Type> struct is_map$/;"	s	namespace:boost::icl
is_mapped_reference_combinable	icl/detail/mapped_reference.hpp	/^struct is_mapped_reference_combinable<std::pair<FirstT,SecondT> >$/;"	s	namespace:boost::icl
is_mapped_reference_combinable	icl/detail/mapped_reference.hpp	/^struct is_mapped_reference_combinable<std::pair<const FirstT,SecondT> >$/;"	s	namespace:boost::icl
is_mapped_reference_combinable	icl/detail/mapped_reference.hpp	/^struct is_mapped_reference_combinable{$/;"	s	namespace:boost::icl
is_mapped_reference_or_combinable	icl/detail/mapped_reference.hpp	/^struct is_mapped_reference_or_combinable<mapped_reference<FirstT,SecondT> >$/;"	s	namespace:boost::icl
is_mapped_reference_or_combinable	icl/detail/mapped_reference.hpp	/^struct is_mapped_reference_or_combinable{$/;"	s	namespace:boost::icl
is_negative	icl/functors.hpp	/^    struct is_negative$/;"	s	namespace:boost::icl
is_negative	icl/functors.hpp	/^    struct is_negative<icl::inplace_bit_subtract<Type> >$/;"	s	namespace:boost::icl
is_negative	icl/functors.hpp	/^    struct is_negative<icl::inplace_minus<Type> >$/;"	s	namespace:boost::icl
is_non_floating_point	icl/type_traits/is_numeric.hpp	/^struct is_non_floating_point$/;"	s	namespace:boost::icl
is_numeric	icl/rational.hpp	/^    struct is_numeric<boost::rational<Integral> >$/;"	s	namespace:boost::icl
is_numeric	icl/type_traits/is_numeric.hpp	/^struct is_numeric<std::complex<Type> >$/;"	s	namespace:boost::icl
is_numeric	icl/type_traits/is_numeric.hpp	/^template <class Type> struct is_numeric$/;"	s	namespace:boost::icl
is_overloadable	icl/type_traits/is_combinable.hpp	/^struct is_overloadable$/;"	s	namespace:boost::icl
is_reverse	icl/detail/element_iterator.hpp	/^struct is_reverse$/;"	s	namespace:boost::icl
is_reverse	icl/detail/element_iterator.hpp	/^struct is_reverse<icl::element_iterator<BaseIteratorT> >$/;"	s	namespace:boost::icl
is_reverse	icl/detail/element_iterator.hpp	/^struct is_reverse<std::reverse_iterator<BaseIteratorT> >$/;"	s	namespace:boost::icl
is_right_closed	icl/concept/interval_bounds.hpp	/^inline bool is_right_closed(interval_bounds bounds)$/;"	f	namespace:boost::icl	signature:(interval_bounds bounds)
is_right_inter_combinable	icl/type_traits/is_combinable.hpp	/^struct is_right_inter_combinable$/;"	s	namespace:boost::icl
is_right_intra_combinable	icl/type_traits/is_combinable.hpp	/^struct is_right_intra_combinable$/;"	s	namespace:boost::icl
is_set	icl/detail/std_set.hpp	/^struct is_set<std::set<Type> >$/;"	s	namespace:boost::icl
is_set	icl/interval_base_set.hpp	/^struct is_set<icl::interval_base_set<SubType,DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_set	icl/interval_set.hpp	/^struct is_set<icl::interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_set	icl/separate_interval_set.hpp	/^struct is_set<icl::separate_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_set	icl/split_interval_set.hpp	/^struct is_set<icl::split_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_set	icl/type_traits/is_set.hpp	/^    template <class Type> struct is_set$/;"	s	namespace:boost::icl
is_singelizable	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_singelizable$/;"	s	namespace:boost::icl
is_static_closed	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_static_closed$/;"	s	namespace:boost::icl
is_static_left_open	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_static_left_open$/;"	s	namespace:boost::icl
is_static_open	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_static_open$/;"	s	namespace:boost::icl
is_static_right_open	icl/type_traits/is_interval.hpp	/^template <class Type> struct is_static_right_open$/;"	s	namespace:boost::icl
is_std_integral	icl/type_traits/is_numeric.hpp	/^template <class Type> struct is_std_integral$/;"	s	namespace:boost::icl
is_std_numeric	icl/type_traits/is_numeric.hpp	/^template <class Type> struct is_std_numeric$/;"	s	namespace:boost::icl
is_std_pair	icl/detail/element_iterator.hpp	/^struct is_std_pair$/;"	s	namespace:boost::icl
is_std_pair	icl/detail/element_iterator.hpp	/^struct is_std_pair<std::pair<FirstT, SecondT> >$/;"	s	namespace:boost::icl
is_std_set	icl/type_traits/is_container.hpp	/^    struct is_std_set$/;"	s	namespace:boost::icl
is_strict_key_container_of	icl/type_traits/is_key_container_of.hpp	/^    struct is_strict_key_container_of \/\/ set is_strict_key_container_of map$/;"	s	namespace:boost::icl
is_subtraction_closed	icl/type_traits/difference_type_of.hpp	/^    struct is_subtraction_closed$/;"	s	namespace:boost::icl
is_total	icl/interval_base_map.hpp	/^struct is_total<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_total	icl/interval_map.hpp	/^struct is_total<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_total	icl/map.hpp	/^    enum { is_total = false };$/;"	e	enum:boost::icl::partial_absorber::__anon13
is_total	icl/map.hpp	/^    enum { is_total = false };$/;"	e	enum:boost::icl::partial_enricher::__anon15
is_total	icl/map.hpp	/^    enum { is_total = true };$/;"	e	enum:boost::icl::total_absorber::__anon17
is_total	icl/map.hpp	/^    enum { is_total = true };$/;"	e	enum:boost::icl::total_enricher::__anon19
is_total	icl/map.hpp	/^struct is_total<icl::map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc> >$/;"	s	namespace:boost::icl
is_total	icl/split_interval_map.hpp	/^struct is_total<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
is_total	icl/type_traits/is_total.hpp	/^    template <class Type> struct is_total$/;"	s	namespace:boost::icl
iterative_size	icl/concept/container.hpp	/^iterative_size(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
iterative_size	icl/concept/element_associator.hpp	/^iterative_size(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
iterative_size	icl/concept/interval.hpp	/^iterative_size(const Type&)$/;"	f	namespace:boost::icl	signature:(const Type&)
iterative_size	icl/concept/interval_associator.hpp	/^iterative_size(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
iterative_size	icl/interval_base_map.hpp	/^    std::size_t iterative_size()const $/;"	f	class:boost::icl::interval_base_map	access:public	signature:() const
iterative_size	icl/interval_base_set.hpp	/^    std::size_t iterative_size()const $/;"	f	class:boost::icl::interval_base_set	access:public	signature:() const
iterative_size	icl/map.hpp	/^    std::size_t iterative_size()const { return base_type::size(); }$/;"	f	class:boost::icl::map	access:public	signature:() const
iterator	icl/detail/interval_set_algo.hpp	/^    typedef typename Type::iterator      iterator;$/;"	t	struct:boost::icl::Interval_Set::on_style	access:public
iterator	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::iterator iterator;$/;"	t	class:boost::icl::interval_base_map	access:public
iterator	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::iterator iterator;$/;"	t	class:boost::icl::interval_base_set	access:public
iterator	icl/interval_map.hpp	/^    typedef typename base_type::iterator      iterator;$/;"	t	class:boost::icl::interval_map	access:public
iterator	icl/interval_set.hpp	/^    typedef typename ImplSetT::iterator iterator;$/;"	t	class:boost::icl::interval_set	access:public
iterator	icl/map.hpp	/^        typedef typename Type::iterator       iterator;$/;"	t	struct:boost::icl::map::on_total_absorbable	access:public
iterator	icl/map.hpp	/^    typedef typename base_type::iterator                iterator;$/;"	t	class:boost::icl::map	access:public
iterator	icl/separate_interval_set.hpp	/^    typedef typename ImplSetT::iterator iterator;$/;"	t	class:boost::icl::separate_interval_set	access:public
iterator	icl/split_interval_map.hpp	/^    typedef typename base_type::iterator iterator;$/;"	t	class:boost::icl::split_interval_map	access:public
iterator	icl/split_interval_set.hpp	/^    typedef typename ImplSetT::iterator iterator;$/;"	t	class:boost::icl::split_interval_set	access:public
iterator_category	icl/iterator.hpp	/^    typedef std::output_iterator_tag iterator_category; $/;"	t	class:boost::icl::add_iterator	access:public
iterator_category	icl/iterator.hpp	/^    typedef std::output_iterator_tag iterator_category; $/;"	t	class:boost::icl::insert_iterator	access:public
join	icl/concept/interval_associator_base.hpp	/^join(Type& object)$/;"	f	namespace:boost::icl	signature:(Type& object)
join_left	icl/detail/interval_set_algo.hpp	/^typename Type::iterator join_left(Type& object, typename Type::iterator& it_)$/;"	f	namespace:boost::icl::segmental	signature:(Type& object, typename Type::iterator& it_)
join_neighbours	icl/detail/interval_set_algo.hpp	/^typename Type::iterator join_neighbours(Type& object, typename Type::iterator& it_)$/;"	f	namespace:boost::icl::segmental	signature:(Type& object, typename Type::iterator& it_)
join_nodes	icl/detail/interval_set_algo.hpp	/^inline void join_nodes(Type& object, typename Type::iterator& left_, $/;"	f	namespace:boost::icl::segmental	signature:(Type& object, typename Type::iterator& left_, typename Type::iterator& right_)
join_on_left	icl/detail/interval_set_algo.hpp	/^    join_on_left(Type& object, typename Type::iterator& left_, $/;"	f	namespace:boost::icl::segmental	signature:(Type& object, typename Type::iterator& left_, typename Type::iterator& right_)
join_on_right	icl/detail/interval_set_algo.hpp	/^    join_on_right(Type& object, typename Type::iterator& left_, $/;"	f	namespace:boost::icl::segmental	signature:(Type& object, typename Type::iterator& left_, typename Type::iterator& right_)
join_right	icl/detail/interval_set_algo.hpp	/^typename Type::iterator join_right(Type& object, typename Type::iterator& it_)$/;"	f	namespace:boost::icl::segmental	signature:(Type& object, typename Type::iterator& it_)
join_under	icl/detail/interval_set_algo.hpp	/^    join_under(Type& object, const typename Type::value_type& addend)$/;"	f	namespace:boost::icl::segmental	signature:(Type& object, const typename Type::value_type& addend)
join_under	icl/detail/interval_set_algo.hpp	/^    join_under(Type& object, const typename Type::value_type& addend,$/;"	f	namespace:boost::icl::segmental	signature:(Type& object, const typename Type::value_type& addend, typename Type::iterator last_)
joinable	icl/detail/interval_set_algo.hpp	/^inline bool joinable(const Type& _Type, typename Type::iterator& some, typename Type::iterator& next)$/;"	f	namespace:boost::icl::segmental	signature:(const Type& _Type, typename Type::iterator& some, typename Type::iterator& next)
joiner	icl/detail/interval_morphism.hpp	/^        struct joiner$/;"	s	namespace:boost::icl::segmental
joint_type	icl/interval_map.hpp	/^    typedef type joint_type;$/;"	t	class:boost::icl::interval_map	access:public
joint_type	icl/interval_set.hpp	/^    typedef type joint_type;$/;"	t	class:boost::icl::interval_set	access:public
joint_type	icl/separate_interval_set.hpp	/^    typedef interval_set<DomainT,Compare,Interval,Alloc> joint_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
joint_type	icl/split_interval_map.hpp	/^    typedef       interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> joint_type;$/;"	t	class:boost::icl::split_interval_map	access:public
joint_type	icl/split_interval_set.hpp	/^    typedef interval_set<DomainT,Compare,Interval,Alloc> joint_type;$/;"	t	class:boost::icl::split_interval_set	access:public
key	icl/interval_base_map.hpp	/^    DomainT   key;$/;"	m	struct:boost::icl::mapping_pair	access:public
key_compare	icl/interval_base_map.hpp	/^    typedef exclusive_less_than<interval_type> key_compare;$/;"	t	class:boost::icl::interval_base_map	access:public
key_compare	icl/interval_base_set.hpp	/^    typedef exclusive_less_than<interval_type> key_compare;$/;"	t	class:boost::icl::interval_base_set	access:public
key_compare	icl/interval_set.hpp	/^    typedef exclusive_less_than<interval_type> key_compare;$/;"	t	class:boost::icl::interval_set	access:public
key_compare	icl/map.hpp	/^    typedef domain_compare                              key_compare;$/;"	t	class:boost::icl::map	access:public
key_compare	icl/separate_interval_set.hpp	/^    typedef exclusive_less_than<interval_type> key_compare;$/;"	t	class:boost::icl::separate_interval_set	access:public
key_compare	icl/split_interval_set.hpp	/^    typedef exclusive_less_than<interval_type> key_compare;$/;"	t	class:boost::icl::split_interval_set	access:public
key_container_type_of	icl/type_traits/is_key_container_of.hpp	/^    struct key_container_type_of$/;"	s	namespace:boost::icl
key_object_type	icl/interval_map.hpp	/^    typedef set_type          key_object_type;$/;"	t	class:boost::icl::interval_map	access:public
key_object_type	icl/interval_set.hpp	/^    typedef type key_object_type;$/;"	t	class:boost::icl::interval_set	access:public
key_object_type	icl/map.hpp	/^    typedef set_type                                       key_object_type;$/;"	t	class:boost::icl::map	access:public
key_object_type	icl/separate_interval_set.hpp	/^    typedef type key_object_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
key_object_type	icl/split_interval_map.hpp	/^    typedef set_type          key_object_type;$/;"	t	class:boost::icl::split_interval_map	access:public
key_object_type	icl/split_interval_set.hpp	/^    typedef type key_object_type;$/;"	t	class:boost::icl::split_interval_set	access:public
key_std_pair_type	icl/detail/mapped_reference.hpp	/^    typedef std::pair<const first_type, second_type> key_std_pair_type; $/;"	t	class:boost::icl::mapped_reference	access:public
key_type	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::key_type   key_type;$/;"	t	class:boost::icl::interval_base_map	access:public
key_type	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::key_type   key_type;$/;"	t	class:boost::icl::interval_base_set	access:public
key_type	icl/interval_set.hpp	/^    typedef typename ImplSetT::key_type   key_type;$/;"	t	class:boost::icl::interval_set	access:public
key_type	icl/map.hpp	/^    typedef DomainT                                     key_type;$/;"	t	class:boost::icl::map	access:public
key_type	icl/separate_interval_set.hpp	/^    typedef typename ImplSetT::key_type   key_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
key_type	icl/split_interval_set.hpp	/^    typedef typename ImplSetT::key_type   key_type;$/;"	t	class:boost::icl::split_interval_set	access:public
key_type_of	icl/type_traits/element_type_of.hpp	/^    struct key_type_of$/;"	s	namespace:boost::icl
key_value	icl/concept/map_value.hpp	/^key_value(Iterator it_)$/;"	f	namespace:boost::icl	signature:(Iterator it_)
key_value	icl/concept/set_value.hpp	/^key_value(Iterator it_)$/;"	f	namespace:boost::icl	signature:(Iterator it_)
known_fineness	icl/type_traits/is_combinable.hpp	/^template<class Type> struct known_fineness$/;"	s	namespace:boost::icl
last	icl/closed_interval.hpp	/^    DomainT last() const{ return _upb; }$/;"	f	class:boost::icl::closed_interval	access:public	signature:() const
last	icl/concept/interval.hpp	/^last(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
last	icl/concept/interval_associator.hpp	/^last(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
last	icl/detail/element_iterator.hpp	/^    static domain_type     last  (const SegmentIteratorT& leaper){ return leaper->first.last();  } $/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
last	icl/detail/element_iterator.hpp	/^    static domain_type     last  (const SegmentIteratorT& leaper){ return leaper->last();  } $/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
last_next	icl/concept/interval.hpp	/^last_next(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
left	icl/concept/interval_bounds.hpp	/^inline interval_bounds left(interval_bounds x1)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1)
left	icl/interval_bounds.hpp	/^    interval_bounds left ()const { return interval_bounds(_bits & _left ); }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:() const
left_bounds	icl/concept/interval_bounds.hpp	/^inline interval_bounds left_bounds(interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
left_bounds	icl/concept/interval_bounds.hpp	/^left_bounds(const IntervalT& x1, const IntervalT& x2)$/;"	f	namespace:boost::icl	signature:(const IntervalT& x1, const IntervalT& x2)
left_bracket	icl/concept/interval.hpp	/^left_bracket(const Type& object) $/;"	f	namespace:boost::icl	signature:(const Type& object)
left_bracket	icl/concept/interval.hpp	/^left_bracket(const Type&) { return "("; }$/;"	f	namespace:boost::icl	signature:(const Type&)
left_bracket	icl/concept/interval.hpp	/^left_bracket(const Type&) { return "["; }$/;"	f	namespace:boost::icl	signature:(const Type&)
left_bracket	icl/concept/interval_bounds.hpp	/^inline std::string left_bracket(interval_bounds bounds)$/;"	f	namespace:boost::icl	signature:(interval_bounds bounds)
left_open	icl/continuous_interval.hpp	/^    static continuous_interval left_open (const DomainT& lo, const DomainT& up){ return continuous_interval(lo, up, interval_bounds::left_open()); }$/;"	f	class:boost::icl::continuous_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
left_open	icl/discrete_interval.hpp	/^    static discrete_interval left_open (const DomainT& lo, const DomainT& up){ return discrete_interval(lo, up, interval_bounds::left_open()); }$/;"	f	class:boost::icl::discrete_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
left_open	icl/interval.hpp	/^        static inline interval_type left_open(const DomainT& low, const DomainT& up)$/;"	f	struct:boost::icl::interval	access:public	signature:(const DomainT& low, const DomainT& up)
left_open	icl/interval_bounds.hpp	/^    static interval_bounds left_open() { return interval_bounds(_left_open); }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:()
left_open_interval	icl/left_open_interval.hpp	/^    explicit left_open_interval(const DomainT& val)$/;"	f	class:boost::icl::left_open_interval	access:public	signature:(const DomainT& val)
left_open_interval	icl/left_open_interval.hpp	/^    left_open_interval() $/;"	f	class:boost::icl::left_open_interval	access:public	signature:()
left_open_interval	icl/left_open_interval.hpp	/^    left_open_interval(const DomainT& low, const DomainT& up) :$/;"	f	class:boost::icl::left_open_interval	access:public	signature:(const DomainT& low, const DomainT& up)
left_open_interval	icl/left_open_interval.hpp	/^class left_open_interval$/;"	c	namespace:boost::icl
left_subtract	icl/concept/interval.hpp	/^left_subtract(Type right, const Type& left_minuend)$/;"	f	namespace:boost::icl	signature:(Type right, const Type& left_minuend)
left_subtract_bounds	icl/concept/interval_bounds.hpp	/^inline interval_bounds left_subtract_bounds(interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
left_subtract_bounds	icl/concept/interval_bounds.hpp	/^left_subtract_bounds(const IntervalT& x1, const IntervalT& x2)$/;"	f	namespace:boost::icl	signature:(const IntervalT& x1, const IntervalT& x2)
length	icl/concept/interval.hpp	/^length(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
length	icl/concept/interval_associator.hpp	/^length(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
length	icl/detail/element_iterator.hpp	/^    static domain_difference_type length(const SegmentIteratorT& leaper){ return icl::length(*leaper);}$/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
length	icl/detail/element_iterator.hpp	/^    static domain_difference_type length(const SegmentIteratorT& leaper){ return icl::length(leaper->first);}$/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
length	icl/detail/element_iterator.hpp	/^    static domain_difference_type length(const SegmentIteratorT& leaper){ return leaper->first.length();}$/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
length	icl/detail/element_iterator.hpp	/^    static domain_difference_type length(const SegmentIteratorT& leaper){ return leaper->length();}$/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(const SegmentIteratorT& leaper)
less	icl/detail/element_comparer.hpp	/^        less    = comparison::less, $/;"	e	enum:boost::icl::Interval_Set::element_comparer::__anon7
less	icl/detail/relation_state.hpp	/^        static const int less    = -1;$/;"	m	namespace:boost::icl::comparison
lexicographical_distinct_equal	icl/detail/map_algo.hpp	/^bool lexicographical_distinct_equal(const MapT& left, const MapT& right)$/;"	f	namespace:boost::icl::Map	signature:(const MapT& left, const MapT& right)
lexicographical_equal	icl/detail/set_algo.hpp	/^inline bool lexicographical_equal(const SetType& left, const SetType& right)$/;"	f	namespace:boost::icl::Set	signature:(const SetType& left, const SetType& right)
lower	icl/closed_interval.hpp	/^    DomainT lower()const{ return _lwb; }$/;"	f	class:boost::icl::closed_interval	access:public	signature:() const
lower	icl/closed_interval.hpp	/^    static domain_type lower(const interval_type& inter_val){ return inter_val.lower(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
lower	icl/concept/interval.hpp	/^lower(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
lower	icl/concept/interval_associator.hpp	/^lower(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
lower	icl/continuous_interval.hpp	/^    domain_type     lower()const { return _lwb; }$/;"	f	class:boost::icl::continuous_interval	access:public	signature:() const
lower	icl/continuous_interval.hpp	/^    static domain_type lower(const interval_type& inter_val){ return inter_val.lower(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
lower	icl/discrete_interval.hpp	/^    domain_type     lower()const { return _lwb; }$/;"	f	class:boost::icl::discrete_interval	access:public	signature:() const
lower	icl/discrete_interval.hpp	/^    static domain_type lower(const interval_type& inter_val){ return inter_val.lower(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
lower	icl/interval_traits.hpp	/^    static domain_type lower(const Type& inter_val);$/;"	p	struct:boost::icl::interval_traits	access:public	signature:(const Type& inter_val)
lower	icl/left_open_interval.hpp	/^    DomainT lower()const{ return _lwb; }$/;"	f	class:boost::icl::left_open_interval	access:public	signature:() const
lower	icl/left_open_interval.hpp	/^    static domain_type lower(const interval_type& inter_val){ return inter_val.lower(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
lower	icl/open_interval.hpp	/^    DomainT lower()const{ return _lwb; }$/;"	f	class:boost::icl::open_interval	access:public	signature:() const
lower	icl/open_interval.hpp	/^    static domain_type lower(const interval_type& inter_val){ return inter_val.lower(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
lower	icl/right_open_interval.hpp	/^    domain_type lower()const{ return _lwb; }$/;"	f	class:boost::icl::right_open_interval	access:public	signature:() const
lower	icl/right_open_interval.hpp	/^    static domain_type lower(const interval_type& inter_val){ return inter_val.lower(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
lower_bound	icl/interval_base_map.hpp	/^    const_iterator lower_bound(const key_type& interval)const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const key_type& interval) const
lower_bound	icl/interval_base_map.hpp	/^    iterator lower_bound(const key_type& interval)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const key_type& interval)
lower_bound	icl/interval_base_set.hpp	/^    const_iterator lower_bound(const value_type& interval)const$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const value_type& interval) const
lower_bound	icl/interval_base_set.hpp	/^    iterator lower_bound(const value_type& interval)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const value_type& interval)
lower_equal	icl/concept/interval.hpp	/^lower_equal(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
lower_less	icl/concept/interval.hpp	/^lower_less(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
lower_less_equal	icl/concept/interval.hpp	/^lower_less_equal(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
lower_max	icl/concept/interval.hpp	/^lower_max(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
lower_min	icl/concept/interval.hpp	/^lower_min(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
m_pred	icl/type_traits/predicate.hpp	/^        bool(Type::* m_pred)()const;$/;"	m	class:boost::icl::member_property	access:private
make_mapped_reference	icl/detail/mapped_reference.hpp	/^inline mapped_reference<FirstT, SecondT> make_mapped_reference(const FirstT& left, SecondT& right)$/;"	f	namespace:boost::icl	signature:(const FirstT& left, SecondT& right)
make_segment	icl/concept/interval_map.hpp	/^make_segment(const typename Type::element_type& element)$/;"	f	namespace:boost::icl	signature:(const typename Type::element_type& element)
make_value	icl/concept/map_value.hpp	/^make_value(const typename Type::     key_type& key_val, $/;"	f	namespace:boost::icl	signature:(const typename Type:: key_type& key_val, const typename Type::codomain_type& co_val)
make_value	icl/concept/set_value.hpp	/^make_value(const typename Type::key_type& key_val, $/;"	f	namespace:boost::icl	signature:(const typename Type::key_type& key_val, const typename codomain_type_of<Type>::type& )
map	icl/map.hpp	/^    explicit map(const element_type& key_value_pair): base_type::map()$/;"	f	class:boost::icl::map	access:public	signature:(const element_type& key_value_pair)
map	icl/map.hpp	/^    map()$/;"	f	class:boost::icl::map	access:public	signature:()
map	icl/map.hpp	/^    map(InputIterator first, InputIterator past)$/;"	f	class:boost::icl::map	access:public	signature:(InputIterator first, InputIterator past)
map	icl/map.hpp	/^    map(InputIterator first, InputIterator past, const key_compare& comp)$/;"	f	class:boost::icl::map	access:public	signature:(InputIterator first, InputIterator past, const key_compare& comp)
map	icl/map.hpp	/^    map(const key_compare& comp): base_type(comp){}$/;"	f	class:boost::icl::map	access:public	signature:(const key_compare& comp)
map	icl/map.hpp	/^    map(const map& src)$/;"	f	class:boost::icl::map	access:public	signature:(const map& src)
map	icl/map.hpp	/^    map(map&& src)$/;"	f	class:boost::icl::map	access:public	signature:(map&& src)
map	icl/map.hpp	/^class map: private ICL_IMPL_SPACE::map<DomainT, CodomainT, ICL_COMPARE_DOMAIN(Compare,DomainT), $/;"	c	namespace:boost::icl	inherits:ICL_IMPL_SPACE::map
map_codomain_compare	icl/detail/interval_subset_comparer.hpp	/^struct map_codomain_compare$/;"	s	namespace:boost::icl::Interval_Set
map_codomain_compare	icl/detail/subset_comparer.hpp	/^struct map_codomain_compare$/;"	s	namespace:boost::icl::Set
mapped_reference	icl/detail/mapped_reference.hpp	/^    mapped_reference(const FirstT& fst, second_reference_type snd) : first(fst), second(snd){}$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const FirstT& fst, second_reference_type snd)
mapped_reference	icl/detail/mapped_reference.hpp	/^    mapped_reference(const mapped_reference<FstT, SndT>& source):$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const mapped_reference<FstT, SndT>& source)
mapped_reference	icl/detail/mapped_reference.hpp	/^class mapped_reference$/;"	c	namespace:boost::icl
mapped_type	icl/map.hpp	/^    typedef CodomainT                                   mapped_type;$/;"	t	class:boost::icl::map	access:public
mapping_pair	icl/interval_base_map.hpp	/^    mapping_pair():key(), data(){}$/;"	f	struct:boost::icl::mapping_pair	access:public	signature:()
mapping_pair	icl/interval_base_map.hpp	/^    mapping_pair(const DomainT& key_value, const CodomainT& data_value)$/;"	f	struct:boost::icl::mapping_pair	access:public	signature:(const DomainT& key_value, const CodomainT& data_value)
mapping_pair	icl/interval_base_map.hpp	/^    mapping_pair(const std::pair<DomainT,CodomainT>& std_pair)$/;"	f	struct:boost::icl::mapping_pair	access:public	signature:(const std::pair<DomainT,CodomainT>& std_pair)
mapping_pair	icl/interval_base_map.hpp	/^struct mapping_pair$/;"	s	namespace:boost::icl
member_property	icl/type_traits/predicate.hpp	/^    class member_property : public property<Type>$/;"	c	namespace:boost::icl	inherits:property
next_both	icl/detail/element_comparer.hpp	/^    int next_both(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::element_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
next_both	icl/detail/interval_subset_comparer.hpp	/^    int next_both(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
next_both	icl/detail/subset_comparer.hpp	/^    int next_both(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Set::subset_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
next_left	icl/detail/element_comparer.hpp	/^    int next_left(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::element_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
next_left	icl/detail/interval_subset_comparer.hpp	/^    int next_left(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
next_proton	icl/detail/map_algo.hpp	/^typename MapT::const_iterator next_proton(typename MapT::const_iterator& iter_, const MapT& object)$/;"	f	namespace:boost::icl::Map	signature:(typename MapT::const_iterator& iter_, const MapT& object)
next_right	icl/detail/element_comparer.hpp	/^    int next_right(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::element_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
next_right	icl/detail/interval_subset_comparer.hpp	/^    int next_right(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
nextboth	icl/detail/element_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::element_comparer::__anon6
nextboth	icl/detail/interval_subset_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon2
nextboth	icl/detail/subset_comparer.hpp	/^    enum{nextboth, stop};$/;"	e	enum:boost::icl::Set::subset_comparer::__anon4
nextleft	icl/detail/element_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::element_comparer::__anon6
nextleft	icl/detail/interval_subset_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon2
nextright	icl/detail/element_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::element_comparer::__anon6
nextright	icl/detail/interval_subset_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon2
no_type	icl/type_traits/is_key_container_of.hpp	/^        typedef Type no_type;$/;"	t	struct:boost::icl::get_key_object_type	access:public
no_type	icl/type_traits/no_type.hpp	/^    struct no_type{};$/;"	s	namespace:boost::icl
non_empty	icl/concept/interval.hpp	/^namespace non_empty$/;"	n	namespace:boost::icl
numeric_infinity	icl/type_traits/infinity.hpp	/^struct numeric_infinity$/;"	s	namespace:boost::icl
numeric_minimum	icl/type_traits/is_numeric.hpp	/^struct numeric_minimum$/;"	s	namespace:boost::icl
numeric_minimum	icl/type_traits/is_numeric.hpp	/^struct numeric_minimum<Type, std::greater<Type>, true>$/;"	s	namespace:boost::icl
numeric_minimum	icl/type_traits/is_numeric.hpp	/^struct numeric_minimum<Type, std::less<Type>, true>$/;"	s	namespace:boost::icl
on_absorbtion	icl/detail/on_absorbtion.hpp	/^struct on_absorbtion<Type, Combiner, false>$/;"	s	namespace:boost::icl
on_absorbtion	icl/detail/on_absorbtion.hpp	/^struct on_absorbtion<Type, Combiner, true>$/;"	s	namespace:boost::icl
on_codomain_absorbtion	icl/interval_base_map.hpp	/^                                Traits::absorbs_identities>::type on_codomain_absorbtion;$/;"	t	class:boost::icl::interval_base_map	access:public
on_codomain_model	icl/interval_base_map.hpp	/^    struct on_codomain_model<Type, false>$/;"	s	class:boost::icl::interval_base_map	access:private
on_codomain_model	icl/interval_base_map.hpp	/^    struct on_codomain_model<Type, true>$/;"	s	class:boost::icl::interval_base_map	access:private
on_codomain_model	icl/map.hpp	/^    struct on_codomain_model<Type, false, false>$/;"	s	class:boost::icl::map	access:private
on_codomain_model	icl/map.hpp	/^    struct on_codomain_model<Type, false, true>$/;"	s	class:boost::icl::map	access:private
on_codomain_model	icl/map.hpp	/^    struct on_codomain_model<Type, true, false>$/;"	s	class:boost::icl::map	access:private
on_codomain_model	icl/map.hpp	/^    struct on_codomain_model<Type, true, true>$/;"	s	class:boost::icl::map	access:private
on_definedness	icl/interval_base_map.hpp	/^    struct on_definedness<Type, false>$/;"	s	class:boost::icl::interval_base_map	access:private
on_definedness	icl/interval_base_map.hpp	/^    struct on_definedness<Type, true>$/;"	s	class:boost::icl::interval_base_map	access:private
on_definedness	icl/map.hpp	/^    struct on_definedness<Type, false>$/;"	s	class:boost::icl::map	access:private
on_definedness	icl/map.hpp	/^    struct on_definedness<Type, true>$/;"	s	class:boost::icl::map	access:private
on_identity_absorbtion	icl/map.hpp	/^                                                        on_identity_absorbtion;$/;"	t	class:boost::icl::map	access:public
on_invertible	icl/interval_base_map.hpp	/^    struct on_invertible<Type, false>$/;"	s	class:boost::icl::interval_base_map	access:private
on_invertible	icl/interval_base_map.hpp	/^    struct on_invertible<Type, true>$/;"	s	class:boost::icl::interval_base_map	access:private
on_invertible	icl/map.hpp	/^    struct on_invertible<Type, false>$/;"	s	class:boost::icl::map	access:private
on_invertible	icl/map.hpp	/^    struct on_invertible<Type, true>$/;"	s	class:boost::icl::map	access:private
on_style	icl/detail/interval_set_algo.hpp	/^struct on_style<Type, interval_combine::joining>$/;"	s	namespace:boost::icl::Interval_Set
on_style	icl/detail/interval_set_algo.hpp	/^struct on_style<Type, interval_combine::separating>$/;"	s	namespace:boost::icl::Interval_Set
on_style	icl/detail/interval_set_algo.hpp	/^struct on_style<Type, interval_combine::splitting>$/;"	s	namespace:boost::icl::Interval_Set
on_total_absorbable	icl/interval_base_map.hpp	/^    struct on_total_absorbable<Type, false, absorbs_identities>$/;"	s	class:boost::icl::interval_base_map	access:private
on_total_absorbable	icl/interval_base_map.hpp	/^    struct on_total_absorbable<Type, true, false>$/;"	s	class:boost::icl::interval_base_map	access:private
on_total_absorbable	icl/interval_base_map.hpp	/^    struct on_total_absorbable<Type, true, true>$/;"	s	class:boost::icl::interval_base_map	access:private
on_total_absorbable	icl/map.hpp	/^    struct on_total_absorbable<Type, false, false>$/;"	s	class:boost::icl::map	access:private
on_total_absorbable	icl/map.hpp	/^    struct on_total_absorbable<Type, false, true>$/;"	s	class:boost::icl::map	access:private
on_total_absorbable	icl/map.hpp	/^    struct on_total_absorbable<Type, true, false>$/;"	s	class:boost::icl::map	access:private
on_total_absorbable	icl/map.hpp	/^    struct on_total_absorbable<Type, true, true>$/;"	s	class:boost::icl::map	access:private
open	icl/continuous_interval.hpp	/^    static continuous_interval open     (const DomainT& lo, const DomainT& up){ return continuous_interval(lo, up, interval_bounds::open());      }$/;"	f	class:boost::icl::continuous_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
open	icl/discrete_interval.hpp	/^    static discrete_interval open      (const DomainT& lo, const DomainT& up){ return discrete_interval(lo, up, interval_bounds::open());      }$/;"	f	class:boost::icl::discrete_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
open	icl/interval.hpp	/^        static inline interval_type open(const DomainT& low, const DomainT& up)$/;"	f	struct:boost::icl::interval	access:public	signature:(const DomainT& low, const DomainT& up)
open	icl/interval_bounds.hpp	/^    static interval_bounds open()      { return interval_bounds(_open);     }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:()
open_interval	icl/open_interval.hpp	/^    explicit open_interval(const DomainT& val)$/;"	f	class:boost::icl::open_interval	access:public	signature:(const DomainT& val)
open_interval	icl/open_interval.hpp	/^    open_interval() $/;"	f	class:boost::icl::open_interval	access:public	signature:()
open_interval	icl/open_interval.hpp	/^    open_interval(const DomainT& low, const DomainT& up) :$/;"	f	class:boost::icl::open_interval	access:public	signature:(const DomainT& low, const DomainT& up)
open_interval	icl/open_interval.hpp	/^class open_interval$/;"	c	namespace:boost::icl
operator !=	icl/concept/comparable.hpp	/^operator != (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
operator !=	icl/concept/interval.hpp	/^operator != (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
operator !=	icl/concept/interval_bounds.hpp	/^inline bool operator != (const interval_bounds x1, const interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(const interval_bounds x1, const interval_bounds x2)
operator !=	icl/detail/mapped_reference.hpp	/^    operator != (const Comparand& right)const$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const Comparand& right) const
operator !=	icl/detail/mapped_reference.hpp	/^operator != (                         const StdPairT& left, $/;"	f	namespace:boost::icl	signature:( const StdPairT& left, const mapped_reference<FirstT, SecondT>& right)
operator &	icl/concept/element_associator.hpp	/^operator & (Type object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const Type& operand)
operator &	icl/concept/element_associator.hpp	/^operator & (Type object, const typename Type::key_type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::key_type& operand)
operator &	icl/concept/element_associator.hpp	/^operator & (const typename Type::key_type& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const typename Type::key_type& operand, Type object)
operator &	icl/concept/element_map.hpp	/^operator & (Type object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::element_type& operand)
operator &	icl/concept/element_map.hpp	/^operator & (Type object, const typename Type::key_object_type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::key_object_type& operand)
operator &	icl/concept/element_map.hpp	/^operator & (const typename Type::element_type& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const typename Type::element_type& operand, Type object)
operator &	icl/concept/element_map.hpp	/^operator & (const typename Type::key_object_type& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const typename Type::key_object_type& operand, Type object)
operator &	icl/concept/interval.hpp	/^operator & (Type left, const Type& right)$/;"	f	namespace:boost::icl	signature:(Type left, const Type& right)
operator &	icl/concept/interval_associator.hpp	/^operator & (Type object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const OperandT& operand)
operator &	icl/concept/interval_associator.hpp	/^operator & (Type object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const Type& operand)
operator &	icl/concept/interval_associator.hpp	/^operator & (Type&& object, Type&& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, Type&& operand)
operator &	icl/concept/interval_associator.hpp	/^operator & (Type&& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const OperandT& operand)
operator &	icl/concept/interval_associator.hpp	/^operator & (Type&& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const Type& operand)
operator &	icl/concept/interval_associator.hpp	/^operator & (const OperandT& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type object)
operator &	icl/concept/interval_associator.hpp	/^operator & (const OperandT& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type&& object)
operator &	icl/concept/interval_associator.hpp	/^operator & (const OperandT& operand, const Type& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, const Type& object)
operator &	icl/concept/interval_associator.hpp	/^operator & (const Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const OperandT& operand)
operator &	icl/concept/interval_associator.hpp	/^operator & (const Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const Type& operand)
operator &	icl/concept/interval_associator.hpp	/^operator & (const Type& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const Type& operand, Type&& object)
operator &	icl/concept/interval_bounds.hpp	/^inline interval_bounds operator & (interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
operator &=	icl/concept/element_associator.hpp	/^operator &= (Type& object, const typename Type::key_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::key_type& operand)
operator &=	icl/concept/element_associator.hpp	/^operator &= (Type& object, const typename key_container_type_of<Type>::type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename key_container_type_of<Type>::type& operand)
operator &=	icl/concept/element_map.hpp	/^operator &=(Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const Type& operand)
operator &=	icl/concept/element_map.hpp	/^operator &=(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
operator &=	icl/concept/interval_associator.hpp	/^operator &= (Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
operator ()	icl/concept/map_value.hpp	/^    bool operator() (const Type& value_pair)const $/;"	f	class:boost::icl::content_is_identity_element	access:public	signature:(const Type& value_pair) const
operator ()	icl/detail/exclusive_less_than.hpp	/^    bool operator()(const IntervalT& left, const IntervalT& right)const$/;"	f	struct:boost::icl::exclusive_less_than	access:public	signature:(const IntervalT& left, const IntervalT& right) const
operator ()	icl/detail/interval_morphism.hpp	/^            void operator()(AbsorberType& absorber, EnricherType& enricher)$/;"	f	struct:boost::icl::segmental::identity_absorber	access:public	signature:(AbsorberType& absorber, EnricherType& enricher)
operator ()	icl/detail/interval_morphism.hpp	/^            void operator()(AtomizedType& atomized, const ClusteredType& clustered)$/;"	f	struct:boost::icl::segmental::atomizer	access:public	signature:(AtomizedType& atomized, const ClusteredType& clustered)
operator ()	icl/detail/interval_morphism.hpp	/^            void operator()(ClusteredType& clustered, const AtomizedType& atomized)$/;"	f	struct:boost::icl::segmental::clusterer	access:public	signature:(ClusteredType& clustered, const AtomizedType& atomized)
operator ()	icl/detail/interval_morphism.hpp	/^            void operator()(JointType& joint, SplitType& split)$/;"	f	struct:boost::icl::segmental::joiner	access:public	signature:(JointType& joint, SplitType& split)
operator ()	icl/functors.hpp	/^        Type operator()(const Type& value)$/;"	f	struct:boost::icl::version	access:public	signature:(const Type& value)
operator ()	icl/functors.hpp	/^        argument_type operator()(const argument_type& value)$/;"	f	struct:boost::icl::version	access:public	signature:(const argument_type& value)
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_bit_add	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_bit_and	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_bit_subtract	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_bit_xor	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_caret	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_erase	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_erasure	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_et	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_insert	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_max	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_min	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_minus	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_plus	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_slash	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inplace_star	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inter_section	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type& object, const Type& operand)const$/;"	f	struct:boost::icl::inverse	access:public	signature:(Type& object, const Type& operand) const
operator ()	icl/functors.hpp	/^        void operator()(Type&, const Type&)const{}$/;"	f	struct:boost::icl::inplace_identity	access:public	signature:(Type&, const Type&) const
operator ()	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<double     > >{double      operator()(double      val){return -val;}};$/;"	f	struct:boost::icl::version	access:public	signature:(double val)
operator ()	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<float      > >{float       operator()(float       val){return -val;}};$/;"	f	struct:boost::icl::version	access:public	signature:(float val)
operator ()	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<int        > >{int         operator()(int         val){return -val;}};$/;"	f	struct:boost::icl::version	access:public	signature:(int val)
operator ()	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<long       > >{long        operator()(long        val){return -val;}};$/;"	f	struct:boost::icl::version	access:public	signature:(long val)
operator ()	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<long double> >{long double operator()(long double val){return -val;}};$/;"	f	struct:boost::icl::version	access:public	signature:(long double val)
operator ()	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<long long  > >{long long   operator()(long long   val){return -val;}};$/;"	f	struct:boost::icl::version	access:public	signature:(long long val)
operator ()	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<short      > >{short       operator()(short       val){return -val;}};$/;"	f	struct:boost::icl::version	access:public	signature:(short val)
operator ()	icl/interval_base_map.hpp	/^    codomain_type operator()(const domain_type& key_value)const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const domain_type& key_value) const
operator ()	icl/map.hpp	/^    codomain_type operator()(const domain_type& key)const$/;"	f	class:boost::icl::map	access:public	signature:(const domain_type& key) const
operator ()	icl/predicates/distinct_equal.hpp	/^        bool operator()(const Type& lhs, const Type& rhs)const$/;"	f	struct:boost::icl::distinct_equal	access:public	signature:(const Type& lhs, const Type& rhs) const
operator ()	icl/predicates/element_equal.hpp	/^        bool operator()(const Type& lhs, const Type& rhs)const$/;"	f	struct:boost::icl::element_equal	access:public	signature:(const Type& lhs, const Type& rhs) const
operator ()	icl/predicates/std_equal.hpp	/^        bool operator()(const Type& lhs, const Type& rhs)const$/;"	f	struct:boost::icl::std_equal	access:public	signature:(const Type& lhs, const Type& rhs) const
operator ()	icl/predicates/sub_super_set.hpp	/^        bool operator()(const Type& sub, const Type& super)const$/;"	f	struct:boost::icl::sub_super_set	access:public	signature:(const Type& sub, const Type& super) const
operator ()	icl/predicates/sub_super_set.hpp	/^        bool operator()(const Type& super, const Type& sub)const$/;"	f	struct:boost::icl::super_sub_set	access:public	signature:(const Type& super, const Type& sub) const
operator ()	icl/type_traits/identity_element.hpp	/^        Type operator()()const { return value(); }$/;"	f	struct:boost::icl::identity_element	access:public	signature:() const
operator ()	icl/type_traits/predicate.hpp	/^        bool operator()(const Type& x)const { return (x.*m_pred)(); }$/;"	f	class:boost::icl::member_property	access:public	signature:(const Type& x) const
operator *	icl/iterator.hpp	/^    add_iterator& operator*()    { return *this; }$/;"	f	class:boost::icl::add_iterator	access:public	signature:()
operator *	icl/iterator.hpp	/^    insert_iterator& operator*()    { return *this; }$/;"	f	class:boost::icl::insert_iterator	access:public	signature:()
operator +	icl/concept/element_associator.hpp	/^operator + (Type object, const Type& operand) $/;"	f	namespace:boost::icl	signature:(Type object, const Type& operand)
operator +	icl/concept/element_associator.hpp	/^operator + (Type object, const typename Type::value_type& operand) $/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::value_type& operand)
operator +	icl/concept/element_associator.hpp	/^operator + (const typename Type::value_type& operand, Type object) $/;"	f	namespace:boost::icl	signature:(const typename Type::value_type& operand, Type object)
operator +	icl/concept/interval_associator.hpp	/^operator + (Type object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const OperandT& operand)
operator +	icl/concept/interval_associator.hpp	/^operator + (Type object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const Type& operand)
operator +	icl/concept/interval_associator.hpp	/^operator + (Type&& object, Type&& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, Type&& operand)
operator +	icl/concept/interval_associator.hpp	/^operator + (Type&& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const OperandT& operand)
operator +	icl/concept/interval_associator.hpp	/^operator + (Type&& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const Type& operand)
operator +	icl/concept/interval_associator.hpp	/^operator + (const OperandT& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type object)
operator +	icl/concept/interval_associator.hpp	/^operator + (const OperandT& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type&& object)
operator +	icl/concept/interval_associator.hpp	/^operator + (const OperandT& operand, const Type& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, const Type& object)
operator +	icl/concept/interval_associator.hpp	/^operator + (const Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const OperandT& operand)
operator +	icl/concept/interval_associator.hpp	/^operator + (const Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const Type& operand)
operator +	icl/concept/interval_associator.hpp	/^operator + (const Type& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const Type& operand, Type&& object)
operator ++	icl/gregorian.hpp	/^    inline boost::gregorian::date operator ++(boost::gregorian::date& x)$/;"	f	namespace:boost::icl	signature:(boost::gregorian::date& x)
operator ++	icl/gregorian.hpp	/^    inline boost::gregorian::date_duration operator ++(boost::gregorian::date_duration& x)$/;"	f	namespace:boost::icl	signature:(boost::gregorian::date_duration& x)
operator ++	icl/iterator.hpp	/^    add_iterator& operator++()   { return *this; }$/;"	f	class:boost::icl::add_iterator	access:public	signature:()
operator ++	icl/iterator.hpp	/^    add_iterator& operator++(int){ return *this; }$/;"	f	class:boost::icl::add_iterator	access:public	signature:(int)
operator ++	icl/iterator.hpp	/^    insert_iterator& operator++()   { return *this; }$/;"	f	class:boost::icl::insert_iterator	access:public	signature:()
operator ++	icl/iterator.hpp	/^    insert_iterator& operator++(int){ return *this; }$/;"	f	class:boost::icl::insert_iterator	access:public	signature:(int)
operator ++	icl/ptime.hpp	/^    inline boost::posix_time::ptime operator ++(boost::posix_time::ptime& x)$/;"	f	namespace:boost::icl	signature:(boost::posix_time::ptime& x)
operator ++	icl/ptime.hpp	/^    inline boost::posix_time::time_duration operator ++(boost::posix_time::time_duration& x)$/;"	f	namespace:boost::icl	signature:(boost::posix_time::time_duration& x)
operator +=	icl/concept/element_associator.hpp	/^operator += (Type& object, const Type& operand) $/;"	f	namespace:boost::icl	signature:(Type& object, const Type& operand)
operator +=	icl/concept/element_associator.hpp	/^operator += (Type& object, const typename Type::value_type& operand) $/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& operand)
operator +=	icl/concept/interval_associator.hpp	/^operator += (Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
operator -	icl/concept/element_associator.hpp	/^operator - (Type object, const Type& subtrahend) $/;"	f	namespace:boost::icl	signature:(Type object, const Type& subtrahend)
operator -	icl/concept/element_associator.hpp	/^operator - (Type object, const typename Type::value_type& operand) $/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::value_type& operand)
operator -	icl/concept/element_map.hpp	/^operator - (Type object, const typename Type::set_type& subtrahend) $/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::set_type& subtrahend)
operator -	icl/concept/interval_associator.hpp	/^operator - (Type object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const OperandT& operand)
operator -	icl/concept/interval_associator.hpp	/^operator - (Type&& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const OperandT& operand)
operator -	icl/concept/interval_associator.hpp	/^operator - (const Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const OperandT& operand)
operator --	icl/gregorian.hpp	/^    inline boost::gregorian::date operator --(boost::gregorian::date& x)$/;"	f	namespace:boost::icl	signature:(boost::gregorian::date& x)
operator --	icl/gregorian.hpp	/^    inline boost::gregorian::date_duration operator --(boost::gregorian::date_duration& x)$/;"	f	namespace:boost::icl	signature:(boost::gregorian::date_duration& x)
operator --	icl/ptime.hpp	/^    inline boost::posix_time::ptime operator --(boost::posix_time::ptime& x)$/;"	f	namespace:boost::icl	signature:(boost::posix_time::ptime& x)
operator --	icl/ptime.hpp	/^    inline boost::posix_time::time_duration operator --(boost::posix_time::time_duration& x)$/;"	f	namespace:boost::icl	signature:(boost::posix_time::time_duration& x)
operator -=	icl/concept/element_associator.hpp	/^operator -= (Type& object, const Type& subtrahend) $/;"	f	namespace:boost::icl	signature:(Type& object, const Type& subtrahend)
operator -=	icl/concept/element_associator.hpp	/^operator -= (Type& object, const typename Type::value_type& operand) $/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& operand)
operator -=	icl/concept/element_map.hpp	/^operator -= (Type& object, const typename Type::set_type& operand) $/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::set_type& operand)
operator -=	icl/concept/interval_associator.hpp	/^operator -= (Type& object, const IntervalSetT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const IntervalSetT& operand)
operator -=	icl/concept/interval_associator.hpp	/^operator -= (Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
operator -=	icl/concept/interval_associator.hpp	/^operator -=(Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
operator <	icl/concept/element_associator.hpp	/^operator < (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
operator <	icl/concept/interval.hpp	/^operator < (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
operator <	icl/concept/interval_associator.hpp	/^operator < (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
operator <	icl/detail/mapped_reference.hpp	/^    operator < (const Comparand& right)const$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const Comparand& right) const
operator <	icl/detail/mapped_reference.hpp	/^operator < (                         const StdPairT& left, $/;"	f	namespace:boost::icl	signature:( const StdPairT& left, const mapped_reference<FirstT, SecondT>& right)
operator <<	icl/concept/element_map.hpp	/^operator << (std::basic_ostream<CharType, CharTraits>& stream, const Type& object)$/;"	f	namespace:boost::icl	signature:(std::basic_ostream<CharType, CharTraits>& stream, const Type& object)
operator <<	icl/concept/element_set.hpp	/^operator << (std::basic_ostream<CharType, CharTraits>& stream, const Type& object)$/;"	f	namespace:boost::icl	signature:(std::basic_ostream<CharType, CharTraits>& stream, const Type& object)
operator <<	icl/concept/interval.hpp	/^operator << (std::basic_ostream<CharType, CharTraits> &stream, Type const& object)$/;"	f	namespace:boost::icl	signature:(std::basic_ostream<CharType, CharTraits> &stream, Type const& object)
operator <<	icl/concept/interval_bounds.hpp	/^inline interval_bounds operator << (interval_bounds bounds, unsigned int shift)$/;"	f	namespace:boost::icl	signature:(interval_bounds bounds, unsigned int shift)
operator <<	icl/concept/interval_bounds.hpp	/^std::basic_ostream<CharType, CharTraits>& operator <<$/;"	f	namespace:boost::icl	signature:(std::basic_ostream<CharType, CharTraits> &stream, interval_bounds const& object)
operator <<	icl/concept/interval_map.hpp	/^operator << (std::basic_ostream<CharType, CharTraits>& stream, const Type& object)$/;"	f	namespace:boost::icl	signature:(std::basic_ostream<CharType, CharTraits>& stream, const Type& object)
operator <<	icl/concept/interval_set.hpp	/^operator << (std::basic_ostream<CharType, CharTraits>& stream, const Type& object)$/;"	f	namespace:boost::icl	signature:(std::basic_ostream<CharType, CharTraits>& stream, const Type& object)
operator <=	icl/concept/comparable.hpp	/^operator <= (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
operator <=	icl/detail/mapped_reference.hpp	/^    operator <= (const Comparand& right)const$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const Comparand& right) const
operator <=	icl/detail/mapped_reference.hpp	/^operator <= (                         const StdPairT& left, $/;"	f	namespace:boost::icl	signature:( const StdPairT& left, const mapped_reference<FirstT, SecondT>& right)
operator =	icl/detail/interval_subset_comparer.hpp	/^    subset_comparer& operator = (const subset_comparer&);$/;"	p	class:boost::icl::Interval_Set::subset_comparer	access:private	signature:(const subset_comparer&)
operator =	icl/detail/mapped_reference.hpp	/^    mapped_reference& operator = (const mapped_reference&);$/;"	p	class:boost::icl::mapped_reference	access:private	signature:(const mapped_reference&)
operator =	icl/detail/subset_comparer.hpp	/^    subset_comparer& operator = (const subset_comparer&);$/;"	p	class:boost::icl::Set::subset_comparer	access:private	signature:(const subset_comparer&)
operator =	icl/interval_base_map.hpp	/^    interval_base_map& operator = (const interval_base_map& src) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const interval_base_map& src)
operator =	icl/interval_base_map.hpp	/^    interval_base_map& operator = (interval_base_map&& src) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(interval_base_map&& src)
operator =	icl/interval_base_set.hpp	/^    interval_base_set& operator = (const interval_base_set& src) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const interval_base_set& src)
operator =	icl/interval_base_set.hpp	/^    interval_base_set& operator = (interval_base_set&& src) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(interval_base_set&& src)
operator =	icl/interval_map.hpp	/^    interval_map& operator = (const interval_map& src)$/;"	f	class:boost::icl::interval_map	access:public	signature:(const interval_map& src)
operator =	icl/interval_map.hpp	/^    interval_map& operator = (interval_map&& src)$/;"	f	class:boost::icl::interval_map	access:public	signature:(interval_map&& src)
operator =	icl/interval_map.hpp	/^    interval_map& operator =$/;"	f	class:boost::icl::interval_map	access:public	signature:(const interval_base_map<SubType,DomainT,CodomainT, Traits,Compare,Combine,Section,Interval,Alloc>& src)
operator =	icl/interval_set.hpp	/^    interval_set& operator = (const interval_set& src)$/;"	f	class:boost::icl::interval_set	access:public	signature:(const interval_set& src)
operator =	icl/interval_set.hpp	/^    interval_set& operator = (interval_set&& src)$/;"	f	class:boost::icl::interval_set	access:public	signature:(interval_set&& src)
operator =	icl/interval_set.hpp	/^    interval_set& operator =$/;"	f	class:boost::icl::interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
operator =	icl/iterator.hpp	/^    add_iterator& operator=(typename ContainerT::const_reference value)$/;"	f	class:boost::icl::add_iterator	access:public	signature:(typename ContainerT::const_reference value)
operator =	icl/iterator.hpp	/^    insert_iterator& operator=(typename ContainerT::const_reference value)$/;"	f	class:boost::icl::insert_iterator	access:public	signature:(typename ContainerT::const_reference value)
operator =	icl/map.hpp	/^    map& operator = (const map& src) $/;"	f	class:boost::icl::map	access:public	signature:(const map& src)
operator =	icl/map.hpp	/^    map& operator = (map&& src) $/;"	f	class:boost::icl::map	access:public	signature:(map&& src)
operator =	icl/separate_interval_set.hpp	/^    separate_interval_set& operator = (const separate_interval_set& src)$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(const separate_interval_set& src)
operator =	icl/separate_interval_set.hpp	/^    separate_interval_set& operator = (separate_interval_set&& src)$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(separate_interval_set&& src)
operator =	icl/separate_interval_set.hpp	/^    separate_interval_set& operator =$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
operator =	icl/split_interval_map.hpp	/^    split_interval_map& operator = (const split_interval_map& src)$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(const split_interval_map& src)
operator =	icl/split_interval_map.hpp	/^    split_interval_map& operator = (split_interval_map&& src)$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(split_interval_map&& src)
operator =	icl/split_interval_map.hpp	/^    split_interval_map& operator =$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(const interval_base_map<SubType,DomainT,CodomainT, Traits,Compare,Combine,Section,Interval,Alloc>& src)
operator =	icl/split_interval_set.hpp	/^    split_interval_set& operator = (const split_interval_set& src)$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(const split_interval_set& src)
operator =	icl/split_interval_set.hpp	/^    split_interval_set& operator = (split_interval_set&& src)$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(split_interval_set&& src)
operator =	icl/split_interval_set.hpp	/^    split_interval_set& operator =$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
operator ==	icl/concept/element_associator.hpp	/^operator == (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
operator ==	icl/concept/interval.hpp	/^operator == (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
operator ==	icl/concept/interval_associator.hpp	/^operator == (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
operator ==	icl/concept/interval_bounds.hpp	/^inline bool operator == (const interval_bounds x1, const interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(const interval_bounds x1, const interval_bounds x2)
operator ==	icl/detail/mapped_reference.hpp	/^    operator == (const Comparand& right)const$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const Comparand& right) const
operator ==	icl/detail/mapped_reference.hpp	/^operator == (                         const StdPairT& left, $/;"	f	namespace:boost::icl	signature:( const StdPairT& left, const mapped_reference<FirstT, SecondT>& right)
operator >	icl/concept/comparable.hpp	/^operator > (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
operator >	icl/concept/interval.hpp	/^operator > (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
operator >	icl/detail/mapped_reference.hpp	/^    operator > (const Comparand& right)const$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const Comparand& right) const
operator >	icl/detail/mapped_reference.hpp	/^operator > (                         const StdPairT& left, $/;"	f	namespace:boost::icl	signature:( const StdPairT& left, const mapped_reference<FirstT, SecondT>& right)
operator >=	icl/concept/comparable.hpp	/^operator >= (const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
operator >=	icl/detail/mapped_reference.hpp	/^    operator >= (const Comparand& right)const$/;"	f	class:boost::icl::mapped_reference	access:public	signature:(const Comparand& right) const
operator >=	icl/detail/mapped_reference.hpp	/^operator >= (                         const StdPairT& left, $/;"	f	namespace:boost::icl	signature:( const StdPairT& left, const mapped_reference<FirstT, SecondT>& right)
operator >>	icl/concept/interval_bounds.hpp	/^inline interval_bounds operator >> (interval_bounds bounds, unsigned int shift)$/;"	f	namespace:boost::icl	signature:(interval_bounds bounds, unsigned int shift)
operator ^	icl/concept/element_associator.hpp	/^operator ^ (Type object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const Type& operand)
operator ^	icl/concept/element_associator.hpp	/^operator ^ (Type object, const typename Type::value_type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::value_type& operand)
operator ^	icl/concept/element_associator.hpp	/^operator ^ (const typename Type::value_type& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const typename Type::value_type& operand, Type object)
operator ^	icl/concept/interval_associator.hpp	/^operator ^ (Type object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const OperandT& operand)
operator ^	icl/concept/interval_associator.hpp	/^operator ^ (Type&& object, Type&& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, Type&& operand)
operator ^	icl/concept/interval_associator.hpp	/^operator ^ (Type&& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const OperandT& operand)
operator ^	icl/concept/interval_associator.hpp	/^operator ^ (Type&& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const Type& operand)
operator ^	icl/concept/interval_associator.hpp	/^operator ^ (const OperandT& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type object)
operator ^	icl/concept/interval_associator.hpp	/^operator ^ (const OperandT& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type&& object)
operator ^	icl/concept/interval_associator.hpp	/^operator ^ (const OperandT& operand, const Type& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, const Type& object)
operator ^	icl/concept/interval_associator.hpp	/^operator ^ (const Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const OperandT& operand)
operator ^	icl/concept/interval_associator.hpp	/^operator ^ (const Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const Type& operand)
operator ^	icl/concept/interval_associator.hpp	/^operator ^ (const Type& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const Type& operand, Type&& object)
operator ^	icl/concept/interval_associator.hpp	/^operator ^ (typename Type::overloadable_type object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(typename Type::overloadable_type object, const Type& operand)
operator ^=	icl/concept/element_map.hpp	/^operator ^= (Type& object, const CoType&)$/;"	f	namespace:boost::icl	signature:(Type& object, const CoType&)
operator ^=	icl/concept/element_map.hpp	/^operator ^= (Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const Type& operand)
operator ^=	icl/concept/element_map.hpp	/^operator ^= (Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
operator ^=	icl/concept/element_set.hpp	/^operator ^= (Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const Type& operand)
operator ^=	icl/concept/element_set.hpp	/^operator ^= (Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
operator ^=	icl/concept/interval_associator.hpp	/^operator ^= (Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
operator std::pair<FstT,SndT>	icl/detail/mapped_reference.hpp	/^    operator std::pair<FstT,SndT>(){ return std::pair<FstT,SndT>(first, second); }$/;"	f	class:boost::icl::mapped_reference	access:public	signature:()
operator |	icl/concept/element_associator.hpp	/^operator | (Type object, const Type& operand) $/;"	f	namespace:boost::icl	signature:(Type object, const Type& operand)
operator |	icl/concept/element_associator.hpp	/^operator | (Type object, const typename Type::value_type& operand) $/;"	f	namespace:boost::icl	signature:(Type object, const typename Type::value_type& operand)
operator |	icl/concept/element_associator.hpp	/^operator | (const typename Type::value_type& operand, Type object) $/;"	f	namespace:boost::icl	signature:(const typename Type::value_type& operand, Type object)
operator |	icl/concept/interval_associator.hpp	/^operator | (Type object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const OperandT& operand)
operator |	icl/concept/interval_associator.hpp	/^operator | (Type object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type object, const Type& operand)
operator |	icl/concept/interval_associator.hpp	/^operator | (Type&& object, Type&& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, Type&& operand)
operator |	icl/concept/interval_associator.hpp	/^operator | (Type&& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const OperandT& operand)
operator |	icl/concept/interval_associator.hpp	/^operator | (Type&& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(Type&& object, const Type& operand)
operator |	icl/concept/interval_associator.hpp	/^operator | (const OperandT& operand, Type object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type object)
operator |	icl/concept/interval_associator.hpp	/^operator | (const OperandT& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, Type&& object)
operator |	icl/concept/interval_associator.hpp	/^operator | (const OperandT& operand, const Type& object)$/;"	f	namespace:boost::icl	signature:(const OperandT& operand, const Type& object)
operator |	icl/concept/interval_associator.hpp	/^operator | (const Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const OperandT& operand)
operator |	icl/concept/interval_associator.hpp	/^operator | (const Type& object, const Type& operand)$/;"	f	namespace:boost::icl	signature:(const Type& object, const Type& operand)
operator |	icl/concept/interval_associator.hpp	/^operator | (const Type& operand, Type&& object)$/;"	f	namespace:boost::icl	signature:(const Type& operand, Type&& object)
operator |	icl/concept/interval_bounds.hpp	/^inline interval_bounds operator | (interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
operator |=	icl/concept/element_associator.hpp	/^operator |= (Type& object, const Type& operand) $/;"	f	namespace:boost::icl	signature:(Type& object, const Type& operand)
operator |=	icl/concept/element_associator.hpp	/^operator |= (Type& object, const typename Type::value_type& operand) $/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& operand)
operator |=	icl/concept/interval_associator.hpp	/^operator |= (Type& object, const OperandT& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const OperandT& operand)
operator ~	icl/concept/interval_bounds.hpp	/^inline interval_bounds operator ~ (interval_bounds x1)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1)
outer_bounds	icl/concept/interval_bounds.hpp	/^inline interval_bounds outer_bounds(interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
outer_bounds	icl/concept/interval_bounds.hpp	/^outer_bounds(const IntervalT& x1, const IntervalT& x2)$/;"	f	namespace:boost::icl	signature:(const IntervalT& x1, const IntervalT& x2)
overloadable_type	icl/interval_base_map.hpp	/^    typedef type overloadable_type;$/;"	t	class:boost::icl::interval_base_map	access:public
overloadable_type	icl/interval_base_set.hpp	/^    typedef type overloadable_type;$/;"	t	class:boost::icl::interval_base_set	access:public
overloadable_type	icl/interval_map.hpp	/^    typedef type overloadable_type;$/;"	t	class:boost::icl::interval_map	access:public
overloadable_type	icl/interval_set.hpp	/^    typedef type overloadable_type;$/;"	t	class:boost::icl::interval_set	access:public
overloadable_type	icl/separate_interval_set.hpp	/^    typedef type overloadable_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
overloadable_type	icl/split_interval_map.hpp	/^    typedef type overloadable_type;$/;"	t	class:boost::icl::split_interval_map	access:public
overloadable_type	icl/split_interval_set.hpp	/^    typedef type overloadable_type;$/;"	t	class:boost::icl::split_interval_set	access:public
partial_absorber	icl/map.hpp	/^struct partial_absorber$/;"	s	namespace:boost::icl
partial_add_intersection	icl/interval_base_map.hpp	/^    void partial_add_intersection(SubType& section, const element_type& operand)const$/;"	f	class:boost::icl::interval_base_map	access:private	signature:(SubType& section, const element_type& operand) const
partial_add_intersection	icl/interval_base_map.hpp	/^    void partial_add_intersection(SubType& section, const segment_type& operand)const$/;"	f	class:boost::icl::interval_base_map	access:private	signature:(SubType& section, const segment_type& operand) const
partial_add_intersection	icl/map.hpp	/^    void partial_add_intersection(type& section, const element_type& operand)const$/;"	f	class:boost::icl::map	access:private	signature:(type& section, const element_type& operand) const
partial_enricher	icl/map.hpp	/^struct partial_enricher$/;"	s	namespace:boost::icl
pointer	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::pointer         pointer;$/;"	t	class:boost::icl::interval_base_map	access:public
pointer	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::pointer         pointer;$/;"	t	class:boost::icl::interval_base_set	access:public
pointer	icl/map.hpp	/^    typedef typename base_type::pointer                 pointer;$/;"	t	class:boost::icl::map	access:public
pred	icl/type_traits/succ_pred.hpp	/^inline static DecrementableT pred(DecrementableT x) { return --x; }$/;"	f	namespace:boost::icl	signature:(DecrementableT x)
predecessor	icl/type_traits/succ_pred.hpp	/^    struct predecessor<DomainT, false>$/;"	s	namespace:boost::icl::detail
predecessor	icl/type_traits/succ_pred.hpp	/^    struct predecessor<DomainT, true>$/;"	s	namespace:boost::icl::detail
predecessor	icl/type_traits/succ_pred.hpp	/^struct predecessor$/;"	s	namespace:boost::icl
proceed	icl/detail/element_comparer.hpp	/^    int proceed(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::element_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
proceed	icl/detail/interval_subset_comparer.hpp	/^    int proceed(LeftIterT& left, RightIterT& right)$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(LeftIterT& left, RightIterT& right)
property	icl/type_traits/predicate.hpp	/^    class property : public std::unary_function<Type,bool>{};$/;"	c	namespace:boost::icl	inherits:std::unary_function
proversion	icl/functors.hpp	/^        static argument_type proversion(const argument_type& value)$/;"	f	struct:boost::icl::conversion	access:public	signature:(const argument_type& value)
rbegin	icl/interval_base_map.hpp	/^    const_reverse_iterator rbegin()const { return _map.rbegin(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:() const
rbegin	icl/interval_base_map.hpp	/^    reverse_iterator rbegin() { return _map.rbegin(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:()
rbegin	icl/interval_base_set.hpp	/^    const_reverse_iterator rbegin()const { return _set.rbegin(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:() const
rbegin	icl/interval_base_set.hpp	/^    reverse_iterator rbegin() { return _set.rbegin(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:()
reference	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::reference       reference;$/;"	t	class:boost::icl::interval_base_map	access:public
reference	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::reference       reference;$/;"	t	class:boost::icl::interval_base_set	access:public
reference	icl/map.hpp	/^    typedef typename base_type::reference               reference;$/;"	t	class:boost::icl::map	access:public
relation	icl/type_traits/predicate.hpp	/^    class relation : public std::binary_function<LeftT,RightT,bool>{};$/;"	c	namespace:boost::icl	inherits:std::binary_function
rend	icl/interval_base_map.hpp	/^    const_reverse_iterator rend()const   { return _map.rend(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:() const
rend	icl/interval_base_map.hpp	/^    reverse_iterator rend()   { return _map.rend(); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:()
rend	icl/interval_base_set.hpp	/^    const_reverse_iterator rend()const   { return _set.rend(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:() const
rend	icl/interval_base_set.hpp	/^    reverse_iterator rend()   { return _set.rend(); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:()
rep_type_of	icl/type_traits/rep_type_of.hpp	/^    struct rep_type_of$/;"	s	namespace:boost::icl
represents	icl/type_traits/rep_type_of.hpp	/^    struct represents \/\/ Rep represents Type;  Type is_wrapper_of Rep$/;"	s	namespace:boost::icl	inherits:mpl::bool_
restrict_result	icl/detail/interval_subset_comparer.hpp	/^    int restrict_result(int state) { return _result &= state; }$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(int state)
restrict_result	icl/detail/subset_comparer.hpp	/^    int restrict_result(int state) { return _result &= state; }$/;"	f	class:boost::icl::Set::subset_comparer	access:public	signature:(int state)
result	icl/detail/element_comparer.hpp	/^    int result()const{ return _result; }$/;"	f	class:boost::icl::Interval_Set::element_comparer	access:public	signature:() const
result	icl/detail/interval_subset_comparer.hpp	/^    int result()const{ return _result; }$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:() const
result	icl/detail/subset_comparer.hpp	/^    int result()const{ return _result; }$/;"	f	class:boost::icl::Set::subset_comparer	access:public	signature:() const
reverse_bounded_lower	icl/concept/interval.hpp	/^reverse_bounded_lower(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
reverse_bounded_upper	icl/concept/interval.hpp	/^reverse_bounded_upper(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
reverse_iterator	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::reverse_iterator reverse_iterator;$/;"	t	class:boost::icl::interval_base_map	access:public
reverse_iterator	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::reverse_iterator reverse_iterator;$/;"	t	class:boost::icl::interval_base_set	access:public
reverse_iterator	icl/map.hpp	/^    typedef typename base_type::reverse_iterator        reverse_iterator;$/;"	t	class:boost::icl::map	access:public
reverse_left	icl/interval_bounds.hpp	/^    interval_bounds reverse_left ()const { return interval_bounds((~_bits>>1) & _right); }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:() const
reverse_right	icl/interval_bounds.hpp	/^    interval_bounds reverse_right()const { return interval_bounds((~_bits<<1) & _left ); }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:() const
right	icl/concept/interval_bounds.hpp	/^inline interval_bounds right(interval_bounds x1)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1)
right	icl/interval_bounds.hpp	/^    interval_bounds right()const { return interval_bounds(_bits & _right); }$/;"	f	class:boost::icl::interval_bounds	access:public	signature:() const
right_bounds	icl/concept/interval_bounds.hpp	/^inline interval_bounds right_bounds(interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
right_bounds	icl/concept/interval_bounds.hpp	/^right_bounds(const IntervalT& x1, const IntervalT& x2)$/;"	f	namespace:boost::icl	signature:(const IntervalT& x1, const IntervalT& x2)
right_bracket	icl/concept/interval.hpp	/^right_bracket(const Type& object) $/;"	f	namespace:boost::icl	signature:(const Type& object)
right_bracket	icl/concept/interval.hpp	/^right_bracket(const Type&) { return ")"; }$/;"	f	namespace:boost::icl	signature:(const Type&)
right_bracket	icl/concept/interval.hpp	/^right_bracket(const Type&) { return "]"; }$/;"	f	namespace:boost::icl	signature:(const Type&)
right_bracket	icl/concept/interval_bounds.hpp	/^inline std::string right_bracket(interval_bounds bounds)$/;"	f	namespace:boost::icl	signature:(interval_bounds bounds)
right_open	icl/continuous_interval.hpp	/^    static continuous_interval right_open(const DomainT& lo, const DomainT& up){ return continuous_interval(lo, up, interval_bounds::right_open());}$/;"	f	class:boost::icl::continuous_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
right_open	icl/discrete_interval.hpp	/^    static discrete_interval right_open(const DomainT& lo, const DomainT& up){ return discrete_interval(lo, up, interval_bounds::right_open());}$/;"	f	class:boost::icl::discrete_interval	access:public	signature:(const DomainT& lo, const DomainT& up)
right_open	icl/interval.hpp	/^        static inline interval_type right_open(const DomainT& low, const DomainT& up)$/;"	f	struct:boost::icl::interval	access:public	signature:(const DomainT& low, const DomainT& up)
right_open	icl/interval_bounds.hpp	/^    static interval_bounds right_open(){ return interval_bounds(_right_open);}$/;"	f	class:boost::icl::interval_bounds	access:public	signature:()
right_open_interval	icl/right_open_interval.hpp	/^    explicit right_open_interval(const DomainT& val)$/;"	f	class:boost::icl::right_open_interval	access:public	signature:(const DomainT& val)
right_open_interval	icl/right_open_interval.hpp	/^    right_open_interval() $/;"	f	class:boost::icl::right_open_interval	access:public	signature:()
right_open_interval	icl/right_open_interval.hpp	/^    right_open_interval(const DomainT& low, const DomainT& up) :$/;"	f	class:boost::icl::right_open_interval	access:public	signature:(const DomainT& low, const DomainT& up)
right_open_interval	icl/right_open_interval.hpp	/^class right_open_interval$/;"	c	namespace:boost::icl
right_subtract	icl/concept/interval.hpp	/^right_subtract(Type left, const Type& right_minuend)$/;"	f	namespace:boost::icl	signature:(Type left, const Type& right_minuend)
right_subtract_bounds	icl/concept/interval_bounds.hpp	/^inline interval_bounds right_subtract_bounds(interval_bounds x1, interval_bounds x2)$/;"	f	namespace:boost::icl	signature:(interval_bounds x1, interval_bounds x2)
right_subtract_bounds	icl/concept/interval_bounds.hpp	/^right_subtract_bounds(const IntervalT& x1, const IntervalT& x2)$/;"	f	namespace:boost::icl	signature:(const IntervalT& x1, const IntervalT& x2)
second	icl/detail/mapped_reference.hpp	/^    second_reference_type second;$/;"	m	class:boost::icl::mapped_reference	access:public
second_reference_type	icl/detail/mapped_reference.hpp	/^                 const second_type&>::type second_reference_type;$/;"	t	class:boost::icl::mapped_reference	access:public
second_type	icl/detail/mapped_reference.hpp	/^    typedef SecondT second_type; $/;"	t	class:boost::icl::mapped_reference	access:public
segment_adapter	icl/detail/element_iterator.hpp	/^struct segment_adapter $/;"	s	namespace:boost::icl
segment_adapter	icl/detail/element_iterator.hpp	/^struct segment_adapter<SegmentIteratorT, ICL_INTERVAL_TYPE(Interval,DomainT,Compare) >$/;"	s	namespace:boost::icl
segment_adapter	icl/detail/element_iterator.hpp	/^struct segment_adapter<SegmentIteratorT, std::pair<ICL_INTERVAL_TYPE(Interval,DomainT,Compare)const, CodomainT> >$/;"	s	namespace:boost::icl
segment_compare	icl/interval_base_map.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,segment_type) segment_compare;$/;"	t	class:boost::icl::interval_base_map	access:public
segment_compare	icl/interval_base_set.hpp	/^    typedef ICL_COMPARE_DOMAIN(Compare,segment_type) segment_compare;$/;"	t	class:boost::icl::interval_base_set	access:public
segment_iterator	icl/detail/element_iterator.hpp	/^    typedef SegmentIteratorT                                segment_iterator;$/;"	t	class:boost::icl::element_iterator	access:public
segment_type	icl/detail/element_iterator.hpp	/^        typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) segment_type;$/;"	t	struct:boost::icl::elemental	access:public
segment_type	icl/detail/element_iterator.hpp	/^        typedef std::pair<ICL_INTERVAL_TYPE(Interval,DomainT,Compare), CodomainT> segment_type;$/;"	t	struct:boost::icl::elemental	access:public
segment_type	icl/detail/element_iterator.hpp	/^    typedef ICL_INTERVAL_TYPE(Interval,DomainT,Compare) segment_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
segment_type	icl/detail/element_iterator.hpp	/^    typedef typename SegmentIteratorT::value_type           segment_type;$/;"	t	class:boost::icl::element_iterator	access:public
segment_type	icl/interval_base_map.hpp	/^        typedef typename Type::segment_type   segment_type;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
segment_type	icl/interval_base_map.hpp	/^        typedef typename Type::segment_type  segment_type;$/;"	t	struct:boost::icl::interval_base_map::on_codomain_model	access:public
segment_type	icl/interval_base_map.hpp	/^        typedef typename Type::segment_type  segment_type;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
segment_type	icl/interval_base_map.hpp	/^        typedef typename Type::segment_type segment_type;$/;"	t	struct:boost::icl::interval_base_map::on_invertible	access:public
segment_type	icl/interval_base_map.hpp	/^    typedef std::pair<interval_type,CodomainT> segment_type;$/;"	t	class:boost::icl::interval_base_map	access:public
segment_type	icl/interval_base_set.hpp	/^    typedef interval_type   segment_type;$/;"	t	class:boost::icl::interval_base_set	access:public
segment_type	icl/interval_map.hpp	/^    typedef typename base_type::segment_type  segment_type;$/;"	t	class:boost::icl::interval_map	access:public
segment_type	icl/interval_set.hpp	/^    typedef interval_type   segment_type;$/;"	t	class:boost::icl::interval_set	access:public
segment_type	icl/separate_interval_set.hpp	/^    typedef interval_type   segment_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
segment_type	icl/split_interval_map.hpp	/^    typedef typename base_type::segment_type segment_type;$/;"	t	class:boost::icl::split_interval_map	access:public
segment_type	icl/split_interval_set.hpp	/^    typedef interval_type   segment_type;$/;"	t	class:boost::icl::split_interval_set	access:public
segment_type_of	icl/type_traits/segment_type_of.hpp	/^    struct segment_type_of$/;"	s	namespace:boost::icl
segmental	icl/concept/joinable.hpp	/^namespace segmental$/;"	n	namespace:boost::icl
segmental	icl/detail/interval_morphism.hpp	/^    namespace segmental$/;"	n	namespace:boost::icl
segmental	icl/detail/interval_set_algo.hpp	/^namespace segmental$/;"	n	namespace:boost::icl
segmentational_fineness	icl/type_traits/is_combinable.hpp	/^template<class Type>struct segmentational_fineness$/;"	s	namespace:boost::icl
separate_interval_set	icl/separate_interval_set.hpp	/^    explicit separate_interval_set(const domain_type& elem): base_type() { this->add(elem); }$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(const domain_type& elem)
separate_interval_set	icl/separate_interval_set.hpp	/^    explicit separate_interval_set(const interval_type& itv): base_type() { this->add(itv); }$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(const interval_type& itv)
separate_interval_set	icl/separate_interval_set.hpp	/^    separate_interval_set$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
separate_interval_set	icl/separate_interval_set.hpp	/^    separate_interval_set(): base_type() {}$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:()
separate_interval_set	icl/separate_interval_set.hpp	/^    separate_interval_set(const separate_interval_set& src): base_type(src) {}$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(const separate_interval_set& src)
separate_interval_set	icl/separate_interval_set.hpp	/^    separate_interval_set(separate_interval_set&& src)$/;"	f	class:boost::icl::separate_interval_set	access:public	signature:(separate_interval_set&& src)
separate_interval_set	icl/separate_interval_set.hpp	/^class separate_interval_set: $/;"	c	namespace:boost::icl	inherits:interval_base_set
set	icl/interval_base_map.hpp	/^    SubType& set(const element_type& key_value_pair) $/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const element_type& key_value_pair)
set	icl/interval_base_map.hpp	/^    SubType& set(const segment_type& interval_value_pair)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const segment_type& interval_value_pair)
set	icl/map.hpp	/^    map& set(const element_type& key_value_pair)$/;"	f	class:boost::icl::map	access:public	signature:(const element_type& key_value_pair)
set_at	icl/concept/element_map.hpp	/^set_at(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
set_at	icl/concept/interval_map.hpp	/^set_at(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
set_at	icl/concept/interval_map.hpp	/^set_at(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
set_type	icl/interval_base_map.hpp	/^        typedef typename Type::set_type       set_type;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
set_type	icl/interval_map.hpp	/^    typedef interval_set_type set_type;$/;"	t	class:boost::icl::interval_map	access:public
set_type	icl/map.hpp	/^    typedef typename ICL_IMPL_SPACE::set<DomainT, domain_compare, Alloc<DomainT> > set_type;$/;"	t	class:boost::icl::map	access:public
set_type	icl/split_interval_map.hpp	/^    typedef interval_set_type set_type;$/;"	t	class:boost::icl::split_interval_map	access:public
settic_codomain_compare	icl/detail/interval_subset_comparer.hpp	/^struct settic_codomain_compare$/;"	s	namespace:boost::icl::Interval_Set
settic_codomain_compare	icl/detail/subset_comparer.hpp	/^struct settic_codomain_compare$/;"	s	namespace:boost::icl::Set
shift_lower	icl/concept/interval_bounds.hpp	/^shift_lower(interval_bounds decl, interval_bounds repr, const Type& low)$/;"	f	namespace:boost::icl	signature:(interval_bounds decl, interval_bounds repr, const Type& low)
shift_upper	icl/concept/interval_bounds.hpp	/^shift_upper(interval_bounds decl, interval_bounds repr, const Type& up)$/;"	f	namespace:boost::icl	signature:(interval_bounds decl, interval_bounds repr, const Type& up)
singleton	icl/concept/interval.hpp	/^singleton(const typename interval_traits<Type>::domain_type& value)$/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& value)
size	icl/concept/element_associator.hpp	/^size(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
size	icl/concept/interval.hpp	/^size(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
size	icl/concept/interval_associator.hpp	/^size(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
size	icl/interval_base_map.hpp	/^    size_type size()const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:() const
size	icl/interval_base_set.hpp	/^    size_type size()const$/;"	f	class:boost::icl::interval_base_set	access:public	signature:() const
size	icl/type_traits/size.hpp	/^    template <class Type> struct size{ typedef std::size_t type; };$/;"	s	namespace:boost::icl
size_type	icl/interval_base_map.hpp	/^    typedef typename size_type_of<domain_type>::type size_type;$/;"	t	class:boost::icl::interval_base_map	access:public
size_type	icl/interval_base_set.hpp	/^    typedef typename size_type_of<domain_type>::type size_type;$/;"	t	class:boost::icl::interval_base_set	access:public
size_type	icl/interval_map.hpp	/^    typedef typename base_type::size_type     size_type;$/;"	t	class:boost::icl::interval_map	access:public
size_type	icl/map.hpp	/^    typedef typename base_type::size_type               size_type;$/;"	t	class:boost::icl::map	access:public
size_type	icl/type_traits/infinity.hpp	/^    typedef typename Type::size_type size_type;$/;"	t	struct:boost::icl::get_infinity	access:public
size_type_of	icl/gregorian.hpp	/^    struct size_type_of<boost::gregorian::date> $/;"	s	namespace:boost::icl
size_type_of	icl/gregorian.hpp	/^    struct size_type_of<boost::gregorian::date_duration> $/;"	s	namespace:boost::icl
size_type_of	icl/interval_traits.hpp	/^struct size_type_of<interval_traits<Type> >$/;"	s	namespace:boost::icl
size_type_of	icl/ptime.hpp	/^    struct size_type_of<boost::posix_time::ptime> $/;"	s	namespace:boost::icl
size_type_of	icl/ptime.hpp	/^    struct size_type_of<boost::posix_time::time_duration> $/;"	s	namespace:boost::icl
size_type_of	icl/type_traits/size_type_of.hpp	/^    struct size_type_of$/;"	s	namespace:boost::icl
span	icl/concept/interval.hpp	/^span(const typename interval_traits<Type>::domain_type& left,$/;"	f	namespace:boost::icl	signature:(const typename interval_traits<Type>::domain_type& left, const typename interval_traits<Type>::domain_type& right)
split_interval_map	icl/split_interval_map.hpp	/^    explicit split_interval_map(const domain_mapping_type& base_pair): base_type()$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(const domain_mapping_type& base_pair)
split_interval_map	icl/split_interval_map.hpp	/^    explicit split_interval_map(const value_type& value_pair): base_type()$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(const value_type& value_pair)
split_interval_map	icl/split_interval_map.hpp	/^    split_interval_map(): base_type() {}$/;"	f	class:boost::icl::split_interval_map	access:public	signature:()
split_interval_map	icl/split_interval_map.hpp	/^    split_interval_map(const split_interval_map& src): base_type(src) {}$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(const split_interval_map& src)
split_interval_map	icl/split_interval_map.hpp	/^    split_interval_map(split_interval_map&& src)$/;"	f	class:boost::icl::split_interval_map	access:public	signature:(split_interval_map&& src)
split_interval_map	icl/split_interval_map.hpp	/^class split_interval_map:$/;"	c	namespace:boost::icl	inherits:interval_base_map
split_interval_set	icl/split_interval_set.hpp	/^    explicit split_interval_set(const domain_type& itv): base_type() { this->add(itv); }$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(const domain_type& itv)
split_interval_set	icl/split_interval_set.hpp	/^    explicit split_interval_set(const interval_type& elem): base_type() { this->add(elem); }$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(const interval_type& elem)
split_interval_set	icl/split_interval_set.hpp	/^    split_interval_set$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(const interval_base_set<SubType,DomainT,Compare,Interval,Alloc>& src)
split_interval_set	icl/split_interval_set.hpp	/^    split_interval_set(): base_type() {}$/;"	f	class:boost::icl::split_interval_set	access:public	signature:()
split_interval_set	icl/split_interval_set.hpp	/^    split_interval_set(const split_interval_set& src): base_type(src) {}$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(const split_interval_set& src)
split_interval_set	icl/split_interval_set.hpp	/^    split_interval_set(split_interval_set&& src)$/;"	f	class:boost::icl::split_interval_set	access:public	signature:(split_interval_set&& src)
split_interval_set	icl/split_interval_set.hpp	/^class split_interval_set: $/;"	c	namespace:boost::icl	inherits:interval_base_set
split_type	icl/interval_map.hpp	/^    typedef split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> split_type;$/;"	t	class:boost::icl::interval_map	access:public
static_interval	icl/interval.hpp	/^    struct static_interval<IntervalT, false, PretendedBounds, RepresentedBounds>$/;"	s	namespace:boost::icl
static_interval	icl/interval.hpp	/^    struct static_interval<IntervalT, true, PretendedBounds, RepresentedBounds>$/;"	s	namespace:boost::icl
std_equal	icl/predicates/std_equal.hpp	/^    template <class Type> struct std_equal : public relation<Type,Type>$/;"	s	namespace:boost::icl	inherits:relation
std_pair_type	icl/detail/mapped_reference.hpp	/^    typedef std::pair<      first_type, second_type>     std_pair_type; $/;"	t	class:boost::icl::mapped_reference	access:public
stop	icl/detail/element_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::element_comparer::__anon6
stop	icl/detail/interval_subset_comparer.hpp	/^    enum{nextboth, nextleft, nextright, stop};$/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon2
stop	icl/detail/subset_comparer.hpp	/^    enum{nextboth, stop};$/;"	e	enum:boost::icl::Set::subset_comparer::__anon4
sub_super_set	icl/predicates/sub_super_set.hpp	/^    struct sub_super_set : public relation<Type,Type>$/;"	s	namespace:boost::icl	inherits:relation
sub_type	icl/interval_base_map.hpp	/^    typedef SubType sub_type;$/;"	t	class:boost::icl::interval_base_map	access:public
sub_type	icl/interval_base_set.hpp	/^    typedef SubType sub_type;$/;"	t	class:boost::icl::interval_base_set	access:public
subset	icl/detail/interval_subset_comparer.hpp	/^        subset     = inclusion::subset,     \/\/ left is_subset_of   right $/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon3
subset	icl/detail/relation_state.hpp	/^        static const int subset    =  1;$/;"	m	namespace:boost::icl::inclusion
subset	icl/detail/subset_comparer.hpp	/^        subset     = inclusion::subset,     \/\/ left is_subset_of   right $/;"	e	enum:boost::icl::Set::subset_comparer::__anon5
subset_compare	icl/detail/interval_subset_comparer.hpp	/^int subset_compare$/;"	f	namespace:boost::icl::Interval_Set	signature:( const LeftT& left, const RightT& right, typename LeftT::const_iterator left_begin, typename LeftT::const_iterator left_end, typename RightT::const_iterator right_begin, typename RightT::const_iterator right_end )
subset_compare	icl/detail/subset_comparer.hpp	/^int subset_compare$/;"	f	namespace:boost::icl::Set	signature:( const LeftT& left, const RightT& right, typename LeftT::const_iterator left_begin, typename LeftT::const_iterator left_end, typename RightT::const_iterator right_begin, typename RightT::const_iterator right_end )
subset_compare	icl/detail/subset_comparer.hpp	/^int subset_compare(const LeftT& left, const RightT& right)$/;"	f	namespace:boost::icl::Set	signature:(const LeftT& left, const RightT& right)
subset_comparer	icl/detail/interval_subset_comparer.hpp	/^    subset_comparer(const LeftT&      left,$/;"	f	class:boost::icl::Interval_Set::subset_comparer	access:public	signature:(const LeftT& left, const RightT& right, const LeftIterT& left_end, const RightIterT& right_end)
subset_comparer	icl/detail/interval_subset_comparer.hpp	/^class subset_comparer$/;"	c	namespace:boost::icl::Interval_Set
subset_comparer	icl/detail/subset_comparer.hpp	/^    subset_comparer(const LeftT&      left,$/;"	f	class:boost::icl::Set::subset_comparer	access:public	signature:(const LeftT& left, const RightT& right, const LeftIterT& left_end, const RightIterT& right_end)
subset_comparer	icl/detail/subset_comparer.hpp	/^class subset_comparer$/;"	c	namespace:boost::icl::Set
subtract	icl/concept/element_map.hpp	/^subtract(Type& object, const typename Type::domain_type& key_value)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::domain_type& key_value)
subtract	icl/concept/element_map.hpp	/^subtract(Type& object, const typename Type::element_type& operand) $/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
subtract	icl/concept/element_set.hpp	/^subtract(Type& object, const typename Type::value_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::value_type& operand)
subtract	icl/concept/interval_map.hpp	/^subtract(Type& object, const typename Type::domain_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::domain_type& operand)
subtract	icl/concept/interval_map.hpp	/^subtract(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
subtract	icl/concept/interval_map.hpp	/^subtract(Type& object, const typename Type::interval_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::interval_type& operand)
subtract	icl/concept/interval_map.hpp	/^subtract(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
subtract	icl/concept/interval_set.hpp	/^subtract(Type& object, const typename Type::element_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::element_type& operand)
subtract	icl/concept/interval_set.hpp	/^subtract(Type& object, const typename Type::segment_type& operand)$/;"	f	namespace:boost::icl	signature:(Type& object, const typename Type::segment_type& operand)
subtract	icl/detail/interval_set_algo.hpp	/^void subtract(Type& object, const typename Type::value_type& minuend)$/;"	f	namespace:boost::icl::Interval_Set	signature:(Type& object, const typename Type::value_type& minuend)
subtract	icl/interval_base_map.hpp	/^        static void subtract(Type& object, const segment_type& operand)$/;"	f	struct:boost::icl::interval_base_map::on_invertible	access:public	signature:(Type& object, const segment_type& operand)
subtract	icl/interval_base_map.hpp	/^    SubType& subtract(const element_type& key_value_pair)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const element_type& key_value_pair)
subtract	icl/interval_base_map.hpp	/^    SubType& subtract(const segment_type& interval_value_pair)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const segment_type& interval_value_pair)
subtract	icl/interval_base_set.hpp	/^    ::subtract(const segment_type& minuend)$/;"	f	class:boost::icl::interval_base_set	signature:(const segment_type& minuend)
subtract	icl/interval_base_set.hpp	/^    SubType& subtract(const element_type& key) $/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const element_type& key)
subtract	icl/interval_base_set.hpp	/^    SubType& subtract(const segment_type& inter_val); $/;"	p	class:boost::icl::interval_base_set	access:public	signature:(const segment_type& inter_val)
subtract	icl/map.hpp	/^        static void subtract(Type& object, const element_type& operand)$/;"	f	struct:boost::icl::map::on_invertible	access:public	signature:(Type& object, const element_type& operand)
subtract	icl/map.hpp	/^        static void subtract(Type& object, typename Type::iterator       it_, $/;"	f	struct:boost::icl::map::on_codomain_model	access:public	signature:(Type& object, typename Type::iterator it_, const typename Type::codomain_type& )
subtract	icl/map.hpp	/^        static void subtract(Type& object, typename Type::iterator       it_, $/;"	f	struct:boost::icl::map::on_codomain_model	access:public	signature:(Type& object, typename Type::iterator it_, const typename Type::codomain_type& co_value)
subtract	icl/map.hpp	/^        static void subtract(Type&, typename Type::iterator       it_, $/;"	f	struct:boost::icl::map::on_codomain_model	access:public	signature:(Type&, typename Type::iterator it_, const typename Type::codomain_type& co_value)
subtract	icl/map.hpp	/^        static void subtract(Type&, typename Type::iterator it_, $/;"	f	struct:boost::icl::map::on_codomain_model	access:public	signature:(Type&, typename Type::iterator it_, const typename Type::codomain_type& )
subtract	icl/map.hpp	/^    map& subtract(const domain_type& key)$/;"	f	class:boost::icl::map	access:public	signature:(const domain_type& key)
subtract	icl/map.hpp	/^    map& subtract(const element_type& value_pair)$/;"	f	class:boost::icl::map	access:public	signature:(const element_type& value_pair)
subtract_front	icl/interval_base_map.hpp	/^    ::subtract_front(const interval_type& inter_val, iterator& it_)$/;"	f	class:boost::icl::interval_base_map	signature:(const interval_type& inter_val, iterator& it_)
subtract_front	icl/interval_base_map.hpp	/^    void subtract_front(const interval_type& inter_val, iterator& first_);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const interval_type& inter_val, iterator& first_)
subtract_main	icl/interval_base_map.hpp	/^    ::subtract_main(const CodomainT& co_val, iterator& it_, const iterator& last_)$/;"	f	class:boost::icl::interval_base_map	signature:(const CodomainT& co_val, iterator& it_, const iterator& last_)
subtract_main	icl/interval_base_map.hpp	/^    void subtract_main(const CodomainT& co_val, iterator& it_, const iterator& last_);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(const CodomainT& co_val, iterator& it_, const iterator& last_)
subtract_rear	icl/interval_base_map.hpp	/^    ::subtract_rear(interval_type& inter_val, const CodomainT& co_val, iterator& it_)$/;"	f	class:boost::icl::interval_base_map	signature:(interval_type& inter_val, const CodomainT& co_val, iterator& it_)
subtract_rear	icl/interval_base_map.hpp	/^    void subtract_rear(interval_type& inter_val, const CodomainT& co_val, iterator& it_);$/;"	p	class:boost::icl::interval_base_map	access:private	signature:(interval_type& inter_val, const CodomainT& co_val, iterator& it_)
succ	icl/type_traits/succ_pred.hpp	/^inline static IncrementableT succ(IncrementableT x) { return ++x; }$/;"	f	namespace:boost::icl	signature:(IncrementableT x)
successor	icl/type_traits/succ_pred.hpp	/^    struct successor<DomainT, false>$/;"	s	namespace:boost::icl::detail
successor	icl/type_traits/succ_pred.hpp	/^    struct successor<DomainT, true>$/;"	s	namespace:boost::icl::detail
successor	icl/type_traits/succ_pred.hpp	/^struct successor$/;"	s	namespace:boost::icl
super_sub_set	icl/predicates/sub_super_set.hpp	/^    struct super_sub_set : public relation<Type,Type>$/;"	s	namespace:boost::icl	inherits:relation
superset	icl/detail/interval_subset_comparer.hpp	/^        superset   = inclusion::superset,   \/\/ left is_superset_of right$/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon3
superset	icl/detail/relation_state.hpp	/^        static const int superset  =  2;$/;"	m	namespace:boost::icl::inclusion
superset	icl/detail/subset_comparer.hpp	/^        superset   = inclusion::superset,   \/\/ left is_superset_of right$/;"	e	enum:boost::icl::Set::subset_comparer::__anon5
swap	icl/concept/container.hpp	/^swap(Type& left, Type& right)$/;"	f	namespace:boost::icl	signature:(Type& left, Type& right)
swap	icl/interval_base_map.hpp	/^    void swap(interval_base_map& object) { _map.swap(object._map); }$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(interval_base_map& object)
swap	icl/interval_base_set.hpp	/^    void swap(interval_base_set& operand) { _set.swap(operand._set); }$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(interval_base_set& operand)
swap	icl/map.hpp	/^    void swap(map& src) { base_type::swap(src); }$/;"	f	class:boost::icl::map	access:public	signature:(map& src)
that	icl/interval_base_map.hpp	/^    const sub_type* that()const { return static_cast<const sub_type*>(this); }$/;"	f	class:boost::icl::interval_base_map	access:protected	signature:() const
that	icl/interval_base_map.hpp	/^    sub_type* that() { return static_cast<sub_type*>(this); }$/;"	f	class:boost::icl::interval_base_map	access:protected	signature:()
that	icl/interval_base_set.hpp	/^    const sub_type* that()const { return static_cast<const sub_type*>(this); }$/;"	f	class:boost::icl::interval_base_set	access:protected	signature:() const
that	icl/interval_base_set.hpp	/^    sub_type* that() { return static_cast<sub_type*>(this); }$/;"	f	class:boost::icl::interval_base_set	access:protected	signature:()
to_string	icl/type_traits/to_string.hpp	/^struct to_string$/;"	s	namespace:boost::icl
to_string	icl/type_traits/type_to_string.hpp	/^        static std::string to_string()$/;"	f	struct:boost::icl::type_to_string	access:public	signature:()
total_absorber	icl/map.hpp	/^struct total_absorber$/;"	s	namespace:boost::icl
total_add_intersection	icl/interval_base_map.hpp	/^    void total_add_intersection(SubType& section, const FragmentT& fragment)const$/;"	f	class:boost::icl::interval_base_map	access:private	signature:(SubType& section, const FragmentT& fragment) const
total_add_intersection	icl/map.hpp	/^    void total_add_intersection(type& section, const FragmentT& fragment)const$/;"	f	class:boost::icl::map	access:private	signature:(type& section, const FragmentT& fragment) const
total_enricher	icl/map.hpp	/^struct total_enricher$/;"	s	namespace:boost::icl
touches	icl/concept/interval.hpp	/^touches(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
traits	icl/interval_base_map.hpp	/^    typedef Traits traits;$/;"	t	class:boost::icl::interval_base_map	access:public
traits	icl/interval_map.hpp	/^    typedef Traits traits;$/;"	t	class:boost::icl::interval_map	access:public
traits	icl/map.hpp	/^    typedef Traits traits;$/;"	t	class:boost::icl::map	access:public
traits	icl/split_interval_map.hpp	/^    typedef Traits traits;$/;"	t	class:boost::icl::split_interval_map	access:public
transient_element	icl/detail/element_iterator.hpp	/^    static transit_type transient_element(domain_type& inter_pos, const SegmentIteratorT& leaper, $/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(domain_type& inter_pos, const SegmentIteratorT& leaper, const domain_difference_type& sneaker)
transient_element	icl/detail/element_iterator.hpp	/^    static transit_type transient_element(domain_type& inter_pos, const SegmentIteratorT& leaper,$/;"	f	struct:boost::icl::segment_adapter	access:public	signature:(domain_type& inter_pos, const SegmentIteratorT& leaper, const domain_difference_type& sneaker)
transit_type	icl/detail/element_iterator.hpp	/^        typedef DomainT                   transit_type;$/;"	t	struct:boost::icl::elemental	access:public
transit_type	icl/detail/element_iterator.hpp	/^        typedef domain_type                         transit_type;$/;"	t	struct:boost::icl::elemental	access:public
transit_type	icl/detail/element_iterator.hpp	/^        typedef mapped_reference<DomainT, CodomainT>            transit_type;$/;"	t	struct:boost::icl::elemental	access:public
transit_type	icl/detail/element_iterator.hpp	/^        typedef mapped_reference<domain_type, codomain_type>    transit_type;$/;"	t	struct:boost::icl::elemental	access:public
transit_type	icl/detail/element_iterator.hpp	/^    typedef domain_type&                             transit_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
transit_type	icl/detail/element_iterator.hpp	/^    typedef domain_type&                            transit_type;$/;"	t	struct:boost::icl::segment_adapter	access:public
transit_type	icl/detail/element_iterator.hpp	/^    typedef mapped_reference<DomainT, CodomainT>    transit_type;    $/;"	t	struct:boost::icl::segment_adapter	access:public
transit_type	icl/detail/element_iterator.hpp	/^    typedef mapped_reference<domain_type, CodomainT>       transit_type;    $/;"	t	struct:boost::icl::segment_adapter	access:public
transit_type	icl/detail/element_iterator.hpp	/^    typedef typename elemental<segment_type>::transit_type  transit_type;$/;"	t	class:boost::icl::element_iterator	access:public
type	icl/closed_interval.hpp	/^    typedef closed_interval<DomainT,Compare> type;$/;"	t	class:boost::icl::closed_interval	access:public
type	icl/closed_interval.hpp	/^    typedef interval_bound_type type;$/;"	t	struct:boost::icl::interval_bound_type	access:public
type	icl/continuous_interval.hpp	/^    typedef continuous_interval<DomainT,Compare> type;$/;"	t	class:boost::icl::continuous_interval	access:public
type	icl/continuous_interval.hpp	/^    typedef dynamic_interval_traits type;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
type	icl/continuous_interval.hpp	/^    typedef interval_bound_type type;$/;"	t	struct:boost::icl::interval_bound_type	access:public
type	icl/continuous_interval.hpp	/^    typedef interval_traits type;$/;"	t	struct:boost::icl::interval_traits	access:public
type	icl/continuous_interval.hpp	/^    typedef is_continuous_interval<continuous_interval<DomainT,Compare> > type;$/;"	t	struct:boost::icl::is_continuous_interval	access:public
type	icl/detail/element_iterator.hpp	/^        typedef DomainT                   type;$/;"	t	struct:boost::icl::elemental	access:public
type	icl/detail/element_iterator.hpp	/^        typedef domain_type                         type;$/;"	t	struct:boost::icl::elemental	access:public
type	icl/detail/element_iterator.hpp	/^        typedef std::pair<DomainT, CodomainT>                   type;$/;"	t	struct:boost::icl::elemental	access:public
type	icl/detail/element_iterator.hpp	/^        typedef std::pair<domain_type, codomain_type>           type;$/;"	t	struct:boost::icl::elemental	access:public
type	icl/detail/element_iterator.hpp	/^    typedef FirstT type; $/;"	t	struct:boost::icl::first_element	access:public
type	icl/detail/element_iterator.hpp	/^    typedef Type type; $/;"	t	struct:boost::icl::first_element	access:public
type	icl/detail/element_iterator.hpp	/^    typedef element_iterator                                type;$/;"	t	class:boost::icl::element_iterator	access:public
type	icl/detail/element_iterator.hpp	/^    typedef is_reverse type; $/;"	t	struct:boost::icl::is_reverse	access:public
type	icl/detail/element_iterator.hpp	/^    typedef is_reverse<icl::element_iterator<BaseIteratorT> > type; $/;"	t	struct:boost::icl::is_reverse	access:public
type	icl/detail/element_iterator.hpp	/^    typedef is_reverse<std::reverse_iterator<BaseIteratorT> > type; $/;"	t	struct:boost::icl::is_reverse	access:public
type	icl/detail/element_iterator.hpp	/^    typedef is_std_pair<Type> type; $/;"	t	struct:boost::icl::is_std_pair	access:public
type	icl/detail/element_iterator.hpp	/^    typedef is_std_pair<std::pair<FirstT, SecondT> > type; $/;"	t	struct:boost::icl::is_std_pair	access:public
type	icl/detail/element_iterator.hpp	/^    typedef segment_adapter                                type;$/;"	t	struct:boost::icl::segment_adapter	access:public
type	icl/detail/element_iterator.hpp	/^    typedef segment_adapter                          type;$/;"	t	struct:boost::icl::segment_adapter	access:public
type	icl/detail/element_iterator.hpp	/^    typedef segment_adapter                         type;$/;"	t	struct:boost::icl::segment_adapter	access:public
type	icl/detail/interval_set_algo.hpp	/^    typedef          on_style            type;$/;"	t	struct:boost::icl::Interval_Set::on_style	access:public
type	icl/detail/mapped_reference.hpp	/^    typedef is_mapped_reference_combinable type;$/;"	t	struct:boost::icl::is_mapped_reference_combinable	access:public
type	icl/detail/mapped_reference.hpp	/^    typedef is_mapped_reference_combinable<std::pair<FirstT,SecondT> > type;$/;"	t	struct:boost::icl::is_mapped_reference_combinable	access:public
type	icl/detail/mapped_reference.hpp	/^    typedef is_mapped_reference_combinable<std::pair<const FirstT,SecondT> > type;$/;"	t	struct:boost::icl::is_mapped_reference_combinable	access:public
type	icl/detail/mapped_reference.hpp	/^    typedef is_mapped_reference_or_combinable type;$/;"	t	struct:boost::icl::is_mapped_reference_or_combinable	access:public
type	icl/detail/mapped_reference.hpp	/^    typedef is_mapped_reference_or_combinable<mapped_reference<FirstT,SecondT> > type;$/;"	t	struct:boost::icl::is_mapped_reference_or_combinable	access:public
type	icl/detail/mapped_reference.hpp	/^    typedef mapped_reference type;$/;"	t	class:boost::icl::mapped_reference	access:public
type	icl/detail/on_absorbtion.hpp	/^    typedef on_absorbtion type;$/;"	t	struct:boost::icl::on_absorbtion	access:public
type	icl/detail/std_set.hpp	/^    typedef is_set<std::set<Type> > type;$/;"	t	struct:boost::icl::is_set	access:public
type	icl/discrete_interval.hpp	/^    typedef discrete_interval<DomainT,Compare> type;$/;"	t	class:boost::icl::discrete_interval	access:public
type	icl/discrete_interval.hpp	/^    typedef dynamic_interval_traits type;$/;"	t	struct:boost::icl::dynamic_interval_traits	access:public
type	icl/discrete_interval.hpp	/^    typedef interval_bound_type type;$/;"	t	struct:boost::icl::interval_bound_type	access:public
type	icl/discrete_interval.hpp	/^    typedef interval_traits type;$/;"	t	struct:boost::icl::interval_traits	access:public
type	icl/discrete_interval.hpp	/^    typedef is_discrete_interval<discrete_interval<DomainT,Compare> > type;$/;"	t	struct:boost::icl::is_discrete_interval	access:public
type	icl/functors.hpp	/^            type;$/;"	t	struct:boost::icl::inter_section	access:public
type	icl/functors.hpp	/^            type;$/;"	t	struct:boost::icl::inverse	access:public
type	icl/functors.hpp	/^        typedef    version<Combiner> type;$/;"	t	struct:boost::icl::version	access:public
type	icl/functors.hpp	/^        typedef    version<icl::inplace_minus<Type> > type;$/;"	t	struct:boost::icl::version	access:public
type	icl/functors.hpp	/^        typedef conversion<Combiner> type;$/;"	t	struct:boost::icl::conversion	access:public
type	icl/functors.hpp	/^        typedef icl::inplace_erasure<argument_type> type; $/;"	t	struct:boost::icl::inverse	access:public
type	icl/functors.hpp	/^        typedef inplace_bit_add<Type> type;$/;"	t	struct:boost::icl::inplace_bit_add	access:public
type	icl/functors.hpp	/^        typedef inplace_bit_and<Type> type;$/;"	t	struct:boost::icl::inplace_bit_and	access:public
type	icl/functors.hpp	/^        typedef inplace_bit_subtract<Type> type;$/;"	t	struct:boost::icl::inplace_bit_subtract	access:public
type	icl/functors.hpp	/^        typedef inplace_bit_xor<Type> type;$/;"	t	struct:boost::icl::inplace_bit_xor	access:public
type	icl/functors.hpp	/^        typedef inplace_caret<Type> type;$/;"	t	struct:boost::icl::inplace_caret	access:public
type	icl/functors.hpp	/^        typedef inplace_erase<Type> type;$/;"	t	struct:boost::icl::inplace_erase	access:public
type	icl/functors.hpp	/^        typedef inplace_erasure<Type> type;$/;"	t	struct:boost::icl::inplace_erasure	access:public
type	icl/functors.hpp	/^        typedef inplace_et<Type> type;$/;"	t	struct:boost::icl::inplace_et	access:public
type	icl/functors.hpp	/^        typedef inplace_identity<Type> type;$/;"	t	struct:boost::icl::inplace_identity	access:public
type	icl/functors.hpp	/^        typedef inplace_insert<Type> type;$/;"	t	struct:boost::icl::inplace_insert	access:public
type	icl/functors.hpp	/^        typedef inplace_max<Type> type;$/;"	t	struct:boost::icl::inplace_max	access:public
type	icl/functors.hpp	/^        typedef inplace_min<Type> type;$/;"	t	struct:boost::icl::inplace_min	access:public
type	icl/functors.hpp	/^        typedef inplace_minus<Type> type;$/;"	t	struct:boost::icl::inplace_minus	access:public
type	icl/functors.hpp	/^        typedef inplace_plus<Type> type;$/;"	t	struct:boost::icl::inplace_plus	access:public
type	icl/functors.hpp	/^        typedef inplace_slash<Type> type;$/;"	t	struct:boost::icl::inplace_slash	access:public
type	icl/functors.hpp	/^        typedef inplace_star<Type> type;$/;"	t	struct:boost::icl::inplace_star	access:public
type	icl/functors.hpp	/^        typedef is_negative type;$/;"	t	struct:boost::icl::is_negative	access:public
type	icl/functors.hpp	/^        typedef is_negative<Functor> type;$/;"	t	struct:boost::icl::is_negative	access:public
type	icl/functors.hpp	/^    { typedef icl::inplace_bit_add<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
type	icl/functors.hpp	/^    { typedef icl::inplace_bit_and<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
type	icl/functors.hpp	/^    { typedef icl::inplace_bit_subtract<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
type	icl/functors.hpp	/^    { typedef icl::inplace_bit_xor<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
type	icl/functors.hpp	/^    { typedef icl::inplace_caret<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
type	icl/functors.hpp	/^    { typedef icl::inplace_erasure<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
type	icl/functors.hpp	/^    { typedef icl::inplace_et<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
type	icl/functors.hpp	/^    { typedef icl::inplace_max<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
type	icl/functors.hpp	/^    { typedef icl::inplace_min<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
type	icl/functors.hpp	/^    { typedef icl::inplace_minus<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
type	icl/functors.hpp	/^    { typedef icl::inplace_plus<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
type	icl/functors.hpp	/^    { typedef icl::inplace_slash<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
type	icl/functors.hpp	/^    { typedef icl::inplace_star<Type> type; };$/;"	t	struct:boost::icl::inverse	access:public
type	icl/gregorian.hpp	/^        typedef boost::gregorian::date_duration type; $/;"	t	struct:boost::icl::size_type_of	access:public
type	icl/gregorian.hpp	/^        typedef has_difference type;$/;"	t	struct:boost::icl::has_difference	access:public
type	icl/gregorian.hpp	/^        typedef is_discrete type;$/;"	t	struct:boost::icl::is_discrete	access:public
type	icl/gregorian.hpp	/^    { typedef boost::gregorian::date_duration type; };  $/;"	t	struct:boost::icl::difference_type_of	access:public
type	icl/gregorian.hpp	/^    { typedef boost::gregorian::date_duration type; };  $/;"	t	struct:boost::icl::size_type_of	access:public
type	icl/interval.hpp	/^        typedef interval_type type;$/;"	t	struct:boost::icl::interval	access:public
type	icl/interval_base_map.hpp	/^                              type;$/;"	t	class:boost::icl::interval_base_map	access:public
type	icl/interval_base_map.hpp	/^    typedef absorbs_identities<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::absorbs_identities	access:public
type	icl/interval_base_map.hpp	/^    typedef has_inverse<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::has_inverse	access:public
type	icl/interval_base_map.hpp	/^    typedef is_interval_container<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_container	access:public
type	icl/interval_base_map.hpp	/^    typedef is_map<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_map	access:public
type	icl/interval_base_map.hpp	/^    typedef is_total<icl::interval_base_map<SubType,DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_total	access:public
type	icl/interval_base_set.hpp	/^    typedef interval_base_set<SubType,DomainT,Compare,Interval,Alloc> type;$/;"	t	class:boost::icl::interval_base_set	access:public
type	icl/interval_base_set.hpp	/^    typedef is_interval_container<icl::interval_base_set<SubType,DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_container	access:public
type	icl/interval_base_set.hpp	/^    typedef is_set<icl::interval_base_set<SubType,DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_set	access:public
type	icl/interval_bounds.hpp	/^    typedef bounded_value<DomainT> type;$/;"	t	class:boost::icl::bounded_value	access:public
type	icl/interval_map.hpp	/^    typedef       interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> type;$/;"	t	class:boost::icl::interval_map	access:public
type	icl/interval_map.hpp	/^    typedef absorbs_identities<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::absorbs_identities	access:public
type	icl/interval_map.hpp	/^    typedef has_inverse<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::has_inverse	access:public
type	icl/interval_map.hpp	/^    typedef is_interval_container<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_container	access:public
type	icl/interval_map.hpp	/^    typedef is_map<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_map	access:public
type	icl/interval_map.hpp	/^    typedef is_total<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_total	access:public
type	icl/interval_set.hpp	/^    typedef interval_set<DomainT,Compare,Interval,Alloc> type;$/;"	t	class:boost::icl::interval_set	access:public
type	icl/interval_set.hpp	/^    typedef is_interval_container<icl::interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_container	access:public
type	icl/interval_set.hpp	/^    typedef is_interval_joiner<icl::interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_joiner	access:public
type	icl/interval_set.hpp	/^    typedef is_set<icl::interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_set	access:public
type	icl/interval_traits.hpp	/^    typedef interval_traits                     type;$/;"	t	struct:boost::icl::interval_traits	access:public
type	icl/interval_traits.hpp	/^    typedef typename difference_type_of<domain_type>::type type;$/;"	t	struct:boost::icl::difference_type_of	access:public
type	icl/interval_traits.hpp	/^    typedef typename interval_traits<Type>::domain_type type;$/;"	t	struct:boost::icl::domain_type_of	access:public
type	icl/interval_traits.hpp	/^    typedef typename size_type_of<domain_type>::type type;$/;"	t	struct:boost::icl::size_type_of	access:public
type	icl/left_open_interval.hpp	/^    typedef interval_bound_type type;$/;"	t	struct:boost::icl::interval_bound_type	access:public
type	icl/left_open_interval.hpp	/^    typedef left_open_interval<DomainT,Compare> type;$/;"	t	class:boost::icl::left_open_interval	access:public
type	icl/map.hpp	/^    typedef absorbs_identities type;$/;"	t	struct:boost::icl::absorbs_identities	access:public
type	icl/map.hpp	/^    typedef has_inverse<icl::map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc> > type;$/;"	t	struct:boost::icl::has_inverse	access:public
type	icl/map.hpp	/^    typedef is_map<icl::map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc> > type;$/;"	t	struct:boost::icl::is_map	access:public
type	icl/map.hpp	/^    typedef is_total type;$/;"	t	struct:boost::icl::is_total	access:public
type	icl/map.hpp	/^    typedef typename icl::map<DomainT,CodomainT,Traits, Compare,Combine,Section,Alloc> type;$/;"	t	class:boost::icl::map	access:public
type	icl/open_interval.hpp	/^    typedef interval_bound_type type;$/;"	t	struct:boost::icl::interval_bound_type	access:public
type	icl/open_interval.hpp	/^    typedef open_interval<DomainT,Compare> type;$/;"	t	class:boost::icl::open_interval	access:public
type	icl/ptime.hpp	/^        typedef boost::posix_time::time_duration type; $/;"	t	struct:boost::icl::difference_type_of	access:public
type	icl/ptime.hpp	/^        typedef boost::posix_time::time_duration type; $/;"	t	struct:boost::icl::size_type_of	access:public
type	icl/ptime.hpp	/^        typedef has_difference type;$/;"	t	struct:boost::icl::has_difference	access:public
type	icl/ptime.hpp	/^        typedef is_discrete type;$/;"	t	struct:boost::icl::is_discrete	access:public
type	icl/rational.hpp	/^        typedef has_inverse type;$/;"	t	struct:boost::icl::has_inverse	access:public
type	icl/rational.hpp	/^        typedef is_continuous type;$/;"	t	struct:boost::icl::is_continuous	access:public
type	icl/rational.hpp	/^        typedef is_discrete type;$/;"	t	struct:boost::icl::is_discrete	access:public
type	icl/rational.hpp	/^        typedef is_numeric type;$/;"	t	struct:boost::icl::is_numeric	access:public
type	icl/right_open_interval.hpp	/^    typedef interval_bound_type type;$/;"	t	struct:boost::icl::interval_bound_type	access:public
type	icl/right_open_interval.hpp	/^    typedef right_open_interval<DomainT,Compare> type;$/;"	t	class:boost::icl::right_open_interval	access:public
type	icl/separate_interval_set.hpp	/^    typedef is_interval_container<icl::separate_interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_container	access:public
type	icl/separate_interval_set.hpp	/^    typedef is_interval_separator<icl::separate_interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_separator	access:public
type	icl/separate_interval_set.hpp	/^    typedef is_set<icl::separate_interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_set	access:public
type	icl/separate_interval_set.hpp	/^    typedef separate_interval_set<DomainT,Compare,Interval,Alloc> type;$/;"	t	class:boost::icl::separate_interval_set	access:public
type	icl/split_interval_map.hpp	/^    typedef absorbs_identities<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::absorbs_identities	access:public
type	icl/split_interval_map.hpp	/^    typedef has_inverse<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::has_inverse	access:public
type	icl/split_interval_map.hpp	/^    typedef is_interval_container<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_container	access:public
type	icl/split_interval_map.hpp	/^    typedef is_interval_splitter<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_splitter	access:public
type	icl/split_interval_map.hpp	/^    typedef is_map<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_map	access:public
type	icl/split_interval_map.hpp	/^    typedef is_total<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_total	access:public
type	icl/split_interval_map.hpp	/^    typedef split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> type;$/;"	t	class:boost::icl::split_interval_map	access:public
type	icl/split_interval_set.hpp	/^    typedef is_interval_container<icl::split_interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_container	access:public
type	icl/split_interval_set.hpp	/^    typedef is_interval_splitter<icl::split_interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_interval_splitter	access:public
type	icl/split_interval_set.hpp	/^    typedef is_set<icl::split_interval_set<DomainT,Compare,Interval,Alloc> > type;$/;"	t	struct:boost::icl::is_set	access:public
type	icl/split_interval_set.hpp	/^    typedef split_interval_set<DomainT,Compare,Interval,Alloc> type;$/;"	t	class:boost::icl::split_interval_set	access:public
type	icl/type_traits/absorbs_identities.hpp	/^        typedef absorbs_identities<Type> type;$/;"	t	struct:boost::icl::absorbs_identities	access:public
type	icl/type_traits/adds_inversely.hpp	/^    typedef adds_inversely type;$/;"	t	struct:boost::icl::adds_inversely	access:public
type	icl/type_traits/codomain_type_of.hpp	/^                             >::type type;$/;"	t	struct:boost::icl::codomain_type_of	access:public
type	icl/type_traits/codomain_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_codomain_type	access:public
type	icl/type_traits/codomain_type_of.hpp	/^        typedef typename Type::codomain_type type;$/;"	t	struct:boost::icl::get_codomain_type	access:public
type	icl/type_traits/codomain_type_of.hpp	/^        typedef typename Type::value_type type;$/;"	t	struct:boost::icl::get_codomain_type	access:public
type	icl/type_traits/difference.hpp	/^    template <class Type> struct difference{ typedef Type type; };$/;"	t	struct:boost::icl::difference	access:public
type	icl/type_traits/difference_type_of.hpp	/^                               >::type type;$/;"	t	struct:boost::icl::difference_type_of	access:public
type	icl/type_traits/difference_type_of.hpp	/^        typedef Type type;$/;"	t	struct:boost::icl::get_difference_type	access:public
type	icl/type_traits/difference_type_of.hpp	/^        typedef has_difference type;$/;"	t	struct:boost::icl::has_difference	access:public
type	icl/type_traits/difference_type_of.hpp	/^        typedef is_subtraction_closed type;$/;"	t	struct:boost::icl::is_subtraction_closed	access:public
type	icl/type_traits/difference_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_difference_type	access:public
type	icl/type_traits/difference_type_of.hpp	/^        typedef std::ptrdiff_t type;$/;"	t	struct:boost::icl::get_difference_type	access:public
type	icl/type_traits/difference_type_of.hpp	/^        typedef typename Type::difference_type type;$/;"	t	struct:boost::icl::get_difference_type	access:public
type	icl/type_traits/domain_type_of.hpp	/^            get_domain_type<Type, has_domain_type<Type>::value>::type type;$/;"	t	struct:boost::icl::domain_type_of	access:public
type	icl/type_traits/domain_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_domain_type	access:public
type	icl/type_traits/domain_type_of.hpp	/^        typedef typename Type::domain_type type;$/;"	t	struct:boost::icl::get_domain_type	access:public
type	icl/type_traits/element_type_of.hpp	/^            get_element_type<Type, has_element_type<Type>::value>::type type;$/;"	t	struct:boost::icl::element_type_of	access:public
type	icl/type_traits/element_type_of.hpp	/^            get_key_type<Type, has_key_type<Type>::value>::type type;$/;"	t	struct:boost::icl::key_type_of	access:public
type	icl/type_traits/element_type_of.hpp	/^            get_value_type<Type, has_value_type<Type>::value>::type type;$/;"	t	struct:boost::icl::value_type_of	access:public
type	icl/type_traits/element_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_element_type	access:public
type	icl/type_traits/element_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_key_type	access:public
type	icl/type_traits/element_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_value_type	access:public
type	icl/type_traits/element_type_of.hpp	/^        typedef typename Type::element_type type;$/;"	t	struct:boost::icl::get_element_type	access:public
type	icl/type_traits/element_type_of.hpp	/^        typedef typename Type::key_type type;$/;"	t	struct:boost::icl::get_key_type	access:public
type	icl/type_traits/element_type_of.hpp	/^        typedef typename Type::value_type type;$/;"	t	struct:boost::icl::get_value_type	access:public
type	icl/type_traits/has_inverse.hpp	/^        typedef has_inverse<Type> type;$/;"	t	struct:boost::icl::has_inverse	access:public
type	icl/type_traits/has_set_semantics.hpp	/^        typedef has_set_semantics<Type> type;$/;"	t	struct:boost::icl::has_set_semantics	access:public
type	icl/type_traits/infinity.hpp	/^    typedef get_infinity type;$/;"	t	struct:boost::icl::get_infinity	access:public
type	icl/type_traits/infinity.hpp	/^    typedef get_numeric_infinity type;$/;"	t	struct:boost::icl::get_numeric_infinity	access:public
type	icl/type_traits/infinity.hpp	/^    typedef has_max_infinity type;$/;"	t	struct:boost::icl::has_max_infinity	access:public
type	icl/type_traits/infinity.hpp	/^    typedef has_std_infinity type;$/;"	t	struct:boost::icl::has_std_infinity	access:public
type	icl/type_traits/infinity.hpp	/^    typedef infinity type;$/;"	t	struct:boost::icl::infinity	access:public
type	icl/type_traits/infinity.hpp	/^    typedef numeric_infinity type;$/;"	t	struct:boost::icl::numeric_infinity	access:public
type	icl/type_traits/interval_type_default.hpp	/^                             >::type type;$/;"	t	struct:boost::icl::interval_type_default	access:public
type	icl/type_traits/interval_type_of.hpp	/^            get_interval_type<Type, has_interval_type<Type>::value>::type type;$/;"	t	struct:boost::icl::interval_type_of	access:public
type	icl/type_traits/interval_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_interval_type	access:public
type	icl/type_traits/interval_type_of.hpp	/^        typedef typename Type::interval_type type;$/;"	t	struct:boost::icl::get_interval_type	access:public
type	icl/type_traits/is_associative_element_container.hpp	/^        typedef is_associative_element_container type;$/;"	t	struct:boost::icl::is_associative_element_container	access:public
type	icl/type_traits/is_asymmetric_interval.hpp	/^    typedef is_asymmetric_interval<Type> type;$/;"	t	struct:boost::icl::is_asymmetric_interval	access:public
type	icl/type_traits/is_asymmetric_interval.hpp	/^    typedef is_continuous_asymmetric<Type> type;$/;"	t	struct:boost::icl::is_continuous_asymmetric	access:public
type	icl/type_traits/is_asymmetric_interval.hpp	/^    typedef is_discrete_asymmetric<Type> type;$/;"	t	struct:boost::icl::is_discrete_asymmetric	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef combines_right_to_interval_container<GuideT, IntervalContainerT> type;$/;"	t	struct:boost::icl::combines_right_to_interval_container	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef combines_right_to_interval_map<GuideT, IntervalMapT> type;$/;"	t	struct:boost::icl::combines_right_to_interval_map	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef combines_right_to_interval_set<GuideT, IntervalSetT> type;$/;"	t	struct:boost::icl::combines_right_to_interval_set	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_binary_cross_combinable<GuideT,CompanionT> type;$/;"	t	struct:boost::icl::is_binary_cross_combinable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_binary_inter_combinable<GuideT,CompanionT> type;$/;"	t	struct:boost::icl::is_binary_inter_combinable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_binary_interval_map_combinable<GuideT,CompanionT> type;$/;"	t	struct:boost::icl::is_binary_interval_map_combinable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_binary_interval_set_combinable<GuideT,CompanionT> type;$/;"	t	struct:boost::icl::is_binary_interval_set_combinable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_binary_intra_combinable<GuideT,CompanionT> type;$/;"	t	struct:boost::icl::is_binary_intra_combinable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_coarser_interval_map_companion<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_coarser_interval_map_companion	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_coarser_interval_set_companion<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_coarser_interval_set_companion	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_codomain_equal<LeftT, RightT> type;$/;"	t	struct:boost::icl::is_codomain_equal	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_codomain_type_equal<LeftT, RightT> type;$/;"	t	struct:boost::icl::is_codomain_type_equal	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_concept_combinable<LeftConcept, RightConcept, LeftT, RightT> type;$/;"	t	struct:boost::icl::is_concept_combinable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_concept_compatible<IsConcept, LeftT, RightT> type;$/;"	t	struct:boost::icl::is_concept_compatible	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_cross_combinable<LeftT, RightT> type;$/;"	t	struct:boost::icl::is_cross_combinable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_cross_derivative<Type, AssociateT> type;$/;"	t	struct:boost::icl::is_cross_derivative	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_fragment_of type;$/;"	t	struct:boost::icl::is_fragment_of	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_inter_combinable<LeftT, RightT> type;$/;"	t	struct:boost::icl::is_inter_combinable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_inter_derivative<Type, AssociateT> type;$/;"	t	struct:boost::icl::is_inter_derivative	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_map_companion<GuideT,CompanionT> type;$/;"	t	struct:boost::icl::is_interval_map_companion	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_map_derivative type;$/;"	t	struct:boost::icl::is_interval_map_derivative	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_map_derivative<Type, AssociateT> type;$/;"	t	struct:boost::icl::is_interval_map_derivative	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_map_right_cross_combinable<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_interval_map_right_cross_combinable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_map_right_inter_combinable<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_interval_map_right_inter_combinable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_map_right_intra_combinable<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_interval_map_right_intra_combinable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_set_companion<GuideT,CompanionT> type;$/;"	t	struct:boost::icl::is_interval_set_companion	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_set_derivative type;$/;"	t	struct:boost::icl::is_interval_set_derivative	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_set_derivative<Type, AssociateT> type;$/;"	t	struct:boost::icl::is_interval_set_derivative	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_interval_set_right_combinable<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_interval_set_right_combinable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_intra_combinable<LeftT, RightT> type;$/;"	t	struct:boost::icl::is_intra_combinable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_intra_derivative<Type, AssociateT> type;$/;"	t	struct:boost::icl::is_intra_derivative	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_key_compare_equal<LeftT, RightT> type;$/;"	t	struct:boost::icl::is_key_compare_equal	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_key_of type;$/;"	t	struct:boost::icl::is_key_of	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_overloadable<Type> type;$/;"	t	struct:boost::icl::is_overloadable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_right_inter_combinable<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_right_inter_combinable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef is_right_intra_combinable<GuideT, CompanionT> type;$/;"	t	struct:boost::icl::is_right_intra_combinable	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef known_fineness<Type> type;$/;"	t	struct:boost::icl::known_fineness	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef segmentational_fineness<Type> type;$/;"	t	struct:boost::icl::segmentational_fineness	access:public
type	icl/type_traits/is_combinable.hpp	/^    typedef unknown_fineness<Type> type;$/;"	t	struct:boost::icl::unknown_fineness	access:public
type	icl/type_traits/is_concept_equivalent.hpp	/^        typedef has_same_concept<IsConcept, LeftT, RightT> type;$/;"	t	struct:boost::icl::has_same_concept	access:public
type	icl/type_traits/is_concept_equivalent.hpp	/^        typedef is_concept_equivalent<IsConcept, LeftT, RightT> type;$/;"	t	struct:boost::icl::is_concept_equivalent	access:public
type	icl/type_traits/is_container.hpp	/^        typedef is_std_set type;$/;"	t	struct:boost::icl::is_std_set	access:public
type	icl/type_traits/is_continuous.hpp	/^        typedef is_continuous type;$/;"	t	struct:boost::icl::is_continuous	access:public
type	icl/type_traits/is_continuous_interval.hpp	/^    typedef is_continuous_interval<Type> type;$/;"	t	struct:boost::icl::is_continuous_interval	access:public
type	icl/type_traits/is_discrete.hpp	/^        typedef is_discrete type;$/;"	t	struct:boost::icl::is_discrete	access:public
type	icl/type_traits/is_discrete_interval.hpp	/^    typedef is_discrete_interval<Type> type;$/;"	t	struct:boost::icl::is_discrete_interval	access:public
type	icl/type_traits/is_element_container.hpp	/^        typedef is_element_container<Type> type;$/;"	t	struct:boost::icl::is_element_container	access:public
type	icl/type_traits/is_element_container.hpp	/^        typedef is_element_map<Type> type;$/;"	t	struct:boost::icl::is_element_map	access:public
type	icl/type_traits/is_element_container.hpp	/^        typedef is_element_set<Type> type;$/;"	t	struct:boost::icl::is_element_set	access:public
type	icl/type_traits/is_icl_container.hpp	/^        typedef is_icl_container<Type> type;$/;"	t	struct:boost::icl::is_icl_container	access:public
type	icl/type_traits/is_increasing.hpp	/^    typedef is_increasing type;$/;"	t	struct:boost::icl::is_increasing	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef has_asymmetric_bounds<Type> type;$/;"	t	struct:boost::icl::has_asymmetric_bounds	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef has_dynamic_bounds<Type> type;$/;"	t	struct:boost::icl::has_dynamic_bounds	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef has_static_bounds<Type> type;$/;"	t	struct:boost::icl::has_static_bounds	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef has_symmetric_bounds<Type> type;$/;"	t	struct:boost::icl::has_symmetric_bounds	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef interval_bound_type type;$/;"	t	struct:boost::icl::interval_bound_type	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef is_continuous_left_open<Type> type;$/;"	t	struct:boost::icl::is_continuous_left_open	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef is_continuous_right_open<Type> type;$/;"	t	struct:boost::icl::is_continuous_right_open	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef is_continuous_static type;$/;"	t	struct:boost::icl::is_continuous_static	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef is_discrete_static type;$/;"	t	struct:boost::icl::is_discrete_static	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef is_interval<Type> type;$/;"	t	struct:boost::icl::is_interval	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef is_singelizable type;$/;"	t	struct:boost::icl::is_singelizable	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef is_static_closed<Type> type;$/;"	t	struct:boost::icl::is_discrete_static_closed	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef is_static_closed<Type> type;$/;"	t	struct:boost::icl::is_discrete_static_open	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef is_static_closed<Type> type;$/;"	t	struct:boost::icl::is_static_closed	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef is_static_left_open<Type> type;$/;"	t	struct:boost::icl::is_static_left_open	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef is_static_open<Type> type;$/;"	t	struct:boost::icl::is_static_open	access:public
type	icl/type_traits/is_interval.hpp	/^    typedef is_static_right_open<Type> type;$/;"	t	struct:boost::icl::is_static_right_open	access:public
type	icl/type_traits/is_interval_container.hpp	/^        typedef is_interval_container<Type> type;$/;"	t	struct:boost::icl::is_interval_container	access:public
type	icl/type_traits/is_interval_container.hpp	/^        typedef is_interval_map<Type> type; $/;"	t	struct:boost::icl::is_interval_map	access:public
type	icl/type_traits/is_interval_container.hpp	/^        typedef is_interval_set<Type> type; $/;"	t	struct:boost::icl::is_interval_set	access:public
type	icl/type_traits/is_interval_joiner.hpp	/^        typedef is_interval_joiner<Type> type;$/;"	t	struct:boost::icl::is_interval_joiner	access:public
type	icl/type_traits/is_interval_separator.hpp	/^        typedef is_interval_separator<Type> type;$/;"	t	struct:boost::icl::is_interval_separator	access:public
type	icl/type_traits/is_interval_splitter.hpp	/^        typedef is_interval_splitter<Type> type;$/;"	t	struct:boost::icl::is_interval_splitter	access:public
type	icl/type_traits/is_key_container_of.hpp	/^            >::type type;$/;"	t	struct:boost::icl::key_container_type_of	access:public
type	icl/type_traits/is_key_container_of.hpp	/^        typedef Type type;$/;"	t	struct:boost::icl::get_key_object_type	access:public
type	icl/type_traits/is_key_container_of.hpp	/^        typedef is_key_container_of<KeyT, ObjectT> type;$/;"	t	struct:boost::icl::is_key_container_of	access:public
type	icl/type_traits/is_key_container_of.hpp	/^        typedef is_strict_key_container_of<KeyT, ObjectT> type;$/;"	t	struct:boost::icl::is_strict_key_container_of	access:public
type	icl/type_traits/is_key_container_of.hpp	/^        typedef typename Type::key_object_type type;$/;"	t	struct:boost::icl::get_key_object_type	access:public
type	icl/type_traits/is_map.hpp	/^        typedef is_map<Type> type;$/;"	t	struct:boost::icl::is_map	access:public
type	icl/type_traits/is_numeric.hpp	/^    typedef is_fixed_numeric type;$/;"	t	struct:boost::icl::is_fixed_numeric	access:public
type	icl/type_traits/is_numeric.hpp	/^    typedef is_non_floating_point type;$/;"	t	struct:boost::icl::is_non_floating_point	access:public
type	icl/type_traits/is_numeric.hpp	/^    typedef is_numeric type;$/;"	t	struct:boost::icl::is_numeric	access:public
type	icl/type_traits/is_numeric.hpp	/^    typedef is_std_integral type;$/;"	t	struct:boost::icl::is_std_integral	access:public
type	icl/type_traits/is_numeric.hpp	/^    typedef is_std_numeric type;$/;"	t	struct:boost::icl::is_std_numeric	access:public
type	icl/type_traits/is_set.hpp	/^        typedef is_set<Type> type;$/;"	t	struct:boost::icl::is_set	access:public
type	icl/type_traits/is_total.hpp	/^        typedef is_total<Type> type;$/;"	t	struct:boost::icl::is_total	access:public
type	icl/type_traits/rep_type_of.hpp	/^            get_rep_type<Type, has_rep_type<Type>::value>::type type;$/;"	t	struct:boost::icl::rep_type_of	access:public
type	icl/type_traits/rep_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_rep_type	access:public
type	icl/type_traits/rep_type_of.hpp	/^        typedef represents type;$/;"	t	struct:boost::icl::represents	access:public
type	icl/type_traits/rep_type_of.hpp	/^        typedef typename Type::rep type;$/;"	t	struct:boost::icl::get_rep_type	access:public
type	icl/type_traits/segment_type_of.hpp	/^            get_segment_type<Type, has_segment_type<Type>::value>::type type;$/;"	t	struct:boost::icl::segment_type_of	access:public
type	icl/type_traits/segment_type_of.hpp	/^        typedef no_type type;$/;"	t	struct:boost::icl::get_segment_type	access:public
type	icl/type_traits/segment_type_of.hpp	/^        typedef typename Type::segment_type type;$/;"	t	struct:boost::icl::get_segment_type	access:public
type	icl/type_traits/size.hpp	/^    template <class Type> struct size{ typedef std::size_t type; };$/;"	t	struct:boost::icl::size	access:public
type	icl/type_traits/size_type_of.hpp	/^                         >::type type;$/;"	t	struct:boost::icl::size_type_of	access:public
type	icl/type_traits/size_type_of.hpp	/^        typedef Type type; $/;"	t	struct:boost::icl::get_size_type	access:public
type	icl/type_traits/size_type_of.hpp	/^        typedef std::size_t type; $/;"	t	struct:boost::icl::get_size_type	access:public
type	icl/type_traits/size_type_of.hpp	/^        typedef typename Type::difference_type type; $/;"	t	struct:boost::icl::get_size_type	access:public
type	icl/type_traits/size_type_of.hpp	/^        typedef typename Type::size_type type; $/;"	t	struct:boost::icl::get_size_type	access:public
type	icl/type_traits/succ_pred.hpp	/^        typedef predecessor type;$/;"	t	struct:boost::icl::detail::predecessor	access:public
type	icl/type_traits/succ_pred.hpp	/^        typedef successor type;$/;"	t	struct:boost::icl::detail::successor	access:public
type_to_string	icl/closed_interval.hpp	/^struct type_to_string<icl::closed_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
type_to_string	icl/continuous_interval.hpp	/^struct type_to_string<icl::continuous_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
type_to_string	icl/detail/std_set.hpp	/^struct type_to_string<std::set<Type, std::greater<Type> > >$/;"	s	namespace:boost::icl
type_to_string	icl/detail/std_set.hpp	/^struct type_to_string<std::set<Type> >$/;"	s	namespace:boost::icl
type_to_string	icl/discrete_interval.hpp	/^struct type_to_string<icl::discrete_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
type_to_string	icl/interval_map.hpp	/^struct type_to_string<icl::interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
type_to_string	icl/interval_set.hpp	/^struct type_to_string<icl::interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
type_to_string	icl/left_open_interval.hpp	/^struct type_to_string<icl::left_open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
type_to_string	icl/map.hpp	/^struct type_to_string<icl::map<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc> >$/;"	s	namespace:boost::icl
type_to_string	icl/open_interval.hpp	/^struct type_to_string<icl::open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
type_to_string	icl/right_open_interval.hpp	/^struct type_to_string<icl::right_open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
type_to_string	icl/separate_interval_set.hpp	/^struct type_to_string<icl::separate_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
type_to_string	icl/split_interval_map.hpp	/^struct type_to_string<icl::split_interval_map<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc> >$/;"	s	namespace:boost::icl
type_to_string	icl/split_interval_set.hpp	/^struct type_to_string<icl::split_interval_set<DomainT,Compare,Interval,Alloc> >$/;"	s	namespace:boost::icl
type_to_string	icl/type_traits/type_to_string.hpp	/^    struct type_to_string$/;"	s	namespace:boost::icl
type_to_string	icl/type_traits/type_to_string.hpp	/^    struct type_to_string<Binary<Type1, Type2> >$/;"	s	namespace:boost::icl
type_to_string	icl/type_traits/type_to_string.hpp	/^    struct type_to_string<Unary<Type> >$/;"	s	namespace:boost::icl
unary_template_to_string	icl/type_traits/type_to_string.hpp	/^    struct unary_template_to_string$/;"	s	namespace:boost::icl
unit_element	icl/type_traits/unit_element.hpp	/^    template <class Type> struct unit_element{ static Type value(); };$/;"	s	namespace:boost::icl
unit_element_based_inplace_combine	icl/functors.hpp	/^    template <typename Type> struct unit_element_based_inplace_combine $/;"	s	namespace:boost::icl	inherits:std::binary_function
unit_trail	icl/concept/interval.hpp	/^unit_trail(const typename interval_traits<Type>::domain_type& value)$/;"	f	namespace:boost::icl::detail	signature:(const typename interval_traits<Type>::domain_type& value)
unknown_fineness	icl/type_traits/is_combinable.hpp	/^template<class Type> struct unknown_fineness$/;"	s	namespace:boost::icl
unrelated	icl/detail/interval_subset_comparer.hpp	/^        unrelated  = inclusion::unrelated, $/;"	e	enum:boost::icl::Interval_Set::subset_comparer::__anon3
unrelated	icl/detail/relation_state.hpp	/^        static const int unrelated =  0;$/;"	m	namespace:boost::icl::inclusion
unrelated	icl/detail/subset_comparer.hpp	/^        unrelated  = inclusion::unrelated, $/;"	e	enum:boost::icl::Set::subset_comparer::__anon5
upper	icl/closed_interval.hpp	/^    DomainT upper()const{ return _upb; }$/;"	f	class:boost::icl::closed_interval	access:public	signature:() const
upper	icl/closed_interval.hpp	/^    static domain_type upper(const interval_type& inter_val){ return inter_val.upper(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
upper	icl/concept/interval.hpp	/^upper(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
upper	icl/concept/interval_associator.hpp	/^upper(const Type& object)$/;"	f	namespace:boost::icl	signature:(const Type& object)
upper	icl/continuous_interval.hpp	/^    domain_type     upper()const { return _upb; }$/;"	f	class:boost::icl::continuous_interval	access:public	signature:() const
upper	icl/continuous_interval.hpp	/^    static domain_type upper(const interval_type& inter_val){ return inter_val.upper(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
upper	icl/discrete_interval.hpp	/^    domain_type     upper()const { return _upb; }$/;"	f	class:boost::icl::discrete_interval	access:public	signature:() const
upper	icl/discrete_interval.hpp	/^    static domain_type upper(const interval_type& inter_val){ return inter_val.upper(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
upper	icl/interval_traits.hpp	/^    static domain_type upper(const Type& inter_val);$/;"	p	struct:boost::icl::interval_traits	access:public	signature:(const Type& inter_val)
upper	icl/left_open_interval.hpp	/^    DomainT upper()const{ return _upb; }$/;"	f	class:boost::icl::left_open_interval	access:public	signature:() const
upper	icl/left_open_interval.hpp	/^    static domain_type upper(const interval_type& inter_val){ return inter_val.upper(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
upper	icl/open_interval.hpp	/^    DomainT upper()const{ return _upb; }$/;"	f	class:boost::icl::open_interval	access:public	signature:() const
upper	icl/open_interval.hpp	/^    static domain_type upper(const interval_type& inter_val){ return inter_val.upper(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
upper	icl/right_open_interval.hpp	/^    domain_type upper()const{ return _upb; }$/;"	f	class:boost::icl::right_open_interval	access:public	signature:() const
upper	icl/right_open_interval.hpp	/^    static domain_type upper(const interval_type& inter_val){ return inter_val.upper(); };$/;"	f	struct:boost::icl::interval_traits	access:public	signature:(const interval_type& inter_val)
upper_bound	icl/interval_base_map.hpp	/^    const_iterator upper_bound(const key_type& interval)const$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const key_type& interval) const
upper_bound	icl/interval_base_map.hpp	/^    iterator upper_bound(const key_type& interval)$/;"	f	class:boost::icl::interval_base_map	access:public	signature:(const key_type& interval)
upper_bound	icl/interval_base_set.hpp	/^    const_iterator upper_bound(const value_type& interval)const$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const value_type& interval) const
upper_bound	icl/interval_base_set.hpp	/^    iterator upper_bound(const value_type& interval)$/;"	f	class:boost::icl::interval_base_set	access:public	signature:(const value_type& interval)
upper_equal	icl/concept/interval.hpp	/^upper_equal(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
upper_less	icl/concept/interval.hpp	/^upper_less(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
upper_less_equal	icl/concept/interval.hpp	/^upper_less_equal(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
upper_max	icl/concept/interval.hpp	/^upper_max(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
upper_min	icl/concept/interval.hpp	/^upper_min(const Type& left, const Type& right)$/;"	f	namespace:boost::icl	signature:(const Type& left, const Type& right)
value	icl/gregorian.hpp	/^        static boost::gregorian::date_duration value()$/;"	f	struct:boost::icl::identity_element	access:public	signature:()
value	icl/gregorian.hpp	/^    inline boost::gregorian::date identity_element<boost::gregorian::date>::value()$/;"	f	class:boost::icl::identity_element	signature:()
value	icl/interval_bounds.hpp	/^    domain_type     value()const { return _value; }$/;"	f	class:boost::icl::bounded_value	access:public	signature:() const
value	icl/ptime.hpp	/^    inline boost::posix_time::ptime identity_element<boost::posix_time::ptime>::value()$/;"	f	class:boost::icl::identity_element	signature:()
value	icl/type_traits/identity_element.hpp	/^        static Type value(); $/;"	p	struct:boost::icl::identity_element	access:public	signature:()
value	icl/type_traits/identity_element.hpp	/^    inline Type identity_element<Type>::value()$/;"	f	class:boost::icl::identity_element	signature:()
value	icl/type_traits/infinity.hpp	/^    static Type value()$/;"	f	struct:boost::icl::get_infinity	access:public	signature:()
value	icl/type_traits/infinity.hpp	/^    static Type value()$/;"	f	struct:boost::icl::get_numeric_infinity	access:public	signature:()
value	icl/type_traits/infinity.hpp	/^    static Type value()$/;"	f	struct:boost::icl::infinity	access:public	signature:()
value	icl/type_traits/infinity.hpp	/^    static Type value()$/;"	f	struct:boost::icl::numeric_infinity	access:public	signature:()
value	icl/type_traits/infinity.hpp	/^    static std::string value()$/;"	f	struct:boost::icl::infinity	access:public	signature:()
value	icl/type_traits/is_combinable.hpp	/^    static const int value = $/;"	m	struct:boost::icl::segmentational_fineness	access:public
value	icl/type_traits/is_combinable.hpp	/^    static const int value = 0;$/;"	m	struct:boost::icl::unknown_fineness	access:public
value	icl/type_traits/is_combinable.hpp	/^    static const int value = Type::fineness;$/;"	m	struct:boost::icl::known_fineness	access:public
value	icl/type_traits/is_combinable.hpp	/^    static const int value =$/;"	m	struct:boost::icl::is_binary_interval_map_combinable	access:public
value	icl/type_traits/is_combinable.hpp	/^    static const int value =$/;"	m	struct:boost::icl::is_binary_interval_set_combinable	access:public
value	icl/type_traits/unit_element.hpp	/^    inline Type unit_element<Type>::value()$/;"	f	class:boost::icl::unit_element	signature:()
value	icl/type_traits/unit_element.hpp	/^    inline std::string unit_element<std::string>::value()$/;"	f	class:boost::icl::unit_element	signature:()
value	icl/type_traits/unit_element.hpp	/^    template <class Type> struct unit_element{ static Type value(); };$/;"	p	struct:boost::icl::unit_element	access:public	signature:()
value	icl/type_traits/unit_element.hpp	/^    template<> inline bool   unit_element<bool>::value()   { return true;}$/;"	f	class:boost::icl::unit_element	signature:()
value	icl/type_traits/unit_element.hpp	/^    template<> inline double unit_element<double>::value() { return 1.0; }$/;"	f	class:boost::icl::unit_element	signature:()
value	icl/type_traits/unit_element.hpp	/^    template<> inline float  unit_element<float>::value()  { return 1.0; }$/;"	f	class:boost::icl::unit_element	signature:()
value	icl/type_traits/unit_element.hpp	/^    template<> inline long double unit_element<long double>::value() $/;"	f	class:boost::icl::unit_element	signature:()
value_compare	icl/map.hpp	/^    typedef typename base_type::value_compare           value_compare;$/;"	t	class:boost::icl::map	access:public
value_size	icl/closed_interval.hpp	/^struct value_size<icl::closed_interval<DomainT> >$/;"	s	namespace:boost::icl
value_size	icl/continuous_interval.hpp	/^struct value_size<icl::continuous_interval<DomainT> >$/;"	s	namespace:boost::icl
value_size	icl/discrete_interval.hpp	/^struct value_size<icl::discrete_interval<DomainT> >$/;"	s	namespace:boost::icl
value_size	icl/left_open_interval.hpp	/^struct value_size<icl::left_open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
value_size	icl/open_interval.hpp	/^struct value_size<icl::open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
value_size	icl/right_open_interval.hpp	/^struct value_size<icl::right_open_interval<DomainT,Compare> >$/;"	s	namespace:boost::icl
value_size	icl/type_traits/value_size.hpp	/^struct value_size$/;"	s	namespace:boost::icl
value_type	icl/detail/element_iterator.hpp	/^    typedef transit_type                                    value_type;$/;"	t	class:boost::icl::element_iterator	access:public
value_type	icl/interval_base_map.hpp	/^        typedef typename Type::value_type     value_type;$/;"	t	struct:boost::icl::interval_base_map::on_total_absorbable	access:public
value_type	icl/interval_base_map.hpp	/^    typedef typename ImplMapT::value_type value_type;$/;"	t	class:boost::icl::interval_base_map	access:public
value_type	icl/interval_base_set.hpp	/^    typedef typename ImplSetT::value_type value_type;$/;"	t	class:boost::icl::interval_base_set	access:public
value_type	icl/interval_map.hpp	/^    typedef typename base_type::value_type    value_type;$/;"	t	class:boost::icl::interval_map	access:public
value_type	icl/interval_set.hpp	/^    typedef typename ImplSetT::value_type value_type;$/;"	t	class:boost::icl::interval_set	access:public
value_type	icl/map.hpp	/^    typedef std::pair<const DomainT, CodomainT>         value_type;$/;"	t	class:boost::icl::map	access:public
value_type	icl/separate_interval_set.hpp	/^    typedef typename ImplSetT::value_type value_type;$/;"	t	class:boost::icl::separate_interval_set	access:public
value_type	icl/split_interval_map.hpp	/^    typedef typename base_type::value_type value_type;$/;"	t	class:boost::icl::split_interval_map	access:public
value_type	icl/split_interval_set.hpp	/^    typedef typename ImplSetT::value_type value_type;$/;"	t	class:boost::icl::split_interval_set	access:public
value_type_of	icl/type_traits/element_type_of.hpp	/^    struct value_type_of$/;"	s	namespace:boost::icl
version	icl/functors.hpp	/^        static void version(Type&){}$/;"	f	struct:boost::icl::inplace_bit_add	access:public	signature:(Type&)
version	icl/functors.hpp	/^        static void version(Type&){}$/;"	f	struct:boost::icl::inplace_plus	access:public	signature:(Type&)
version	icl/functors.hpp	/^    struct version<icl::inplace_minus<Type> > : public conversion<icl::inplace_minus<Type> >$/;"	s	namespace:boost::icl	inherits:conversion
version	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<double     > >{double      operator()(double      val){return -val;}};$/;"	s	namespace:boost::icl
version	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<float      > >{float       operator()(float       val){return -val;}};$/;"	s	namespace:boost::icl
version	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<int        > >{int         operator()(int         val){return -val;}};$/;"	s	namespace:boost::icl
version	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<long       > >{long        operator()(long        val){return -val;}};$/;"	s	namespace:boost::icl
version	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<long double> >{long double operator()(long double val){return -val;}};$/;"	s	namespace:boost::icl
version	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<long long  > >{long long   operator()(long long   val){return -val;}};$/;"	s	namespace:boost::icl
version	icl/functors.hpp	/^    template<>struct version<icl::inplace_minus<short      > >{short       operator()(short       val){return -val;}};$/;"	s	namespace:boost::icl
version	icl/functors.hpp	/^    template<class Combiner> struct version : public conversion<Combiner>$/;"	s	namespace:boost::icl	inherits:conversion
within	icl/concept/element_associator.hpp	/^within(const SubT& sub, const SuperT& super)$/;"	f	namespace:boost::icl	signature:(const SubT& sub, const SuperT& super)
within	icl/concept/element_associator.hpp	/^within(const typename Type::key_type& key, const Type& super)$/;"	f	namespace:boost::icl	signature:(const typename Type::key_type& key, const Type& super)
within	icl/concept/element_map.hpp	/^within(const typename Type::element_type& value_pair, const Type& super)$/;"	f	namespace:boost::icl	signature:(const typename Type::element_type& value_pair, const Type& super)
within	icl/concept/interval.hpp	/^within(const Type& sub, const Type& super)$/;"	f	namespace:boost::icl	signature:(const Type& sub, const Type& super)
within	icl/concept/interval_associator.hpp	/^within(const SubT& sub, const SuperT& super)$/;"	f	namespace:boost::icl	signature:(const SubT& sub, const SuperT& super)
within	icl/detail/interval_set_algo.hpp	/^within(const LeftT& sub, const RightT& super)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT& sub, const RightT& super)
within	icl/detail/interval_set_algo.hpp	/^within(const LeftT&, const RightT&)$/;"	f	namespace:boost::icl::Interval_Set	signature:(const LeftT&, const RightT&)
within	icl/detail/set_algo.hpp	/^inline bool within(const SetType& sub, const SetType& super)$/;"	f	namespace:boost::icl::Set	signature:(const SetType& sub, const SetType& super)
within	icl/map.hpp	/^    bool within(const map& super)const $/;"	f	class:boost::icl::map	access:public	signature:(const map& super) const
